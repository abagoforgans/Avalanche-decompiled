contract main {




// =====================  Runtime code  =====================


#
#  - transferFrom(address arg1, address arg2, uint256 arg3)
#  - cashoutAll()
#  - sub_5e6710de(?)
#  - cashoutReward(uint256 arg1)
#  - sub_6748b4d6(?)
#  - transfer(address arg1, uint256 arg2)
#  - _fallback()
#
const name = '', 0

const totalSupply = 10^15

const decimals = 9

const getTime = block.timestamp

const symbol = '', 0


address owner;
uint256 unlockTime;
address nodeRewardManagementAddress;
address rewardsPoolAddress;
uint256 rewardsPoolFee;
address treasuryAddress;
uint256 treasuryFee;
address sub_829d65edAddress;
uint256 sub_15799844;
address sub_81ccaf7bAddress;
uint256 sub_fe4bc80c;
uint256 cashoutFee;
address deadWalletAddress;
uint256 sub_7e78c672;
uint256 stor18;
uint256 stor19;
uint256 stor20;
mapping of uint8 stor21;
address liquidityAddress;
mapping of uint256 stor23;
mapping of uint256 stor24;
mapping of uint256 allowance;
uint8 transferDelayEnabled;
uint8 limitsInEffect; offset 8
uint16 stor27;
mapping of uint8 stor28;
mapping of uint8 stor29;
array of address stor30;
uint256 stor31;
uint256 totalFees;
uint256 stor33;
uint256 stor35;
uint256 _buyTaxFee;
uint256 _buyLiquidityFee;
uint256 sub_138ea692;
uint256 _sellTaxFee;
uint256 _sellLiquidityFee;
uint256 sub_ed9cbd93;
uint256 tradingActiveBlock;
uint256 _liquidityTokensToSwap;
uint256 sub_432654c4;
uint256 maxTransactionAmount;
mapping of uint8 stor48;
uint256 maxWallet;
uint8 stor50;
uint256 stor51;
mapping of uint8 stor52;
uint256 minimumTokensBeforeSwapAmount;
address uniswapV2RouterAddress;
uint8 stor55; offset 160
uint8 swapAndLiquifyEnabled; offset 168
uint8 tradingActive; offset 176
uint128 stor55; offset 176
uint128 stor55; offset 168
address uniswapV2PairAddress;
array of address stor36516136433507714556481507284757523525550975291680945358964353894568634540880;

function _isExcludedMaxTransactionAmount(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor48[arg1])
}

function totalFees() {
    return totalFees
}

function sub_138ea692(?) {
    return sub_138ea692
}

function sub_15799844(?) {
    return sub_15799844
}

function uniswapV2Router() {
    return uniswapV2RouterAddress
}

function _isBlacklisted(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor21[arg1])
}

function _sellTaxFee() {
    return _sellTaxFee
}

function liquidityAddress() {
    return liquidityAddress
}

function _liquidityTokensToSwap() {
    return _liquidityTokensToSwap
}

function sub_432654c4(?) {
    return sub_432654c4
}

function uniswapV2Pair() {
    return uniswapV2PairAddress
}

function limitsInEffect() {
    return bool(limitsInEffect)
}

function swapAndLiquifyEnabled() {
    return bool(swapAndLiquifyEnabled)
}

function isExcludedFromFee(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor28[address(arg1)])
}

function getUnlockTime() {
    return unlockTime
}

function nodeRewardManagement() {
    return nodeRewardManagementAddress
}

function cashoutFee() {
    return cashoutFee
}

function sub_7e78c672(?) {
    return sub_7e78c672
}

function sub_81ccaf7b(?) {
    return sub_81ccaf7bAddress
}

function sub_829d65ed(?) {
    return sub_829d65edAddress
}

function deadWallet() {
    return deadWalletAddress
}

function rewardsPoolFee() {
    return rewardsPoolFee
}

function _sellLiquidityFee() {
    return _sellLiquidityFee
}

function isExcludedFromReward(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor29[address(arg1)])
}

function owner() {
    return owner
}

function minimumTokensBeforeSwapAmount() {
    return minimumTokensBeforeSwapAmount
}

function automatedMarketMakerPairs(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor52[arg1])
}

function tradingActive() {
    return bool(tradingActive)
}

function treasuryAddress() {
    return treasuryAddress
}

function transferDelayEnabled() {
    return bool(transferDelayEnabled)
}

function maxTransactionAmount() {
    return maxTransactionAmount
}

function treasuryFee() {
    return treasuryFee
}

function rewardsPoolAddress() {
    return rewardsPoolAddress
}

function _buyLiquidityFee() {
    return _buyLiquidityFee
}

function allowance(address arg1, address arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    return allowance[address(arg1)][address(arg2)]
}

function sub_ed9cbd93(?) {
    return sub_ed9cbd93
}

function tradingActiveBlock() {
    return tradingActiveBlock
}

function _buyTaxFee() {
    return _buyTaxFee
}

function maxWallet() {
    return maxWallet
}

function sub_fe4bc80c(?) {
    return sub_fe4bc80c
}

function removeLimits() {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor50 = 0
    stor27 = 0
    return 1
}

function disableTransferDelay() {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    transferDelayEnabled = 0
    return 1
}

function sub_256fc2ff(?) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor20 = arg1
}

function sub_6703794d(?) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor19 = arg1
}

function sub_fd0ac917(?) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor18 = arg1
}

function renounceOwnership() {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function sub_1a6dae83(?) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_fe4bc80c = arg1
}

function sub_f6b6c8b8(?) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_15799844 = arg1
}

function updateCashoutFee(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    cashoutFee = arg1
}

function updateRewardsFee(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    rewardsPoolFee = arg1
}

function setGasPriceLimit(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    require arg1 >= 750000 * 24 * 3600
    stor51 = arg1
}

function sub_a2065e71(?) {
    require calldata.size - 4 >= 32
    require arg1 == bool(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    transferDelayEnabled = uint8(bool(arg1))
}

function setNodeManagement(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    nodeRewardManagementAddress = arg1
}

function includeInFee(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor28[address(arg1)] = 0
    emit IncludeInFee(arg1);
}

function excludeFromFee(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor28[address(arg1)] = 1
    emit ExcludeFromFee(arg1);
}

function setIsExcluded(address arg1, bool arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor29[address(arg1)] = uint8(arg2)
}

function excludeFromMaxTransaction(address arg1, bool arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor48[address(arg1)] = uint8(arg2)
}

function setSwapAndLiquifyEnabled(bool arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    Mask(88, 0, stor55.field_168) = Mask(88, 0, arg1)
    emit SwapAndLiquifyEnabledUpdated(arg1);
}

function sub_ecb42a79(?) {
    require calldata.size - 4 >= 32
    require arg1 == bool(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    Mask(80, 0, stor55.field_176) = Mask(80, 0, bool(arg1))
    if not tradingActiveBlock:
        tradingActiveBlock = block.number
}

function sub_30879d7d(?) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if eth.balance(this.address) <= 0:
        revert with 0, 'Contract balance is zero'
    call msg.sender with:
       value eth.balance(this.address) wei
         gas gas_remaining wei
}

function transferOwnership(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function updateTreasuryAddress(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'operationPoolAddress address cannot be 0'
    stor28[stor6] = 0
    treasuryAddress = arg1
    stor28[arg1] = 1
}

function sub_9b581f1d(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not address(arg1):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'rewardsPoolAddress address cannot be 0'
    stor28[stor4] = 0
    rewardsPoolAddress = address(arg1)
    stor28[address(arg1)] = 1
}

function sub_c300b479(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not address(arg1):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'operationPoolAddress address cannot be 0'
    stor28[stor10] = 0
    sub_81ccaf7bAddress = address(arg1)
    stor28[address(arg1)] = 1
}

function sub_24fed132(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not address(arg1):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'smoothingReserveAddress address cannot be 0'
    stor28[stor8] = 0
    sub_829d65edAddress = address(arg1)
    stor28[address(arg1)] = 1
}

function setLiquidityAddress(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, '_liquidityAddress address cannot be 0'
    liquidityAddress = arg1
    stor28[address(arg1)] = 1
    emit UpdatedLiquidityAddress(arg1);
}

function updateMaxWallet(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if arg1 < 0:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Cannot set maxTransactionAmount lower than 0.2%'
    if arg1 > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
        revert with 0, 17
    maxWallet = 10^18 * arg1
}

function setBuyFee(uint256 arg1, uint256 arg2, uint256 arg3) {
    require calldata.size - 4 >= 96
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    _buyTaxFee = arg1
    _buyLiquidityFee = arg2
    sub_138ea692 = arg3
    if arg1 > !arg2:
        revert with 0, 17
    if arg1 + arg2 > !arg3:
        revert with 0, 17
    if arg1 + arg2 + arg3 > 1500:
        revert with 0, 'Must keep buy taxes below 15%'
}

function updateMaxAmount(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if arg1 < 0:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Cannot set maxTransactionAmount lower than 0.2%'
    if arg1 > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
        revert with 0, 17
    maxTransactionAmount = 10^18 * arg1
}

function setSellFee(uint256 arg1, uint256 arg2, uint256 arg3) {
    require calldata.size - 4 >= 96
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    _sellTaxFee = arg1
    _sellLiquidityFee = arg2
    sub_ed9cbd93 = arg3
    if arg1 > !arg2:
        revert with 0, 17
    if arg1 + arg2 > !arg3:
        revert with 0, 17
    if arg1 + arg2 + arg3 > 2000:
        revert with 0, 'Must keep sell taxes below 20%'
}

function approve(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] = arg2
    emit Approval(arg2, msg.sender, arg1);
    return 1
}

function updateMinimumTokensBeforeSwap(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if arg1 < 10^10:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    'Swap amount cannot be lower than 0.001% total supply.'
    if arg1 > 5 * 10^12:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    'Swap amount cannot be higher than 0.5% total supply.'
    minimumTokensBeforeSwapAmount = arg1
}

function decreaseAllowance(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if arg2 > allowance[msg.sender][address(arg1)]:
        revert with 0, 32, 37, 0x6545524332303a2064656372656173656420616c6c6f77616e63652062656c6f77207a6572, mem[165 len 27] >> 40, 0
    if allowance[msg.sender][address(arg1)] < arg2:
        revert with 0, 17
    if not msg.sender:
        revert with 0, 'ERC20: approve from the zero address'
    if not arg1:
        revert with 0, 'ERC20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] = allowance[msg.sender][address(arg1)] - arg2
    emit Approval((allowance[msg.sender][address(arg1)] - arg2), msg.sender, arg1);
    return 1
}

function increaseAllowance(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if allowance[msg.sender][address(arg1)] > !arg2:
        revert with 0, 17
    if allowance[msg.sender][address(arg1)] + arg2 < allowance[msg.sender][address(arg1)]:
        revert with 0, 'SafeMath: addition overflow'
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] = allowance[msg.sender][address(arg1)] + arg2
    emit Approval((allowance[msg.sender][address(arg1)] + arg2), msg.sender, arg1);
    return 1
}

function includeInReward(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not stor29[address(arg1)]:
        revert with 0, 'Account is not excluded'
    idx = 0
    while idx < stor30.length:
        mem[0] = 30
        if stor30[idx] != arg1:
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if stor30.length < 1:
            revert with 0, 17
        if stor30.length - 1 >= stor30.length:
            revert with 0, 50
        if idx >= stor30.length:
            revert with 0, 50
        stor30[idx] = stor30[stor30.length]
        stor24[address(arg1)] = 0
        stor29[address(arg1)] = 0
        if not stor30.length:
            revert with 0, 49
        stor30[stor30.length] = 0
        stor30.length--
}

function transferForeignToken(address arg1, address arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0, '_token address cannot be 0'
    if this.address == arg1:
        revert with 0, 'Can't withdraw native tokens'
    staticcall arg1.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    call arg1.0xa9059cbb with:
         gas gas_remaining wei
        args address(arg2), ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    emit TransferForeignToken(address(arg1), ext_call.return_data[0]);
    return bool(ext_call.return_data[0])
}

function tokenFromReflection(uint256 arg1) payable {
    mem[64] = 96
    require not msg.value
    require calldata.size - 4 >= 32
    if arg1 > stor31:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
    idx = 0
    s = 10^15
    t = stor31
    while idx < stor30.length:
        mem[0] = stor30[idx]
        mem[32] = 23
        if stor23[stor30[idx]] > t:
            _65 = mem[64]
            mem[64] = mem[64] + 64
            mem[_65] = 26
            mem[_65 + 32] = 'SafeMath: division by zero'
            _77 = mem[64]
            mem[64] = mem[64] + 64
            mem[_77] = 26
            mem[_77 + 32] = 'SafeMath: division by zero'
            if stor31 / 10^15:
                return (arg1 / stor31 / 10^15)
            _83 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _83 + 68] = mem[idx + _77 + 32]
                idx = idx + 32
                continue 
            mem[_83 + 94] = 0
            revert with memory
              from mem[64]
               len _83 + -mem[64] + 100
        if idx >= stor30.length:
            revert with 0, 50
        mem[0] = stor30[idx]
        mem[32] = 24
        if stor24[stor30[idx]] > s:
            _69 = mem[64]
            mem[64] = mem[64] + 64
            mem[_69] = 26
            mem[_69 + 32] = 'SafeMath: division by zero'
            _85 = mem[64]
            mem[64] = mem[64] + 64
            mem[_85] = 26
            mem[_85 + 32] = 'SafeMath: division by zero'
            if stor31 / 10^15:
                return (arg1 / stor31 / 10^15)
            _89 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _89 + 68] = mem[idx + _85 + 32]
                idx = idx + 32
                continue 
            mem[_89 + 94] = 0
            revert with memory
              from mem[64]
               len _89 + -mem[64] + 100
        if idx >= stor30.length:
            revert with 0, 50
        mem[0] = stor30[idx]
        mem[32] = 23
        _68 = mem[64]
        mem[64] = mem[64] + 64
        mem[_68] = 30
        mem[_68 + 32] = 'SafeMath: subtraction overflow'
        if stor23[stor30[idx]] > t:
            _70 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _70 + 68] = mem[idx + _68 + 32]
                idx = idx + 32
                continue 
            mem[_70 + 98] = 0
            revert with memory
              from mem[64]
               len _70 + -mem[64] + 100
        if t < stor23[stor30[idx]]:
            revert with 0, 17
        if idx >= stor30.length:
            revert with 0, 50
        mem[0] = stor30[idx]
        mem[32] = 24
        _84 = mem[64]
        mem[64] = mem[64] + 64
        mem[_84] = 30
        mem[_84 + 32] = 'SafeMath: subtraction overflow'
        if stor24[stor30[idx]] <= s:
            if s < stor24[stor30[idx]]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s - stor24[stor30[idx]]
            t = t - stor23[stor30[idx]]
            continue 
        _88 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 30
        idx = 0
        while idx < 30:
            mem[idx + _88 + 68] = mem[idx + _84 + 32]
            idx = idx + 32
            continue 
        mem[_88 + 98] = 0
        revert with memory
          from mem[64]
           len _88 + -mem[64] + 100
    if t < stor31 / 10^15:
        if not stor31 / 10^15:
            revert with 0, 'SafeMath: division by zero', 0
        return (arg1 / stor31 / 10^15)
    if not s:
        revert with 0, 'SafeMath: division by zero', 0
    if not t / s:
        revert with 0, 'SafeMath: division by zero', 0
    return (arg1 / t / s)
}

function balanceOf(address arg1) payable {
    mem[64] = 96
    require not msg.value
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if stor29[address(arg1)]:
        return stor24[address(arg1)]
    mem[0] = arg1
    mem[32] = 23
    if stor23[address(arg1)] > stor31:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
    idx = 0
    s = 10^15
    t = stor31
    while idx < stor30.length:
        mem[0] = stor30[idx]
        mem[32] = 23
        if stor23[stor30[idx]] > t:
            _70 = mem[64]
            mem[64] = mem[64] + 64
            mem[_70] = 26
            mem[_70 + 32] = 'SafeMath: division by zero'
            _82 = mem[64]
            mem[64] = mem[64] + 64
            mem[_82] = 26
            mem[_82 + 32] = 'SafeMath: division by zero'
            if stor31 / 10^15:
                return (stor23[address(arg1)] / stor31 / 10^15)
            _88 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _88 + 68] = mem[idx + _82 + 32]
                idx = idx + 32
                continue 
            mem[_88 + 94] = 0
            revert with memory
              from mem[64]
               len _88 + -mem[64] + 100
        if idx >= stor30.length:
            revert with 0, 50
        mem[0] = stor30[idx]
        mem[32] = 24
        if stor24[stor30[idx]] > s:
            _74 = mem[64]
            mem[64] = mem[64] + 64
            mem[_74] = 26
            mem[_74 + 32] = 'SafeMath: division by zero'
            _90 = mem[64]
            mem[64] = mem[64] + 64
            mem[_90] = 26
            mem[_90 + 32] = 'SafeMath: division by zero'
            if stor31 / 10^15:
                return (stor23[address(arg1)] / stor31 / 10^15)
            _94 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _94 + 68] = mem[idx + _90 + 32]
                idx = idx + 32
                continue 
            mem[_94 + 94] = 0
            revert with memory
              from mem[64]
               len _94 + -mem[64] + 100
        if idx >= stor30.length:
            revert with 0, 50
        mem[0] = stor30[idx]
        mem[32] = 23
        _73 = mem[64]
        mem[64] = mem[64] + 64
        mem[_73] = 30
        mem[_73 + 32] = 'SafeMath: subtraction overflow'
        if stor23[stor30[idx]] > t:
            _75 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _75 + 68] = mem[idx + _73 + 32]
                idx = idx + 32
                continue 
            mem[_75 + 98] = 0
            revert with memory
              from mem[64]
               len _75 + -mem[64] + 100
        if t < stor23[stor30[idx]]:
            revert with 0, 17
        if idx >= stor30.length:
            revert with 0, 50
        mem[0] = stor30[idx]
        mem[32] = 24
        _89 = mem[64]
        mem[64] = mem[64] + 64
        mem[_89] = 30
        mem[_89 + 32] = 'SafeMath: subtraction overflow'
        if stor24[stor30[idx]] <= s:
            if s < stor24[stor30[idx]]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s - stor24[stor30[idx]]
            t = t - stor23[stor30[idx]]
            continue 
        _93 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 30
        idx = 0
        while idx < 30:
            mem[idx + _93 + 68] = mem[idx + _89 + 32]
            idx = idx + 32
            continue 
        mem[_93 + 98] = 0
        revert with memory
          from mem[64]
           len _93 + -mem[64] + 100
    if t < stor31 / 10^15:
        if not stor31 / 10^15:
            revert with 0, 'SafeMath: division by zero', 0
        return (stor23[address(arg1)] / stor31 / 10^15)
    if not s:
        revert with 0, 'SafeMath: division by zero', 0
    if not t / s:
        revert with 0, 'SafeMath: division by zero', 0
    return (stor23[address(arg1)] / t / s)
}

function excludeFromReward(address arg1) payable {
    mem[64] = 96
    require not msg.value
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if stor29[address(arg1)]:
        revert with 0, 'Account is already excluded'
    if 1 > !stor30.length:
        revert with 0, 17
    if stor30.length + 1 > 50:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    'Cannot exclude more than 50 accounts.  Include a previously excluded address.'
    if stor23[address(arg1)]:
        mem[0] = arg1
        mem[32] = 23
        if stor23[address(arg1)] > stor31:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
        idx = 0
        s = 10^15
        t = stor31
        while idx < stor30.length:
            mem[0] = stor30[idx]
            mem[32] = 23
            if stor23[stor30[idx]] > t:
                _75 = mem[64]
                mem[64] = mem[64] + 64
                mem[_75] = 26
                mem[_75 + 32] = 'SafeMath: division by zero'
                _87 = mem[64]
                mem[64] = mem[64] + 64
                mem[_87] = 26
                mem[_87 + 32] = 'SafeMath: division by zero'
                if stor31 / 10^15:
                    stor24[address(arg1)] = stor23[address(arg1)] / stor31 / 10^15
                    stor29[address(arg1)] = 1
                    stor30.length++
                    stor50BB[stor30.length] = arg1
                _93 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _93 + 68] = mem[idx + _87 + 32]
                    idx = idx + 32
                    continue 
                mem[_93 + 94] = 0
                revert with memory
                  from mem[64]
                   len _93 + -mem[64] + 100
            if idx >= stor30.length:
                revert with 0, 50
            mem[0] = stor30[idx]
            mem[32] = 24
            if stor24[stor30[idx]] > s:
                _79 = mem[64]
                mem[64] = mem[64] + 64
                mem[_79] = 26
                mem[_79 + 32] = 'SafeMath: division by zero'
                _95 = mem[64]
                mem[64] = mem[64] + 64
                mem[_95] = 26
                mem[_95 + 32] = 'SafeMath: division by zero'
                if stor31 / 10^15:
                    stor24[address(arg1)] = stor23[address(arg1)] / stor31 / 10^15
                    stor29[address(arg1)] = 1
                    stor30.length++
                    stor50BB[stor30.length] = arg1
                _99 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _99 + 68] = mem[idx + _95 + 32]
                    idx = idx + 32
                    continue 
                mem[_99 + 94] = 0
                revert with memory
                  from mem[64]
                   len _99 + -mem[64] + 100
            if idx >= stor30.length:
                revert with 0, 50
            mem[0] = stor30[idx]
            mem[32] = 23
            _78 = mem[64]
            mem[64] = mem[64] + 64
            mem[_78] = 30
            mem[_78 + 32] = 'SafeMath: subtraction overflow'
            if stor23[stor30[idx]] > t:
                _80 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _80 + 68] = mem[idx + _78 + 32]
                    idx = idx + 32
                    continue 
                mem[_80 + 98] = 0
                revert with memory
                  from mem[64]
                   len _80 + -mem[64] + 100
            if t < stor23[stor30[idx]]:
                revert with 0, 17
            if idx >= stor30.length:
                revert with 0, 50
            mem[0] = stor30[idx]
            mem[32] = 24
            _94 = mem[64]
            mem[64] = mem[64] + 64
            mem[_94] = 30
            mem[_94 + 32] = 'SafeMath: subtraction overflow'
            if stor24[stor30[idx]] <= s:
                if s < stor24[stor30[idx]]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s - stor24[stor30[idx]]
                t = t - stor23[stor30[idx]]
                continue 
            _98 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _98 + 68] = mem[idx + _94 + 32]
                idx = idx + 32
                continue 
            mem[_98 + 98] = 0
            revert with memory
              from mem[64]
               len _98 + -mem[64] + 100
        if t < stor31 / 10^15:
            if not stor31 / 10^15:
                revert with 0, 'SafeMath: division by zero', 0
            stor24[address(arg1)] = stor23[address(arg1)] / stor31 / 10^15
        else:
            if not s:
                revert with 0, 'SafeMath: division by zero', 0
            if not t / s:
                revert with 0, 'SafeMath: division by zero', 0
            stor24[address(arg1)] = stor23[address(arg1)] / t / s
    stor29[address(arg1)] = 1
    stor30.length++
    stor50BB[stor30.length] = arg1
}

function setAutomatedMarketMakerPair(address arg1, bool arg2) payable {
    mem[64] = 96
    require not msg.value
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if uniswapV2PairAddress == arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    'The pair cannot be removed from automatedMarketMakerPairs'
    stor52[address(arg1)] = uint8(arg2)
    stor48[address(arg1)] = uint8(arg2)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg2:
        if not stor29[address(arg1)]:
            revert with 0, 'Account is not excluded'
        idx = 0
        while idx < stor30.length:
            mem[0] = 30
            if stor30[idx] != arg1:
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if stor30.length < 1:
                revert with 0, 17
            if stor30.length - 1 >= stor30.length:
                revert with 0, 50
            if idx >= stor30.length:
                revert with 0, 50
            stor30[idx] = stor30[stor30.length]
            stor24[address(arg1)] = 0
            stor29[address(arg1)] = 0
            if not stor30.length:
                revert with 0, 49
            stor30[stor30.length] = 0
            stor30.length--
    else:
        if stor29[address(arg1)]:
            revert with 0, 'Account is already excluded'
        if 1 > !stor30.length:
            revert with 0, 17
        if stor30.length + 1 > 50:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        'Cannot exclude more than 50 accounts.  Include a previously excluded address.'
        if stor23[address(arg1)]:
            mem[0] = arg1
            mem[32] = 23
            if stor23[address(arg1)] > stor31:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
            idx = 0
            s = 10^15
            t = stor31
            while idx < stor30.length:
                mem[0] = stor30[idx]
                mem[32] = 23
                if stor23[stor30[idx]] > t:
                    _149 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_149] = 26
                    mem[_149 + 32] = 'SafeMath: division by zero'
                    _171 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_171] = 26
                    mem[_171 + 32] = 'SafeMath: division by zero'
                    if not stor31 / 10^15:
                        _177 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _177 + 68] = mem[idx + _171 + 32]
                            idx = idx + 32
                            continue 
                        mem[_177 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _177 + -mem[64] + 100
                    stor24[address(arg1)] = stor23[address(arg1)] / stor31 / 10^15
                    stor29[address(arg1)] = 1
                    stor30.length++
                    stor50BB[stor30.length] = arg1
                    if not arg2:
                        if owner != msg.sender:
                            revert with 0, 'Ownable: caller is not the owner'
                        if not stor29[address(arg1)]:
                            revert with 0, 'Account is not excluded'
                        idx = 0
                        while idx < stor30.length:
                            mem[0] = 30
                            if stor30[idx] != arg1:
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if stor30.length < 1:
                                revert with 0, 17
                            if stor30.length - 1 >= stor30.length:
                                revert with 0, 50
                            if idx >= stor30.length:
                                revert with 0, 50
                            stor30[idx] = stor30[stor30.length]
                            stor24[address(arg1)] = 0
                            stor29[address(arg1)] = 0
                            if not stor30.length:
                                revert with 0, 49
                            stor30[stor30.length] = 0
                            stor30.length--
                if idx >= stor30.length:
                    revert with 0, 50
                mem[0] = stor30[idx]
                mem[32] = 24
                if stor24[stor30[idx]] > s:
                    _161 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_161] = 26
                    mem[_161 + 32] = 'SafeMath: division by zero'
                    _179 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_179] = 26
                    mem[_179 + 32] = 'SafeMath: division by zero'
                    if not stor31 / 10^15:
                        _183 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _183 + 68] = mem[idx + _179 + 32]
                            idx = idx + 32
                            continue 
                        mem[_183 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _183 + -mem[64] + 100
                    stor24[address(arg1)] = stor23[address(arg1)] / stor31 / 10^15
                    stor29[address(arg1)] = 1
                    stor30.length++
                    stor50BB[stor30.length] = arg1
                    if not arg2:
                        if owner != msg.sender:
                            revert with 0, 'Ownable: caller is not the owner'
                        if not stor29[address(arg1)]:
                            revert with 0, 'Account is not excluded'
                        idx = 0
                        while idx < stor30.length:
                            mem[0] = 30
                            if stor30[idx] != arg1:
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if stor30.length < 1:
                                revert with 0, 17
                            if stor30.length - 1 >= stor30.length:
                                revert with 0, 50
                            if idx >= stor30.length:
                                revert with 0, 50
                            stor30[idx] = stor30[stor30.length]
                            stor24[address(arg1)] = 0
                            stor29[address(arg1)] = 0
                            if not stor30.length:
                                revert with 0, 49
                            stor30[stor30.length] = 0
                            stor30.length--
                if idx >= stor30.length:
                    revert with 0, 50
                mem[0] = stor30[idx]
                mem[32] = 23
                _160 = mem[64]
                mem[64] = mem[64] + 64
                mem[_160] = 30
                mem[_160 + 32] = 'SafeMath: subtraction overflow'
                if stor23[stor30[idx]] > t:
                    _164 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _164 + 68] = mem[idx + _160 + 32]
                        idx = idx + 32
                        continue 
                    mem[_164 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _164 + -mem[64] + 100
                if t < stor23[stor30[idx]]:
                    revert with 0, 17
                if idx >= stor30.length:
                    revert with 0, 50
                mem[0] = stor30[idx]
                mem[32] = 24
                _178 = mem[64]
                mem[64] = mem[64] + 64
                mem[_178] = 30
                mem[_178 + 32] = 'SafeMath: subtraction overflow'
                if stor24[stor30[idx]] <= s:
                    if s < stor24[stor30[idx]]:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s - stor24[stor30[idx]]
                    t = t - stor23[stor30[idx]]
                    continue 
                _182 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _182 + 68] = mem[idx + _178 + 32]
                    idx = idx + 32
                    continue 
                mem[_182 + 98] = 0
                revert with memory
                  from mem[64]
                   len _182 + -mem[64] + 100
            if t < stor31 / 10^15:
                if not stor31 / 10^15:
                    revert with 0, 'SafeMath: division by zero', 0
                stor24[address(arg1)] = stor23[address(arg1)] / stor31 / 10^15
            else:
                if not s:
                    revert with 0, 'SafeMath: division by zero', 0
                if not t / s:
                    revert with 0, 'SafeMath: division by zero', 0
                stor24[address(arg1)] = stor23[address(arg1)] / t / s
        stor29[address(arg1)] = 1
        stor30.length++
        stor50BB[stor30.length] = arg1
        if not arg2:
            if owner != msg.sender:
                revert with 0, 'Ownable: caller is not the owner'
            if not stor29[address(arg1)]:
                revert with 0, 'Account is not excluded'
            idx = 0
            while idx < stor30.length:
                mem[0] = 30
                if stor30[idx] != arg1:
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if stor30.length < 1:
                    revert with 0, 17
                if stor30.length - 1 >= stor30.length:
                    revert with 0, 50
                if idx >= stor30.length:
                    revert with 0, 50
                stor30[idx] = stor30[stor30.length]
                stor24[address(arg1)] = 0
                stor29[address(arg1)] = 0
                if not stor30.length:
                    revert with 0, 49
                stor30[stor30.length] = 0
                stor30.length--
}

function sub_eea21274(?) payable {
    mem[64] = 96
    require not msg.value
    require calldata.size - 4 >= 96
    require arg1 == address(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if tradingActive:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Trading is already active, cannot relaunch.'
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor48[address(arg1)] = 1
    uniswapV2RouterAddress = address(arg1)
    if stor29[address(this.address)]:
        if not this.address:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve from the zero address'
        if not address(arg1):
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve to the zero address'
        allowance[address(this.address)][address(arg1)] = stor24[address(this.address)]
        emit Approval(stor24[address(this.address)], this.address, address(arg1));
        staticcall address(arg1).factory() with:
                gas gas_remaining wei
        mem[96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        staticcall address(arg1).0x73b295c2 with:
                gas gas_remaining wei
        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        mem[(2 * ceil32(return_data.size)) + 100] = this.address
        mem[(2 * ceil32(return_data.size)) + 132] = address(ext_call.return_data[0])
        call address(ext_call.return_data[0]).createPair(address arg1, address arg2) with:
             gas gas_remaining wei
            args address(this.address), address(ext_call.return_data[0])
        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[64] = (4 * ceil32(return_data.size)) + 96
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        uniswapV2PairAddress = ext_call.return_data[12 len 20]
        if owner != msg.sender:
            revert with 0, 'Ownable: caller is not the owner'
        stor48[ext_call.return_data[12 len 20]] = 1
        stor52[address(stor55.field_0)] = 1
        stor48[address(stor55.field_0)] = 1
        if owner != msg.sender:
            revert with 0, 'Ownable: caller is not the owner'
        if stor29[address(stor55.field_0)]:
            revert with 0, 'Account is already excluded'
        if 1 > !stor30.length:
            revert with 0, 17
        if stor30.length + 1 > 50:
            revert with 0, 'Cannot exclude more than 50 accounts.  Include a previously excluded address.'
        if stor23[address(stor55.field_0)]:
            mem[0] = uniswapV2PairAddress
            mem[32] = 23
            if stor23[address(stor55.field_0)] > stor31:
                revert with 0, 'Amount must be less than total reflections'
            idx = 0
            s = 10^15
            t = stor31
            while idx < stor30.length:
                mem[0] = stor30[idx]
                mem[32] = 23
                if stor23[stor30[idx]] > t:
                    _868 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_868] = 26
                    mem[_868 + 32] = 'SafeMath: division by zero'
                    _893 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_893] = 26
                    mem[_893 + 32] = 'SafeMath: division by zero'
                    if not stor31 / 10^15:
                        _906 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _906 + 68] = mem[idx + _893 + 32]
                            idx = idx + 32
                            continue 
                        mem[_906 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _906 + -mem[64] + 100
                    stor24[address(stor55.field_0)] = stor23[address(stor55.field_0)] / stor31 / 10^15
                    stor29[address(stor55.field_0)] = 1
                    stor30.length++
                    stor50BB[stor30.length] = uniswapV2PairAddress
                    if arg2 <= 0:
                        revert with 0, 'Initial avax for add liquidity should be bigger than zero'
                    if arg3 <= 0:
                        revert with 0, 'Initial tokens for add liquidity be bigger than zero'
                    if eth.balance(this.address) <= 0:
                        revert with 0, 'Must have AVAX on contract to launch'
                    if owner != msg.sender:
                        revert with 0, 'Ownable: caller is not the owner'
                    if not msg.sender:
                        revert with 0, '_liquidityAddress address cannot be 0'
                    liquidityAddress = msg.sender
                    stor28[address(msg.sender)] = 1
                    emit UpdatedLiquidityAddress(msg.sender);
                if idx >= stor30.length:
                    revert with 0, 50
                mem[0] = stor30[idx]
                mem[32] = 24
                if stor24[stor30[idx]] > s:
                    _876 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_876] = 26
                    mem[_876 + 32] = 'SafeMath: division by zero'
                    _908 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_908] = 26
                    mem[_908 + 32] = 'SafeMath: division by zero'
                    if not stor31 / 10^15:
                        _916 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _916 + 68] = mem[idx + _908 + 32]
                            idx = idx + 32
                            continue 
                        mem[_916 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _916 + -mem[64] + 100
                    stor24[address(stor55.field_0)] = stor23[address(stor55.field_0)] / stor31 / 10^15
                    stor29[address(stor55.field_0)] = 1
                    stor30.length++
                    stor50BB[stor30.length] = uniswapV2PairAddress
                    if arg2 <= 0:
                        revert with 0, 'Initial avax for add liquidity should be bigger than zero'
                    if arg3 <= 0:
                        revert with 0, 'Initial tokens for add liquidity be bigger than zero'
                    if eth.balance(this.address) <= 0:
                        revert with 0, 'Must have AVAX on contract to launch'
                    if owner != msg.sender:
                        revert with 0, 'Ownable: caller is not the owner'
                    if not msg.sender:
                        revert with 0, '_liquidityAddress address cannot be 0'
                    liquidityAddress = msg.sender
                    stor28[address(msg.sender)] = 1
                    emit UpdatedLiquidityAddress(msg.sender);
                if idx >= stor30.length:
                    revert with 0, 50
                mem[0] = stor30[idx]
                mem[32] = 23
                _875 = mem[64]
                mem[64] = mem[64] + 64
                mem[_875] = 30
                mem[_875 + 32] = 'SafeMath: subtraction overflow'
                if stor23[stor30[idx]] > t:
                    _878 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _878 + 68] = mem[idx + _875 + 32]
                        idx = idx + 32
                        continue 
                    mem[_878 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _878 + -mem[64] + 100
                if t < stor23[stor30[idx]]:
                    revert with 0, 17
                if idx >= stor30.length:
                    revert with 0, 50
                mem[0] = stor30[idx]
                mem[32] = 24
                _907 = mem[64]
                mem[64] = mem[64] + 64
                mem[_907] = 30
                mem[_907 + 32] = 'SafeMath: subtraction overflow'
                if stor24[stor30[idx]] <= s:
                    if s < stor24[stor30[idx]]:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s - stor24[stor30[idx]]
                    t = t - stor23[stor30[idx]]
                    continue 
                _915 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _915 + 68] = mem[idx + _907 + 32]
                    idx = idx + 32
                    continue 
                mem[_915 + 98] = 0
                revert with memory
                  from mem[64]
                   len _915 + -mem[64] + 100
            if t < stor31 / 10^15:
                if not stor31 / 10^15:
                    revert with 0, 'SafeMath: division by zero', 0
                stor24[address(stor55.field_0)] = stor23[address(stor55.field_0)] / stor31 / 10^15
            else:
                if not s:
                    revert with 0, 'SafeMath: division by zero', 0
                if not t / s:
                    revert with 0, 'SafeMath: division by zero', 0
                stor24[address(stor55.field_0)] = stor23[address(stor55.field_0)] / t / s
    else:
        mem[0] = this.address
        mem[32] = 23
        if stor23[address(this.address)] > stor31:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
        idx = 0
        s = 10^15
        t = stor31
        while idx < stor30.length:
            mem[0] = stor30[idx]
            mem[32] = 23
            if stor23[stor30[idx]] > t:
                _867 = mem[64]
                mem[64] = mem[64] + 64
                mem[_867] = 26
                mem[_867 + 32] = 'SafeMath: division by zero'
                _890 = mem[64]
                mem[64] = mem[64] + 64
                mem[_890] = 26
                mem[_890 + 32] = 'SafeMath: division by zero'
                if not stor31 / 10^15:
                    _902 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _902 + 68] = mem[idx + _890 + 32]
                        idx = idx + 32
                        continue 
                    mem[_902 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _902 + -mem[64] + 100
                if not this.address:
                    revert with 0, 'ERC20: approve from the zero address'
                if not address(arg1):
                    revert with 0, 'ERC20: approve to the zero address'
                mem[0] = address(arg1)
                mem[32] = sha3(address(this.address), 25)
                allowance[address(this.address)][address(arg1)] = stor23[address(this.address)] / stor31 / 10^15
                emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, address(arg1));
                staticcall address(arg1).factory() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _979 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1000 = mem[_979]
                require mem[_979] == mem[_979 + 12 len 20]
                staticcall address(arg1).0x73b295c2 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1050 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1064 = mem[_1050]
                require mem[_1050] == mem[_1050 + 12 len 20]
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = address(_1064)
                call address(_1000).createPair(address arg1, address arg2) with:
                     gas gas_remaining wei
                    args address(this.address), address(_1064)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1089 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1089] == mem[_1089 + 12 len 20]
                uniswapV2PairAddress = mem[_1089 + 12 len 20]
                if owner != msg.sender:
                    revert with 0, 'Ownable: caller is not the owner'
                mem[0] = mem[_1089 + 12 len 20]
                stor48[mem[0]] = 1
                stor52[address(stor55.field_0)] = 1
                stor48[address(stor55.field_0)] = 1
                if owner != msg.sender:
                    revert with 0, 'Ownable: caller is not the owner'
                if stor29[address(stor55.field_0)]:
                    revert with 0, 'Account is already excluded'
                if 1 > !stor30.length:
                    revert with 0, 17
                if stor30.length + 1 > 50:
                    revert with 0, 'Cannot exclude more than 50 accounts.  Include a previously excluded address.'
                if stor23[address(stor55.field_0)]:
                    mem[0] = uniswapV2PairAddress
                    mem[32] = 23
                    if stor23[address(stor55.field_0)] > stor31:
                        revert with 0, 'Amount must be less than total reflections'
                    idx = 0
                    s = 10^15
                    t = stor31
                    while idx < stor30.length:
                        mem[0] = stor30[idx]
                        mem[32] = 23
                        if stor23[stor30[idx]] > t:
                            _1725 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1725] = 26
                            mem[_1725 + 32] = 'SafeMath: division by zero'
                            _1774 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1774] = 26
                            mem[_1774 + 32] = 'SafeMath: division by zero'
                            if not stor31 / 10^15:
                                _1800 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _1800 + 68] = mem[idx + _1774 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1800 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1800 + -mem[64] + 100
                            stor24[address(stor55.field_0)] = stor23[address(stor55.field_0)] / stor31 / 10^15
                            stor29[address(stor55.field_0)] = 1
                            stor30.length++
                            stor50BB[stor30.length] = uniswapV2PairAddress
                            if arg2 <= 0:
                                revert with 0, 'Initial avax for add liquidity should be bigger than zero'
                            if arg3 <= 0:
                                revert with 0, 'Initial tokens for add liquidity be bigger than zero'
                            if eth.balance(this.address) <= 0:
                                revert with 0, 'Must have AVAX on contract to launch'
                            if owner != msg.sender:
                                revert with 0, 'Ownable: caller is not the owner'
                            if not msg.sender:
                                revert with 0, '_liquidityAddress address cannot be 0'
                            liquidityAddress = msg.sender
                            stor28[address(msg.sender)] = 1
                            emit UpdatedLiquidityAddress(msg.sender);
                        if idx >= stor30.length:
                            revert with 0, 50
                        mem[0] = stor30[idx]
                        mem[32] = 24
                        if stor24[stor30[idx]] > s:
                            _1740 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1740] = 26
                            mem[_1740 + 32] = 'SafeMath: division by zero'
                            _1802 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1802] = 26
                            mem[_1802 + 32] = 'SafeMath: division by zero'
                            if not stor31 / 10^15:
                                _1819 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _1819 + 68] = mem[idx + _1802 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1819 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1819 + -mem[64] + 100
                            stor24[address(stor55.field_0)] = stor23[address(stor55.field_0)] / stor31 / 10^15
                            stor29[address(stor55.field_0)] = 1
                            stor30.length++
                            stor50BB[stor30.length] = uniswapV2PairAddress
                            if arg2 <= 0:
                                revert with 0, 'Initial avax for add liquidity should be bigger than zero'
                            if arg3 <= 0:
                                revert with 0, 'Initial tokens for add liquidity be bigger than zero'
                            if eth.balance(this.address) <= 0:
                                revert with 0, 'Must have AVAX on contract to launch'
                            if owner != msg.sender:
                                revert with 0, 'Ownable: caller is not the owner'
                            if not msg.sender:
                                revert with 0, '_liquidityAddress address cannot be 0'
                            liquidityAddress = msg.sender
                            stor28[address(msg.sender)] = 1
                            emit UpdatedLiquidityAddress(msg.sender);
                        if idx >= stor30.length:
                            revert with 0, 50
                        mem[0] = stor30[idx]
                        mem[32] = 23
                        _1739 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1739] = 30
                        mem[_1739 + 32] = 'SafeMath: subtraction overflow'
                        if stor23[stor30[idx]] > t:
                            _1745 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _1745 + 68] = mem[idx + _1739 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1745 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _1745 + -mem[64] + 100
                        if t < stor23[stor30[idx]]:
                            revert with 0, 17
                        if idx >= stor30.length:
                            revert with 0, 50
                        mem[0] = stor30[idx]
                        mem[32] = 24
                        _1801 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1801] = 30
                        mem[_1801 + 32] = 'SafeMath: subtraction overflow'
                        if stor24[stor30[idx]] <= s:
                            if s < stor24[stor30[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor24[stor30[idx]]
                            t = t - stor23[stor30[idx]]
                            continue 
                        _1818 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _1818 + 68] = mem[idx + _1801 + 32]
                            idx = idx + 32
                            continue 
                        mem[_1818 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _1818 + -mem[64] + 100
                    _1681 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1681] = 26
                    mem[_1681 + 32] = 'SafeMath: division by zero'
                    if t < stor31 / 10^15:
                        _1756 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1756] = 26
                        mem[_1756 + 32] = 'SafeMath: division by zero'
                        _1844 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1844] = 26
                        mem[_1844 + 32] = 'SafeMath: division by zero'
                        if not stor31 / 10^15:
                            _1868 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            s = 0
                            while s < 26:
                                mem[s + _1868 + 68] = mem[s + _1844 + 32]
                                s = s + 32
                                continue 
                            mem[_1868 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1868 + -mem[64] + 100
                        stor24[address(stor55.field_0)] = stor23[address(stor55.field_0)] / stor31 / 10^15
                    else:
                        _1755 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1755] = 26
                        mem[_1755 + 32] = 'SafeMath: division by zero'
                        if not s:
                            _1765 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _1765 + 68] = mem[idx + _1755 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1765 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1765 + -mem[64] + 100
                        _1843 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1843] = 26
                        mem[_1843 + 32] = 'SafeMath: division by zero'
                        if not t / s:
                            _1867 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            s = 0
                            while s < 26:
                                mem[s + _1867 + 68] = mem[s + _1843 + 32]
                                s = s + 32
                                continue 
                            mem[_1867 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1867 + -mem[64] + 100
                        stor24[address(stor55.field_0)] = stor23[address(stor55.field_0)] / t / s
            else:
                if idx >= stor30.length:
                    revert with 0, 50
                mem[0] = stor30[idx]
                mem[32] = 24
                if stor24[stor30[idx]] <= s:
                    if idx >= stor30.length:
                        revert with 0, 50
                    mem[0] = stor30[idx]
                    mem[32] = 23
                    _873 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_873] = 30
                    mem[_873 + 32] = 'SafeMath: subtraction overflow'
                    if stor23[stor30[idx]] > t:
                        _877 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _877 + 68] = mem[idx + _873 + 32]
                            idx = idx + 32
                            continue 
                        mem[_877 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _877 + -mem[64] + 100
                    if t < stor23[stor30[idx]]:
                        revert with 0, 17
                    if idx >= stor30.length:
                        revert with 0, 50
                    mem[0] = stor30[idx]
                    mem[32] = 24
                    _903 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_903] = 30
                    mem[_903 + 32] = 'SafeMath: subtraction overflow'
                    if stor24[stor30[idx]] <= s:
                        if s < stor24[stor30[idx]]:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s - stor24[stor30[idx]]
                        t = t - stor23[stor30[idx]]
                        continue 
                    _912 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _912 + 68] = mem[idx + _903 + 32]
                        idx = idx + 32
                        continue 
                    mem[_912 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _912 + -mem[64] + 100
                _874 = mem[64]
                mem[64] = mem[64] + 64
                mem[_874] = 26
                mem[_874 + 32] = 'SafeMath: division by zero'
                _904 = mem[64]
                mem[64] = mem[64] + 64
                mem[_904] = 26
                mem[_904 + 32] = 'SafeMath: division by zero'
                if not stor31 / 10^15:
                    _913 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _913 + 68] = mem[idx + _904 + 32]
                        idx = idx + 32
                        continue 
                    mem[_913 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _913 + -mem[64] + 100
                if not this.address:
                    revert with 0, 'ERC20: approve from the zero address'
                if not address(arg1):
                    revert with 0, 'ERC20: approve to the zero address'
                mem[0] = address(arg1)
                mem[32] = sha3(address(this.address), 25)
                allowance[address(this.address)][address(arg1)] = stor23[address(this.address)] / stor31 / 10^15
                emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, address(arg1));
                staticcall address(arg1).factory() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1001 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1022 = mem[_1001]
                require mem[_1001] == mem[_1001 + 12 len 20]
                staticcall address(arg1).0x73b295c2 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1065 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1074 = mem[_1065]
                require mem[_1065] == mem[_1065 + 12 len 20]
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = address(_1074)
                call address(_1022).createPair(address arg1, address arg2) with:
                     gas gas_remaining wei
                    args address(this.address), address(_1074)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1095 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1095] == mem[_1095 + 12 len 20]
                uniswapV2PairAddress = mem[_1095 + 12 len 20]
                if owner != msg.sender:
                    revert with 0, 'Ownable: caller is not the owner'
                mem[0] = mem[_1095 + 12 len 20]
                stor48[mem[0]] = 1
                stor52[address(stor55.field_0)] = 1
                stor48[address(stor55.field_0)] = 1
                if owner != msg.sender:
                    revert with 0, 'Ownable: caller is not the owner'
                if stor29[address(stor55.field_0)]:
                    revert with 0, 'Account is already excluded'
                if 1 > !stor30.length:
                    revert with 0, 17
                if stor30.length + 1 > 50:
                    revert with 0, 'Cannot exclude more than 50 accounts.  Include a previously excluded address.'
                if stor23[address(stor55.field_0)]:
                    mem[0] = uniswapV2PairAddress
                    mem[32] = 23
                    if stor23[address(stor55.field_0)] > stor31:
                        revert with 0, 'Amount must be less than total reflections'
                    idx = 0
                    s = 10^15
                    t = stor31
                    while idx < stor30.length:
                        mem[0] = stor30[idx]
                        mem[32] = 23
                        if stor23[stor30[idx]] > t:
                            _1726 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1726] = 26
                            mem[_1726 + 32] = 'SafeMath: division by zero'
                            _1777 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1777] = 26
                            mem[_1777 + 32] = 'SafeMath: division by zero'
                            if not stor31 / 10^15:
                                _1804 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _1804 + 68] = mem[idx + _1777 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1804 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1804 + -mem[64] + 100
                            stor24[address(stor55.field_0)] = stor23[address(stor55.field_0)] / stor31 / 10^15
                            stor29[address(stor55.field_0)] = 1
                            stor30.length++
                            stor50BB[stor30.length] = uniswapV2PairAddress
                            if arg2 <= 0:
                                revert with 0, 'Initial avax for add liquidity should be bigger than zero'
                            if arg3 <= 0:
                                revert with 0, 'Initial tokens for add liquidity be bigger than zero'
                            if eth.balance(this.address) <= 0:
                                revert with 0, 'Must have AVAX on contract to launch'
                            if owner != msg.sender:
                                revert with 0, 'Ownable: caller is not the owner'
                            if not msg.sender:
                                revert with 0, '_liquidityAddress address cannot be 0'
                            liquidityAddress = msg.sender
                            stor28[address(msg.sender)] = 1
                            emit UpdatedLiquidityAddress(msg.sender);
                        if idx >= stor30.length:
                            revert with 0, 50
                        mem[0] = stor30[idx]
                        mem[32] = 24
                        if stor24[stor30[idx]] > s:
                            _1742 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1742] = 26
                            mem[_1742 + 32] = 'SafeMath: division by zero'
                            _1806 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1806] = 26
                            mem[_1806 + 32] = 'SafeMath: division by zero'
                            if not stor31 / 10^15:
                                _1822 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _1822 + 68] = mem[idx + _1806 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1822 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1822 + -mem[64] + 100
                            stor24[address(stor55.field_0)] = stor23[address(stor55.field_0)] / stor31 / 10^15
                            stor29[address(stor55.field_0)] = 1
                            stor30.length++
                            stor50BB[stor30.length] = uniswapV2PairAddress
                            if arg2 <= 0:
                                revert with 0, 'Initial avax for add liquidity should be bigger than zero'
                            if arg3 <= 0:
                                revert with 0, 'Initial tokens for add liquidity be bigger than zero'
                            if eth.balance(this.address) <= 0:
                                revert with 0, 'Must have AVAX on contract to launch'
                            if owner != msg.sender:
                                revert with 0, 'Ownable: caller is not the owner'
                            if not msg.sender:
                                revert with 0, '_liquidityAddress address cannot be 0'
                            liquidityAddress = msg.sender
                            stor28[address(msg.sender)] = 1
                            emit UpdatedLiquidityAddress(msg.sender);
                        if idx >= stor30.length:
                            revert with 0, 50
                        mem[0] = stor30[idx]
                        mem[32] = 23
                        _1741 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1741] = 30
                        mem[_1741 + 32] = 'SafeMath: subtraction overflow'
                        if stor23[stor30[idx]] > t:
                            _1746 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _1746 + 68] = mem[idx + _1741 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1746 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _1746 + -mem[64] + 100
                        if t < stor23[stor30[idx]]:
                            revert with 0, 17
                        if idx >= stor30.length:
                            revert with 0, 50
                        mem[0] = stor30[idx]
                        mem[32] = 24
                        _1805 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1805] = 30
                        mem[_1805 + 32] = 'SafeMath: subtraction overflow'
                        if stor24[stor30[idx]] <= s:
                            if s < stor24[stor30[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor24[stor30[idx]]
                            t = t - stor23[stor30[idx]]
                            continue 
                        _1821 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _1821 + 68] = mem[idx + _1805 + 32]
                            idx = idx + 32
                            continue 
                        mem[_1821 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _1821 + -mem[64] + 100
                    _1684 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1684] = 26
                    mem[_1684 + 32] = 'SafeMath: division by zero'
                    if t < stor31 / 10^15:
                        _1758 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1758] = 26
                        mem[_1758 + 32] = 'SafeMath: division by zero'
                        _1846 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1846] = 26
                        mem[_1846 + 32] = 'SafeMath: division by zero'
                        if not stor31 / 10^15:
                            _1872 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            s = 0
                            while s < 26:
                                mem[s + _1872 + 68] = mem[s + _1846 + 32]
                                s = s + 32
                                continue 
                            mem[_1872 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1872 + -mem[64] + 100
                        stor24[address(stor55.field_0)] = stor23[address(stor55.field_0)] / stor31 / 10^15
                    else:
                        _1757 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1757] = 26
                        mem[_1757 + 32] = 'SafeMath: division by zero'
                        if not s:
                            _1766 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _1766 + 68] = mem[idx + _1757 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1766 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1766 + -mem[64] + 100
                        _1845 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1845] = 26
                        mem[_1845 + 32] = 'SafeMath: division by zero'
                        if not t / s:
                            _1871 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            s = 0
                            while s < 26:
                                mem[s + _1871 + 68] = mem[s + _1845 + 32]
                                s = s + 32
                                continue 
                            mem[_1871 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1871 + -mem[64] + 100
                        stor24[address(stor55.field_0)] = stor23[address(stor55.field_0)] / t / s
            stor29[address(stor55.field_0)] = 1
            stor30.length++
            stor50BB[stor30.length] = uniswapV2PairAddress
            if arg2 <= 0:
                revert with 0, 'Initial avax for add liquidity should be bigger than zero'
            if arg3 <= 0:
                revert with 0, 'Initial tokens for add liquidity be bigger than zero'
            if eth.balance(this.address) <= 0:
                revert with 0, 'Must have AVAX on contract to launch'
            if owner != msg.sender:
                revert with 0, 'Ownable: caller is not the owner'
            if not msg.sender:
                revert with 0, '_liquidityAddress address cannot be 0'
            liquidityAddress = msg.sender
            stor28[address(msg.sender)] = 1
            emit UpdatedLiquidityAddress(msg.sender);
        _857 = mem[64]
        mem[64] = mem[64] + 64
        mem[_857] = 26
        mem[_857 + 32] = 'SafeMath: division by zero'
        if t < stor31 / 10^15:
            _882 = mem[64]
            mem[64] = mem[64] + 64
            mem[_882] = 26
            mem[_882 + 32] = 'SafeMath: division by zero'
            _926 = mem[64]
            mem[64] = mem[64] + 64
            mem[_926] = 26
            mem[_926 + 32] = 'SafeMath: division by zero'
            if not stor31 / 10^15:
                revert with 0, 'SafeMath: division by zero', 0
            if not this.address:
                revert with 0, 'ERC20: approve from the zero address'
            if not address(arg1):
                revert with 0, 'ERC20: approve to the zero address'
            mem[0] = address(arg1)
            mem[32] = sha3(address(this.address), 25)
            allowance[address(this.address)][address(arg1)] = stor23[address(this.address)] / stor31 / 10^15
            emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, address(arg1));
            staticcall address(arg1).factory() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1040 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1059 = mem[_1040]
            require mem[_1040] == mem[_1040 + 12 len 20]
            staticcall address(arg1).0x73b295c2 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1086 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1091 = mem[_1086]
            require mem[_1086] == mem[_1086 + 12 len 20]
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = address(_1091)
            call address(_1059).createPair(address arg1, address arg2) with:
                 gas gas_remaining wei
                args address(this.address), address(_1091)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1102 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_1102] == mem[_1102 + 12 len 20]
            uniswapV2PairAddress = mem[_1102 + 12 len 20]
            if owner != msg.sender:
                revert with 0, 'Ownable: caller is not the owner'
            mem[0] = mem[_1102 + 12 len 20]
            stor48[mem[0]] = 1
            stor52[address(stor55.field_0)] = 1
            stor48[address(stor55.field_0)] = 1
            if owner != msg.sender:
                revert with 0, 'Ownable: caller is not the owner'
            if stor29[address(stor55.field_0)]:
                revert with 0, 'Account is already excluded'
            if 1 > !stor30.length:
                revert with 0, 17
            if stor30.length + 1 > 50:
                revert with 0, 'Cannot exclude more than 50 accounts.  Include a previously excluded address.'
            if stor23[address(stor55.field_0)]:
                mem[0] = uniswapV2PairAddress
                mem[32] = 23
                if stor23[address(stor55.field_0)] > stor31:
                    revert with 0, 'Amount must be less than total reflections'
                idx = 0
                s = 10^15
                t = stor31
                while idx < stor30.length:
                    mem[0] = stor30[idx]
                    mem[32] = 23
                    if stor23[stor30[idx]] > t:
                        _1724 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1724] = 26
                        mem[_1724 + 32] = 'SafeMath: division by zero'
                        _1771 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1771] = 26
                        mem[_1771 + 32] = 'SafeMath: division by zero'
                        if not stor31 / 10^15:
                            _1796 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _1796 + 68] = mem[idx + _1771 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1796 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1796 + -mem[64] + 100
                        stor24[address(stor55.field_0)] = stor23[address(stor55.field_0)] / stor31 / 10^15
                        stor29[address(stor55.field_0)] = 1
                        stor30.length++
                        stor50BB[stor30.length] = uniswapV2PairAddress
                        if arg2 <= 0:
                            revert with 0, 'Initial avax for add liquidity should be bigger than zero'
                        if arg3 <= 0:
                            revert with 0, 'Initial tokens for add liquidity be bigger than zero'
                        if eth.balance(this.address) <= 0:
                            revert with 0, 'Must have AVAX on contract to launch'
                        if owner != msg.sender:
                            revert with 0, 'Ownable: caller is not the owner'
                        if not msg.sender:
                            revert with 0, '_liquidityAddress address cannot be 0'
                        liquidityAddress = msg.sender
                        stor28[address(msg.sender)] = 1
                        emit UpdatedLiquidityAddress(msg.sender);
                    if idx >= stor30.length:
                        revert with 0, 50
                    mem[0] = stor30[idx]
                    mem[32] = 24
                    if stor24[stor30[idx]] > s:
                        _1738 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1738] = 26
                        mem[_1738 + 32] = 'SafeMath: division by zero'
                        _1798 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1798] = 26
                        mem[_1798 + 32] = 'SafeMath: division by zero'
                        if not stor31 / 10^15:
                            _1816 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _1816 + 68] = mem[idx + _1798 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1816 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1816 + -mem[64] + 100
                        stor24[address(stor55.field_0)] = stor23[address(stor55.field_0)] / stor31 / 10^15
                        stor29[address(stor55.field_0)] = 1
                        stor30.length++
                        stor50BB[stor30.length] = uniswapV2PairAddress
                        if arg2 <= 0:
                            revert with 0, 'Initial avax for add liquidity should be bigger than zero'
                        if arg3 <= 0:
                            revert with 0, 'Initial tokens for add liquidity be bigger than zero'
                        if eth.balance(this.address) <= 0:
                            revert with 0, 'Must have AVAX on contract to launch'
                        if owner != msg.sender:
                            revert with 0, 'Ownable: caller is not the owner'
                        if not msg.sender:
                            revert with 0, '_liquidityAddress address cannot be 0'
                        liquidityAddress = msg.sender
                        stor28[address(msg.sender)] = 1
                        emit UpdatedLiquidityAddress(msg.sender);
                    if idx >= stor30.length:
                        revert with 0, 50
                    mem[0] = stor30[idx]
                    mem[32] = 23
                    _1737 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1737] = 30
                    mem[_1737 + 32] = 'SafeMath: subtraction overflow'
                    if stor23[stor30[idx]] > t:
                        _1744 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _1744 + 68] = mem[idx + _1737 + 32]
                            idx = idx + 32
                            continue 
                        mem[_1744 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _1744 + -mem[64] + 100
                    if t < stor23[stor30[idx]]:
                        revert with 0, 17
                    if idx >= stor30.length:
                        revert with 0, 50
                    mem[0] = stor30[idx]
                    mem[32] = 24
                    _1797 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1797] = 30
                    mem[_1797 + 32] = 'SafeMath: subtraction overflow'
                    if stor24[stor30[idx]] <= s:
                        if s < stor24[stor30[idx]]:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s - stor24[stor30[idx]]
                        t = t - stor23[stor30[idx]]
                        continue 
                    _1815 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1815 + 68] = mem[idx + _1797 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1815 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _1815 + -mem[64] + 100
                if t < stor31 / 10^15:
                    if not stor31 / 10^15:
                        revert with 0, 'SafeMath: division by zero', 0
                    stor24[address(stor55.field_0)] = stor23[address(stor55.field_0)] / stor31 / 10^15
                else:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not t / s:
                        revert with 0, 'SafeMath: division by zero', 0
                    stor24[address(stor55.field_0)] = stor23[address(stor55.field_0)] / t / s
        else:
            _881 = mem[64]
            mem[64] = mem[64] + 64
            mem[_881] = 26
            mem[_881 + 32] = 'SafeMath: division by zero'
            if not s:
                revert with 0, 'SafeMath: division by zero', 0
            _925 = mem[64]
            mem[64] = mem[64] + 64
            mem[_925] = 26
            mem[_925 + 32] = 'SafeMath: division by zero'
            if not t / s:
                revert with 0, 'SafeMath: division by zero', 0
            if not this.address:
                revert with 0, 'ERC20: approve from the zero address'
            if not address(arg1):
                revert with 0, 'ERC20: approve to the zero address'
            mem[0] = address(arg1)
            mem[32] = sha3(address(this.address), 25)
            allowance[address(this.address)][address(arg1)] = stor23[address(this.address)] / t / s
            emit Approval((stor23[address(this.address)] / t / s), this.address, address(arg1));
            staticcall address(arg1).factory() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1039 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1058 = mem[_1039]
            require mem[_1039] == mem[_1039 + 12 len 20]
            staticcall address(arg1).0x73b295c2 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1085 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1090 = mem[_1085]
            require mem[_1085] == mem[_1085 + 12 len 20]
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = address(_1090)
            call address(_1058).createPair(address arg1, address arg2) with:
                 gas gas_remaining wei
                args address(this.address), address(_1090)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1101 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_1101] == mem[_1101 + 12 len 20]
            uniswapV2PairAddress = mem[_1101 + 12 len 20]
            if owner != msg.sender:
                revert with 0, 'Ownable: caller is not the owner'
            mem[0] = mem[_1101 + 12 len 20]
            stor48[mem[0]] = 1
            stor52[address(stor55.field_0)] = 1
            stor48[address(stor55.field_0)] = 1
            if owner != msg.sender:
                revert with 0, 'Ownable: caller is not the owner'
            if stor29[address(stor55.field_0)]:
                revert with 0, 'Account is already excluded'
            if 1 > !stor30.length:
                revert with 0, 17
            if stor30.length + 1 > 50:
                revert with 0, 'Cannot exclude more than 50 accounts.  Include a previously excluded address.'
            if stor23[address(stor55.field_0)]:
                mem[0] = uniswapV2PairAddress
                mem[32] = 23
                if stor23[address(stor55.field_0)] > stor31:
                    revert with 0, 'Amount must be less than total reflections'
                idx = 0
                s = 10^15
                t = stor31
                while idx < stor30.length:
                    mem[0] = stor30[idx]
                    mem[32] = 23
                    if stor23[stor30[idx]] > t:
                        _1723 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1723] = 26
                        mem[_1723 + 32] = 'SafeMath: division by zero'
                        _1768 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1768] = 26
                        mem[_1768 + 32] = 'SafeMath: division by zero'
                        if not stor31 / 10^15:
                            _1792 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _1792 + 68] = mem[idx + _1768 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1792 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1792 + -mem[64] + 100
                        stor24[address(stor55.field_0)] = stor23[address(stor55.field_0)] / stor31 / 10^15
                        stor29[address(stor55.field_0)] = 1
                        stor30.length++
                        stor50BB[stor30.length] = uniswapV2PairAddress
                        if arg2 <= 0:
                            revert with 0, 'Initial avax for add liquidity should be bigger than zero'
                        if arg3 <= 0:
                            revert with 0, 'Initial tokens for add liquidity be bigger than zero'
                        if eth.balance(this.address) <= 0:
                            revert with 0, 'Must have AVAX on contract to launch'
                        if owner != msg.sender:
                            revert with 0, 'Ownable: caller is not the owner'
                        if not msg.sender:
                            revert with 0, '_liquidityAddress address cannot be 0'
                        liquidityAddress = msg.sender
                        stor28[address(msg.sender)] = 1
                        emit UpdatedLiquidityAddress(msg.sender);
                    if idx >= stor30.length:
                        revert with 0, 50
                    mem[0] = stor30[idx]
                    mem[32] = 24
                    if stor24[stor30[idx]] > s:
                        _1736 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1736] = 26
                        mem[_1736 + 32] = 'SafeMath: division by zero'
                        _1794 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1794] = 26
                        mem[_1794 + 32] = 'SafeMath: division by zero'
                        if not stor31 / 10^15:
                            _1813 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _1813 + 68] = mem[idx + _1794 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1813 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1813 + -mem[64] + 100
                        stor24[address(stor55.field_0)] = stor23[address(stor55.field_0)] / stor31 / 10^15
                        stor29[address(stor55.field_0)] = 1
                        stor30.length++
                        stor50BB[stor30.length] = uniswapV2PairAddress
                        if arg2 <= 0:
                            revert with 0, 'Initial avax for add liquidity should be bigger than zero'
                        if arg3 <= 0:
                            revert with 0, 'Initial tokens for add liquidity be bigger than zero'
                        if eth.balance(this.address) <= 0:
                            revert with 0, 'Must have AVAX on contract to launch'
                        if owner != msg.sender:
                            revert with 0, 'Ownable: caller is not the owner'
                        if not msg.sender:
                            revert with 0, '_liquidityAddress address cannot be 0'
                        liquidityAddress = msg.sender
                        stor28[address(msg.sender)] = 1
                        emit UpdatedLiquidityAddress(msg.sender);
                    if idx >= stor30.length:
                        revert with 0, 50
                    mem[0] = stor30[idx]
                    mem[32] = 23
                    _1735 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1735] = 30
                    mem[_1735 + 32] = 'SafeMath: subtraction overflow'
                    if stor23[stor30[idx]] > t:
                        _1743 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _1743 + 68] = mem[idx + _1735 + 32]
                            idx = idx + 32
                            continue 
                        mem[_1743 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _1743 + -mem[64] + 100
                    if t < stor23[stor30[idx]]:
                        revert with 0, 17
                    if idx >= stor30.length:
                        revert with 0, 50
                    mem[0] = stor30[idx]
                    mem[32] = 24
                    _1793 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1793] = 30
                    mem[_1793 + 32] = 'SafeMath: subtraction overflow'
                    if stor24[stor30[idx]] <= s:
                        if s < stor24[stor30[idx]]:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s - stor24[stor30[idx]]
                        t = t - stor23[stor30[idx]]
                        continue 
                    _1812 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1812 + 68] = mem[idx + _1793 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1812 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _1812 + -mem[64] + 100
                if t < stor31 / 10^15:
                    if not stor31 / 10^15:
                        revert with 0, 'SafeMath: division by zero', 0
                    stor24[address(stor55.field_0)] = stor23[address(stor55.field_0)] / stor31 / 10^15
                else:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not t / s:
                        revert with 0, 'SafeMath: division by zero', 0
                    stor24[address(stor55.field_0)] = stor23[address(stor55.field_0)] / t / s
    stor29[address(stor55.field_0)] = 1
    stor30.length++
    stor50BB[stor30.length] = uniswapV2PairAddress
    if arg2 <= 0:
        revert with 0, 'Initial avax for add liquidity should be bigger than zero'
    if arg3 <= 0:
        revert with 0, 'Initial tokens for add liquidity be bigger than zero'
    if eth.balance(this.address) <= 0:
        revert with 0, 'Must have AVAX on contract to launch'
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not msg.sender:
        revert with 0, '_liquidityAddress address cannot be 0'
    liquidityAddress = msg.sender
    stor28[address(msg.sender)] = 1
    emit UpdatedLiquidityAddress(msg.sender);
}

function reflectionFromToken(uint256 arg1, bool arg2) {
    require calldata.size - 4 >= 64
    require arg2 == arg2
    if arg1 > 10^15:
        revert with 0, 'Amount must be less than supply'
    if arg2:
        if not arg1:
            mem[96] = 26
            mem[128] = 'SafeMath: division by zero'
            if not arg1:
                mem[160] = 26
                mem[192] = 'SafeMath: division by zero'
                mem[224] = 30
                mem[256] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 0, 17
                mem[64] = 352
                mem[288] = 30
                mem[320] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 0, 17
                idx = 0
                s = 10^15
                t = stor31
                while idx < stor30.length:
                    mem[0] = stor30[idx]
                    mem[32] = 23
                    if stor23[stor30[idx]] > t:
                        _2254 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2254] = 26
                        mem[_2254 + 32] = 'SafeMath: division by zero'
                        if not arg1:
                            return 0
                        if arg1 and stor31 / 10^15 > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor31 / 10^15 / arg1 != stor31 / 10^15:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _2578 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2578] = 30
                        mem[_2578 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor31 / 10^15:
                            _2636 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _2636 + 68] = mem[idx + _2578 + 32]
                                idx = idx + 32
                                continue 
                            mem[_2636 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _2636 + -mem[64] + 100
                        if arg1 * stor31 / 10^15 < 0:
                            revert with 0, 17
                        _2883 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2883] = 30
                        mem[_2883 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor31 / 10^15:
                            if arg1 * stor31 / 10^15 < 0:
                                revert with 0, 17
                            return (arg1 * stor31 / 10^15)
                        _3006 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _3006 + 68] = mem[idx + _2883 + 32]
                            idx = idx + 32
                            continue 
                        mem[_3006 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _3006 + -mem[64] + 100
                    if idx >= stor30.length:
                        revert with 0, 50
                    mem[0] = stor30[idx]
                    mem[32] = 24
                    if stor24[stor30[idx]] <= s:
                        if idx >= stor30.length:
                            revert with 0, 50
                        mem[0] = stor30[idx]
                        mem[32] = 23
                        _2281 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2281] = 30
                        mem[_2281 + 32] = 'SafeMath: subtraction overflow'
                        if stor23[stor30[idx]] > t:
                            _2294 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _2294 + 68] = mem[idx + _2281 + 32]
                                idx = idx + 32
                                continue 
                            mem[_2294 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _2294 + -mem[64] + 100
                        if t < stor23[stor30[idx]]:
                            revert with 0, 17
                        if idx >= stor30.length:
                            revert with 0, 50
                        mem[0] = stor30[idx]
                        mem[32] = 24
                        _2386 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2386] = 30
                        mem[_2386 + 32] = 'SafeMath: subtraction overflow'
                        if stor24[stor30[idx]] <= s:
                            if s < stor24[stor30[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor24[stor30[idx]]
                            t = t - stor23[stor30[idx]]
                            continue 
                        _2402 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _2402 + 68] = mem[idx + _2386 + 32]
                            idx = idx + 32
                            continue 
                        mem[_2402 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2402 + -mem[64] + 100
                    _2282 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2282] = 26
                    mem[_2282 + 32] = 'SafeMath: division by zero'
                    if not arg1:
                        return 0
                    if arg1 and stor31 / 10^15 > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor31 / 10^15 / arg1 != stor31 / 10^15:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2638 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2638] = 30
                    mem[_2638 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor31 / 10^15:
                        _2690 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _2690 + 68] = mem[idx + _2638 + 32]
                            idx = idx + 32
                            continue 
                        mem[_2690 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2690 + -mem[64] + 100
                    if arg1 * stor31 / 10^15 < 0:
                        revert with 0, 17
                    _3007 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3007] = 30
                    mem[_3007 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= arg1 * stor31 / 10^15:
                        if arg1 * stor31 / 10^15 < 0:
                            revert with 0, 17
                        return (arg1 * stor31 / 10^15)
                    _3136 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _3136 + 68] = mem[idx + _3007 + 32]
                        idx = idx + 32
                        continue 
                    mem[_3136 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _3136 + -mem[64] + 100
                if t < stor31 / 10^15:
                    if not arg1:
                        return 0
                    if arg1 and stor31 / 10^15 > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor31 / 10^15 / arg1 != stor31 / 10^15:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * stor31 / 10^15:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor31 / 10^15 < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor31 / 10^15:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor31 / 10^15 < 0:
                        revert with 0, 17
                    return (arg1 * stor31 / 10^15)
                if not s:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    return 0
                if arg1 and t / s > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * t / s / arg1 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < 0:
                    revert with 0, 17
                if 0 > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < 0:
                    revert with 0, 17
                return (arg1 * t / s)
            if arg1 and stor35 > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor35 / arg1 != stor35:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[160] = 26
            mem[192] = 'SafeMath: division by zero'
            mem[224] = 30
            mem[256] = 'SafeMath: subtraction overflow'
            if 0 > arg1:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 < 0:
                revert with 0, 17
            mem[64] = 352
            mem[288] = 30
            mem[320] = 'SafeMath: subtraction overflow'
            if arg1 * stor35 / 10000 > arg1:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 < arg1 * stor35 / 10000:
                revert with 0, 17
            idx = 0
            s = 10^15
            t = stor31
            while idx < stor30.length:
                mem[0] = stor30[idx]
                mem[32] = 23
                if stor23[stor30[idx]] > t:
                    _2253 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2253] = 26
                    mem[_2253 + 32] = 'SafeMath: division by zero'
                    if not arg1:
                        if not arg1 * stor35 / 10000:
                            return 0
                        if arg1 * stor35 / 10000 and stor31 / 10^15 > -1 / arg1 * stor35 / 10000:
                            revert with 0, 17
                        if not arg1 * stor35 / 10000:
                            revert with 0, 18
                        if arg1 * stor35 / 10000 * stor31 / 10^15 / arg1 * stor35 / 10000 != stor31 / 10^15:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _2574 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2574] = 30
                        mem[_2574 + 32] = 'SafeMath: subtraction overflow'
                        _2877 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2877] = 30
                        mem[_2877 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor35 / 10000 * stor31 / 10^15 <= 0:
                            if 0 < arg1 * stor35 / 10000 * stor31 / 10^15:
                                revert with 0, 17
                            return (-1 * arg1 * stor35 / 10000 * stor31 / 10^15)
                        _3001 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _3001 + 68] = mem[idx + _2877 + 32]
                            idx = idx + 32
                            continue 
                        mem[_3001 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _3001 + -mem[64] + 100
                    if arg1 and stor31 / 10^15 > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor31 / 10^15 / arg1 != stor31 / 10^15:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor35 / 10000:
                        _2573 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2573] = 30
                        mem[_2573 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor31 / 10^15:
                            _2632 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _2632 + 68] = mem[idx + _2573 + 32]
                                idx = idx + 32
                                continue 
                            mem[_2632 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _2632 + -mem[64] + 100
                        if arg1 * stor31 / 10^15 < 0:
                            revert with 0, 17
                        _2875 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2875] = 30
                        mem[_2875 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor31 / 10^15:
                            if arg1 * stor31 / 10^15 < 0:
                                revert with 0, 17
                            return (arg1 * stor31 / 10^15)
                        _3000 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _3000 + 68] = mem[idx + _2875 + 32]
                            idx = idx + 32
                            continue 
                        mem[_3000 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _3000 + -mem[64] + 100
                    if arg1 * stor35 / 10000 and stor31 / 10^15 > -1 / arg1 * stor35 / 10000:
                        revert with 0, 17
                    if not arg1 * stor35 / 10000:
                        revert with 0, 18
                    if arg1 * stor35 / 10000 * stor31 / 10^15 / arg1 * stor35 / 10000 != stor31 / 10^15:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2771 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2771] = 30
                    mem[_2771 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor31 / 10^15:
                        _2874 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _2874 + 68] = mem[idx + _2771 + 32]
                            idx = idx + 32
                            continue 
                        mem[_2874 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2874 + -mem[64] + 100
                    if arg1 * stor31 / 10^15 < 0:
                        revert with 0, 17
                    _3289 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3289] = 30
                    mem[_3289 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor35 / 10000 * stor31 / 10^15 <= arg1 * stor31 / 10^15:
                        if arg1 * stor31 / 10^15 < arg1 * stor35 / 10000 * stor31 / 10^15:
                            revert with 0, 17
                        return ((arg1 * stor31 / 10^15) - (arg1 * stor35 / 10000 * stor31 / 10^15))
                    _3459 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _3459 + 68] = mem[idx + _3289 + 32]
                        idx = idx + 32
                        continue 
                    mem[_3459 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _3459 + -mem[64] + 100
                if idx >= stor30.length:
                    revert with 0, 50
                mem[0] = stor30[idx]
                mem[32] = 24
                if stor24[stor30[idx]] <= s:
                    if idx >= stor30.length:
                        revert with 0, 50
                    mem[0] = stor30[idx]
                    mem[32] = 23
                    _2279 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2279] = 30
                    mem[_2279 + 32] = 'SafeMath: subtraction overflow'
                    if stor23[stor30[idx]] > t:
                        _2293 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _2293 + 68] = mem[idx + _2279 + 32]
                            idx = idx + 32
                            continue 
                        mem[_2293 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2293 + -mem[64] + 100
                    if t < stor23[stor30[idx]]:
                        revert with 0, 17
                    if idx >= stor30.length:
                        revert with 0, 50
                    mem[0] = stor30[idx]
                    mem[32] = 24
                    _2384 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2384] = 30
                    mem[_2384 + 32] = 'SafeMath: subtraction overflow'
                    if stor24[stor30[idx]] <= s:
                        if s < stor24[stor30[idx]]:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s - stor24[stor30[idx]]
                        t = t - stor23[stor30[idx]]
                        continue 
                    _2400 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _2400 + 68] = mem[idx + _2384 + 32]
                        idx = idx + 32
                        continue 
                    mem[_2400 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _2400 + -mem[64] + 100
                _2280 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2280] = 26
                mem[_2280 + 32] = 'SafeMath: division by zero'
                if not arg1:
                    if not arg1 * stor35 / 10000:
                        return 0
                    if arg1 * stor35 / 10000 and stor31 / 10^15 > -1 / arg1 * stor35 / 10000:
                        revert with 0, 17
                    if not arg1 * stor35 / 10000:
                        revert with 0, 18
                    if arg1 * stor35 / 10000 * stor31 / 10^15 / arg1 * stor35 / 10000 != stor31 / 10^15:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2635 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2635] = 30
                    mem[_2635 + 32] = 'SafeMath: subtraction overflow'
                    _3005 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3005] = 30
                    mem[_3005 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor35 / 10000 * stor31 / 10^15 <= 0:
                        if 0 < arg1 * stor35 / 10000 * stor31 / 10^15:
                            revert with 0, 17
                        return (-1 * arg1 * stor35 / 10000 * stor31 / 10^15)
                    _3135 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _3135 + 68] = mem[idx + _3005 + 32]
                        idx = idx + 32
                        continue 
                    mem[_3135 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _3135 + -mem[64] + 100
                if arg1 and stor31 / 10^15 > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor31 / 10^15 / arg1 != stor31 / 10^15:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor35 / 10000:
                    _2634 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2634] = 30
                    mem[_2634 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor31 / 10^15:
                        _2688 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _2688 + 68] = mem[idx + _2634 + 32]
                            idx = idx + 32
                            continue 
                        mem[_2688 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2688 + -mem[64] + 100
                    if arg1 * stor31 / 10^15 < 0:
                        revert with 0, 17
                    _3003 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3003] = 30
                    mem[_3003 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= arg1 * stor31 / 10^15:
                        if arg1 * stor31 / 10^15 < 0:
                            revert with 0, 17
                        return (arg1 * stor31 / 10^15)
                    _3134 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _3134 + 68] = mem[idx + _3003 + 32]
                        idx = idx + 32
                        continue 
                    mem[_3134 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _3134 + -mem[64] + 100
                if arg1 * stor35 / 10000 and stor31 / 10^15 > -1 / arg1 * stor35 / 10000:
                    revert with 0, 17
                if not arg1 * stor35 / 10000:
                    revert with 0, 18
                if arg1 * stor35 / 10000 * stor31 / 10^15 / arg1 * stor35 / 10000 != stor31 / 10^15:
                    revert with 0, 'SafeMath: multiplication overflow'
                _2878 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2878] = 30
                mem[_2878 + 32] = 'SafeMath: subtraction overflow'
                if 0 > arg1 * stor31 / 10^15:
                    _3002 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _3002 + 68] = mem[idx + _2878 + 32]
                        idx = idx + 32
                        continue 
                    mem[_3002 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _3002 + -mem[64] + 100
                if arg1 * stor31 / 10^15 < 0:
                    revert with 0, 17
                _3462 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3462] = 30
                mem[_3462 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor35 / 10000 * stor31 / 10^15 <= arg1 * stor31 / 10^15:
                    if arg1 * stor31 / 10^15 < arg1 * stor35 / 10000 * stor31 / 10^15:
                        revert with 0, 17
                    return ((arg1 * stor31 / 10^15) - (arg1 * stor35 / 10000 * stor31 / 10^15))
                _3612 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _3612 + 68] = mem[idx + _3462 + 32]
                    idx = idx + 32
                    continue 
                mem[_3612 + 98] = 0
                revert with memory
                  from mem[64]
                   len _3612 + -mem[64] + 100
            if t < stor31 / 10^15:
                if not arg1:
                    if not arg1 * stor35 / 10000:
                        return 0
                    if arg1 * stor35 / 10000 and stor31 / 10^15 > -1 / arg1 * stor35 / 10000:
                        revert with 0, 17
                    if not arg1 * stor35 / 10000:
                        revert with 0, 18
                    if arg1 * stor35 / 10000 * stor31 / 10^15 / arg1 * stor35 / 10000 != stor31 / 10^15:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor35 / 10000 * stor31 / 10^15 > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor35 / 10000 * stor31 / 10^15:
                        revert with 0, 17
                    return (-1 * arg1 * stor35 / 10000 * stor31 / 10^15)
                if arg1 and stor31 / 10^15 > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor31 / 10^15 / arg1 != stor31 / 10^15:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor35 / 10000:
                    if 0 > arg1 * stor31 / 10^15:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor31 / 10^15 < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor31 / 10^15:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor31 / 10^15 < 0:
                        revert with 0, 17
                    return (arg1 * stor31 / 10^15)
                if arg1 * stor35 / 10000 and stor31 / 10^15 > -1 / arg1 * stor35 / 10000:
                    revert with 0, 17
                if not arg1 * stor35 / 10000:
                    revert with 0, 18
                if arg1 * stor35 / 10000 * stor31 / 10^15 / arg1 * stor35 / 10000 != stor31 / 10^15:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor31 / 10^15:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor31 / 10^15 < 0:
                    revert with 0, 17
                if arg1 * stor35 / 10000 * stor31 / 10^15 > arg1 * stor31 / 10^15:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor31 / 10^15 < arg1 * stor35 / 10000 * stor31 / 10^15:
                    revert with 0, 17
                return ((arg1 * stor31 / 10^15) - (arg1 * stor35 / 10000 * stor31 / 10^15))
            if not s:
                revert with 0, 'SafeMath: division by zero', 0
            if not arg1:
                if not arg1 * stor35 / 10000:
                    return 0
                if arg1 * stor35 / 10000 and t / s > -1 / arg1 * stor35 / 10000:
                    revert with 0, 17
                if not arg1 * stor35 / 10000:
                    revert with 0, 18
                if arg1 * stor35 / 10000 * t / s / arg1 * stor35 / 10000 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * stor35 / 10000 * t / s > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * stor35 / 10000 * t / s:
                    revert with 0, 17
                return (-1 * arg1 * stor35 / 10000 * t / s)
            if arg1 and t / s > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * t / s / arg1 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor35 / 10000:
                if 0 > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < 0:
                    revert with 0, 17
                if 0 > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < 0:
                    revert with 0, 17
                return (arg1 * t / s)
            if arg1 * stor35 / 10000 and t / s > -1 / arg1 * stor35 / 10000:
                revert with 0, 17
            if not arg1 * stor35 / 10000:
                revert with 0, 18
            if arg1 * stor35 / 10000 * t / s / arg1 * stor35 / 10000 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if 0 > arg1 * t / s:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * t / s < 0:
                revert with 0, 17
            if arg1 * stor35 / 10000 * t / s > arg1 * t / s:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * t / s < arg1 * stor35 / 10000 * t / s:
                revert with 0, 17
            return ((arg1 * t / s) - (arg1 * stor35 / 10000 * t / s))
        if arg1 and stor33 > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * stor33 / arg1 != stor33:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
        mem[96] = 26
        mem[128] = 'SafeMath: division by zero'
        if not arg1:
            mem[160] = 26
            mem[192] = 'SafeMath: division by zero'
            mem[224] = 30
            mem[256] = 'SafeMath: subtraction overflow'
            if arg1 * stor33 / 10000 > arg1:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 < arg1 * stor33 / 10000:
                revert with 0, 17
            mem[64] = 352
            mem[288] = 30
            mem[320] = 'SafeMath: subtraction overflow'
            if 0 > arg1 - (arg1 * stor33 / 10000):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (arg1 * stor33 / 10000) < 0:
                revert with 0, 17
            idx = 0
            s = 10^15
            t = stor31
            while idx < stor30.length:
                mem[0] = stor30[idx]
                mem[32] = 23
                if stor23[stor30[idx]] > t:
                    _2252 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2252] = 26
                    mem[_2252 + 32] = 'SafeMath: division by zero'
                    if not arg1:
                        if not arg1 * stor33 / 10000:
                            return 0
                        if arg1 * stor33 / 10000 and stor31 / 10^15 > -1 / arg1 * stor33 / 10000:
                            revert with 0, 17
                        if not arg1 * stor33 / 10000:
                            revert with 0, 18
                        if arg1 * stor33 / 10000 * stor31 / 10^15 / arg1 * stor33 / 10000 != stor31 / 10^15:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _2570 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2570] = 30
                        mem[_2570 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor33 / 10000 * stor31 / 10^15 > 0:
                            _2627 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _2627 + 68] = mem[idx + _2570 + 32]
                                idx = idx + 32
                                continue 
                            mem[_2627 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _2627 + -mem[64] + 100
                        if 0 < arg1 * stor33 / 10000 * stor31 / 10^15:
                            revert with 0, 17
                        _2867 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2867] = 30
                        mem[_2867 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * stor33 / 10000 * stor31 / 10^15:
                            if -1 * arg1 * stor33 / 10000 * stor31 / 10^15 < 0:
                                revert with 0, 17
                            return (-1 * arg1 * stor33 / 10000 * stor31 / 10^15)
                        _2992 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _2992 + 68] = mem[idx + _2867 + 32]
                            idx = idx + 32
                            continue 
                        mem[_2992 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2992 + -mem[64] + 100
                    if arg1 and stor31 / 10^15 > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor31 / 10^15 / arg1 != stor31 / 10^15:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor33 / 10000:
                        _2569 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2569] = 30
                        mem[_2569 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor31 / 10^15:
                            _2626 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _2626 + 68] = mem[idx + _2569 + 32]
                                idx = idx + 32
                                continue 
                            mem[_2626 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _2626 + -mem[64] + 100
                        if arg1 * stor31 / 10^15 < 0:
                            revert with 0, 17
                        _2865 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2865] = 30
                        mem[_2865 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor31 / 10^15:
                            if arg1 * stor31 / 10^15 < 0:
                                revert with 0, 17
                            return (arg1 * stor31 / 10^15)
                        _2991 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _2991 + 68] = mem[idx + _2865 + 32]
                            idx = idx + 32
                            continue 
                        mem[_2991 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2991 + -mem[64] + 100
                    if arg1 * stor33 / 10000 and stor31 / 10^15 > -1 / arg1 * stor33 / 10000:
                        revert with 0, 17
                    if not arg1 * stor33 / 10000:
                        revert with 0, 18
                    if arg1 * stor33 / 10000 * stor31 / 10^15 / arg1 * stor33 / 10000 != stor31 / 10^15:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2766 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2766] = 30
                    mem[_2766 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor33 / 10000 * stor31 / 10^15 > arg1 * stor31 / 10^15:
                        _2864 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _2864 + 68] = mem[idx + _2766 + 32]
                            idx = idx + 32
                            continue 
                        mem[_2864 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2864 + -mem[64] + 100
                    if arg1 * stor31 / 10^15 < arg1 * stor33 / 10000 * stor31 / 10^15:
                        revert with 0, 17
                    _3278 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3278] = 30
                    mem[_3278 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor31 / 10^15) - (arg1 * stor33 / 10000 * stor31 / 10^15):
                        if (arg1 * stor31 / 10^15) - (arg1 * stor33 / 10000 * stor31 / 10^15) < 0:
                            revert with 0, 17
                        return ((arg1 * stor31 / 10^15) - (arg1 * stor33 / 10000 * stor31 / 10^15))
                    _3449 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _3449 + 68] = mem[idx + _3278 + 32]
                        idx = idx + 32
                        continue 
                    mem[_3449 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _3449 + -mem[64] + 100
                if idx >= stor30.length:
                    revert with 0, 50
                mem[0] = stor30[idx]
                mem[32] = 24
                if stor24[stor30[idx]] <= s:
                    if idx >= stor30.length:
                        revert with 0, 50
                    mem[0] = stor30[idx]
                    mem[32] = 23
                    _2277 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2277] = 30
                    mem[_2277 + 32] = 'SafeMath: subtraction overflow'
                    if stor23[stor30[idx]] > t:
                        _2292 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _2292 + 68] = mem[idx + _2277 + 32]
                            idx = idx + 32
                            continue 
                        mem[_2292 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2292 + -mem[64] + 100
                    if t < stor23[stor30[idx]]:
                        revert with 0, 17
                    if idx >= stor30.length:
                        revert with 0, 50
                    mem[0] = stor30[idx]
                    mem[32] = 24
                    _2382 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2382] = 30
                    mem[_2382 + 32] = 'SafeMath: subtraction overflow'
                    if stor24[stor30[idx]] <= s:
                        if s < stor24[stor30[idx]]:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s - stor24[stor30[idx]]
                        t = t - stor23[stor30[idx]]
                        continue 
                    _2398 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _2398 + 68] = mem[idx + _2382 + 32]
                        idx = idx + 32
                        continue 
                    mem[_2398 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _2398 + -mem[64] + 100
                _2278 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2278] = 26
                mem[_2278 + 32] = 'SafeMath: division by zero'
                if not arg1:
                    if not arg1 * stor33 / 10000:
                        return 0
                    if arg1 * stor33 / 10000 and stor31 / 10^15 > -1 / arg1 * stor33 / 10000:
                        revert with 0, 17
                    if not arg1 * stor33 / 10000:
                        revert with 0, 18
                    if arg1 * stor33 / 10000 * stor31 / 10^15 / arg1 * stor33 / 10000 != stor31 / 10^15:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2631 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2631] = 30
                    mem[_2631 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor33 / 10000 * stor31 / 10^15 > 0:
                        _2683 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _2683 + 68] = mem[idx + _2631 + 32]
                            idx = idx + 32
                            continue 
                        mem[_2683 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2683 + -mem[64] + 100
                    if 0 < arg1 * stor33 / 10000 * stor31 / 10^15:
                        revert with 0, 17
                    _2996 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2996] = 30
                    mem[_2996 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= -1 * arg1 * stor33 / 10000 * stor31 / 10^15:
                        if -1 * arg1 * stor33 / 10000 * stor31 / 10^15 < 0:
                            revert with 0, 17
                        return (-1 * arg1 * stor33 / 10000 * stor31 / 10^15)
                    _3131 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _3131 + 68] = mem[idx + _2996 + 32]
                        idx = idx + 32
                        continue 
                    mem[_3131 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _3131 + -mem[64] + 100
                if arg1 and stor31 / 10^15 > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor31 / 10^15 / arg1 != stor31 / 10^15:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor33 / 10000:
                    _2630 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2630] = 30
                    mem[_2630 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor31 / 10^15:
                        _2682 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _2682 + 68] = mem[idx + _2630 + 32]
                            idx = idx + 32
                            continue 
                        mem[_2682 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2682 + -mem[64] + 100
                    if arg1 * stor31 / 10^15 < 0:
                        revert with 0, 17
                    _2994 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2994] = 30
                    mem[_2994 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= arg1 * stor31 / 10^15:
                        if arg1 * stor31 / 10^15 < 0:
                            revert with 0, 17
                        return (arg1 * stor31 / 10^15)
                    _3130 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _3130 + 68] = mem[idx + _2994 + 32]
                        idx = idx + 32
                        continue 
                    mem[_3130 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _3130 + -mem[64] + 100
                if arg1 * stor33 / 10000 and stor31 / 10^15 > -1 / arg1 * stor33 / 10000:
                    revert with 0, 17
                if not arg1 * stor33 / 10000:
                    revert with 0, 18
                if arg1 * stor33 / 10000 * stor31 / 10^15 / arg1 * stor33 / 10000 != stor31 / 10^15:
                    revert with 0, 'SafeMath: multiplication overflow'
                _2869 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2869] = 30
                mem[_2869 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor33 / 10000 * stor31 / 10^15 > arg1 * stor31 / 10^15:
                    _2993 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _2993 + 68] = mem[idx + _2869 + 32]
                        idx = idx + 32
                        continue 
                    mem[_2993 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _2993 + -mem[64] + 100
                if arg1 * stor31 / 10^15 < arg1 * stor33 / 10000 * stor31 / 10^15:
                    revert with 0, 17
                _3452 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3452] = 30
                mem[_3452 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= (arg1 * stor31 / 10^15) - (arg1 * stor33 / 10000 * stor31 / 10^15):
                    if (arg1 * stor31 / 10^15) - (arg1 * stor33 / 10000 * stor31 / 10^15) < 0:
                        revert with 0, 17
                    return ((arg1 * stor31 / 10^15) - (arg1 * stor33 / 10000 * stor31 / 10^15))
                _3609 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _3609 + 68] = mem[idx + _3452 + 32]
                    idx = idx + 32
                    continue 
                mem[_3609 + 98] = 0
                revert with memory
                  from mem[64]
                   len _3609 + -mem[64] + 100
            if t < stor31 / 10^15:
                if not arg1:
                    if not arg1 * stor33 / 10000:
                        return 0
                    if arg1 * stor33 / 10000 and stor31 / 10^15 > -1 / arg1 * stor33 / 10000:
                        revert with 0, 17
                    if not arg1 * stor33 / 10000:
                        revert with 0, 18
                    if arg1 * stor33 / 10000 * stor31 / 10^15 / arg1 * stor33 / 10000 != stor31 / 10^15:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor33 / 10000 * stor31 / 10^15 > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor33 / 10000 * stor31 / 10^15:
                        revert with 0, 17
                    if 0 > -1 * arg1 * stor33 / 10000 * stor31 / 10^15:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor33 / 10000 * stor31 / 10^15 < 0:
                        revert with 0, 17
                    return (-1 * arg1 * stor33 / 10000 * stor31 / 10^15)
                if arg1 and stor31 / 10^15 > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor31 / 10^15 / arg1 != stor31 / 10^15:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor33 / 10000:
                    if 0 > arg1 * stor31 / 10^15:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor31 / 10^15 < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor31 / 10^15:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor31 / 10^15 < 0:
                        revert with 0, 17
                    return (arg1 * stor31 / 10^15)
                if arg1 * stor33 / 10000 and stor31 / 10^15 > -1 / arg1 * stor33 / 10000:
                    revert with 0, 17
                if not arg1 * stor33 / 10000:
                    revert with 0, 18
                if arg1 * stor33 / 10000 * stor31 / 10^15 / arg1 * stor33 / 10000 != stor31 / 10^15:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * stor33 / 10000 * stor31 / 10^15 > arg1 * stor31 / 10^15:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor31 / 10^15 < arg1 * stor33 / 10000 * stor31 / 10^15:
                    revert with 0, 17
                if 0 > (arg1 * stor31 / 10^15) - (arg1 * stor33 / 10000 * stor31 / 10^15):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor31 / 10^15) - (arg1 * stor33 / 10000 * stor31 / 10^15) < 0:
                    revert with 0, 17
                return ((arg1 * stor31 / 10^15) - (arg1 * stor33 / 10000 * stor31 / 10^15))
            if not s:
                revert with 0, 'SafeMath: division by zero', 0
            if not arg1:
                if not arg1 * stor33 / 10000:
                    return 0
                if arg1 * stor33 / 10000 and t / s > -1 / arg1 * stor33 / 10000:
                    revert with 0, 17
                if not arg1 * stor33 / 10000:
                    revert with 0, 18
                if arg1 * stor33 / 10000 * t / s / arg1 * stor33 / 10000 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * stor33 / 10000 * t / s > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * stor33 / 10000 * t / s:
                    revert with 0, 17
                if 0 > -1 * arg1 * stor33 / 10000 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * stor33 / 10000 * t / s < 0:
                    revert with 0, 17
                return (-1 * arg1 * stor33 / 10000 * t / s)
            if arg1 and t / s > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * t / s / arg1 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor33 / 10000:
                if 0 > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < 0:
                    revert with 0, 17
                if 0 > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < 0:
                    revert with 0, 17
                return (arg1 * t / s)
            if arg1 * stor33 / 10000 and t / s > -1 / arg1 * stor33 / 10000:
                revert with 0, 17
            if not arg1 * stor33 / 10000:
                revert with 0, 18
            if arg1 * stor33 / 10000 * t / s / arg1 * stor33 / 10000 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * stor33 / 10000 * t / s > arg1 * t / s:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * t / s < arg1 * stor33 / 10000 * t / s:
                revert with 0, 17
            if 0 > (arg1 * t / s) - (arg1 * stor33 / 10000 * t / s):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * t / s) - (arg1 * stor33 / 10000 * t / s) < 0:
                revert with 0, 17
            return ((arg1 * t / s) - (arg1 * stor33 / 10000 * t / s))
        if arg1 and stor35 > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * stor35 / arg1 != stor35:
            revert with 0, 'SafeMath: multiplication overflow'
        mem[160] = 26
        mem[192] = 'SafeMath: division by zero'
        mem[224] = 30
        mem[256] = 'SafeMath: subtraction overflow'
        if arg1 * stor33 / 10000 > arg1:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 < arg1 * stor33 / 10000:
            revert with 0, 17
        mem[64] = 352
        mem[288] = 30
        mem[320] = 'SafeMath: subtraction overflow'
        if arg1 * stor35 / 10000 > arg1 - (arg1 * stor33 / 10000):
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 - (arg1 * stor33 / 10000) < arg1 * stor35 / 10000:
            revert with 0, 17
        idx = 0
        s = 10^15
        t = stor31
        while idx < stor30.length:
            mem[0] = stor30[idx]
            mem[32] = 23
            if stor23[stor30[idx]] > t:
                _2251 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2251] = 26
                mem[_2251 + 32] = 'SafeMath: division by zero'
                if not arg1:
                    if not arg1 * stor33 / 10000:
                        if not arg1 * stor35 / 10000:
                            return 0
                        if arg1 * stor35 / 10000 and stor31 / 10^15 > -1 / arg1 * stor35 / 10000:
                            revert with 0, 17
                        if not arg1 * stor35 / 10000:
                            revert with 0, 18
                        if arg1 * stor35 / 10000 * stor31 / 10^15 / arg1 * stor35 / 10000 != stor31 / 10^15:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _2562 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2562] = 30
                        mem[_2562 + 32] = 'SafeMath: subtraction overflow'
                        _2854 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2854] = 30
                        mem[_2854 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor35 / 10000 * stor31 / 10^15 <= 0:
                            if 0 < arg1 * stor35 / 10000 * stor31 / 10^15:
                                revert with 0, 17
                            return (-1 * arg1 * stor35 / 10000 * stor31 / 10^15)
                        _2982 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _2982 + 68] = mem[idx + _2854 + 32]
                            idx = idx + 32
                            continue 
                        mem[_2982 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2982 + -mem[64] + 100
                    if arg1 * stor33 / 10000 and stor31 / 10^15 > -1 / arg1 * stor33 / 10000:
                        revert with 0, 17
                    if not arg1 * stor33 / 10000:
                        revert with 0, 18
                    if arg1 * stor33 / 10000 * stor31 / 10^15 / arg1 * stor33 / 10000 != stor31 / 10^15:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor35 / 10000:
                        _2561 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2561] = 30
                        mem[_2561 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor33 / 10000 * stor31 / 10^15 > 0:
                            _2620 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _2620 + 68] = mem[idx + _2561 + 32]
                                idx = idx + 32
                                continue 
                            mem[_2620 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _2620 + -mem[64] + 100
                        if 0 < arg1 * stor33 / 10000 * stor31 / 10^15:
                            revert with 0, 17
                        _2852 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2852] = 30
                        mem[_2852 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * stor33 / 10000 * stor31 / 10^15:
                            if -1 * arg1 * stor33 / 10000 * stor31 / 10^15 < 0:
                                revert with 0, 17
                            return (-1 * arg1 * stor33 / 10000 * stor31 / 10^15)
                        _2981 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _2981 + 68] = mem[idx + _2852 + 32]
                            idx = idx + 32
                            continue 
                        mem[_2981 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2981 + -mem[64] + 100
                    if arg1 * stor35 / 10000 and stor31 / 10^15 > -1 / arg1 * stor35 / 10000:
                        revert with 0, 17
                    if not arg1 * stor35 / 10000:
                        revert with 0, 18
                    if arg1 * stor35 / 10000 * stor31 / 10^15 / arg1 * stor35 / 10000 != stor31 / 10^15:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2757 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2757] = 30
                    mem[_2757 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor33 / 10000 * stor31 / 10^15 > 0:
                        _2851 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _2851 + 68] = mem[idx + _2757 + 32]
                            idx = idx + 32
                            continue 
                        mem[_2851 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2851 + -mem[64] + 100
                    if 0 < arg1 * stor33 / 10000 * stor31 / 10^15:
                        revert with 0, 17
                    _3264 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3264] = 30
                    mem[_3264 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor35 / 10000 * stor31 / 10^15 <= -1 * arg1 * stor33 / 10000 * stor31 / 10^15:
                        if -1 * arg1 * stor33 / 10000 * stor31 / 10^15 < arg1 * stor35 / 10000 * stor31 / 10^15:
                            revert with 0, 17
                        return ((-1 * arg1 * stor33 / 10000 * stor31 / 10^15) - (arg1 * stor35 / 10000 * stor31 / 10^15))
                    _3434 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _3434 + 68] = mem[idx + _3264 + 32]
                        idx = idx + 32
                        continue 
                    mem[_3434 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _3434 + -mem[64] + 100
                if arg1 and stor31 / 10^15 > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor31 / 10^15 / arg1 != stor31 / 10^15:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor33 / 10000:
                    if not arg1 * stor35 / 10000:
                        _2560 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2560] = 30
                        mem[_2560 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor31 / 10^15:
                            _2619 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _2619 + 68] = mem[idx + _2560 + 32]
                                idx = idx + 32
                                continue 
                            mem[_2619 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _2619 + -mem[64] + 100
                        if arg1 * stor31 / 10^15 < 0:
                            revert with 0, 17
                        _2849 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2849] = 30
                        mem[_2849 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor31 / 10^15:
                            if arg1 * stor31 / 10^15 < 0:
                                revert with 0, 17
                            return (arg1 * stor31 / 10^15)
                        _2980 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _2980 + 68] = mem[idx + _2849 + 32]
                            idx = idx + 32
                            continue 
                        mem[_2980 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2980 + -mem[64] + 100
                    if arg1 * stor35 / 10000 and stor31 / 10^15 > -1 / arg1 * stor35 / 10000:
                        revert with 0, 17
                    if not arg1 * stor35 / 10000:
                        revert with 0, 18
                    if arg1 * stor35 / 10000 * stor31 / 10^15 / arg1 * stor35 / 10000 != stor31 / 10^15:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2756 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2756] = 30
                    mem[_2756 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor31 / 10^15:
                        _2848 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _2848 + 68] = mem[idx + _2756 + 32]
                            idx = idx + 32
                            continue 
                        mem[_2848 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2848 + -mem[64] + 100
                    if arg1 * stor31 / 10^15 < 0:
                        revert with 0, 17
                    _3262 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3262] = 30
                    mem[_3262 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor35 / 10000 * stor31 / 10^15 <= arg1 * stor31 / 10^15:
                        if arg1 * stor31 / 10^15 < arg1 * stor35 / 10000 * stor31 / 10^15:
                            revert with 0, 17
                        return ((arg1 * stor31 / 10^15) - (arg1 * stor35 / 10000 * stor31 / 10^15))
                    _3432 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _3432 + 68] = mem[idx + _3262 + 32]
                        idx = idx + 32
                        continue 
                    mem[_3432 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _3432 + -mem[64] + 100
                if arg1 * stor33 / 10000 and stor31 / 10^15 > -1 / arg1 * stor33 / 10000:
                    revert with 0, 17
                if not arg1 * stor33 / 10000:
                    revert with 0, 18
                if arg1 * stor33 / 10000 * stor31 / 10^15 / arg1 * stor33 / 10000 != stor31 / 10^15:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor35 / 10000:
                    _2755 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2755] = 30
                    mem[_2755 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor33 / 10000 * stor31 / 10^15 > arg1 * stor31 / 10^15:
                        _2847 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _2847 + 68] = mem[idx + _2755 + 32]
                            idx = idx + 32
                            continue 
                        mem[_2847 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2847 + -mem[64] + 100
                    if arg1 * stor31 / 10^15 < arg1 * stor33 / 10000 * stor31 / 10^15:
                        revert with 0, 17
                    _3260 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3260] = 30
                    mem[_3260 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor31 / 10^15) - (arg1 * stor33 / 10000 * stor31 / 10^15):
                        if (arg1 * stor31 / 10^15) - (arg1 * stor33 / 10000 * stor31 / 10^15) < 0:
                            revert with 0, 17
                        return ((arg1 * stor31 / 10^15) - (arg1 * stor33 / 10000 * stor31 / 10^15))
                    _3431 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _3431 + 68] = mem[idx + _3260 + 32]
                        idx = idx + 32
                        continue 
                    mem[_3431 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _3431 + -mem[64] + 100
                if arg1 * stor35 / 10000 and stor31 / 10^15 > -1 / arg1 * stor35 / 10000:
                    revert with 0, 17
                if not arg1 * stor35 / 10000:
                    revert with 0, 18
                if arg1 * stor35 / 10000 * stor31 / 10^15 / arg1 * stor35 / 10000 != stor31 / 10^15:
                    revert with 0, 'SafeMath: multiplication overflow'
                _3123 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3123] = 30
                mem[_3123 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor33 / 10000 * stor31 / 10^15 > arg1 * stor31 / 10^15:
                    _3259 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _3259 + 68] = mem[idx + _3123 + 32]
                        idx = idx + 32
                        continue 
                    mem[_3259 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _3259 + -mem[64] + 100
                if arg1 * stor31 / 10^15 < arg1 * stor33 / 10000 * stor31 / 10^15:
                    revert with 0, 17
                _3755 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3755] = 30
                mem[_3755 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor35 / 10000 * stor31 / 10^15 <= (arg1 * stor31 / 10^15) - (arg1 * stor33 / 10000 * stor31 / 10^15):
                    if (arg1 * stor31 / 10^15) - (arg1 * stor33 / 10000 * stor31 / 10^15) < arg1 * stor35 / 10000 * stor31 / 10^15:
                        revert with 0, 17
                    return ((arg1 * stor31 / 10^15) - (arg1 * stor33 / 10000 * stor31 / 10^15) - (arg1 * stor35 / 10000 * stor31 / 10^15))
                _3905 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _3905 + 68] = mem[idx + _3755 + 32]
                    idx = idx + 32
                    continue 
                mem[_3905 + 98] = 0
                revert with memory
                  from mem[64]
                   len _3905 + -mem[64] + 100
            if idx >= stor30.length:
                revert with 0, 50
            mem[0] = stor30[idx]
            mem[32] = 24
            if stor24[stor30[idx]] <= s:
                if idx >= stor30.length:
                    revert with 0, 50
                mem[0] = stor30[idx]
                mem[32] = 23
                _2275 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2275] = 30
                mem[_2275 + 32] = 'SafeMath: subtraction overflow'
                if stor23[stor30[idx]] > t:
                    _2291 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _2291 + 68] = mem[idx + _2275 + 32]
                        idx = idx + 32
                        continue 
                    mem[_2291 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _2291 + -mem[64] + 100
                if t < stor23[stor30[idx]]:
                    revert with 0, 17
                if idx >= stor30.length:
                    revert with 0, 50
                mem[0] = stor30[idx]
                mem[32] = 24
                _2380 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2380] = 30
                mem[_2380 + 32] = 'SafeMath: subtraction overflow'
                if stor24[stor30[idx]] <= s:
                    if s < stor24[stor30[idx]]:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s - stor24[stor30[idx]]
                    t = t - stor23[stor30[idx]]
                    continue 
                _2396 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _2396 + 68] = mem[idx + _2380 + 32]
                    idx = idx + 32
                    continue 
                mem[_2396 + 98] = 0
                revert with memory
                  from mem[64]
                   len _2396 + -mem[64] + 100
            _2276 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2276] = 26
            mem[_2276 + 32] = 'SafeMath: division by zero'
            if not arg1:
                if not arg1 * stor33 / 10000:
                    if not arg1 * stor35 / 10000:
                        return 0
                    if arg1 * stor35 / 10000 and stor31 / 10^15 > -1 / arg1 * stor35 / 10000:
                        revert with 0, 17
                    if not arg1 * stor35 / 10000:
                        revert with 0, 18
                    if arg1 * stor35 / 10000 * stor31 / 10^15 / arg1 * stor35 / 10000 != stor31 / 10^15:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2625 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2625] = 30
                    mem[_2625 + 32] = 'SafeMath: subtraction overflow'
                    _2990 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2990] = 30
                    mem[_2990 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor35 / 10000 * stor31 / 10^15 <= 0:
                        if 0 < arg1 * stor35 / 10000 * stor31 / 10^15:
                            revert with 0, 17
                        return (-1 * arg1 * stor35 / 10000 * stor31 / 10^15)
                    _3127 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _3127 + 68] = mem[idx + _2990 + 32]
                        idx = idx + 32
                        continue 
                    mem[_3127 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _3127 + -mem[64] + 100
                if arg1 * stor33 / 10000 and stor31 / 10^15 > -1 / arg1 * stor33 / 10000:
                    revert with 0, 17
                if not arg1 * stor33 / 10000:
                    revert with 0, 18
                if arg1 * stor33 / 10000 * stor31 / 10^15 / arg1 * stor33 / 10000 != stor31 / 10^15:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor35 / 10000:
                    _2624 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2624] = 30
                    mem[_2624 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor33 / 10000 * stor31 / 10^15 > 0:
                        _2680 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _2680 + 68] = mem[idx + _2624 + 32]
                            idx = idx + 32
                            continue 
                        mem[_2680 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2680 + -mem[64] + 100
                    if 0 < arg1 * stor33 / 10000 * stor31 / 10^15:
                        revert with 0, 17
                    _2988 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2988] = 30
                    mem[_2988 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= -1 * arg1 * stor33 / 10000 * stor31 / 10^15:
                        if -1 * arg1 * stor33 / 10000 * stor31 / 10^15 < 0:
                            revert with 0, 17
                        return (-1 * arg1 * stor33 / 10000 * stor31 / 10^15)
                    _3126 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _3126 + 68] = mem[idx + _2988 + 32]
                        idx = idx + 32
                        continue 
                    mem[_3126 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _3126 + -mem[64] + 100
                if arg1 * stor35 / 10000 and stor31 / 10^15 > -1 / arg1 * stor35 / 10000:
                    revert with 0, 17
                if not arg1 * stor35 / 10000:
                    revert with 0, 18
                if arg1 * stor35 / 10000 * stor31 / 10^15 / arg1 * stor35 / 10000 != stor31 / 10^15:
                    revert with 0, 'SafeMath: multiplication overflow'
                _2857 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2857] = 30
                mem[_2857 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor33 / 10000 * stor31 / 10^15 > 0:
                    _2987 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _2987 + 68] = mem[idx + _2857 + 32]
                        idx = idx + 32
                        continue 
                    mem[_2987 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _2987 + -mem[64] + 100
                if 0 < arg1 * stor33 / 10000 * stor31 / 10^15:
                    revert with 0, 17
                _3442 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3442] = 30
                mem[_3442 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor35 / 10000 * stor31 / 10^15 <= -1 * arg1 * stor33 / 10000 * stor31 / 10^15:
                    if -1 * arg1 * stor33 / 10000 * stor31 / 10^15 < arg1 * stor35 / 10000 * stor31 / 10^15:
                        revert with 0, 17
                    return ((-1 * arg1 * stor33 / 10000 * stor31 / 10^15) - (arg1 * stor35 / 10000 * stor31 / 10^15))
                _3606 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _3606 + 68] = mem[idx + _3442 + 32]
                    idx = idx + 32
                    continue 
                mem[_3606 + 98] = 0
                revert with memory
                  from mem[64]
                   len _3606 + -mem[64] + 100
            if arg1 and stor31 / 10^15 > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor31 / 10^15 / arg1 != stor31 / 10^15:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor33 / 10000:
                if not arg1 * stor35 / 10000:
                    _2623 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2623] = 30
                    mem[_2623 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor31 / 10^15:
                        _2679 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _2679 + 68] = mem[idx + _2623 + 32]
                            idx = idx + 32
                            continue 
                        mem[_2679 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2679 + -mem[64] + 100
                    if arg1 * stor31 / 10^15 < 0:
                        revert with 0, 17
                    _2985 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2985] = 30
                    mem[_2985 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= arg1 * stor31 / 10^15:
                        if arg1 * stor31 / 10^15 < 0:
                            revert with 0, 17
                        return (arg1 * stor31 / 10^15)
                    _3125 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _3125 + 68] = mem[idx + _2985 + 32]
                        idx = idx + 32
                        continue 
                    mem[_3125 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _3125 + -mem[64] + 100
                if arg1 * stor35 / 10000 and stor31 / 10^15 > -1 / arg1 * stor35 / 10000:
                    revert with 0, 17
                if not arg1 * stor35 / 10000:
                    revert with 0, 18
                if arg1 * stor35 / 10000 * stor31 / 10^15 / arg1 * stor35 / 10000 != stor31 / 10^15:
                    revert with 0, 'SafeMath: multiplication overflow'
                _2856 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2856] = 30
                mem[_2856 + 32] = 'SafeMath: subtraction overflow'
                if 0 > arg1 * stor31 / 10^15:
                    _2984 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _2984 + 68] = mem[idx + _2856 + 32]
                        idx = idx + 32
                        continue 
                    mem[_2984 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _2984 + -mem[64] + 100
                if arg1 * stor31 / 10^15 < 0:
                    revert with 0, 17
                _3440 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3440] = 30
                mem[_3440 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor35 / 10000 * stor31 / 10^15 <= arg1 * stor31 / 10^15:
                    if arg1 * stor31 / 10^15 < arg1 * stor35 / 10000 * stor31 / 10^15:
                        revert with 0, 17
                    return ((arg1 * stor31 / 10^15) - (arg1 * stor35 / 10000 * stor31 / 10^15))
                _3604 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _3604 + 68] = mem[idx + _3440 + 32]
                    idx = idx + 32
                    continue 
                mem[_3604 + 98] = 0
                revert with memory
                  from mem[64]
                   len _3604 + -mem[64] + 100
            if arg1 * stor33 / 10000 and stor31 / 10^15 > -1 / arg1 * stor33 / 10000:
                revert with 0, 17
            if not arg1 * stor33 / 10000:
                revert with 0, 18
            if arg1 * stor33 / 10000 * stor31 / 10^15 / arg1 * stor33 / 10000 != stor31 / 10^15:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor35 / 10000:
                _2855 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2855] = 30
                mem[_2855 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor33 / 10000 * stor31 / 10^15 > arg1 * stor31 / 10^15:
                    _2983 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _2983 + 68] = mem[idx + _2855 + 32]
                        idx = idx + 32
                        continue 
                    mem[_2983 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _2983 + -mem[64] + 100
                if arg1 * stor31 / 10^15 < arg1 * stor33 / 10000 * stor31 / 10^15:
                    revert with 0, 17
                _3438 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3438] = 30
                mem[_3438 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= (arg1 * stor31 / 10^15) - (arg1 * stor33 / 10000 * stor31 / 10^15):
                    if (arg1 * stor31 / 10^15) - (arg1 * stor33 / 10000 * stor31 / 10^15) < 0:
                        revert with 0, 17
                    return ((arg1 * stor31 / 10^15) - (arg1 * stor33 / 10000 * stor31 / 10^15))
                _3603 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _3603 + 68] = mem[idx + _3438 + 32]
                    idx = idx + 32
                    continue 
                mem[_3603 + 98] = 0
                revert with memory
                  from mem[64]
                   len _3603 + -mem[64] + 100
            if arg1 * stor35 / 10000 and stor31 / 10^15 > -1 / arg1 * stor35 / 10000:
                revert with 0, 17
            if not arg1 * stor35 / 10000:
                revert with 0, 18
            if arg1 * stor35 / 10000 * stor31 / 10^15 / arg1 * stor35 / 10000 != stor31 / 10^15:
                revert with 0, 'SafeMath: multiplication overflow'
            _3267 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3267] = 30
            mem[_3267 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * stor33 / 10000 * stor31 / 10^15 > arg1 * stor31 / 10^15:
                _3437 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _3437 + 68] = mem[idx + _3267 + 32]
                    idx = idx + 32
                    continue 
                mem[_3437 + 98] = 0
                revert with memory
                  from mem[64]
                   len _3437 + -mem[64] + 100
            if arg1 * stor31 / 10^15 < arg1 * stor33 / 10000 * stor31 / 10^15:
                revert with 0, 17
            _3909 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3909] = 30
            mem[_3909 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * stor35 / 10000 * stor31 / 10^15 <= (arg1 * stor31 / 10^15) - (arg1 * stor33 / 10000 * stor31 / 10^15):
                if (arg1 * stor31 / 10^15) - (arg1 * stor33 / 10000 * stor31 / 10^15) < arg1 * stor35 / 10000 * stor31 / 10^15:
                    revert with 0, 17
                return ((arg1 * stor31 / 10^15) - (arg1 * stor33 / 10000 * stor31 / 10^15) - (arg1 * stor35 / 10000 * stor31 / 10^15))
            _4013 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _4013 + 68] = mem[idx + _3909 + 32]
                idx = idx + 32
                continue 
            mem[_4013 + 98] = 0
            revert with memory
              from mem[64]
               len _4013 + -mem[64] + 100
        if t < stor31 / 10^15:
            if not arg1:
                if not arg1 * stor33 / 10000:
                    if not arg1 * stor35 / 10000:
                        return 0
                    if arg1 * stor35 / 10000 and stor31 / 10^15 > -1 / arg1 * stor35 / 10000:
                        revert with 0, 17
                    if not arg1 * stor35 / 10000:
                        revert with 0, 18
                    if arg1 * stor35 / 10000 * stor31 / 10^15 / arg1 * stor35 / 10000 != stor31 / 10^15:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor35 / 10000 * stor31 / 10^15 > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor35 / 10000 * stor31 / 10^15:
                        revert with 0, 17
                    return (-1 * arg1 * stor35 / 10000 * stor31 / 10^15)
                if arg1 * stor33 / 10000 and stor31 / 10^15 > -1 / arg1 * stor33 / 10000:
                    revert with 0, 17
                if not arg1 * stor33 / 10000:
                    revert with 0, 18
                if arg1 * stor33 / 10000 * stor31 / 10^15 / arg1 * stor33 / 10000 != stor31 / 10^15:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor35 / 10000:
                    if arg1 * stor33 / 10000 * stor31 / 10^15 > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor33 / 10000 * stor31 / 10^15:
                        revert with 0, 17
                    if 0 > -1 * arg1 * stor33 / 10000 * stor31 / 10^15:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor33 / 10000 * stor31 / 10^15 < 0:
                        revert with 0, 17
                    return (-1 * arg1 * stor33 / 10000 * stor31 / 10^15)
                if arg1 * stor35 / 10000 and stor31 / 10^15 > -1 / arg1 * stor35 / 10000:
                    revert with 0, 17
                if not arg1 * stor35 / 10000:
                    revert with 0, 18
                if arg1 * stor35 / 10000 * stor31 / 10^15 / arg1 * stor35 / 10000 != stor31 / 10^15:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * stor33 / 10000 * stor31 / 10^15 > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * stor33 / 10000 * stor31 / 10^15:
                    revert with 0, 17
                if arg1 * stor35 / 10000 * stor31 / 10^15 > -1 * arg1 * stor33 / 10000 * stor31 / 10^15:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * stor33 / 10000 * stor31 / 10^15 < arg1 * stor35 / 10000 * stor31 / 10^15:
                    revert with 0, 17
                return ((-1 * arg1 * stor33 / 10000 * stor31 / 10^15) - (arg1 * stor35 / 10000 * stor31 / 10^15))
            if arg1 and stor31 / 10^15 > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor31 / 10^15 / arg1 != stor31 / 10^15:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor33 / 10000:
                if not arg1 * stor35 / 10000:
                    if 0 > arg1 * stor31 / 10^15:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor31 / 10^15 < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor31 / 10^15:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor31 / 10^15 < 0:
                        revert with 0, 17
                    return (arg1 * stor31 / 10^15)
                if arg1 * stor35 / 10000 and stor31 / 10^15 > -1 / arg1 * stor35 / 10000:
                    revert with 0, 17
                if not arg1 * stor35 / 10000:
                    revert with 0, 18
                if arg1 * stor35 / 10000 * stor31 / 10^15 / arg1 * stor35 / 10000 != stor31 / 10^15:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor31 / 10^15:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor31 / 10^15 < 0:
                    revert with 0, 17
                if arg1 * stor35 / 10000 * stor31 / 10^15 > arg1 * stor31 / 10^15:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor31 / 10^15 < arg1 * stor35 / 10000 * stor31 / 10^15:
                    revert with 0, 17
                return ((arg1 * stor31 / 10^15) - (arg1 * stor35 / 10000 * stor31 / 10^15))
            if arg1 * stor33 / 10000 and stor31 / 10^15 > -1 / arg1 * stor33 / 10000:
                revert with 0, 17
            if not arg1 * stor33 / 10000:
                revert with 0, 18
            if arg1 * stor33 / 10000 * stor31 / 10^15 / arg1 * stor33 / 10000 != stor31 / 10^15:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor35 / 10000:
                if arg1 * stor33 / 10000 * stor31 / 10^15 > arg1 * stor31 / 10^15:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor31 / 10^15 < arg1 * stor33 / 10000 * stor31 / 10^15:
                    revert with 0, 17
                if 0 > (arg1 * stor31 / 10^15) - (arg1 * stor33 / 10000 * stor31 / 10^15):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor31 / 10^15) - (arg1 * stor33 / 10000 * stor31 / 10^15) < 0:
                    revert with 0, 17
                return ((arg1 * stor31 / 10^15) - (arg1 * stor33 / 10000 * stor31 / 10^15))
            if arg1 * stor35 / 10000 and stor31 / 10^15 > -1 / arg1 * stor35 / 10000:
                revert with 0, 17
            if not arg1 * stor35 / 10000:
                revert with 0, 18
            if arg1 * stor35 / 10000 * stor31 / 10^15 / arg1 * stor35 / 10000 != stor31 / 10^15:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * stor33 / 10000 * stor31 / 10^15 > arg1 * stor31 / 10^15:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor31 / 10^15 < arg1 * stor33 / 10000 * stor31 / 10^15:
                revert with 0, 17
            if arg1 * stor35 / 10000 * stor31 / 10^15 > (arg1 * stor31 / 10^15) - (arg1 * stor33 / 10000 * stor31 / 10^15):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor31 / 10^15) - (arg1 * stor33 / 10000 * stor31 / 10^15) < arg1 * stor35 / 10000 * stor31 / 10^15:
                revert with 0, 17
            return ((arg1 * stor31 / 10^15) - (arg1 * stor33 / 10000 * stor31 / 10^15) - (arg1 * stor35 / 10000 * stor31 / 10^15))
        if not s:
            revert with 0, 'SafeMath: division by zero', 0
        if not arg1:
            if not arg1 * stor33 / 10000:
                if not arg1 * stor35 / 10000:
                    return 0
                if arg1 * stor35 / 10000 and t / s > -1 / arg1 * stor35 / 10000:
                    revert with 0, 17
                if not arg1 * stor35 / 10000:
                    revert with 0, 18
                if arg1 * stor35 / 10000 * t / s / arg1 * stor35 / 10000 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * stor35 / 10000 * t / s > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * stor35 / 10000 * t / s:
                    revert with 0, 17
                return (-1 * arg1 * stor35 / 10000 * t / s)
            if arg1 * stor33 / 10000 and t / s > -1 / arg1 * stor33 / 10000:
                revert with 0, 17
            if not arg1 * stor33 / 10000:
                revert with 0, 18
            if arg1 * stor33 / 10000 * t / s / arg1 * stor33 / 10000 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor35 / 10000:
                if arg1 * stor33 / 10000 * t / s > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * stor33 / 10000 * t / s:
                    revert with 0, 17
                if 0 > -1 * arg1 * stor33 / 10000 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * stor33 / 10000 * t / s < 0:
                    revert with 0, 17
                return (-1 * arg1 * stor33 / 10000 * t / s)
            if arg1 * stor35 / 10000 and t / s > -1 / arg1 * stor35 / 10000:
                revert with 0, 17
            if not arg1 * stor35 / 10000:
                revert with 0, 18
            if arg1 * stor35 / 10000 * t / s / arg1 * stor35 / 10000 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * stor33 / 10000 * t / s > 0:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if 0 < arg1 * stor33 / 10000 * t / s:
                revert with 0, 17
            if arg1 * stor35 / 10000 * t / s > -1 * arg1 * stor33 / 10000 * t / s:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if -1 * arg1 * stor33 / 10000 * t / s < arg1 * stor35 / 10000 * t / s:
                revert with 0, 17
            return ((-1 * arg1 * stor33 / 10000 * t / s) - (arg1 * stor35 / 10000 * t / s))
        if arg1 and t / s > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * t / s / arg1 != t / s:
            revert with 0, 'SafeMath: multiplication overflow'
        if not arg1 * stor33 / 10000:
            if not arg1 * stor35 / 10000:
                if 0 > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < 0:
                    revert with 0, 17
                if 0 > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < 0:
                    revert with 0, 17
                return (arg1 * t / s)
            if arg1 * stor35 / 10000 and t / s > -1 / arg1 * stor35 / 10000:
                revert with 0, 17
            if not arg1 * stor35 / 10000:
                revert with 0, 18
            if arg1 * stor35 / 10000 * t / s / arg1 * stor35 / 10000 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if 0 > arg1 * t / s:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * t / s < 0:
                revert with 0, 17
            if arg1 * stor35 / 10000 * t / s > arg1 * t / s:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * t / s < arg1 * stor35 / 10000 * t / s:
                revert with 0, 17
            return ((arg1 * t / s) - (arg1 * stor35 / 10000 * t / s))
        if arg1 * stor33 / 10000 and t / s > -1 / arg1 * stor33 / 10000:
            revert with 0, 17
        if not arg1 * stor33 / 10000:
            revert with 0, 18
        if arg1 * stor33 / 10000 * t / s / arg1 * stor33 / 10000 != t / s:
            revert with 0, 'SafeMath: multiplication overflow'
        if not arg1 * stor35 / 10000:
            if arg1 * stor33 / 10000 * t / s > arg1 * t / s:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * t / s < arg1 * stor33 / 10000 * t / s:
                revert with 0, 17
            if 0 > (arg1 * t / s) - (arg1 * stor33 / 10000 * t / s):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * t / s) - (arg1 * stor33 / 10000 * t / s) < 0:
                revert with 0, 17
            return ((arg1 * t / s) - (arg1 * stor33 / 10000 * t / s))
        if arg1 * stor35 / 10000 and t / s > -1 / arg1 * stor35 / 10000:
            revert with 0, 17
        if not arg1 * stor35 / 10000:
            revert with 0, 18
        if arg1 * stor35 / 10000 * t / s / arg1 * stor35 / 10000 != t / s:
            revert with 0, 'SafeMath: multiplication overflow'
        if arg1 * stor33 / 10000 * t / s > arg1 * t / s:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 * t / s < arg1 * stor33 / 10000 * t / s:
            revert with 0, 17
        if arg1 * stor35 / 10000 * t / s > (arg1 * t / s) - (arg1 * stor33 / 10000 * t / s):
            revert with 0, 'SafeMath: subtraction overflow', 0
        if (arg1 * t / s) - (arg1 * stor33 / 10000 * t / s) < arg1 * stor35 / 10000 * t / s:
            revert with 0, 17
        return ((arg1 * t / s) - (arg1 * stor33 / 10000 * t / s) - (arg1 * stor35 / 10000 * t / s))
    if not arg1:
        mem[96] = 26
        mem[128] = 'SafeMath: division by zero'
        if not arg1:
            mem[160] = 26
            mem[192] = 'SafeMath: division by zero'
            mem[224] = 30
            mem[256] = 'SafeMath: subtraction overflow'
            if 0 > arg1:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 < 0:
                revert with 0, 17
            mem[64] = 352
            mem[288] = 30
            mem[320] = 'SafeMath: subtraction overflow'
            if 0 > arg1:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 < 0:
                revert with 0, 17
            idx = 0
            s = 10^15
            t = stor31
            while idx < stor30.length:
                mem[0] = stor30[idx]
                mem[32] = 23
                if stor23[stor30[idx]] > t:
                    _2258 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2258] = 26
                    mem[_2258 + 32] = 'SafeMath: division by zero'
                    if not arg1:
                        return 0
                    if arg1 and stor31 / 10^15 > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor31 / 10^15 / arg1 != stor31 / 10^15:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2602 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2602] = 30
                    mem[_2602 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor31 / 10^15:
                        _2656 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _2656 + 68] = mem[idx + _2602 + 32]
                            idx = idx + 32
                            continue 
                        mem[_2656 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2656 + -mem[64] + 100
                    if arg1 * stor31 / 10^15 < 0:
                        revert with 0, 17
                    _2927 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2927] = 30
                    mem[_2927 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= arg1 * stor31 / 10^15:
                        if arg1 * stor31 / 10^15 < 0:
                            revert with 0, 17
                        return (arg1 * stor31 / 10^15)
                    _3040 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _3040 + 68] = mem[idx + _2927 + 32]
                        idx = idx + 32
                        continue 
                    mem[_3040 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _3040 + -mem[64] + 100
                if idx >= stor30.length:
                    revert with 0, 50
                mem[0] = stor30[idx]
                mem[32] = 24
                if stor24[stor30[idx]] <= s:
                    if idx >= stor30.length:
                        revert with 0, 50
                    mem[0] = stor30[idx]
                    mem[32] = 23
                    _2289 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2289] = 30
                    mem[_2289 + 32] = 'SafeMath: subtraction overflow'
                    if stor23[stor30[idx]] > t:
                        _2298 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _2298 + 68] = mem[idx + _2289 + 32]
                            idx = idx + 32
                            continue 
                        mem[_2298 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2298 + -mem[64] + 100
                    if t < stor23[stor30[idx]]:
                        revert with 0, 17
                    if idx >= stor30.length:
                        revert with 0, 50
                    mem[0] = stor30[idx]
                    mem[32] = 24
                    _2394 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2394] = 30
                    mem[_2394 + 32] = 'SafeMath: subtraction overflow'
                    if stor24[stor30[idx]] <= s:
                        if s < stor24[stor30[idx]]:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s - stor24[stor30[idx]]
                        t = t - stor23[stor30[idx]]
                        continue 
                    _2410 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _2410 + 68] = mem[idx + _2394 + 32]
                        idx = idx + 32
                        continue 
                    mem[_2410 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _2410 + -mem[64] + 100
                _2290 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2290] = 26
                mem[_2290 + 32] = 'SafeMath: division by zero'
                if not arg1:
                    return 0
                if arg1 and stor31 / 10^15 > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor31 / 10^15 / arg1 != stor31 / 10^15:
                    revert with 0, 'SafeMath: multiplication overflow'
                _2658 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2658] = 30
                mem[_2658 + 32] = 'SafeMath: subtraction overflow'
                if 0 > arg1 * stor31 / 10^15:
                    _2707 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _2707 + 68] = mem[idx + _2658 + 32]
                        idx = idx + 32
                        continue 
                    mem[_2707 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _2707 + -mem[64] + 100
                if arg1 * stor31 / 10^15 < 0:
                    revert with 0, 17
                _3041 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3041] = 30
                mem[_3041 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= arg1 * stor31 / 10^15:
                    if arg1 * stor31 / 10^15 < 0:
                        revert with 0, 17
                    return (arg1 * stor31 / 10^15)
                _3156 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _3156 + 68] = mem[idx + _3041 + 32]
                    idx = idx + 32
                    continue 
                mem[_3156 + 98] = 0
                revert with memory
                  from mem[64]
                   len _3156 + -mem[64] + 100
            if t < stor31 / 10^15:
                if not arg1:
                    return 0
                if arg1 and stor31 / 10^15 > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor31 / 10^15 / arg1 != stor31 / 10^15:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor31 / 10^15:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor31 / 10^15 < 0:
                    revert with 0, 17
                if 0 > arg1 * stor31 / 10^15:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor31 / 10^15 < 0:
                    revert with 0, 17
                return (arg1 * stor31 / 10^15)
            if not s:
                revert with 0, 'SafeMath: division by zero', 0
            if not arg1:
                return 0
            if arg1 and t / s > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * t / s / arg1 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if 0 > arg1 * t / s:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * t / s < 0:
                revert with 0, 17
            if 0 > arg1 * t / s:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * t / s < 0:
                revert with 0, 17
        else:
            if arg1 and stor35 > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor35 / arg1 != stor35:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[160] = 26
            mem[192] = 'SafeMath: division by zero'
            mem[224] = 30
            mem[256] = 'SafeMath: subtraction overflow'
            if 0 > arg1:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 < 0:
                revert with 0, 17
            mem[64] = 352
            mem[288] = 30
            mem[320] = 'SafeMath: subtraction overflow'
            if arg1 * stor35 / 10000 > arg1:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 < arg1 * stor35 / 10000:
                revert with 0, 17
            idx = 0
            s = 10^15
            t = stor31
            while idx < stor30.length:
                mem[0] = stor30[idx]
                mem[32] = 23
                if stor23[stor30[idx]] > t:
                    _2257 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2257] = 26
                    mem[_2257 + 32] = 'SafeMath: division by zero'
                    if not arg1:
                        if not arg1 * stor35 / 10000:
                            return 0
                        if arg1 * stor35 / 10000 and stor31 / 10^15 > -1 / arg1 * stor35 / 10000:
                            revert with 0, 17
                        if not arg1 * stor35 / 10000:
                            revert with 0, 18
                        if arg1 * stor35 / 10000 * stor31 / 10^15 / arg1 * stor35 / 10000 != stor31 / 10^15:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _2598 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2598] = 30
                        mem[_2598 + 32] = 'SafeMath: subtraction overflow'
                        _2921 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2921] = 30
                        mem[_2921 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor35 / 10000 * stor31 / 10^15 <= 0:
                            if 0 < arg1 * stor35 / 10000 * stor31 / 10^15:
                                revert with 0, 17
                            else:
                                return 0
                        _3035 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _3035 + 68] = mem[idx + _2921 + 32]
                            idx = idx + 32
                            continue 
                        mem[_3035 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _3035 + -mem[64] + 100
                    if arg1 and stor31 / 10^15 > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor31 / 10^15 / arg1 != stor31 / 10^15:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor35 / 10000:
                        _2597 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2597] = 30
                        mem[_2597 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor31 / 10^15:
                            _2652 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _2652 + 68] = mem[idx + _2597 + 32]
                                idx = idx + 32
                                continue 
                            mem[_2652 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _2652 + -mem[64] + 100
                        if arg1 * stor31 / 10^15 < 0:
                            revert with 0, 17
                        _2919 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2919] = 30
                        mem[_2919 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor31 / 10^15:
                            if arg1 * stor31 / 10^15 < 0:
                                revert with 0, 17
                            return (arg1 * stor31 / 10^15)
                        _3034 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _3034 + 68] = mem[idx + _2919 + 32]
                            idx = idx + 32
                            continue 
                        mem[_3034 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _3034 + -mem[64] + 100
                    if arg1 * stor35 / 10000 and stor31 / 10^15 > -1 / arg1 * stor35 / 10000:
                        revert with 0, 17
                    if not arg1 * stor35 / 10000:
                        revert with 0, 18
                    if arg1 * stor35 / 10000 * stor31 / 10^15 / arg1 * stor35 / 10000 != stor31 / 10^15:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2799 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2799] = 30
                    mem[_2799 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor31 / 10^15:
                        _2918 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _2918 + 68] = mem[idx + _2799 + 32]
                            idx = idx + 32
                            continue 
                        mem[_2918 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2918 + -mem[64] + 100
                    if arg1 * stor31 / 10^15 < 0:
                        revert with 0, 17
                    _3343 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3343] = 30
                    mem[_3343 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor35 / 10000 * stor31 / 10^15 <= arg1 * stor31 / 10^15:
                        if arg1 * stor31 / 10^15 < arg1 * stor35 / 10000 * stor31 / 10^15:
                            revert with 0, 17
                        return (arg1 * stor31 / 10^15)
                    _3505 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _3505 + 68] = mem[idx + _3343 + 32]
                        idx = idx + 32
                        continue 
                    mem[_3505 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _3505 + -mem[64] + 100
                if idx >= stor30.length:
                    revert with 0, 50
                mem[0] = stor30[idx]
                mem[32] = 24
                if stor24[stor30[idx]] <= s:
                    if idx >= stor30.length:
                        revert with 0, 50
                    mem[0] = stor30[idx]
                    mem[32] = 23
                    _2287 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2287] = 30
                    mem[_2287 + 32] = 'SafeMath: subtraction overflow'
                    if stor23[stor30[idx]] > t:
                        _2297 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _2297 + 68] = mem[idx + _2287 + 32]
                            idx = idx + 32
                            continue 
                        mem[_2297 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2297 + -mem[64] + 100
                    if t < stor23[stor30[idx]]:
                        revert with 0, 17
                    if idx >= stor30.length:
                        revert with 0, 50
                    mem[0] = stor30[idx]
                    mem[32] = 24
                    _2392 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2392] = 30
                    mem[_2392 + 32] = 'SafeMath: subtraction overflow'
                    if stor24[stor30[idx]] <= s:
                        if s < stor24[stor30[idx]]:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s - stor24[stor30[idx]]
                        t = t - stor23[stor30[idx]]
                        continue 
                    _2408 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _2408 + 68] = mem[idx + _2392 + 32]
                        idx = idx + 32
                        continue 
                    mem[_2408 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _2408 + -mem[64] + 100
                _2288 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2288] = 26
                mem[_2288 + 32] = 'SafeMath: division by zero'
                if not arg1:
                    if not arg1 * stor35 / 10000:
                        return 0
                    if arg1 * stor35 / 10000 and stor31 / 10^15 > -1 / arg1 * stor35 / 10000:
                        revert with 0, 17
                    if not arg1 * stor35 / 10000:
                        revert with 0, 18
                    if arg1 * stor35 / 10000 * stor31 / 10^15 / arg1 * stor35 / 10000 != stor31 / 10^15:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2655 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2655] = 30
                    mem[_2655 + 32] = 'SafeMath: subtraction overflow'
                    _3039 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3039] = 30
                    mem[_3039 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor35 / 10000 * stor31 / 10^15 <= 0:
                        if 0 < arg1 * stor35 / 10000 * stor31 / 10^15:
                            revert with 0, 17
                        else:
                            return 0
                    _3155 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _3155 + 68] = mem[idx + _3039 + 32]
                        idx = idx + 32
                        continue 
                    mem[_3155 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _3155 + -mem[64] + 100
                if arg1 and stor31 / 10^15 > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor31 / 10^15 / arg1 != stor31 / 10^15:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor35 / 10000:
                    _2654 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2654] = 30
                    mem[_2654 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor31 / 10^15:
                        _2705 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _2705 + 68] = mem[idx + _2654 + 32]
                            idx = idx + 32
                            continue 
                        mem[_2705 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2705 + -mem[64] + 100
                    if arg1 * stor31 / 10^15 < 0:
                        revert with 0, 17
                    _3037 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3037] = 30
                    mem[_3037 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= arg1 * stor31 / 10^15:
                        if arg1 * stor31 / 10^15 < 0:
                            revert with 0, 17
                        return (arg1 * stor31 / 10^15)
                    _3154 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _3154 + 68] = mem[idx + _3037 + 32]
                        idx = idx + 32
                        continue 
                    mem[_3154 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _3154 + -mem[64] + 100
                if arg1 * stor35 / 10000 and stor31 / 10^15 > -1 / arg1 * stor35 / 10000:
                    revert with 0, 17
                if not arg1 * stor35 / 10000:
                    revert with 0, 18
                if arg1 * stor35 / 10000 * stor31 / 10^15 / arg1 * stor35 / 10000 != stor31 / 10^15:
                    revert with 0, 'SafeMath: multiplication overflow'
                _2922 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2922] = 30
                mem[_2922 + 32] = 'SafeMath: subtraction overflow'
                if 0 > arg1 * stor31 / 10^15:
                    _3036 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _3036 + 68] = mem[idx + _2922 + 32]
                        idx = idx + 32
                        continue 
                    mem[_3036 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _3036 + -mem[64] + 100
                if arg1 * stor31 / 10^15 < 0:
                    revert with 0, 17
                _3508 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3508] = 30
                mem[_3508 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor35 / 10000 * stor31 / 10^15 <= arg1 * stor31 / 10^15:
                    if arg1 * stor31 / 10^15 < arg1 * stor35 / 10000 * stor31 / 10^15:
                        revert with 0, 17
                    return (arg1 * stor31 / 10^15)
                _3627 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _3627 + 68] = mem[idx + _3508 + 32]
                    idx = idx + 32
                    continue 
                mem[_3627 + 98] = 0
                revert with memory
                  from mem[64]
                   len _3627 + -mem[64] + 100
            if t < stor31 / 10^15:
                if not arg1:
                    if arg1 * stor35 / 10000:
                        if arg1 * stor35 / 10000 and stor31 / 10^15 > -1 / arg1 * stor35 / 10000:
                            revert with 0, 17
                        if not arg1 * stor35 / 10000:
                            revert with 0, 18
                        if arg1 * stor35 / 10000 * stor31 / 10^15 / arg1 * stor35 / 10000 != stor31 / 10^15:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor35 / 10000 * stor31 / 10^15 > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor35 / 10000 * stor31 / 10^15:
                            revert with 0, 17
                        else:
                            return 0
                    else:
                        return 0
                if arg1 and stor31 / 10^15 > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor31 / 10^15 / arg1 != stor31 / 10^15:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor35 / 10000:
                    if 0 > arg1 * stor31 / 10^15:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor31 / 10^15 < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor31 / 10^15:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor31 / 10^15 < 0:
                        revert with 0, 17
                else:
                    if arg1 * stor35 / 10000 and stor31 / 10^15 > -1 / arg1 * stor35 / 10000:
                        revert with 0, 17
                    if not arg1 * stor35 / 10000:
                        revert with 0, 18
                    if arg1 * stor35 / 10000 * stor31 / 10^15 / arg1 * stor35 / 10000 != stor31 / 10^15:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * stor31 / 10^15:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor31 / 10^15 < 0:
                        revert with 0, 17
                    if arg1 * stor35 / 10000 * stor31 / 10^15 > arg1 * stor31 / 10^15:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor31 / 10^15 < arg1 * stor35 / 10000 * stor31 / 10^15:
                        revert with 0, 17
                return (arg1 * stor31 / 10^15)
            if not s:
                revert with 0, 'SafeMath: division by zero', 0
            if not arg1:
                if arg1 * stor35 / 10000:
                    if arg1 * stor35 / 10000 and t / s > -1 / arg1 * stor35 / 10000:
                        revert with 0, 17
                    if not arg1 * stor35 / 10000:
                        revert with 0, 18
                    if arg1 * stor35 / 10000 * t / s / arg1 * stor35 / 10000 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor35 / 10000 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor35 / 10000 * t / s:
                        revert with 0, 17
                    else:
                        return 0
                else:
                    return 0
            if arg1 and t / s > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * t / s / arg1 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor35 / 10000:
                if 0 > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < 0:
                    revert with 0, 17
                if 0 > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < 0:
                    revert with 0, 17
            else:
                if arg1 * stor35 / 10000 and t / s > -1 / arg1 * stor35 / 10000:
                    revert with 0, 17
                if not arg1 * stor35 / 10000:
                    revert with 0, 18
                if arg1 * stor35 / 10000 * t / s / arg1 * stor35 / 10000 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < 0:
                    revert with 0, 17
                if arg1 * stor35 / 10000 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * stor35 / 10000 * t / s:
                    revert with 0, 17
    else:
        if arg1 and stor33 > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * stor33 / arg1 != stor33:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
        mem[96] = 26
        mem[128] = 'SafeMath: division by zero'
        if not arg1:
            mem[160] = 26
            mem[192] = 'SafeMath: division by zero'
            mem[224] = 30
            mem[256] = 'SafeMath: subtraction overflow'
            if arg1 * stor33 / 10000 > arg1:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 < arg1 * stor33 / 10000:
                revert with 0, 17
            mem[64] = 352
            mem[288] = 30
            mem[320] = 'SafeMath: subtraction overflow'
            if 0 > arg1 - (arg1 * stor33 / 10000):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (arg1 * stor33 / 10000) < 0:
                revert with 0, 17
            idx = 0
            s = 10^15
            t = stor31
            while idx < stor30.length:
                mem[0] = stor30[idx]
                mem[32] = 23
                if stor23[stor30[idx]] > t:
                    _2256 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2256] = 26
                    mem[_2256 + 32] = 'SafeMath: division by zero'
                    if not arg1:
                        if not arg1 * stor33 / 10000:
                            return 0
                        if arg1 * stor33 / 10000 and stor31 / 10^15 > -1 / arg1 * stor33 / 10000:
                            revert with 0, 17
                        if not arg1 * stor33 / 10000:
                            revert with 0, 18
                        if arg1 * stor33 / 10000 * stor31 / 10^15 / arg1 * stor33 / 10000 != stor31 / 10^15:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _2594 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2594] = 30
                        mem[_2594 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor33 / 10000 * stor31 / 10^15 > 0:
                            _2647 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _2647 + 68] = mem[idx + _2594 + 32]
                                idx = idx + 32
                                continue 
                            mem[_2647 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _2647 + -mem[64] + 100
                        if 0 < arg1 * stor33 / 10000 * stor31 / 10^15:
                            revert with 0, 17
                        _2911 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2911] = 30
                        mem[_2911 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * stor33 / 10000 * stor31 / 10^15:
                            if -1 * arg1 * stor33 / 10000 * stor31 / 10^15 < 0:
                                revert with 0, 17
                            else:
                                return 0
                        _3026 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _3026 + 68] = mem[idx + _2911 + 32]
                            idx = idx + 32
                            continue 
                        mem[_3026 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _3026 + -mem[64] + 100
                    if arg1 and stor31 / 10^15 > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor31 / 10^15 / arg1 != stor31 / 10^15:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor33 / 10000:
                        _2593 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2593] = 30
                        mem[_2593 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor31 / 10^15:
                            _2646 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _2646 + 68] = mem[idx + _2593 + 32]
                                idx = idx + 32
                                continue 
                            mem[_2646 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _2646 + -mem[64] + 100
                        if arg1 * stor31 / 10^15 < 0:
                            revert with 0, 17
                        _2909 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2909] = 30
                        mem[_2909 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor31 / 10^15:
                            if arg1 * stor31 / 10^15 < 0:
                                revert with 0, 17
                            return (arg1 * stor31 / 10^15)
                        _3025 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _3025 + 68] = mem[idx + _2909 + 32]
                            idx = idx + 32
                            continue 
                        mem[_3025 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _3025 + -mem[64] + 100
                    if arg1 * stor33 / 10000 and stor31 / 10^15 > -1 / arg1 * stor33 / 10000:
                        revert with 0, 17
                    if not arg1 * stor33 / 10000:
                        revert with 0, 18
                    if arg1 * stor33 / 10000 * stor31 / 10^15 / arg1 * stor33 / 10000 != stor31 / 10^15:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2794 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2794] = 30
                    mem[_2794 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor33 / 10000 * stor31 / 10^15 > arg1 * stor31 / 10^15:
                        _2908 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _2908 + 68] = mem[idx + _2794 + 32]
                            idx = idx + 32
                            continue 
                        mem[_2908 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2908 + -mem[64] + 100
                    if arg1 * stor31 / 10^15 < arg1 * stor33 / 10000 * stor31 / 10^15:
                        revert with 0, 17
                    _3332 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3332] = 30
                    mem[_3332 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor31 / 10^15) - (arg1 * stor33 / 10000 * stor31 / 10^15):
                        if (arg1 * stor31 / 10^15) - (arg1 * stor33 / 10000 * stor31 / 10^15) < 0:
                            revert with 0, 17
                        return (arg1 * stor31 / 10^15)
                    _3495 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _3495 + 68] = mem[idx + _3332 + 32]
                        idx = idx + 32
                        continue 
                    mem[_3495 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _3495 + -mem[64] + 100
                if idx >= stor30.length:
                    revert with 0, 50
                mem[0] = stor30[idx]
                mem[32] = 24
                if stor24[stor30[idx]] <= s:
                    if idx >= stor30.length:
                        revert with 0, 50
                    mem[0] = stor30[idx]
                    mem[32] = 23
                    _2285 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2285] = 30
                    mem[_2285 + 32] = 'SafeMath: subtraction overflow'
                    if stor23[stor30[idx]] > t:
                        _2296 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _2296 + 68] = mem[idx + _2285 + 32]
                            idx = idx + 32
                            continue 
                        mem[_2296 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2296 + -mem[64] + 100
                    if t < stor23[stor30[idx]]:
                        revert with 0, 17
                    if idx >= stor30.length:
                        revert with 0, 50
                    mem[0] = stor30[idx]
                    mem[32] = 24
                    _2390 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2390] = 30
                    mem[_2390 + 32] = 'SafeMath: subtraction overflow'
                    if stor24[stor30[idx]] <= s:
                        if s < stor24[stor30[idx]]:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s - stor24[stor30[idx]]
                        t = t - stor23[stor30[idx]]
                        continue 
                    _2406 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _2406 + 68] = mem[idx + _2390 + 32]
                        idx = idx + 32
                        continue 
                    mem[_2406 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _2406 + -mem[64] + 100
                _2286 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2286] = 26
                mem[_2286 + 32] = 'SafeMath: division by zero'
                if not arg1:
                    if not arg1 * stor33 / 10000:
                        return 0
                    if arg1 * stor33 / 10000 and stor31 / 10^15 > -1 / arg1 * stor33 / 10000:
                        revert with 0, 17
                    if not arg1 * stor33 / 10000:
                        revert with 0, 18
                    if arg1 * stor33 / 10000 * stor31 / 10^15 / arg1 * stor33 / 10000 != stor31 / 10^15:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2651 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2651] = 30
                    mem[_2651 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor33 / 10000 * stor31 / 10^15 > 0:
                        _2700 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _2700 + 68] = mem[idx + _2651 + 32]
                            idx = idx + 32
                            continue 
                        mem[_2700 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2700 + -mem[64] + 100
                    if 0 < arg1 * stor33 / 10000 * stor31 / 10^15:
                        revert with 0, 17
                    _3030 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3030] = 30
                    mem[_3030 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= -1 * arg1 * stor33 / 10000 * stor31 / 10^15:
                        if -1 * arg1 * stor33 / 10000 * stor31 / 10^15 < 0:
                            revert with 0, 17
                        else:
                            return 0
                    _3151 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _3151 + 68] = mem[idx + _3030 + 32]
                        idx = idx + 32
                        continue 
                    mem[_3151 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _3151 + -mem[64] + 100
                if arg1 and stor31 / 10^15 > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor31 / 10^15 / arg1 != stor31 / 10^15:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor33 / 10000:
                    _2650 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2650] = 30
                    mem[_2650 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor31 / 10^15:
                        _2699 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _2699 + 68] = mem[idx + _2650 + 32]
                            idx = idx + 32
                            continue 
                        mem[_2699 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2699 + -mem[64] + 100
                    if arg1 * stor31 / 10^15 < 0:
                        revert with 0, 17
                    _3028 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3028] = 30
                    mem[_3028 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= arg1 * stor31 / 10^15:
                        if arg1 * stor31 / 10^15 < 0:
                            revert with 0, 17
                        return (arg1 * stor31 / 10^15)
                    _3150 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _3150 + 68] = mem[idx + _3028 + 32]
                        idx = idx + 32
                        continue 
                    mem[_3150 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _3150 + -mem[64] + 100
                if arg1 * stor33 / 10000 and stor31 / 10^15 > -1 / arg1 * stor33 / 10000:
                    revert with 0, 17
                if not arg1 * stor33 / 10000:
                    revert with 0, 18
                if arg1 * stor33 / 10000 * stor31 / 10^15 / arg1 * stor33 / 10000 != stor31 / 10^15:
                    revert with 0, 'SafeMath: multiplication overflow'
                _2913 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2913] = 30
                mem[_2913 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor33 / 10000 * stor31 / 10^15 > arg1 * stor31 / 10^15:
                    _3027 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _3027 + 68] = mem[idx + _2913 + 32]
                        idx = idx + 32
                        continue 
                    mem[_3027 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _3027 + -mem[64] + 100
                if arg1 * stor31 / 10^15 < arg1 * stor33 / 10000 * stor31 / 10^15:
                    revert with 0, 17
                _3498 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3498] = 30
                mem[_3498 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= (arg1 * stor31 / 10^15) - (arg1 * stor33 / 10000 * stor31 / 10^15):
                    if (arg1 * stor31 / 10^15) - (arg1 * stor33 / 10000 * stor31 / 10^15) < 0:
                        revert with 0, 17
                    return (arg1 * stor31 / 10^15)
                _3624 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _3624 + 68] = mem[idx + _3498 + 32]
                    idx = idx + 32
                    continue 
                mem[_3624 + 98] = 0
                revert with memory
                  from mem[64]
                   len _3624 + -mem[64] + 100
            if t < stor31 / 10^15:
                if not arg1:
                    if arg1 * stor33 / 10000:
                        if arg1 * stor33 / 10000 and stor31 / 10^15 > -1 / arg1 * stor33 / 10000:
                            revert with 0, 17
                        if not arg1 * stor33 / 10000:
                            revert with 0, 18
                        if arg1 * stor33 / 10000 * stor31 / 10^15 / arg1 * stor33 / 10000 != stor31 / 10^15:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor33 / 10000 * stor31 / 10^15 > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor33 / 10000 * stor31 / 10^15:
                            revert with 0, 17
                        if 0 > -1 * arg1 * stor33 / 10000 * stor31 / 10^15:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor33 / 10000 * stor31 / 10^15 < 0:
                            revert with 0, 17
                        else:
                            return 0
                    else:
                        return 0
                if arg1 and stor31 / 10^15 > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor31 / 10^15 / arg1 != stor31 / 10^15:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor33 / 10000:
                    if 0 > arg1 * stor31 / 10^15:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor31 / 10^15 < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor31 / 10^15:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor31 / 10^15 < 0:
                        revert with 0, 17
                else:
                    if arg1 * stor33 / 10000 and stor31 / 10^15 > -1 / arg1 * stor33 / 10000:
                        revert with 0, 17
                    if not arg1 * stor33 / 10000:
                        revert with 0, 18
                    if arg1 * stor33 / 10000 * stor31 / 10^15 / arg1 * stor33 / 10000 != stor31 / 10^15:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor33 / 10000 * stor31 / 10^15 > arg1 * stor31 / 10^15:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor31 / 10^15 < arg1 * stor33 / 10000 * stor31 / 10^15:
                        revert with 0, 17
                    if 0 > (arg1 * stor31 / 10^15) - (arg1 * stor33 / 10000 * stor31 / 10^15):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor31 / 10^15) - (arg1 * stor33 / 10000 * stor31 / 10^15) < 0:
                        revert with 0, 17
                return (arg1 * stor31 / 10^15)
            if not s:
                revert with 0, 'SafeMath: division by zero', 0
            if not arg1:
                if arg1 * stor33 / 10000:
                    if arg1 * stor33 / 10000 and t / s > -1 / arg1 * stor33 / 10000:
                        revert with 0, 17
                    if not arg1 * stor33 / 10000:
                        revert with 0, 18
                    if arg1 * stor33 / 10000 * t / s / arg1 * stor33 / 10000 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor33 / 10000 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor33 / 10000 * t / s:
                        revert with 0, 17
                    if 0 > -1 * arg1 * stor33 / 10000 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor33 / 10000 * t / s < 0:
                        revert with 0, 17
                    else:
                        return 0
                else:
                    return 0
            if arg1 and t / s > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * t / s / arg1 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor33 / 10000:
                if 0 > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < 0:
                    revert with 0, 17
                if 0 > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < 0:
                    revert with 0, 17
            else:
                if arg1 * stor33 / 10000 and t / s > -1 / arg1 * stor33 / 10000:
                    revert with 0, 17
                if not arg1 * stor33 / 10000:
                    revert with 0, 18
                if arg1 * stor33 / 10000 * t / s / arg1 * stor33 / 10000 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * stor33 / 10000 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * stor33 / 10000 * t / s:
                    revert with 0, 17
                if 0 > (arg1 * t / s) - (arg1 * stor33 / 10000 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * stor33 / 10000 * t / s) < 0:
                    revert with 0, 17
        else:
            if arg1 and stor35 > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor35 / arg1 != stor35:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[160] = 26
            mem[192] = 'SafeMath: division by zero'
            mem[224] = 30
            mem[256] = 'SafeMath: subtraction overflow'
            if arg1 * stor33 / 10000 > arg1:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 < arg1 * stor33 / 10000:
                revert with 0, 17
            mem[64] = 352
            mem[288] = 30
            mem[320] = 'SafeMath: subtraction overflow'
            if arg1 * stor35 / 10000 > arg1 - (arg1 * stor33 / 10000):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (arg1 * stor33 / 10000) < arg1 * stor35 / 10000:
                revert with 0, 17
            idx = 0
            s = 10^15
            t = stor31
            while idx < stor30.length:
                mem[0] = stor30[idx]
                mem[32] = 23
                if stor23[stor30[idx]] > t:
                    _2255 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2255] = 26
                    mem[_2255 + 32] = 'SafeMath: division by zero'
                    if not arg1:
                        if not arg1 * stor33 / 10000:
                            if not arg1 * stor35 / 10000:
                                return 0
                            if arg1 * stor35 / 10000 and stor31 / 10^15 > -1 / arg1 * stor35 / 10000:
                                revert with 0, 17
                            if not arg1 * stor35 / 10000:
                                revert with 0, 18
                            if arg1 * stor35 / 10000 * stor31 / 10^15 / arg1 * stor35 / 10000 != stor31 / 10^15:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _2586 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2586] = 30
                            mem[_2586 + 32] = 'SafeMath: subtraction overflow'
                            _2898 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2898] = 30
                            mem[_2898 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor35 / 10000 * stor31 / 10^15 <= 0:
                                if 0 < arg1 * stor35 / 10000 * stor31 / 10^15:
                                    revert with 0, 17
                                else:
                                    return 0
                            _3016 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _3016 + 68] = mem[idx + _2898 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3016 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _3016 + -mem[64] + 100
                        if arg1 * stor33 / 10000 and stor31 / 10^15 > -1 / arg1 * stor33 / 10000:
                            revert with 0, 17
                        if not arg1 * stor33 / 10000:
                            revert with 0, 18
                        if arg1 * stor33 / 10000 * stor31 / 10^15 / arg1 * stor33 / 10000 != stor31 / 10^15:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor35 / 10000:
                            _2585 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2585] = 30
                            mem[_2585 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor33 / 10000 * stor31 / 10^15 > 0:
                                _2640 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2640 + 68] = mem[idx + _2585 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2640 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2640 + -mem[64] + 100
                            if 0 < arg1 * stor33 / 10000 * stor31 / 10^15:
                                revert with 0, 17
                            _2896 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2896] = 30
                            mem[_2896 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor33 / 10000 * stor31 / 10^15:
                                if -1 * arg1 * stor33 / 10000 * stor31 / 10^15 < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _3015 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _3015 + 68] = mem[idx + _2896 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3015 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _3015 + -mem[64] + 100
                        if arg1 * stor35 / 10000 and stor31 / 10^15 > -1 / arg1 * stor35 / 10000:
                            revert with 0, 17
                        if not arg1 * stor35 / 10000:
                            revert with 0, 18
                        if arg1 * stor35 / 10000 * stor31 / 10^15 / arg1 * stor35 / 10000 != stor31 / 10^15:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _2785 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2785] = 30
                        mem[_2785 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor33 / 10000 * stor31 / 10^15 > 0:
                            _2895 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _2895 + 68] = mem[idx + _2785 + 32]
                                idx = idx + 32
                                continue 
                            mem[_2895 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _2895 + -mem[64] + 100
                        if 0 < arg1 * stor33 / 10000 * stor31 / 10^15:
                            revert with 0, 17
                        _3318 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3318] = 30
                        mem[_3318 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor35 / 10000 * stor31 / 10^15 <= -1 * arg1 * stor33 / 10000 * stor31 / 10^15:
                            if -1 * arg1 * stor33 / 10000 * stor31 / 10^15 < arg1 * stor35 / 10000 * stor31 / 10^15:
                                revert with 0, 17
                            else:
                                return 0
                        _3480 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _3480 + 68] = mem[idx + _3318 + 32]
                            idx = idx + 32
                            continue 
                        mem[_3480 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _3480 + -mem[64] + 100
                    if arg1 and stor31 / 10^15 > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor31 / 10^15 / arg1 != stor31 / 10^15:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor33 / 10000:
                        if not arg1 * stor35 / 10000:
                            _2584 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2584] = 30
                            mem[_2584 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor31 / 10^15:
                                _2639 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2639 + 68] = mem[idx + _2584 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2639 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2639 + -mem[64] + 100
                            if arg1 * stor31 / 10^15 < 0:
                                revert with 0, 17
                            _2893 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2893] = 30
                            mem[_2893 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor31 / 10^15:
                                if arg1 * stor31 / 10^15 < 0:
                                    revert with 0, 17
                                return (arg1 * stor31 / 10^15)
                            _3014 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _3014 + 68] = mem[idx + _2893 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3014 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _3014 + -mem[64] + 100
                        if arg1 * stor35 / 10000 and stor31 / 10^15 > -1 / arg1 * stor35 / 10000:
                            revert with 0, 17
                        if not arg1 * stor35 / 10000:
                            revert with 0, 18
                        if arg1 * stor35 / 10000 * stor31 / 10^15 / arg1 * stor35 / 10000 != stor31 / 10^15:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _2784 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2784] = 30
                        mem[_2784 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor31 / 10^15:
                            _2892 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _2892 + 68] = mem[idx + _2784 + 32]
                                idx = idx + 32
                                continue 
                            mem[_2892 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _2892 + -mem[64] + 100
                        if arg1 * stor31 / 10^15 < 0:
                            revert with 0, 17
                        _3316 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3316] = 30
                        mem[_3316 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor35 / 10000 * stor31 / 10^15 <= arg1 * stor31 / 10^15:
                            if arg1 * stor31 / 10^15 < arg1 * stor35 / 10000 * stor31 / 10^15:
                                revert with 0, 17
                            return (arg1 * stor31 / 10^15)
                        _3478 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _3478 + 68] = mem[idx + _3316 + 32]
                            idx = idx + 32
                            continue 
                        mem[_3478 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _3478 + -mem[64] + 100
                    if arg1 * stor33 / 10000 and stor31 / 10^15 > -1 / arg1 * stor33 / 10000:
                        revert with 0, 17
                    if not arg1 * stor33 / 10000:
                        revert with 0, 18
                    if arg1 * stor33 / 10000 * stor31 / 10^15 / arg1 * stor33 / 10000 != stor31 / 10^15:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor35 / 10000:
                        _2783 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2783] = 30
                        mem[_2783 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor33 / 10000 * stor31 / 10^15 > arg1 * stor31 / 10^15:
                            _2891 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _2891 + 68] = mem[idx + _2783 + 32]
                                idx = idx + 32
                                continue 
                            mem[_2891 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _2891 + -mem[64] + 100
                        if arg1 * stor31 / 10^15 < arg1 * stor33 / 10000 * stor31 / 10^15:
                            revert with 0, 17
                        _3314 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3314] = 30
                        mem[_3314 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor31 / 10^15) - (arg1 * stor33 / 10000 * stor31 / 10^15):
                            if (arg1 * stor31 / 10^15) - (arg1 * stor33 / 10000 * stor31 / 10^15) < 0:
                                revert with 0, 17
                            return (arg1 * stor31 / 10^15)
                        _3477 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _3477 + 68] = mem[idx + _3314 + 32]
                            idx = idx + 32
                            continue 
                        mem[_3477 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _3477 + -mem[64] + 100
                    if arg1 * stor35 / 10000 and stor31 / 10^15 > -1 / arg1 * stor35 / 10000:
                        revert with 0, 17
                    if not arg1 * stor35 / 10000:
                        revert with 0, 18
                    if arg1 * stor35 / 10000 * stor31 / 10^15 / arg1 * stor35 / 10000 != stor31 / 10^15:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _3143 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3143] = 30
                    mem[_3143 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor33 / 10000 * stor31 / 10^15 > arg1 * stor31 / 10^15:
                        _3313 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _3313 + 68] = mem[idx + _3143 + 32]
                            idx = idx + 32
                            continue 
                        mem[_3313 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _3313 + -mem[64] + 100
                    if arg1 * stor31 / 10^15 < arg1 * stor33 / 10000 * stor31 / 10^15:
                        revert with 0, 17
                    _3795 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3795] = 30
                    mem[_3795 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor35 / 10000 * stor31 / 10^15 <= (arg1 * stor31 / 10^15) - (arg1 * stor33 / 10000 * stor31 / 10^15):
                        if (arg1 * stor31 / 10^15) - (arg1 * stor33 / 10000 * stor31 / 10^15) < arg1 * stor35 / 10000 * stor31 / 10^15:
                            revert with 0, 17
                        return (arg1 * stor31 / 10^15)
                    _3947 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _3947 + 68] = mem[idx + _3795 + 32]
                        idx = idx + 32
                        continue 
                    mem[_3947 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _3947 + -mem[64] + 100
                if idx >= stor30.length:
                    revert with 0, 50
                mem[0] = stor30[idx]
                mem[32] = 24
                if stor24[stor30[idx]] <= s:
                    if idx >= stor30.length:
                        revert with 0, 50
                    mem[0] = stor30[idx]
                    mem[32] = 23
                    _2283 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2283] = 30
                    mem[_2283 + 32] = 'SafeMath: subtraction overflow'
                    if stor23[stor30[idx]] > t:
                        _2295 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _2295 + 68] = mem[idx + _2283 + 32]
                            idx = idx + 32
                            continue 
                        mem[_2295 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2295 + -mem[64] + 100
                    if t < stor23[stor30[idx]]:
                        revert with 0, 17
                    if idx >= stor30.length:
                        revert with 0, 50
                    mem[0] = stor30[idx]
                    mem[32] = 24
                    _2388 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2388] = 30
                    mem[_2388 + 32] = 'SafeMath: subtraction overflow'
                    if stor24[stor30[idx]] <= s:
                        if s < stor24[stor30[idx]]:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s - stor24[stor30[idx]]
                        t = t - stor23[stor30[idx]]
                        continue 
                    _2404 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _2404 + 68] = mem[idx + _2388 + 32]
                        idx = idx + 32
                        continue 
                    mem[_2404 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _2404 + -mem[64] + 100
                _2284 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2284] = 26
                mem[_2284 + 32] = 'SafeMath: division by zero'
                if not arg1:
                    if not arg1 * stor33 / 10000:
                        if not arg1 * stor35 / 10000:
                            return 0
                        if arg1 * stor35 / 10000 and stor31 / 10^15 > -1 / arg1 * stor35 / 10000:
                            revert with 0, 17
                        if not arg1 * stor35 / 10000:
                            revert with 0, 18
                        if arg1 * stor35 / 10000 * stor31 / 10^15 / arg1 * stor35 / 10000 != stor31 / 10^15:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _2645 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2645] = 30
                        mem[_2645 + 32] = 'SafeMath: subtraction overflow'
                        _3024 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3024] = 30
                        mem[_3024 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor35 / 10000 * stor31 / 10^15 <= 0:
                            if 0 < arg1 * stor35 / 10000 * stor31 / 10^15:
                                revert with 0, 17
                            else:
                                return 0
                        _3147 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _3147 + 68] = mem[idx + _3024 + 32]
                            idx = idx + 32
                            continue 
                        mem[_3147 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _3147 + -mem[64] + 100
                    if arg1 * stor33 / 10000 and stor31 / 10^15 > -1 / arg1 * stor33 / 10000:
                        revert with 0, 17
                    if not arg1 * stor33 / 10000:
                        revert with 0, 18
                    if arg1 * stor33 / 10000 * stor31 / 10^15 / arg1 * stor33 / 10000 != stor31 / 10^15:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor35 / 10000:
                        _2644 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2644] = 30
                        mem[_2644 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor33 / 10000 * stor31 / 10^15 > 0:
                            _2697 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _2697 + 68] = mem[idx + _2644 + 32]
                                idx = idx + 32
                                continue 
                            mem[_2697 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _2697 + -mem[64] + 100
                        if 0 < arg1 * stor33 / 10000 * stor31 / 10^15:
                            revert with 0, 17
                        _3022 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3022] = 30
                        mem[_3022 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * stor33 / 10000 * stor31 / 10^15:
                            if -1 * arg1 * stor33 / 10000 * stor31 / 10^15 < 0:
                                revert with 0, 17
                            else:
                                return 0
                        _3146 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _3146 + 68] = mem[idx + _3022 + 32]
                            idx = idx + 32
                            continue 
                        mem[_3146 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _3146 + -mem[64] + 100
                    if arg1 * stor35 / 10000 and stor31 / 10^15 > -1 / arg1 * stor35 / 10000:
                        revert with 0, 17
                    if not arg1 * stor35 / 10000:
                        revert with 0, 18
                    if arg1 * stor35 / 10000 * stor31 / 10^15 / arg1 * stor35 / 10000 != stor31 / 10^15:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2901 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2901] = 30
                    mem[_2901 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor33 / 10000 * stor31 / 10^15 > 0:
                        _3021 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _3021 + 68] = mem[idx + _2901 + 32]
                            idx = idx + 32
                            continue 
                        mem[_3021 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _3021 + -mem[64] + 100
                    if 0 < arg1 * stor33 / 10000 * stor31 / 10^15:
                        revert with 0, 17
                    _3488 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3488] = 30
                    mem[_3488 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor35 / 10000 * stor31 / 10^15 <= -1 * arg1 * stor33 / 10000 * stor31 / 10^15:
                        if -1 * arg1 * stor33 / 10000 * stor31 / 10^15 < arg1 * stor35 / 10000 * stor31 / 10^15:
                            revert with 0, 17
                        else:
                            return 0
                    _3621 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _3621 + 68] = mem[idx + _3488 + 32]
                        idx = idx + 32
                        continue 
                    mem[_3621 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _3621 + -mem[64] + 100
                if arg1 and stor31 / 10^15 > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor31 / 10^15 / arg1 != stor31 / 10^15:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor33 / 10000:
                    if not arg1 * stor35 / 10000:
                        _2643 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2643] = 30
                        mem[_2643 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor31 / 10^15:
                            _2696 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _2696 + 68] = mem[idx + _2643 + 32]
                                idx = idx + 32
                                continue 
                            mem[_2696 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _2696 + -mem[64] + 100
                        if arg1 * stor31 / 10^15 < 0:
                            revert with 0, 17
                        _3019 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3019] = 30
                        mem[_3019 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor31 / 10^15:
                            if arg1 * stor31 / 10^15 < 0:
                                revert with 0, 17
                            return (arg1 * stor31 / 10^15)
                        _3145 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _3145 + 68] = mem[idx + _3019 + 32]
                            idx = idx + 32
                            continue 
                        mem[_3145 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _3145 + -mem[64] + 100
                    if arg1 * stor35 / 10000 and stor31 / 10^15 > -1 / arg1 * stor35 / 10000:
                        revert with 0, 17
                    if not arg1 * stor35 / 10000:
                        revert with 0, 18
                    if arg1 * stor35 / 10000 * stor31 / 10^15 / arg1 * stor35 / 10000 != stor31 / 10^15:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2900 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2900] = 30
                    mem[_2900 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor31 / 10^15:
                        _3018 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _3018 + 68] = mem[idx + _2900 + 32]
                            idx = idx + 32
                            continue 
                        mem[_3018 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _3018 + -mem[64] + 100
                    if arg1 * stor31 / 10^15 < 0:
                        revert with 0, 17
                    _3486 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3486] = 30
                    mem[_3486 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor35 / 10000 * stor31 / 10^15 <= arg1 * stor31 / 10^15:
                        if arg1 * stor31 / 10^15 < arg1 * stor35 / 10000 * stor31 / 10^15:
                            revert with 0, 17
                        return (arg1 * stor31 / 10^15)
                    _3619 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _3619 + 68] = mem[idx + _3486 + 32]
                        idx = idx + 32
                        continue 
                    mem[_3619 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _3619 + -mem[64] + 100
                if arg1 * stor33 / 10000 and stor31 / 10^15 > -1 / arg1 * stor33 / 10000:
                    revert with 0, 17
                if not arg1 * stor33 / 10000:
                    revert with 0, 18
                if arg1 * stor33 / 10000 * stor31 / 10^15 / arg1 * stor33 / 10000 != stor31 / 10^15:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor35 / 10000:
                    _2899 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2899] = 30
                    mem[_2899 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor33 / 10000 * stor31 / 10^15 > arg1 * stor31 / 10^15:
                        _3017 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _3017 + 68] = mem[idx + _2899 + 32]
                            idx = idx + 32
                            continue 
                        mem[_3017 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _3017 + -mem[64] + 100
                    if arg1 * stor31 / 10^15 < arg1 * stor33 / 10000 * stor31 / 10^15:
                        revert with 0, 17
                    _3484 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3484] = 30
                    mem[_3484 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor31 / 10^15) - (arg1 * stor33 / 10000 * stor31 / 10^15):
                        if (arg1 * stor31 / 10^15) - (arg1 * stor33 / 10000 * stor31 / 10^15) < 0:
                            revert with 0, 17
                        return (arg1 * stor31 / 10^15)
                    _3618 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _3618 + 68] = mem[idx + _3484 + 32]
                        idx = idx + 32
                        continue 
                    mem[_3618 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _3618 + -mem[64] + 100
                if arg1 * stor35 / 10000 and stor31 / 10^15 > -1 / arg1 * stor35 / 10000:
                    revert with 0, 17
                if not arg1 * stor35 / 10000:
                    revert with 0, 18
                if arg1 * stor35 / 10000 * stor31 / 10^15 / arg1 * stor35 / 10000 != stor31 / 10^15:
                    revert with 0, 'SafeMath: multiplication overflow'
                _3321 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3321] = 30
                mem[_3321 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor33 / 10000 * stor31 / 10^15 > arg1 * stor31 / 10^15:
                    _3483 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _3483 + 68] = mem[idx + _3321 + 32]
                        idx = idx + 32
                        continue 
                    mem[_3483 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _3483 + -mem[64] + 100
                if arg1 * stor31 / 10^15 < arg1 * stor33 / 10000 * stor31 / 10^15:
                    revert with 0, 17
                _3951 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3951] = 30
                mem[_3951 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor35 / 10000 * stor31 / 10^15 <= (arg1 * stor31 / 10^15) - (arg1 * stor33 / 10000 * stor31 / 10^15):
                    if (arg1 * stor31 / 10^15) - (arg1 * stor33 / 10000 * stor31 / 10^15) < arg1 * stor35 / 10000 * stor31 / 10^15:
                        revert with 0, 17
                    return (arg1 * stor31 / 10^15)
                _4019 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _4019 + 68] = mem[idx + _3951 + 32]
                    idx = idx + 32
                    continue 
                mem[_4019 + 98] = 0
                revert with memory
                  from mem[64]
                   len _4019 + -mem[64] + 100
            if t < stor31 / 10^15:
                if not arg1:
                    if not arg1 * stor33 / 10000:
                        if arg1 * stor35 / 10000:
                            if arg1 * stor35 / 10000 and stor31 / 10^15 > -1 / arg1 * stor35 / 10000:
                                revert with 0, 17
                            if not arg1 * stor35 / 10000:
                                revert with 0, 18
                            if arg1 * stor35 / 10000 * stor31 / 10^15 / arg1 * stor35 / 10000 != stor31 / 10^15:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor35 / 10000 * stor31 / 10^15 > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * stor35 / 10000 * stor31 / 10^15:
                                revert with 0, 17
                    else:
                        if arg1 * stor33 / 10000 and stor31 / 10^15 > -1 / arg1 * stor33 / 10000:
                            revert with 0, 17
                        if not arg1 * stor33 / 10000:
                            revert with 0, 18
                        if arg1 * stor33 / 10000 * stor31 / 10^15 / arg1 * stor33 / 10000 != stor31 / 10^15:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor35 / 10000:
                            if arg1 * stor33 / 10000 * stor31 / 10^15 > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * stor33 / 10000 * stor31 / 10^15:
                                revert with 0, 17
                            if 0 > -1 * arg1 * stor33 / 10000 * stor31 / 10^15:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * stor33 / 10000 * stor31 / 10^15 < 0:
                                revert with 0, 17
                        else:
                            if arg1 * stor35 / 10000 and stor31 / 10^15 > -1 / arg1 * stor35 / 10000:
                                revert with 0, 17
                            if not arg1 * stor35 / 10000:
                                revert with 0, 18
                            if arg1 * stor35 / 10000 * stor31 / 10^15 / arg1 * stor35 / 10000 != stor31 / 10^15:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor33 / 10000 * stor31 / 10^15 > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * stor33 / 10000 * stor31 / 10^15:
                                revert with 0, 17
                            if arg1 * stor35 / 10000 * stor31 / 10^15 > -1 * arg1 * stor33 / 10000 * stor31 / 10^15:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * stor33 / 10000 * stor31 / 10^15 < arg1 * stor35 / 10000 * stor31 / 10^15:
                                revert with 0, 17
                    return 0
                if arg1 and stor31 / 10^15 > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor31 / 10^15 / arg1 != stor31 / 10^15:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor33 / 10000:
                    if not arg1 * stor35 / 10000:
                        if 0 > arg1 * stor31 / 10^15:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor31 / 10^15 < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor31 / 10^15:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor31 / 10^15 < 0:
                            revert with 0, 17
                    else:
                        if arg1 * stor35 / 10000 and stor31 / 10^15 > -1 / arg1 * stor35 / 10000:
                            revert with 0, 17
                        if not arg1 * stor35 / 10000:
                            revert with 0, 18
                        if arg1 * stor35 / 10000 * stor31 / 10^15 / arg1 * stor35 / 10000 != stor31 / 10^15:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * stor31 / 10^15:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor31 / 10^15 < 0:
                            revert with 0, 17
                        if arg1 * stor35 / 10000 * stor31 / 10^15 > arg1 * stor31 / 10^15:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor31 / 10^15 < arg1 * stor35 / 10000 * stor31 / 10^15:
                            revert with 0, 17
                else:
                    if arg1 * stor33 / 10000 and stor31 / 10^15 > -1 / arg1 * stor33 / 10000:
                        revert with 0, 17
                    if not arg1 * stor33 / 10000:
                        revert with 0, 18
                    if arg1 * stor33 / 10000 * stor31 / 10^15 / arg1 * stor33 / 10000 != stor31 / 10^15:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor35 / 10000:
                        if arg1 * stor33 / 10000 * stor31 / 10^15 > arg1 * stor31 / 10^15:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor31 / 10^15 < arg1 * stor33 / 10000 * stor31 / 10^15:
                            revert with 0, 17
                        if 0 > (arg1 * stor31 / 10^15) - (arg1 * stor33 / 10000 * stor31 / 10^15):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor31 / 10^15) - (arg1 * stor33 / 10000 * stor31 / 10^15) < 0:
                            revert with 0, 17
                    else:
                        if arg1 * stor35 / 10000 and stor31 / 10^15 > -1 / arg1 * stor35 / 10000:
                            revert with 0, 17
                        if not arg1 * stor35 / 10000:
                            revert with 0, 18
                        if arg1 * stor35 / 10000 * stor31 / 10^15 / arg1 * stor35 / 10000 != stor31 / 10^15:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor33 / 10000 * stor31 / 10^15 > arg1 * stor31 / 10^15:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor31 / 10^15 < arg1 * stor33 / 10000 * stor31 / 10^15:
                            revert with 0, 17
                        if arg1 * stor35 / 10000 * stor31 / 10^15 > (arg1 * stor31 / 10^15) - (arg1 * stor33 / 10000 * stor31 / 10^15):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor31 / 10^15) - (arg1 * stor33 / 10000 * stor31 / 10^15) < arg1 * stor35 / 10000 * stor31 / 10^15:
                            revert with 0, 17
                return (arg1 * stor31 / 10^15)
            if not s:
                revert with 0, 'SafeMath: division by zero', 0
            if not arg1:
                if not arg1 * stor33 / 10000:
                    if arg1 * stor35 / 10000:
                        if arg1 * stor35 / 10000 and t / s > -1 / arg1 * stor35 / 10000:
                            revert with 0, 17
                        if not arg1 * stor35 / 10000:
                            revert with 0, 18
                        if arg1 * stor35 / 10000 * t / s / arg1 * stor35 / 10000 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor35 / 10000 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor35 / 10000 * t / s:
                            revert with 0, 17
                else:
                    if arg1 * stor33 / 10000 and t / s > -1 / arg1 * stor33 / 10000:
                        revert with 0, 17
                    if not arg1 * stor33 / 10000:
                        revert with 0, 18
                    if arg1 * stor33 / 10000 * t / s / arg1 * stor33 / 10000 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor35 / 10000:
                        if arg1 * stor33 / 10000 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor33 / 10000 * t / s:
                            revert with 0, 17
                        if 0 > -1 * arg1 * stor33 / 10000 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor33 / 10000 * t / s < 0:
                            revert with 0, 17
                    else:
                        if arg1 * stor35 / 10000 and t / s > -1 / arg1 * stor35 / 10000:
                            revert with 0, 17
                        if not arg1 * stor35 / 10000:
                            revert with 0, 18
                        if arg1 * stor35 / 10000 * t / s / arg1 * stor35 / 10000 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor33 / 10000 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor33 / 10000 * t / s:
                            revert with 0, 17
                        if arg1 * stor35 / 10000 * t / s > -1 * arg1 * stor33 / 10000 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor33 / 10000 * t / s < arg1 * stor35 / 10000 * t / s:
                            revert with 0, 17
                return 0
            if arg1 and t / s > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * t / s / arg1 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor33 / 10000:
                if not arg1 * stor35 / 10000:
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                else:
                    if arg1 * stor35 / 10000 and t / s > -1 / arg1 * stor35 / 10000:
                        revert with 0, 17
                    if not arg1 * stor35 / 10000:
                        revert with 0, 18
                    if arg1 * stor35 / 10000 * t / s / arg1 * stor35 / 10000 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if arg1 * stor35 / 10000 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * stor35 / 10000 * t / s:
                        revert with 0, 17
            else:
                if arg1 * stor33 / 10000 and t / s > -1 / arg1 * stor33 / 10000:
                    revert with 0, 17
                if not arg1 * stor33 / 10000:
                    revert with 0, 18
                if arg1 * stor33 / 10000 * t / s / arg1 * stor33 / 10000 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor35 / 10000:
                    if arg1 * stor33 / 10000 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * stor33 / 10000 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * stor33 / 10000 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * stor33 / 10000 * t / s) < 0:
                        revert with 0, 17
                else:
                    if arg1 * stor35 / 10000 and t / s > -1 / arg1 * stor35 / 10000:
                        revert with 0, 17
                    if not arg1 * stor35 / 10000:
                        revert with 0, 18
                    if arg1 * stor35 / 10000 * t / s / arg1 * stor35 / 10000 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor33 / 10000 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * stor33 / 10000 * t / s:
                        revert with 0, 17
                    if arg1 * stor35 / 10000 * t / s > (arg1 * t / s) - (arg1 * stor33 / 10000 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * stor33 / 10000 * t / s) < arg1 * stor35 / 10000 * t / s:
                        revert with 0, 17
    return (arg1 * t / s)
}

function sub_12247d8b(?) payable {
    mem[64] = 96
    require not msg.value
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if stor29[address(this.address)]:
        if stor24[address(this.address)] < 10^11:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        'Can only swap back if more than .01% of tokens stuck on contract'
        uint8(stor55.field_160) = 1
        if stor29[address(this.address)]:
            if _liquidityTokensToSwap > !sub_432654c4:
                revert with 0, 17
            if minimumTokensBeforeSwapAmount > 0x1999999999999999999999999999999999999999999999999999999999999999:
                revert with 0, 17
            if stor24[address(this.address)] < 10 * minimumTokensBeforeSwapAmount:
                if stor24[address(this.address)]:
                    if _liquidityTokensToSwap + sub_432654c4:
                        if stor24[address(this.address)] and _liquidityTokensToSwap > -1 / stor24[address(this.address)]:
                            revert with 0, 17
                        if not _liquidityTokensToSwap + sub_432654c4:
                            revert with 0, 18
                        if stor24[address(this.address)] * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2 > stor24[address(this.address)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor24[address(this.address)] < stor24[address(this.address)] * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2:
                            revert with 0, 17
                        mem[192] = this.address
                        staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                gas gas_remaining wei
                        mem[256] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        mem[224] = ext_call.return_data[12 len 20]
                        if not this.address:
                            revert with 0, 'ERC20: approve from the zero address'
                        if not uniswapV2RouterAddress:
                            revert with 0, 'ERC20: approve to the zero address'
                        allowance[address(this.address)][stor54] = stor24[address(this.address)] - (stor24[address(this.address)] * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                        emit Approval((stor24[address(this.address)] - (stor24[address(this.address)] * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)), this.address, uniswapV2RouterAddress);
                        mem[ceil32(return_data.size) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                        mem[ceil32(return_data.size) + 260] = stor24[address(this.address)] - (stor24[address(this.address)] * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                        idx = 0
                        s = ceil32(return_data.size) + 452
                        t = 192
                        while idx < 2:
                            mem[s] = mem[t + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        require ext_code.size(uniswapV2RouterAddress)
                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args stor24[address(this.address)] - (stor24[address(this.address)] * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2), 0, 160, address(this.address), block.timestamp, 2, mem[ceil32(return_data.size) + 452 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if eth.balance(this.address) > eth.balance(this.address):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if eth.balance(this.address) < eth.balance(this.address):
                            revert with 0, 17
                        _liquidityTokensToSwap = 0
                        sub_432654c4 = 0
            else:
                if minimumTokensBeforeSwapAmount > 0x1999999999999999999999999999999999999999999999999999999999999999:
                    revert with 0, 17
                if 10 * minimumTokensBeforeSwapAmount:
                    if _liquidityTokensToSwap + sub_432654c4:
                        if 10 * minimumTokensBeforeSwapAmount and _liquidityTokensToSwap > -1 / 10 * minimumTokensBeforeSwapAmount:
                            revert with 0, 17
                        if not _liquidityTokensToSwap + sub_432654c4:
                            revert with 0, 18
                        if 10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2 > 10 * minimumTokensBeforeSwapAmount:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 10 * minimumTokensBeforeSwapAmount < 10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2:
                            revert with 0, 17
                        mem[192] = this.address
                        staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                gas gas_remaining wei
                        mem[256] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        mem[224] = ext_call.return_data[12 len 20]
                        if not this.address:
                            revert with 0, 'ERC20: approve from the zero address'
                        if not uniswapV2RouterAddress:
                            revert with 0, 'ERC20: approve to the zero address'
                        allowance[address(this.address)][stor54] = (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                        emit Approval(((10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)), this.address, uniswapV2RouterAddress);
                        mem[ceil32(return_data.size) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                        mem[ceil32(return_data.size) + 260] = (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                        idx = 0
                        s = ceil32(return_data.size) + 452
                        t = 192
                        while idx < 2:
                            mem[s] = mem[t + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        require ext_code.size(uniswapV2RouterAddress)
                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2), 0, 160, address(this.address), block.timestamp, 2, mem[ceil32(return_data.size) + 452 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if eth.balance(this.address) > eth.balance(this.address):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if eth.balance(this.address) < eth.balance(this.address):
                            revert with 0, 17
                        _liquidityTokensToSwap = 0
                        sub_432654c4 = 0
        else:
            mem[0] = this.address
            mem[32] = 23
            if stor23[address(this.address)] > stor31:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
            idx = 0
            s = 10^15
            t = stor31
            while idx < stor30.length:
                mem[0] = stor30[idx]
                mem[32] = 23
                if stor23[stor30[idx]] > t:
                    _2308 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2308] = 26
                    mem[_2308 + 32] = 'SafeMath: division by zero'
                    _2345 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2345] = 26
                    mem[_2345 + 32] = 'SafeMath: division by zero'
                    if not stor31 / 10^15:
                        _2358 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _2358 + 68] = mem[idx + _2345 + 32]
                            idx = idx + 32
                            continue 
                        mem[_2358 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2358 + -mem[64] + 100
                    if _liquidityTokensToSwap > !sub_432654c4:
                        revert with 0, 17
                    if minimumTokensBeforeSwapAmount > 0x1999999999999999999999999999999999999999999999999999999999999999:
                        revert with 0, 17
                    if stor23[address(this.address)] / stor31 / 10^15 < 10 * minimumTokensBeforeSwapAmount:
                        if not stor23[address(this.address)] / stor31 / 10^15:
                            uint8(stor55.field_160) = 0
                            emit OwnerForcedSwapBack(block.timestamp);
                        if not _liquidityTokensToSwap + sub_432654c4:
                            uint8(stor55.field_160) = 0
                            emit OwnerForcedSwapBack(block.timestamp);
                        if stor23[address(this.address)] / stor31 / 10^15 and _liquidityTokensToSwap > -1 / stor23[address(this.address)] / stor31 / 10^15:
                            revert with 0, 17
                        if not _liquidityTokensToSwap + sub_432654c4:
                            revert with 0, 18
                        _2502 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2502] = 30
                        mem[_2502 + 32] = 'SafeMath: subtraction overflow'
                        if stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2 > stor23[address(this.address)] / stor31 / 10^15:
                            _2522 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _2522 + 68] = mem[idx + _2502 + 32]
                                idx = idx + 32
                                continue 
                            mem[_2522 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _2522 + -mem[64] + 100
                        if stor23[address(this.address)] / stor31 / 10^15 < stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2:
                            revert with 0, 17
                        _2584 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        mem[_2584 + 32 len 64] = call.data[calldata.size len 64]
                        if 0 >= mem[_2584]:
                            revert with 0, 50
                        mem[_2584 + 32] = this.address
                        staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                gas gas_remaining wei
                        mem[_2584 + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _2584 + ceil32(return_data.size) + 96
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        if 1 >= mem[_2584]:
                            revert with 0, 50
                        mem[_2584 + 64] = ext_call.return_data[12 len 20]
                        if not this.address:
                            revert with 0, 'ERC20: approve from the zero address'
                        if not uniswapV2RouterAddress:
                            revert with 0, 'ERC20: approve to the zero address'
                        mem[0] = uniswapV2RouterAddress
                        mem[32] = sha3(address(this.address), 25)
                        allowance[address(this.address)][stor54] = (stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                        emit Approval(((stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)), this.address, uniswapV2RouterAddress);
                        mem[_2584 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                        mem[_2584 + ceil32(return_data.size) + 100] = (stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                        mem[_2584 + ceil32(return_data.size) + 132] = 0
                        mem[_2584 + ceil32(return_data.size) + 164] = 160
                        mem[_2584 + ceil32(return_data.size) + 260] = mem[_2584]
                        idx = 0
                        s = _2584 + ceil32(return_data.size) + 292
                        t = _2584 + 32
                        while idx < mem[_2584]:
                            mem[s] = mem[t + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_2584 + ceil32(return_data.size) + 196] = this.address
                        mem[_2584 + ceil32(return_data.size) + 228] = block.timestamp
                        require ext_code.size(uniswapV2RouterAddress)
                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _2584 + ceil32(return_data.size) + (32 * mem[_2584]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4685 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4685] = 30
                        mem[_4685 + 32] = 'SafeMath: subtraction overflow'
                        if eth.balance(this.address) <= eth.balance(this.address):
                            if eth.balance(this.address) < eth.balance(this.address):
                                revert with 0, 17
                            _liquidityTokensToSwap = 0
                            sub_432654c4 = 0
                            uint8(stor55.field_160) = 0
                            emit OwnerForcedSwapBack(block.timestamp);
                        _4717 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _4717 + 68] = mem[idx + _4685 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4717 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _4717 + -mem[64] + 100
                    if minimumTokensBeforeSwapAmount > 0x1999999999999999999999999999999999999999999999999999999999999999:
                        revert with 0, 17
                    if not 10 * minimumTokensBeforeSwapAmount:
                        uint8(stor55.field_160) = 0
                        emit OwnerForcedSwapBack(block.timestamp);
                    if not _liquidityTokensToSwap + sub_432654c4:
                        uint8(stor55.field_160) = 0
                        emit OwnerForcedSwapBack(block.timestamp);
                    if 10 * minimumTokensBeforeSwapAmount and _liquidityTokensToSwap > -1 / 10 * minimumTokensBeforeSwapAmount:
                        revert with 0, 17
                    if not _liquidityTokensToSwap + sub_432654c4:
                        revert with 0, 18
                    _2537 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2537] = 30
                    mem[_2537 + 32] = 'SafeMath: subtraction overflow'
                    if 10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2 > 10 * minimumTokensBeforeSwapAmount:
                        _2565 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _2565 + 68] = mem[idx + _2537 + 32]
                            idx = idx + 32
                            continue 
                        mem[_2565 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2565 + -mem[64] + 100
                    if 10 * minimumTokensBeforeSwapAmount < 10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2:
                        revert with 0, 17
                    _2649 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    mem[_2649 + 32 len 64] = call.data[calldata.size len 64]
                    if 0 >= mem[_2649]:
                        revert with 0, 50
                    mem[_2649 + 32] = this.address
                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                            gas gas_remaining wei
                    mem[_2649 + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _2649 + ceil32(return_data.size) + 96
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if 1 >= mem[_2649]:
                        revert with 0, 50
                    mem[_2649 + 64] = ext_call.return_data[12 len 20]
                    if not this.address:
                        revert with 0, 'ERC20: approve from the zero address'
                    if not uniswapV2RouterAddress:
                        revert with 0, 'ERC20: approve to the zero address'
                    mem[0] = uniswapV2RouterAddress
                    mem[32] = sha3(address(this.address), 25)
                    allowance[address(this.address)][stor54] = (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                    emit Approval(((10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)), this.address, uniswapV2RouterAddress);
                    mem[_2649 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                    mem[_2649 + ceil32(return_data.size) + 100] = (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                    mem[_2649 + ceil32(return_data.size) + 132] = 0
                    mem[_2649 + ceil32(return_data.size) + 164] = 160
                    mem[_2649 + ceil32(return_data.size) + 260] = mem[_2649]
                    idx = 0
                    s = _2649 + ceil32(return_data.size) + 292
                    t = _2649 + 32
                    while idx < mem[_2649]:
                        mem[s] = mem[t + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_2649 + ceil32(return_data.size) + 196] = this.address
                    mem[_2649 + ceil32(return_data.size) + 228] = block.timestamp
                    require ext_code.size(uniswapV2RouterAddress)
                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _2649 + ceil32(return_data.size) + (32 * mem[_2649]) + -mem[64] + 288]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _4686 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4686] = 30
                    mem[_4686 + 32] = 'SafeMath: subtraction overflow'
                    if eth.balance(this.address) <= eth.balance(this.address):
                        if eth.balance(this.address) < eth.balance(this.address):
                            revert with 0, 17
                        _liquidityTokensToSwap = 0
                        sub_432654c4 = 0
                        uint8(stor55.field_160) = 0
                        emit OwnerForcedSwapBack(block.timestamp);
                    _4718 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _4718 + 68] = mem[idx + _4686 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4718 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _4718 + -mem[64] + 100
                if idx >= stor30.length:
                    revert with 0, 50
                mem[0] = stor30[idx]
                mem[32] = 24
                if stor24[stor30[idx]] <= s:
                    if idx >= stor30.length:
                        revert with 0, 50
                    mem[0] = stor30[idx]
                    mem[32] = 23
                    _2317 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2317] = 30
                    mem[_2317 + 32] = 'SafeMath: subtraction overflow'
                    if stor23[stor30[idx]] > t:
                        _2324 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _2324 + 68] = mem[idx + _2317 + 32]
                            idx = idx + 32
                            continue 
                        mem[_2324 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2324 + -mem[64] + 100
                    if t < stor23[stor30[idx]]:
                        revert with 0, 17
                    if idx >= stor30.length:
                        revert with 0, 50
                    mem[0] = stor30[idx]
                    mem[32] = 24
                    _2359 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2359] = 30
                    mem[_2359 + 32] = 'SafeMath: subtraction overflow'
                    if stor24[stor30[idx]] <= s:
                        if s < stor24[stor30[idx]]:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s - stor24[stor30[idx]]
                        t = t - stor23[stor30[idx]]
                        continue 
                    _2373 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _2373 + 68] = mem[idx + _2359 + 32]
                        idx = idx + 32
                        continue 
                    mem[_2373 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _2373 + -mem[64] + 100
                _2318 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2318] = 26
                mem[_2318 + 32] = 'SafeMath: division by zero'
                _2360 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2360] = 26
                mem[_2360 + 32] = 'SafeMath: division by zero'
                if not stor31 / 10^15:
                    _2374 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _2374 + 68] = mem[idx + _2360 + 32]
                        idx = idx + 32
                        continue 
                    mem[_2374 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2374 + -mem[64] + 100
                if _liquidityTokensToSwap > !sub_432654c4:
                    revert with 0, 17
                if minimumTokensBeforeSwapAmount > 0x1999999999999999999999999999999999999999999999999999999999999999:
                    revert with 0, 17
                if stor23[address(this.address)] / stor31 / 10^15 < 10 * minimumTokensBeforeSwapAmount:
                    if stor23[address(this.address)] / stor31 / 10^15:
                        if _liquidityTokensToSwap + sub_432654c4:
                            if stor23[address(this.address)] / stor31 / 10^15 and _liquidityTokensToSwap > -1 / stor23[address(this.address)] / stor31 / 10^15:
                                revert with 0, 17
                            if not _liquidityTokensToSwap + sub_432654c4:
                                revert with 0, 18
                            _2523 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2523] = 30
                            mem[_2523 + 32] = 'SafeMath: subtraction overflow'
                            if stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2 > stor23[address(this.address)] / stor31 / 10^15:
                                _2538 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2538 + 68] = mem[idx + _2523 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2538 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2538 + -mem[64] + 100
                            if stor23[address(this.address)] / stor31 / 10^15 < stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2:
                                revert with 0, 17
                            _2621 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_2621 + 32 len 64] = call.data[calldata.size len 64]
                            if 0 >= mem[_2621]:
                                revert with 0, 50
                            mem[_2621 + 32] = this.address
                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                    gas gas_remaining wei
                            mem[_2621 + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _2621 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            if 1 >= mem[_2621]:
                                revert with 0, 50
                            mem[_2621 + 64] = ext_call.return_data[12 len 20]
                            if not this.address:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not uniswapV2RouterAddress:
                                revert with 0, 'ERC20: approve to the zero address'
                            mem[0] = uniswapV2RouterAddress
                            mem[32] = sha3(address(this.address), 25)
                            allowance[address(this.address)][stor54] = (stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                            emit Approval(((stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)), this.address, uniswapV2RouterAddress);
                            mem[_2621 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                            mem[_2621 + ceil32(return_data.size) + 100] = (stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                            mem[_2621 + ceil32(return_data.size) + 132] = 0
                            mem[_2621 + ceil32(return_data.size) + 164] = 160
                            mem[_2621 + ceil32(return_data.size) + 260] = mem[_2621]
                            idx = 0
                            s = _2621 + ceil32(return_data.size) + 292
                            t = _2621 + 32
                            while idx < mem[_2621]:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_2621 + ceil32(return_data.size) + 228] = block.timestamp
                            require ext_code.size(uniswapV2RouterAddress)
                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args (stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2), 0, 160, address(this.address), block.timestamp, mem[_2621 + ceil32(return_data.size) + 260 len (32 * mem[_2621]) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_2621 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                            if eth.balance(this.address) > eth.balance(this.address):
                                mem[_2621 + ceil32(return_data.size) + 160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_2621 + ceil32(return_data.size) + 164] = 32
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2621 + ceil32(return_data.size) + 228] = mem[idx + _2621 + ceil32(return_data.size) + 128]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 30, mem[_2621 + ceil32(return_data.size) + 228 len 30], 0
                            if eth.balance(this.address) < eth.balance(this.address):
                                revert with 0, 17
                            _liquidityTokensToSwap = 0
                            sub_432654c4 = 0
                    uint8(stor55.field_160) = 0
                    emit OwnerForcedSwapBack(block.timestamp);
                if minimumTokensBeforeSwapAmount > 0x1999999999999999999999999999999999999999999999999999999999999999:
                    revert with 0, 17
                if not 10 * minimumTokensBeforeSwapAmount:
                    uint8(stor55.field_160) = 0
                    emit OwnerForcedSwapBack(block.timestamp);
                if not _liquidityTokensToSwap + sub_432654c4:
                    uint8(stor55.field_160) = 0
                    emit OwnerForcedSwapBack(block.timestamp);
                if 10 * minimumTokensBeforeSwapAmount and _liquidityTokensToSwap > -1 / 10 * minimumTokensBeforeSwapAmount:
                    revert with 0, 17
                if not _liquidityTokensToSwap + sub_432654c4:
                    revert with 0, 18
                _2566 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2566] = 30
                mem[_2566 + 32] = 'SafeMath: subtraction overflow'
                if 10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2 > 10 * minimumTokensBeforeSwapAmount:
                    _2587 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _2587 + 68] = mem[idx + _2566 + 32]
                        idx = idx + 32
                        continue 
                    mem[_2587 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _2587 + -mem[64] + 100
                if 10 * minimumTokensBeforeSwapAmount < 10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2:
                    revert with 0, 17
                _2694 = mem[64]
                mem[mem[64]] = 2
                mem[64] = mem[64] + 96
                mem[_2694 + 32 len 64] = call.data[calldata.size len 64]
                if 0 >= mem[_2694]:
                    revert with 0, 50
                mem[_2694 + 32] = this.address
                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                        gas gas_remaining wei
                mem[_2694 + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = _2694 + ceil32(return_data.size) + 96
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                if 1 >= mem[_2694]:
                    revert with 0, 50
                mem[_2694 + 64] = ext_call.return_data[12 len 20]
                if not this.address:
                    revert with 0, 'ERC20: approve from the zero address'
                if not uniswapV2RouterAddress:
                    revert with 0, 'ERC20: approve to the zero address'
                mem[0] = uniswapV2RouterAddress
                mem[32] = sha3(address(this.address), 25)
                allowance[address(this.address)][stor54] = (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                emit Approval(((10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)), this.address, uniswapV2RouterAddress);
                mem[_2694 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                mem[_2694 + ceil32(return_data.size) + 100] = (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                mem[_2694 + ceil32(return_data.size) + 132] = 0
                mem[_2694 + ceil32(return_data.size) + 164] = 160
                mem[_2694 + ceil32(return_data.size) + 260] = mem[_2694]
                idx = 0
                s = _2694 + ceil32(return_data.size) + 292
                t = _2694 + 32
                while idx < mem[_2694]:
                    mem[s] = mem[t + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_2694 + ceil32(return_data.size) + 196] = this.address
                mem[_2694 + ceil32(return_data.size) + 228] = block.timestamp
                require ext_code.size(uniswapV2RouterAddress)
                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len _2694 + ceil32(return_data.size) + (32 * mem[_2694]) + -mem[64] + 288]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _4688 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4688] = 30
                mem[_4688 + 32] = 'SafeMath: subtraction overflow'
                if eth.balance(this.address) <= eth.balance(this.address):
                    if eth.balance(this.address) < eth.balance(this.address):
                        revert with 0, 17
                    _liquidityTokensToSwap = 0
                    sub_432654c4 = 0
                    uint8(stor55.field_160) = 0
                    emit OwnerForcedSwapBack(block.timestamp);
                _4720 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _4720 + 68] = mem[idx + _4688 + 32]
                    idx = idx + 32
                    continue 
                mem[_4720 + 98] = 0
                revert with memory
                  from mem[64]
                   len _4720 + -mem[64] + 100
            _2294 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2294] = 26
            mem[_2294 + 32] = 'SafeMath: division by zero'
            if t >= stor31 / 10^15:
                _2331 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2331] = 26
                mem[_2331 + 32] = 'SafeMath: division by zero'
                if not s:
                    revert with 0, 'SafeMath: division by zero', 0
                _2387 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2387] = 26
                mem[_2387 + 32] = 'SafeMath: division by zero'
                if not t / s:
                    revert with 0, 'SafeMath: division by zero', 0
                if _liquidityTokensToSwap > !sub_432654c4:
                    revert with 0, 17
                if minimumTokensBeforeSwapAmount > 0x1999999999999999999999999999999999999999999999999999999999999999:
                    revert with 0, 17
                if stor23[address(this.address)] / t / s >= 10 * minimumTokensBeforeSwapAmount:
                    if minimumTokensBeforeSwapAmount > 0x1999999999999999999999999999999999999999999999999999999999999999:
                        revert with 0, 17
                    if 10 * minimumTokensBeforeSwapAmount:
                        if _liquidityTokensToSwap + sub_432654c4:
                            if 10 * minimumTokensBeforeSwapAmount and _liquidityTokensToSwap > -1 / 10 * minimumTokensBeforeSwapAmount:
                                revert with 0, 17
                            if not _liquidityTokensToSwap + sub_432654c4:
                                revert with 0, 18
                            _2618 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2618] = 30
                            mem[_2618 + 32] = 'SafeMath: subtraction overflow'
                            if 10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2 > 10 * minimumTokensBeforeSwapAmount:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 10 * minimumTokensBeforeSwapAmount < 10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2:
                                revert with 0, 17
                            _2776 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_2776 + 32 len 64] = call.data[calldata.size len 64]
                            if 0 >= mem[_2776]:
                                revert with 0, 50
                            mem[_2776 + 32] = this.address
                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                    gas gas_remaining wei
                            mem[_2776 + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _2776 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            if 1 >= mem[_2776]:
                                revert with 0, 50
                            mem[_2776 + 64] = ext_call.return_data[12 len 20]
                            if not this.address:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not uniswapV2RouterAddress:
                                revert with 0, 'ERC20: approve to the zero address'
                            mem[0] = uniswapV2RouterAddress
                            mem[32] = sha3(address(this.address), 25)
                            allowance[address(this.address)][stor54] = (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                            emit Approval(((10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)), this.address, uniswapV2RouterAddress);
                            mem[_2776 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                            mem[_2776 + ceil32(return_data.size) + 100] = (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                            mem[_2776 + ceil32(return_data.size) + 132] = 0
                            mem[_2776 + ceil32(return_data.size) + 164] = 160
                            mem[_2776 + ceil32(return_data.size) + 260] = mem[_2776]
                            idx = 0
                            s = _2776 + ceil32(return_data.size) + 292
                            t = _2776 + 32
                            while idx < mem[_2776]:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(uniswapV2RouterAddress)
                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2), 0, 160, address(this.address), block.timestamp, mem[_2776 + ceil32(return_data.size) + 260 len (32 * mem[_2776]) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if eth.balance(this.address) > eth.balance(this.address):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if eth.balance(this.address) < eth.balance(this.address):
                                revert with 0, 17
                            _liquidityTokensToSwap = 0
                            sub_432654c4 = 0
                else:
                    if stor23[address(this.address)] / t / s:
                        if _liquidityTokensToSwap + sub_432654c4:
                            if stor23[address(this.address)] / t / s and _liquidityTokensToSwap > -1 / stor23[address(this.address)] / t / s:
                                revert with 0, 17
                            if not _liquidityTokensToSwap + sub_432654c4:
                                revert with 0, 18
                            _2563 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2563] = 30
                            mem[_2563 + 32] = 'SafeMath: subtraction overflow'
                            if stor23[address(this.address)] / t / s * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2 > stor23[address(this.address)] / t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor23[address(this.address)] / t / s < stor23[address(this.address)] / t / s * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2:
                                revert with 0, 17
                            _2686 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_2686 + 32 len 64] = call.data[calldata.size len 64]
                            if 0 >= mem[_2686]:
                                revert with 0, 50
                            mem[_2686 + 32] = this.address
                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                    gas gas_remaining wei
                            mem[_2686 + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _2686 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            if 1 >= mem[_2686]:
                                revert with 0, 50
                            mem[_2686 + 64] = ext_call.return_data[12 len 20]
                            if not this.address:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not uniswapV2RouterAddress:
                                revert with 0, 'ERC20: approve to the zero address'
                            mem[0] = uniswapV2RouterAddress
                            mem[32] = sha3(address(this.address), 25)
                            allowance[address(this.address)][stor54] = (stor23[address(this.address)] / t / s) - (stor23[address(this.address)] / t / s * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                            emit Approval(((stor23[address(this.address)] / t / s) - (stor23[address(this.address)] / t / s * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)), this.address, uniswapV2RouterAddress);
                            mem[_2686 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                            mem[_2686 + ceil32(return_data.size) + 100] = (stor23[address(this.address)] / t / s) - (stor23[address(this.address)] / t / s * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                            mem[_2686 + ceil32(return_data.size) + 132] = 0
                            mem[_2686 + ceil32(return_data.size) + 164] = 160
                            mem[_2686 + ceil32(return_data.size) + 260] = mem[_2686]
                            idx = 0
                            u = _2686 + ceil32(return_data.size) + 292
                            v = _2686 + 32
                            while idx < mem[_2686]:
                                mem[u] = mem[v + 12 len 20]
                                idx = idx + 1
                                u = u + 32
                                v = v + 32
                                continue 
                            mem[_2686 + ceil32(return_data.size) + 196] = this.address
                            mem[_2686 + ceil32(return_data.size) + 228] = block.timestamp
                            require ext_code.size(uniswapV2RouterAddress)
                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _2686 + ceil32(return_data.size) + (32 * mem[_2686]) + -mem[64] + 288]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if eth.balance(this.address) > eth.balance(this.address):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if eth.balance(this.address) < eth.balance(this.address):
                                revert with 0, 17
                            _liquidityTokensToSwap = 0
                            sub_432654c4 = 0
            else:
                _2332 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2332] = 26
                mem[_2332 + 32] = 'SafeMath: division by zero'
                _2388 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2388] = 26
                mem[_2388 + 32] = 'SafeMath: division by zero'
                if not stor31 / 10^15:
                    revert with 0, 'SafeMath: division by zero', 0
                if _liquidityTokensToSwap > !sub_432654c4:
                    revert with 0, 17
                if minimumTokensBeforeSwapAmount > 0x1999999999999999999999999999999999999999999999999999999999999999:
                    revert with 0, 17
                if stor23[address(this.address)] / stor31 / 10^15 < 10 * minimumTokensBeforeSwapAmount:
                    if stor23[address(this.address)] / stor31 / 10^15:
                        if _liquidityTokensToSwap + sub_432654c4:
                            if stor23[address(this.address)] / stor31 / 10^15 and _liquidityTokensToSwap > -1 / stor23[address(this.address)] / stor31 / 10^15:
                                revert with 0, 17
                            if not _liquidityTokensToSwap + sub_432654c4:
                                revert with 0, 18
                            _2564 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2564] = 30
                            mem[_2564 + 32] = 'SafeMath: subtraction overflow'
                            if stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2 > stor23[address(this.address)] / stor31 / 10^15:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor23[address(this.address)] / stor31 / 10^15 < stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2:
                                revert with 0, 17
                            _2689 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_2689 + 32 len 64] = call.data[calldata.size len 64]
                            if 0 >= mem[_2689]:
                                revert with 0, 50
                            mem[_2689 + 32] = this.address
                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                    gas gas_remaining wei
                            mem[_2689 + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _2689 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            if 1 >= mem[_2689]:
                                revert with 0, 50
                            mem[_2689 + 64] = ext_call.return_data[12 len 20]
                            if not this.address:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not uniswapV2RouterAddress:
                                revert with 0, 'ERC20: approve to the zero address'
                            mem[0] = uniswapV2RouterAddress
                            mem[32] = sha3(address(this.address), 25)
                            allowance[address(this.address)][stor54] = (stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                            emit Approval(((stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)), this.address, uniswapV2RouterAddress);
                            mem[_2689 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                            mem[_2689 + ceil32(return_data.size) + 100] = (stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                            mem[_2689 + ceil32(return_data.size) + 132] = 0
                            mem[_2689 + ceil32(return_data.size) + 164] = 160
                            mem[_2689 + ceil32(return_data.size) + 260] = mem[_2689]
                            idx = 0
                            s = _2689 + ceil32(return_data.size) + 292
                            t = _2689 + 32
                            while idx < mem[_2689]:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(uniswapV2RouterAddress)
                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args (stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2), 0, 160, address(this.address), block.timestamp, mem[_2689 + ceil32(return_data.size) + 260 len (32 * mem[_2689]) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if eth.balance(this.address) > eth.balance(this.address):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if eth.balance(this.address) < eth.balance(this.address):
                                revert with 0, 17
                            _liquidityTokensToSwap = 0
                            sub_432654c4 = 0
                else:
                    if minimumTokensBeforeSwapAmount > 0x1999999999999999999999999999999999999999999999999999999999999999:
                        revert with 0, 17
                    if 10 * minimumTokensBeforeSwapAmount:
                        if _liquidityTokensToSwap + sub_432654c4:
                            if 10 * minimumTokensBeforeSwapAmount and _liquidityTokensToSwap > -1 / 10 * minimumTokensBeforeSwapAmount:
                                revert with 0, 17
                            if not _liquidityTokensToSwap + sub_432654c4:
                                revert with 0, 18
                            _2619 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2619] = 30
                            mem[_2619 + 32] = 'SafeMath: subtraction overflow'
                            if 10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2 > 10 * minimumTokensBeforeSwapAmount:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 10 * minimumTokensBeforeSwapAmount < 10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2:
                                revert with 0, 17
                            _2780 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_2780 + 32 len 64] = call.data[calldata.size len 64]
                            if 0 >= mem[_2780]:
                                revert with 0, 50
                            mem[_2780 + 32] = this.address
                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                    gas gas_remaining wei
                            mem[_2780 + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _2780 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            if 1 >= mem[_2780]:
                                revert with 0, 50
                            mem[_2780 + 64] = ext_call.return_data[12 len 20]
                            if not this.address:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not uniswapV2RouterAddress:
                                revert with 0, 'ERC20: approve to the zero address'
                            mem[0] = uniswapV2RouterAddress
                            mem[32] = sha3(address(this.address), 25)
                            allowance[address(this.address)][stor54] = (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                            emit Approval(((10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)), this.address, uniswapV2RouterAddress);
                            mem[_2780 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                            mem[_2780 + ceil32(return_data.size) + 100] = (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                            mem[_2780 + ceil32(return_data.size) + 132] = 0
                            mem[_2780 + ceil32(return_data.size) + 164] = 160
                            mem[_2780 + ceil32(return_data.size) + 260] = mem[_2780]
                            idx = 0
                            s = _2780 + ceil32(return_data.size) + 292
                            t = _2780 + 32
                            while idx < mem[_2780]:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_2780 + ceil32(return_data.size) + 196] = this.address
                            mem[_2780 + ceil32(return_data.size) + 228] = block.timestamp
                            require ext_code.size(uniswapV2RouterAddress)
                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _2780 + ceil32(return_data.size) + (32 * mem[_2780]) + -mem[64] + 288]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if eth.balance(this.address) > eth.balance(this.address):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if eth.balance(this.address) < eth.balance(this.address):
                                revert with 0, 17
                            _liquidityTokensToSwap = 0
                            sub_432654c4 = 0
    else:
        mem[0] = this.address
        mem[32] = 23
        if stor23[address(this.address)] > stor31:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
        idx = 0
        s = 10^15
        t = stor31
        while idx < stor30.length:
            mem[0] = stor30[idx]
            mem[32] = 23
            if stor23[stor30[idx]] > t:
                _2307 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2307] = 26
                mem[_2307 + 32] = 'SafeMath: division by zero'
                _2342 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2342] = 26
                mem[_2342 + 32] = 'SafeMath: division by zero'
                if not stor31 / 10^15:
                    _2354 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _2354 + 68] = mem[idx + _2342 + 32]
                        idx = idx + 32
                        continue 
                    mem[_2354 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2354 + -mem[64] + 100
                if stor23[address(this.address)] / stor31 / 10^15 < 10^11:
                    revert with 0, 'Can only swap back if more than .01% of tokens stuck on contract'
                uint8(stor55.field_160) = 1
                mem[0] = this.address
                if stor29[address(this.address)]:
                    mem[32] = 24
                    if _liquidityTokensToSwap > !sub_432654c4:
                        revert with 0, 17
                    if minimumTokensBeforeSwapAmount > 0x1999999999999999999999999999999999999999999999999999999999999999:
                        revert with 0, 17
                    if stor24[address(this.address)] < 10 * minimumTokensBeforeSwapAmount:
                        if stor24[address(this.address)]:
                            if _liquidityTokensToSwap + sub_432654c4:
                                if stor24[address(this.address)] and _liquidityTokensToSwap > -1 / stor24[address(this.address)]:
                                    revert with 0, 17
                                if not _liquidityTokensToSwap + sub_432654c4:
                                    revert with 0, 18
                                _2581 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2581] = 30
                                mem[_2581 + 32] = 'SafeMath: subtraction overflow'
                                if stor24[address(this.address)] * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2 > stor24[address(this.address)]:
                                    _2613 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2613 + 68] = mem[idx + _2581 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2613 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2613 + -mem[64] + 100
                                if stor24[address(this.address)] < stor24[address(this.address)] * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2:
                                    revert with 0, 17
                                _2727 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_2727 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_2727]:
                                    revert with 0, 50
                                mem[_2727 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_2727 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _2727 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_2727]:
                                    revert with 0, 50
                                mem[_2727 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = stor24[address(this.address)] - (stor24[address(this.address)] * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                                emit Approval((stor24[address(this.address)] - (stor24[address(this.address)] * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)), this.address, uniswapV2RouterAddress);
                                mem[_2727 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_2727 + ceil32(return_data.size) + 100] = stor24[address(this.address)] - (stor24[address(this.address)] * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                                mem[_2727 + ceil32(return_data.size) + 132] = 0
                                mem[_2727 + ceil32(return_data.size) + 164] = 160
                                mem[_2727 + ceil32(return_data.size) + 260] = mem[_2727]
                                idx = 0
                                s = _2727 + ceil32(return_data.size) + 292
                                t = _2727 + 32
                                while idx < mem[_2727]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_2727 + ceil32(return_data.size) + 228] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args stor24[address(this.address)] - (stor24[address(this.address)] * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2), 0, 160, address(this.address), block.timestamp, mem[_2727 + ceil32(return_data.size) + 260 len (32 * mem[_2727]) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_2727 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                if eth.balance(this.address) > eth.balance(this.address):
                                    mem[_2727 + ceil32(return_data.size) + 160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_2727 + ceil32(return_data.size) + 164] = 32
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2727 + ceil32(return_data.size) + 228] = mem[idx + _2727 + ceil32(return_data.size) + 128]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 32, 30, mem[_2727 + ceil32(return_data.size) + 228 len 30], 0
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                _liquidityTokensToSwap = 0
                                sub_432654c4 = 0
                        uint8(stor55.field_160) = 0
                        emit OwnerForcedSwapBack(block.timestamp);
                    if minimumTokensBeforeSwapAmount > 0x1999999999999999999999999999999999999999999999999999999999999999:
                        revert with 0, 17
                    if not 10 * minimumTokensBeforeSwapAmount:
                        uint8(stor55.field_160) = 0
                        emit OwnerForcedSwapBack(block.timestamp);
                    if not _liquidityTokensToSwap + sub_432654c4:
                        uint8(stor55.field_160) = 0
                        emit OwnerForcedSwapBack(block.timestamp);
                    if 10 * minimumTokensBeforeSwapAmount and _liquidityTokensToSwap > -1 / 10 * minimumTokensBeforeSwapAmount:
                        revert with 0, 17
                    if not _liquidityTokensToSwap + sub_432654c4:
                        revert with 0, 18
                    _2643 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2643] = 30
                    mem[_2643 + 32] = 'SafeMath: subtraction overflow'
                    if 10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2 > 10 * minimumTokensBeforeSwapAmount:
                        _2681 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _2681 + 68] = mem[idx + _2643 + 32]
                            idx = idx + 32
                            continue 
                        mem[_2681 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _2681 + -mem[64] + 100
                    if 10 * minimumTokensBeforeSwapAmount < 10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2:
                        revert with 0, 17
                    _2813 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    mem[_2813 + 32 len 64] = call.data[calldata.size len 64]
                    if 0 >= mem[_2813]:
                        revert with 0, 50
                    mem[_2813 + 32] = this.address
                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                            gas gas_remaining wei
                    mem[_2813 + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _2813 + ceil32(return_data.size) + 96
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if 1 >= mem[_2813]:
                        revert with 0, 50
                    mem[_2813 + 64] = ext_call.return_data[12 len 20]
                    if not this.address:
                        revert with 0, 'ERC20: approve from the zero address'
                    if not uniswapV2RouterAddress:
                        revert with 0, 'ERC20: approve to the zero address'
                    mem[0] = uniswapV2RouterAddress
                    mem[32] = sha3(address(this.address), 25)
                    allowance[address(this.address)][stor54] = (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                    emit Approval(((10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)), this.address, uniswapV2RouterAddress);
                    mem[_2813 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                    mem[_2813 + ceil32(return_data.size) + 100] = (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                    mem[_2813 + ceil32(return_data.size) + 132] = 0
                    mem[_2813 + ceil32(return_data.size) + 164] = 160
                    mem[_2813 + ceil32(return_data.size) + 260] = mem[_2813]
                    idx = 0
                    s = _2813 + ceil32(return_data.size) + 292
                    t = _2813 + 32
                    while idx < mem[_2813]:
                        mem[s] = mem[t + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_2813 + ceil32(return_data.size) + 196] = this.address
                    mem[_2813 + ceil32(return_data.size) + 228] = block.timestamp
                    require ext_code.size(uniswapV2RouterAddress)
                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _2813 + ceil32(return_data.size) + (32 * mem[_2813]) + -mem[64] + 288]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _4677 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4677] = 30
                    mem[_4677 + 32] = 'SafeMath: subtraction overflow'
                    if eth.balance(this.address) <= eth.balance(this.address):
                        if eth.balance(this.address) < eth.balance(this.address):
                            revert with 0, 17
                        _liquidityTokensToSwap = 0
                        sub_432654c4 = 0
                        uint8(stor55.field_160) = 0
                        emit OwnerForcedSwapBack(block.timestamp);
                    _4708 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _4708 + 68] = mem[idx + _4677 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4708 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _4708 + -mem[64] + 100
                mem[32] = 23
                if stor23[address(this.address)] > stor31:
                    revert with 0, 'Amount must be less than total reflections'
                idx = 0
                s = 10^15
                t = stor31
                while idx < stor30.length:
                    mem[0] = stor30[idx]
                    mem[32] = 23
                    if stor23[stor30[idx]] > t:
                        _4675 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4675] = 26
                        mem[_4675 + 32] = 'SafeMath: division by zero'
                        _4816 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4816] = 26
                        mem[_4816 + 32] = 'SafeMath: division by zero'
                        if not stor31 / 10^15:
                            _4846 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4846 + 68] = mem[idx + _4816 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4846 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _4846 + -mem[64] + 100
                        if _liquidityTokensToSwap > !sub_432654c4:
                            revert with 0, 17
                        if minimumTokensBeforeSwapAmount > 0x1999999999999999999999999999999999999999999999999999999999999999:
                            revert with 0, 17
                        if stor23[address(this.address)] / stor31 / 10^15 < 10 * minimumTokensBeforeSwapAmount:
                            if not stor23[address(this.address)] / stor31 / 10^15:
                                uint8(stor55.field_160) = 0
                                emit OwnerForcedSwapBack(block.timestamp);
                            if not _liquidityTokensToSwap + sub_432654c4:
                                uint8(stor55.field_160) = 0
                                emit OwnerForcedSwapBack(block.timestamp);
                            if stor23[address(this.address)] / stor31 / 10^15 and _liquidityTokensToSwap > -1 / stor23[address(this.address)] / stor31 / 10^15:
                                revert with 0, 17
                            if not _liquidityTokensToSwap + sub_432654c4:
                                revert with 0, 18
                            _5123 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5123] = 30
                            mem[_5123 + 32] = 'SafeMath: subtraction overflow'
                            if stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2 > stor23[address(this.address)] / stor31 / 10^15:
                                _5149 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _5149 + 68] = mem[idx + _5123 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5149 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5149 + -mem[64] + 100
                            if stor23[address(this.address)] / stor31 / 10^15 < stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2:
                                revert with 0, 17
                            _5227 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_5227 + 32 len 64] = call.data[calldata.size len 64]
                            if 0 >= mem[_5227]:
                                revert with 0, 50
                            mem[_5227 + 32] = this.address
                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                    gas gas_remaining wei
                            mem[_5227 + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _5227 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            if 1 >= mem[_5227]:
                                revert with 0, 50
                            mem[_5227 + 64] = ext_call.return_data[12 len 20]
                            if not this.address:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not uniswapV2RouterAddress:
                                revert with 0, 'ERC20: approve to the zero address'
                            mem[0] = uniswapV2RouterAddress
                            mem[32] = sha3(address(this.address), 25)
                            allowance[address(this.address)][stor54] = (stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                            emit Approval(((stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)), this.address, uniswapV2RouterAddress);
                            mem[_5227 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                            mem[_5227 + ceil32(return_data.size) + 100] = (stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                            mem[_5227 + ceil32(return_data.size) + 132] = 0
                            mem[_5227 + ceil32(return_data.size) + 164] = 160
                            mem[_5227 + ceil32(return_data.size) + 260] = mem[_5227]
                            idx = 0
                            s = _5227 + ceil32(return_data.size) + 292
                            t = _5227 + 32
                            while idx < mem[_5227]:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_5227 + ceil32(return_data.size) + 196] = this.address
                            mem[_5227 + ceil32(return_data.size) + 228] = block.timestamp
                            require ext_code.size(uniswapV2RouterAddress)
                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _5227 + ceil32(return_data.size) + (32 * mem[_5227]) + -mem[64] + 288]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _6585 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6585] = 30
                            mem[_6585 + 32] = 'SafeMath: subtraction overflow'
                            if eth.balance(this.address) <= eth.balance(this.address):
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                _liquidityTokensToSwap = 0
                                sub_432654c4 = 0
                                uint8(stor55.field_160) = 0
                                emit OwnerForcedSwapBack(block.timestamp);
                            _6617 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _6617 + 68] = mem[idx + _6585 + 32]
                                idx = idx + 32
                                continue 
                            mem[_6617 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _6617 + -mem[64] + 100
                        if minimumTokensBeforeSwapAmount > 0x1999999999999999999999999999999999999999999999999999999999999999:
                            revert with 0, 17
                        if not 10 * minimumTokensBeforeSwapAmount:
                            uint8(stor55.field_160) = 0
                            emit OwnerForcedSwapBack(block.timestamp);
                        if not _liquidityTokensToSwap + sub_432654c4:
                            uint8(stor55.field_160) = 0
                            emit OwnerForcedSwapBack(block.timestamp);
                        if 10 * minimumTokensBeforeSwapAmount and _liquidityTokensToSwap > -1 / 10 * minimumTokensBeforeSwapAmount:
                            revert with 0, 17
                        if not _liquidityTokensToSwap + sub_432654c4:
                            revert with 0, 18
                        _5173 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5173] = 30
                        mem[_5173 + 32] = 'SafeMath: subtraction overflow'
                        if 10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2 > 10 * minimumTokensBeforeSwapAmount:
                            _5195 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _5195 + 68] = mem[idx + _5173 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5195 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5195 + -mem[64] + 100
                        if 10 * minimumTokensBeforeSwapAmount < 10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2:
                            revert with 0, 17
                        _5330 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        mem[_5330 + 32 len 64] = call.data[calldata.size len 64]
                        if 0 >= mem[_5330]:
                            revert with 0, 50
                        mem[_5330 + 32] = this.address
                        staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                gas gas_remaining wei
                        mem[_5330 + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _5330 + ceil32(return_data.size) + 96
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        if 1 >= mem[_5330]:
                            revert with 0, 50
                        mem[_5330 + 64] = ext_call.return_data[12 len 20]
                        if not this.address:
                            revert with 0, 'ERC20: approve from the zero address'
                        if not uniswapV2RouterAddress:
                            revert with 0, 'ERC20: approve to the zero address'
                        mem[0] = uniswapV2RouterAddress
                        mem[32] = sha3(address(this.address), 25)
                        allowance[address(this.address)][stor54] = (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                        emit Approval(((10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)), this.address, uniswapV2RouterAddress);
                        mem[_5330 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                        mem[_5330 + ceil32(return_data.size) + 100] = (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                        mem[_5330 + ceil32(return_data.size) + 132] = 0
                        mem[_5330 + ceil32(return_data.size) + 164] = 160
                        mem[_5330 + ceil32(return_data.size) + 260] = mem[_5330]
                        idx = 0
                        s = _5330 + ceil32(return_data.size) + 292
                        t = _5330 + 32
                        while idx < mem[_5330]:
                            mem[s] = mem[t + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_5330 + ceil32(return_data.size) + 196] = this.address
                        mem[_5330 + ceil32(return_data.size) + 228] = block.timestamp
                        require ext_code.size(uniswapV2RouterAddress)
                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _5330 + ceil32(return_data.size) + (32 * mem[_5330]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6586 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6586] = 30
                        mem[_6586 + 32] = 'SafeMath: subtraction overflow'
                        if eth.balance(this.address) <= eth.balance(this.address):
                            if eth.balance(this.address) < eth.balance(this.address):
                                revert with 0, 17
                            _liquidityTokensToSwap = 0
                            sub_432654c4 = 0
                            uint8(stor55.field_160) = 0
                            emit OwnerForcedSwapBack(block.timestamp);
                        _6618 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _6618 + 68] = mem[idx + _6586 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6618 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _6618 + -mem[64] + 100
                    if idx >= stor30.length:
                        revert with 0, 50
                    mem[0] = stor30[idx]
                    mem[32] = 24
                    if stor24[stor30[idx]] <= s:
                        if idx >= stor30.length:
                            revert with 0, 50
                        mem[0] = stor30[idx]
                        mem[32] = 23
                        _4705 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4705] = 30
                        mem[_4705 + 32] = 'SafeMath: subtraction overflow'
                        if stor23[stor30[idx]] > t:
                            _4739 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _4739 + 68] = mem[idx + _4705 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4739 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4739 + -mem[64] + 100
                        if t < stor23[stor30[idx]]:
                            revert with 0, 17
                        if idx >= stor30.length:
                            revert with 0, 50
                        mem[0] = stor30[idx]
                        mem[32] = 24
                        _4847 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4847] = 30
                        mem[_4847 + 32] = 'SafeMath: subtraction overflow'
                        if stor24[stor30[idx]] <= s:
                            if s < stor24[stor30[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor24[stor30[idx]]
                            t = t - stor23[stor30[idx]]
                            continue 
                        _4912 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _4912 + 68] = mem[idx + _4847 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4912 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _4912 + -mem[64] + 100
                    _4706 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4706] = 26
                    mem[_4706 + 32] = 'SafeMath: division by zero'
                    _4848 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4848] = 26
                    mem[_4848 + 32] = 'SafeMath: division by zero'
                    if not stor31 / 10^15:
                        _4913 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4913 + 68] = mem[idx + _4848 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4913 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4913 + -mem[64] + 100
                    if _liquidityTokensToSwap > !sub_432654c4:
                        revert with 0, 17
                    if minimumTokensBeforeSwapAmount > 0x1999999999999999999999999999999999999999999999999999999999999999:
                        revert with 0, 17
                    if stor23[address(this.address)] / stor31 / 10^15 >= 10 * minimumTokensBeforeSwapAmount:
                        if minimumTokensBeforeSwapAmount > 0x1999999999999999999999999999999999999999999999999999999999999999:
                            revert with 0, 17
                        if 10 * minimumTokensBeforeSwapAmount:
                            if _liquidityTokensToSwap + sub_432654c4:
                                if 10 * minimumTokensBeforeSwapAmount and _liquidityTokensToSwap > -1 / 10 * minimumTokensBeforeSwapAmount:
                                    revert with 0, 17
                                if not _liquidityTokensToSwap + sub_432654c4:
                                    revert with 0, 18
                                _5196 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5196] = 30
                                mem[_5196 + 32] = 'SafeMath: subtraction overflow'
                                if 10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2 > 10 * minimumTokensBeforeSwapAmount:
                                    _5230 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _5230 + 68] = mem[idx + _5196 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5230 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5230 + -mem[64] + 100
                                if 10 * minimumTokensBeforeSwapAmount < 10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2:
                                    revert with 0, 17
                                _5399 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_5399 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_5399]:
                                    revert with 0, 50
                                mem[_5399 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_5399 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _5399 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_5399]:
                                    revert with 0, 50
                                mem[_5399 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                                emit Approval(((10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)), this.address, uniswapV2RouterAddress);
                                mem[_5399 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_5399 + ceil32(return_data.size) + 100] = (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                                mem[_5399 + ceil32(return_data.size) + 132] = 0
                                mem[_5399 + ceil32(return_data.size) + 164] = 160
                                mem[_5399 + ceil32(return_data.size) + 260] = mem[_5399]
                                idx = 0
                                s = _5399 + ceil32(return_data.size) + 292
                                t = _5399 + 32
                                while idx < mem[_5399]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_5399 + ceil32(return_data.size) + 228] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2), 0, 160, address(this.address), block.timestamp, mem[_5399 + ceil32(return_data.size) + 260 len (32 * mem[_5399]) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_5399 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                if eth.balance(this.address) > eth.balance(this.address):
                                    mem[_5399 + ceil32(return_data.size) + 160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_5399 + ceil32(return_data.size) + 164] = 32
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _5399 + ceil32(return_data.size) + 228] = mem[idx + _5399 + ceil32(return_data.size) + 128]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 32, 30, mem[_5399 + ceil32(return_data.size) + 228 len 30], 0
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                _liquidityTokensToSwap = 0
                                sub_432654c4 = 0
                        uint8(stor55.field_160) = 0
                        emit OwnerForcedSwapBack(block.timestamp);
                    if not stor23[address(this.address)] / stor31 / 10^15:
                        uint8(stor55.field_160) = 0
                        emit OwnerForcedSwapBack(block.timestamp);
                    if not _liquidityTokensToSwap + sub_432654c4:
                        uint8(stor55.field_160) = 0
                        emit OwnerForcedSwapBack(block.timestamp);
                    if stor23[address(this.address)] / stor31 / 10^15 and _liquidityTokensToSwap > -1 / stor23[address(this.address)] / stor31 / 10^15:
                        revert with 0, 17
                    if not _liquidityTokensToSwap + sub_432654c4:
                        revert with 0, 18
                    _5150 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5150] = 30
                    mem[_5150 + 32] = 'SafeMath: subtraction overflow'
                    if stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2 > stor23[address(this.address)] / stor31 / 10^15:
                        _5174 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _5174 + 68] = mem[idx + _5150 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5174 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5174 + -mem[64] + 100
                    if stor23[address(this.address)] / stor31 / 10^15 < stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2:
                        revert with 0, 17
                    _5280 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    mem[_5280 + 32 len 64] = call.data[calldata.size len 64]
                    if 0 >= mem[_5280]:
                        revert with 0, 50
                    mem[_5280 + 32] = this.address
                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                            gas gas_remaining wei
                    mem[_5280 + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _5280 + ceil32(return_data.size) + 96
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if 1 >= mem[_5280]:
                        revert with 0, 50
                    mem[_5280 + 64] = ext_call.return_data[12 len 20]
                    if not this.address:
                        revert with 0, 'ERC20: approve from the zero address'
                    if not uniswapV2RouterAddress:
                        revert with 0, 'ERC20: approve to the zero address'
                    mem[0] = uniswapV2RouterAddress
                    mem[32] = sha3(address(this.address), 25)
                    allowance[address(this.address)][stor54] = (stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                    emit Approval(((stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)), this.address, uniswapV2RouterAddress);
                    mem[_5280 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                    mem[_5280 + ceil32(return_data.size) + 100] = (stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                    mem[_5280 + ceil32(return_data.size) + 132] = 0
                    mem[_5280 + ceil32(return_data.size) + 164] = 160
                    mem[_5280 + ceil32(return_data.size) + 260] = mem[_5280]
                    idx = 0
                    s = _5280 + ceil32(return_data.size) + 292
                    t = _5280 + 32
                    while idx < mem[_5280]:
                        mem[s] = mem[t + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_5280 + ceil32(return_data.size) + 196] = this.address
                    mem[_5280 + ceil32(return_data.size) + 228] = block.timestamp
                    require ext_code.size(uniswapV2RouterAddress)
                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _5280 + ceil32(return_data.size) + (32 * mem[_5280]) + -mem[64] + 288]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _6587 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6587] = 30
                    mem[_6587 + 32] = 'SafeMath: subtraction overflow'
                    if eth.balance(this.address) <= eth.balance(this.address):
                        if eth.balance(this.address) < eth.balance(this.address):
                            revert with 0, 17
                        _liquidityTokensToSwap = 0
                        sub_432654c4 = 0
                        uint8(stor55.field_160) = 0
                        emit OwnerForcedSwapBack(block.timestamp);
                    _6619 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _6619 + 68] = mem[idx + _6587 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6619 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _6619 + -mem[64] + 100
                _4579 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4579] = 26
                mem[_4579 + 32] = 'SafeMath: division by zero'
                if t < stor31 / 10^15:
                    _4766 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4766] = 26
                    mem[_4766 + 32] = 'SafeMath: division by zero'
                    _4950 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4950] = 26
                    mem[_4950 + 32] = 'SafeMath: division by zero'
                    if not stor31 / 10^15:
                        _4972 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        s = 0
                        while s < 26:
                            mem[s + _4972 + 68] = mem[s + _4950 + 32]
                            s = s + 32
                            continue 
                        mem[_4972 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4972 + -mem[64] + 100
                    if _liquidityTokensToSwap > !sub_432654c4:
                        revert with 0, 17
                    if minimumTokensBeforeSwapAmount > 0x1999999999999999999999999999999999999999999999999999999999999999:
                        revert with 0, 17
                    if stor23[address(this.address)] / stor31 / 10^15 < 10 * minimumTokensBeforeSwapAmount:
                        if stor23[address(this.address)] / stor31 / 10^15:
                            if _liquidityTokensToSwap + sub_432654c4:
                                if stor23[address(this.address)] / stor31 / 10^15 and _liquidityTokensToSwap > -1 / stor23[address(this.address)] / stor31 / 10^15:
                                    revert with 0, 17
                                if not _liquidityTokensToSwap + sub_432654c4:
                                    revert with 0, 18
                                _5194 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5194] = 30
                                mem[_5194 + 32] = 'SafeMath: subtraction overflow'
                                if stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2 > stor23[address(this.address)] / stor31 / 10^15:
                                    _5226 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _5226 + 68] = mem[idx + _5194 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5226 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5226 + -mem[64] + 100
                                if stor23[address(this.address)] / stor31 / 10^15 < stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2:
                                    revert with 0, 17
                                _5394 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_5394 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_5394]:
                                    revert with 0, 50
                                mem[_5394 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_5394 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _5394 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_5394]:
                                    revert with 0, 50
                                mem[_5394 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = (stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                                emit Approval(((stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)), this.address, uniswapV2RouterAddress);
                                mem[_5394 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_5394 + ceil32(return_data.size) + 100] = (stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                                mem[_5394 + ceil32(return_data.size) + 132] = 0
                                mem[_5394 + ceil32(return_data.size) + 164] = 160
                                mem[_5394 + ceil32(return_data.size) + 260] = mem[_5394]
                                idx = 0
                                s = _5394 + ceil32(return_data.size) + 292
                                t = _5394 + 32
                                while idx < mem[_5394]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_5394 + ceil32(return_data.size) + 228] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args (stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2), 0, 160, address(this.address), block.timestamp, mem[_5394 + ceil32(return_data.size) + 260 len (32 * mem[_5394]) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_5394 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                if eth.balance(this.address) > eth.balance(this.address):
                                    mem[_5394 + ceil32(return_data.size) + 160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_5394 + ceil32(return_data.size) + 164] = 32
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _5394 + ceil32(return_data.size) + 228] = mem[idx + _5394 + ceil32(return_data.size) + 128]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 32, 30, mem[_5394 + ceil32(return_data.size) + 228 len 30], 0
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                _liquidityTokensToSwap = 0
                                sub_432654c4 = 0
                    else:
                        if minimumTokensBeforeSwapAmount > 0x1999999999999999999999999999999999999999999999999999999999999999:
                            revert with 0, 17
                        if 10 * minimumTokensBeforeSwapAmount:
                            if _liquidityTokensToSwap + sub_432654c4:
                                if 10 * minimumTokensBeforeSwapAmount and _liquidityTokensToSwap > -1 / 10 * minimumTokensBeforeSwapAmount:
                                    revert with 0, 17
                                if not _liquidityTokensToSwap + sub_432654c4:
                                    revert with 0, 18
                                _5278 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5278] = 30
                                mem[_5278 + 32] = 'SafeMath: subtraction overflow'
                                if 10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2 > 10 * minimumTokensBeforeSwapAmount:
                                    _5328 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _5328 + 68] = mem[idx + _5278 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5328 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5328 + -mem[64] + 100
                                if 10 * minimumTokensBeforeSwapAmount < 10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2:
                                    revert with 0, 17
                                _5498 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_5498 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_5498]:
                                    revert with 0, 50
                                mem[_5498 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_5498 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _5498 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_5498]:
                                    revert with 0, 50
                                mem[_5498 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                                emit Approval(((10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)), this.address, uniswapV2RouterAddress);
                                mem[_5498 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_5498 + ceil32(return_data.size) + 100] = (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                                mem[_5498 + ceil32(return_data.size) + 132] = 0
                                mem[_5498 + ceil32(return_data.size) + 164] = 160
                                mem[_5498 + ceil32(return_data.size) + 260] = mem[_5498]
                                idx = 0
                                s = _5498 + ceil32(return_data.size) + 292
                                t = _5498 + 32
                                while idx < mem[_5498]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_5498 + ceil32(return_data.size) + 228] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2), 0, 160, address(this.address), block.timestamp, mem[_5498 + ceil32(return_data.size) + 260 len (32 * mem[_5498]) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_5498 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                if eth.balance(this.address) > eth.balance(this.address):
                                    mem[_5498 + ceil32(return_data.size) + 160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_5498 + ceil32(return_data.size) + 164] = 32
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _5498 + ceil32(return_data.size) + 228] = mem[idx + _5498 + ceil32(return_data.size) + 128]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 32, 30, mem[_5498 + ceil32(return_data.size) + 228 len 30], 0
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                _liquidityTokensToSwap = 0
                                sub_432654c4 = 0
                    uint8(stor55.field_160) = 0
                    emit OwnerForcedSwapBack(block.timestamp);
                _4765 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4765] = 26
                mem[_4765 + 32] = 'SafeMath: division by zero'
                if not s:
                    _4795 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4795 + 68] = mem[idx + _4765 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4795 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4795 + -mem[64] + 100
                _4949 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4949] = 26
                mem[_4949 + 32] = 'SafeMath: division by zero'
                if not t / s:
                    _4971 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    s = 0
                    while s < 26:
                        mem[s + _4971 + 68] = mem[s + _4949 + 32]
                        s = s + 32
                        continue 
                    mem[_4971 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4971 + -mem[64] + 100
                if _liquidityTokensToSwap > !sub_432654c4:
                    revert with 0, 17
                if minimumTokensBeforeSwapAmount > 0x1999999999999999999999999999999999999999999999999999999999999999:
                    revert with 0, 17
                if stor23[address(this.address)] / t / s >= 10 * minimumTokensBeforeSwapAmount:
                    if minimumTokensBeforeSwapAmount > 0x1999999999999999999999999999999999999999999999999999999999999999:
                        revert with 0, 17
                    if 10 * minimumTokensBeforeSwapAmount:
                        if _liquidityTokensToSwap + sub_432654c4:
                            if 10 * minimumTokensBeforeSwapAmount and _liquidityTokensToSwap > -1 / 10 * minimumTokensBeforeSwapAmount:
                                revert with 0, 17
                            if not _liquidityTokensToSwap + sub_432654c4:
                                revert with 0, 18
                            _5277 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5277] = 30
                            mem[_5277 + 32] = 'SafeMath: subtraction overflow'
                            if 10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2 > 10 * minimumTokensBeforeSwapAmount:
                                _5327 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _5327 + 68] = mem[idx + _5277 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5327 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5327 + -mem[64] + 100
                            if 10 * minimumTokensBeforeSwapAmount < 10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2:
                                revert with 0, 17
                            _5494 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_5494 + 32 len 64] = call.data[calldata.size len 64]
                            if 0 >= mem[_5494]:
                                revert with 0, 50
                            mem[_5494 + 32] = this.address
                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                    gas gas_remaining wei
                            mem[_5494 + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _5494 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            if 1 >= mem[_5494]:
                                revert with 0, 50
                            mem[_5494 + 64] = ext_call.return_data[12 len 20]
                            if not this.address:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not uniswapV2RouterAddress:
                                revert with 0, 'ERC20: approve to the zero address'
                            mem[0] = uniswapV2RouterAddress
                            mem[32] = sha3(address(this.address), 25)
                            allowance[address(this.address)][stor54] = (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                            emit Approval(((10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)), this.address, uniswapV2RouterAddress);
                            mem[_5494 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                            mem[_5494 + ceil32(return_data.size) + 100] = (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                            mem[_5494 + ceil32(return_data.size) + 132] = 0
                            mem[_5494 + ceil32(return_data.size) + 164] = 160
                            mem[_5494 + ceil32(return_data.size) + 260] = mem[_5494]
                            idx = 0
                            s = _5494 + ceil32(return_data.size) + 292
                            t = _5494 + 32
                            while idx < mem[_5494]:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_5494 + ceil32(return_data.size) + 228] = block.timestamp
                            require ext_code.size(uniswapV2RouterAddress)
                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2), 0, 160, address(this.address), block.timestamp, mem[_5494 + ceil32(return_data.size) + 260 len (32 * mem[_5494]) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_5494 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                            if eth.balance(this.address) > eth.balance(this.address):
                                mem[_5494 + ceil32(return_data.size) + 160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_5494 + ceil32(return_data.size) + 164] = 32
                                idx = 0
                                while idx < 30:
                                    mem[idx + _5494 + ceil32(return_data.size) + 228] = mem[idx + _5494 + ceil32(return_data.size) + 128]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 30, mem[_5494 + ceil32(return_data.size) + 228 len 30], 0
                            if eth.balance(this.address) < eth.balance(this.address):
                                revert with 0, 17
                            _liquidityTokensToSwap = 0
                            sub_432654c4 = 0
                    uint8(stor55.field_160) = 0
                    emit OwnerForcedSwapBack(block.timestamp);
                if not stor23[address(this.address)] / t / s:
                    uint8(stor55.field_160) = 0
                    emit OwnerForcedSwapBack(block.timestamp);
                if not _liquidityTokensToSwap + sub_432654c4:
                    uint8(stor55.field_160) = 0
                    emit OwnerForcedSwapBack(block.timestamp);
                if stor23[address(this.address)] / t / s and _liquidityTokensToSwap > -1 / stor23[address(this.address)] / t / s:
                    revert with 0, 17
                if not _liquidityTokensToSwap + sub_432654c4:
                    revert with 0, 18
                _5193 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5193] = 30
                mem[_5193 + 32] = 'SafeMath: subtraction overflow'
                if stor23[address(this.address)] / t / s * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2 > stor23[address(this.address)] / t / s:
                    _5225 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _5225 + 68] = mem[idx + _5193 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5225 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _5225 + -mem[64] + 100
                if stor23[address(this.address)] / t / s < stor23[address(this.address)] / t / s * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2:
                    revert with 0, 17
                _5391 = mem[64]
                mem[mem[64]] = 2
                mem[64] = mem[64] + 96
                mem[_5391 + 32 len 64] = call.data[calldata.size len 64]
                if 0 >= mem[_5391]:
                    revert with 0, 50
                mem[_5391 + 32] = this.address
                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                        gas gas_remaining wei
                mem[_5391 + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = _5391 + ceil32(return_data.size) + 96
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                if 1 >= mem[_5391]:
                    revert with 0, 50
                mem[_5391 + 64] = ext_call.return_data[12 len 20]
                if not this.address:
                    revert with 0, 'ERC20: approve from the zero address'
                if not uniswapV2RouterAddress:
                    revert with 0, 'ERC20: approve to the zero address'
                mem[0] = uniswapV2RouterAddress
                mem[32] = sha3(address(this.address), 25)
                allowance[address(this.address)][stor54] = (stor23[address(this.address)] / t / s) - (stor23[address(this.address)] / t / s * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                emit Approval(((stor23[address(this.address)] / t / s) - (stor23[address(this.address)] / t / s * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)), this.address, uniswapV2RouterAddress);
                mem[_5391 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                mem[_5391 + ceil32(return_data.size) + 100] = (stor23[address(this.address)] / t / s) - (stor23[address(this.address)] / t / s * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                mem[_5391 + ceil32(return_data.size) + 132] = 0
                mem[_5391 + ceil32(return_data.size) + 164] = 160
                mem[_5391 + ceil32(return_data.size) + 260] = mem[_5391]
                idx = 0
                u = _5391 + ceil32(return_data.size) + 292
                v = _5391 + 32
                while idx < mem[_5391]:
                    mem[u] = mem[v + 12 len 20]
                    idx = idx + 1
                    u = u + 32
                    v = v + 32
                    continue 
                mem[_5391 + ceil32(return_data.size) + 196] = this.address
                mem[_5391 + ceil32(return_data.size) + 228] = block.timestamp
                require ext_code.size(uniswapV2RouterAddress)
                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len _5391 + ceil32(return_data.size) + (32 * mem[_5391]) + -mem[64] + 288]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _6581 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6581] = 30
                mem[_6581 + 32] = 'SafeMath: subtraction overflow'
                if eth.balance(this.address) <= eth.balance(this.address):
                    if eth.balance(this.address) < eth.balance(this.address):
                        revert with 0, 17
                    _liquidityTokensToSwap = 0
                    sub_432654c4 = 0
                    uint8(stor55.field_160) = 0
                    emit OwnerForcedSwapBack(block.timestamp);
                _6613 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _6613 + 68] = mem[idx + _6581 + 32]
                    idx = idx + 32
                    continue 
                mem[_6613 + 98] = 0
                revert with memory
                  from mem[64]
                   len _6613 + -mem[64] + 100
            if idx >= stor30.length:
                revert with 0, 50
            mem[0] = stor30[idx]
            mem[32] = 24
            if stor24[stor30[idx]] <= s:
                if idx >= stor30.length:
                    revert with 0, 50
                mem[0] = stor30[idx]
                mem[32] = 23
                _2315 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2315] = 30
                mem[_2315 + 32] = 'SafeMath: subtraction overflow'
                if stor23[stor30[idx]] > t:
                    _2323 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _2323 + 68] = mem[idx + _2315 + 32]
                        idx = idx + 32
                        continue 
                    mem[_2323 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _2323 + -mem[64] + 100
                if t < stor23[stor30[idx]]:
                    revert with 0, 17
                if idx >= stor30.length:
                    revert with 0, 50
                mem[0] = stor30[idx]
                mem[32] = 24
                _2355 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2355] = 30
                mem[_2355 + 32] = 'SafeMath: subtraction overflow'
                if stor24[stor30[idx]] <= s:
                    if s < stor24[stor30[idx]]:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s - stor24[stor30[idx]]
                    t = t - stor23[stor30[idx]]
                    continue 
                _2370 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _2370 + 68] = mem[idx + _2355 + 32]
                    idx = idx + 32
                    continue 
                mem[_2370 + 98] = 0
                revert with memory
                  from mem[64]
                   len _2370 + -mem[64] + 100
            _2316 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2316] = 26
            mem[_2316 + 32] = 'SafeMath: division by zero'
            _2356 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2356] = 26
            mem[_2356 + 32] = 'SafeMath: division by zero'
            if not stor31 / 10^15:
                _2371 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _2371 + 68] = mem[idx + _2356 + 32]
                    idx = idx + 32
                    continue 
                mem[_2371 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2371 + -mem[64] + 100
            if stor23[address(this.address)] / stor31 / 10^15 < 10^11:
                revert with 0, 'Can only swap back if more than .01% of tokens stuck on contract'
            uint8(stor55.field_160) = 1
            mem[0] = this.address
            if stor29[address(this.address)]:
                mem[32] = 24
                if _liquidityTokensToSwap > !sub_432654c4:
                    revert with 0, 17
                if minimumTokensBeforeSwapAmount > 0x1999999999999999999999999999999999999999999999999999999999999999:
                    revert with 0, 17
                if stor24[address(this.address)] >= 10 * minimumTokensBeforeSwapAmount:
                    if minimumTokensBeforeSwapAmount > 0x1999999999999999999999999999999999999999999999999999999999999999:
                        revert with 0, 17
                    if 10 * minimumTokensBeforeSwapAmount:
                        if _liquidityTokensToSwap + sub_432654c4:
                            if 10 * minimumTokensBeforeSwapAmount and _liquidityTokensToSwap > -1 / 10 * minimumTokensBeforeSwapAmount:
                                revert with 0, 17
                            if not _liquidityTokensToSwap + sub_432654c4:
                                revert with 0, 18
                            _2685 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2685] = 30
                            mem[_2685 + 32] = 'SafeMath: subtraction overflow'
                            if 10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2 > 10 * minimumTokensBeforeSwapAmount:
                                _2733 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2733 + 68] = mem[idx + _2685 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2733 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2733 + -mem[64] + 100
                            if 10 * minimumTokensBeforeSwapAmount < 10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2:
                                revert with 0, 17
                            _2864 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_2864 + 32 len 64] = call.data[calldata.size len 64]
                            if 0 >= mem[_2864]:
                                revert with 0, 50
                            mem[_2864 + 32] = this.address
                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                    gas gas_remaining wei
                            mem[_2864 + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _2864 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            if 1 >= mem[_2864]:
                                revert with 0, 50
                            mem[_2864 + 64] = ext_call.return_data[12 len 20]
                            if not this.address:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not uniswapV2RouterAddress:
                                revert with 0, 'ERC20: approve to the zero address'
                            mem[0] = uniswapV2RouterAddress
                            mem[32] = sha3(address(this.address), 25)
                            allowance[address(this.address)][stor54] = (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                            emit Approval(((10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)), this.address, uniswapV2RouterAddress);
                            mem[_2864 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                            mem[_2864 + ceil32(return_data.size) + 100] = (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                            mem[_2864 + ceil32(return_data.size) + 132] = 0
                            mem[_2864 + ceil32(return_data.size) + 164] = 160
                            mem[_2864 + ceil32(return_data.size) + 260] = mem[_2864]
                            idx = 0
                            s = _2864 + ceil32(return_data.size) + 292
                            t = _2864 + 32
                            while idx < mem[_2864]:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_2864 + ceil32(return_data.size) + 228] = block.timestamp
                            require ext_code.size(uniswapV2RouterAddress)
                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2), 0, 160, address(this.address), block.timestamp, mem[_2864 + ceil32(return_data.size) + 260 len (32 * mem[_2864]) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_2864 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                            if eth.balance(this.address) > eth.balance(this.address):
                                mem[_2864 + ceil32(return_data.size) + 160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_2864 + ceil32(return_data.size) + 164] = 32
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2864 + ceil32(return_data.size) + 228] = mem[idx + _2864 + ceil32(return_data.size) + 128]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 30, mem[_2864 + ceil32(return_data.size) + 228 len 30], 0
                            if eth.balance(this.address) < eth.balance(this.address):
                                revert with 0, 17
                            _liquidityTokensToSwap = 0
                            sub_432654c4 = 0
                    uint8(stor55.field_160) = 0
                    emit OwnerForcedSwapBack(block.timestamp);
                if not stor24[address(this.address)]:
                    uint8(stor55.field_160) = 0
                    emit OwnerForcedSwapBack(block.timestamp);
                if not _liquidityTokensToSwap + sub_432654c4:
                    uint8(stor55.field_160) = 0
                    emit OwnerForcedSwapBack(block.timestamp);
                if stor24[address(this.address)] and _liquidityTokensToSwap > -1 / stor24[address(this.address)]:
                    revert with 0, 17
                if not _liquidityTokensToSwap + sub_432654c4:
                    revert with 0, 18
                _2617 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2617] = 30
                mem[_2617 + 32] = 'SafeMath: subtraction overflow'
                if stor24[address(this.address)] * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2 > stor24[address(this.address)]:
                    _2645 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _2645 + 68] = mem[idx + _2617 + 32]
                        idx = idx + 32
                        continue 
                    mem[_2645 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _2645 + -mem[64] + 100
                if stor24[address(this.address)] < stor24[address(this.address)] * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2:
                    revert with 0, 17
                _2772 = mem[64]
                mem[mem[64]] = 2
                mem[64] = mem[64] + 96
                mem[_2772 + 32 len 64] = call.data[calldata.size len 64]
                if 0 >= mem[_2772]:
                    revert with 0, 50
                mem[_2772 + 32] = this.address
                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                        gas gas_remaining wei
                mem[_2772 + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = _2772 + ceil32(return_data.size) + 96
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                if 1 >= mem[_2772]:
                    revert with 0, 50
                mem[_2772 + 64] = ext_call.return_data[12 len 20]
                if not this.address:
                    revert with 0, 'ERC20: approve from the zero address'
                if not uniswapV2RouterAddress:
                    revert with 0, 'ERC20: approve to the zero address'
                mem[0] = uniswapV2RouterAddress
                mem[32] = sha3(address(this.address), 25)
                allowance[address(this.address)][stor54] = stor24[address(this.address)] - (stor24[address(this.address)] * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                emit Approval((stor24[address(this.address)] - (stor24[address(this.address)] * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)), this.address, uniswapV2RouterAddress);
                mem[_2772 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                mem[_2772 + ceil32(return_data.size) + 100] = stor24[address(this.address)] - (stor24[address(this.address)] * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                mem[_2772 + ceil32(return_data.size) + 132] = 0
                mem[_2772 + ceil32(return_data.size) + 164] = 160
                mem[_2772 + ceil32(return_data.size) + 260] = mem[_2772]
                idx = 0
                s = _2772 + ceil32(return_data.size) + 292
                t = _2772 + 32
                while idx < mem[_2772]:
                    mem[s] = mem[t + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_2772 + ceil32(return_data.size) + 196] = this.address
                mem[_2772 + ceil32(return_data.size) + 228] = block.timestamp
                require ext_code.size(uniswapV2RouterAddress)
                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len _2772 + ceil32(return_data.size) + (32 * mem[_2772]) + -mem[64] + 288]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _4679 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4679] = 30
                mem[_4679 + 32] = 'SafeMath: subtraction overflow'
                if eth.balance(this.address) <= eth.balance(this.address):
                    if eth.balance(this.address) < eth.balance(this.address):
                        revert with 0, 17
                    _liquidityTokensToSwap = 0
                    sub_432654c4 = 0
                    uint8(stor55.field_160) = 0
                    emit OwnerForcedSwapBack(block.timestamp);
                _4711 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _4711 + 68] = mem[idx + _4679 + 32]
                    idx = idx + 32
                    continue 
                mem[_4711 + 98] = 0
                revert with memory
                  from mem[64]
                   len _4711 + -mem[64] + 100
            mem[32] = 23
            if stor23[address(this.address)] > stor31:
                revert with 0, 'Amount must be less than total reflections'
            idx = 0
            s = 10^15
            t = stor31
            while idx < stor30.length:
                mem[0] = stor30[idx]
                mem[32] = 23
                if stor23[stor30[idx]] > t:
                    _4678 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4678] = 26
                    mem[_4678 + 32] = 'SafeMath: division by zero'
                    _4819 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4819] = 26
                    mem[_4819 + 32] = 'SafeMath: division by zero'
                    if not stor31 / 10^15:
                        _4852 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4852 + 68] = mem[idx + _4819 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4852 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4852 + -mem[64] + 100
                    if _liquidityTokensToSwap > !sub_432654c4:
                        revert with 0, 17
                    if minimumTokensBeforeSwapAmount > 0x1999999999999999999999999999999999999999999999999999999999999999:
                        revert with 0, 17
                    if stor23[address(this.address)] / stor31 / 10^15 < 10 * minimumTokensBeforeSwapAmount:
                        if stor23[address(this.address)] / stor31 / 10^15:
                            if _liquidityTokensToSwap + sub_432654c4:
                                if stor23[address(this.address)] / stor31 / 10^15 and _liquidityTokensToSwap > -1 / stor23[address(this.address)] / stor31 / 10^15:
                                    revert with 0, 17
                                if not _liquidityTokensToSwap + sub_432654c4:
                                    revert with 0, 18
                                _5124 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5124] = 30
                                mem[_5124 + 32] = 'SafeMath: subtraction overflow'
                                if stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2 > stor23[address(this.address)] / stor31 / 10^15:
                                    _5155 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _5155 + 68] = mem[idx + _5124 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5155 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5155 + -mem[64] + 100
                                if stor23[address(this.address)] / stor31 / 10^15 < stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2:
                                    revert with 0, 17
                                _5233 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_5233 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_5233]:
                                    revert with 0, 50
                                mem[_5233 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_5233 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _5233 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_5233]:
                                    revert with 0, 50
                                mem[_5233 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = (stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                                emit Approval(((stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)), this.address, uniswapV2RouterAddress);
                                mem[_5233 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_5233 + ceil32(return_data.size) + 100] = (stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                                mem[_5233 + ceil32(return_data.size) + 132] = 0
                                mem[_5233 + ceil32(return_data.size) + 164] = 160
                                mem[_5233 + ceil32(return_data.size) + 260] = mem[_5233]
                                idx = 0
                                s = _5233 + ceil32(return_data.size) + 292
                                t = _5233 + 32
                                while idx < mem[_5233]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_5233 + ceil32(return_data.size) + 228] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args (stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2), 0, 160, address(this.address), block.timestamp, mem[_5233 + ceil32(return_data.size) + 260 len (32 * mem[_5233]) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_5233 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                if eth.balance(this.address) > eth.balance(this.address):
                                    mem[_5233 + ceil32(return_data.size) + 160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_5233 + ceil32(return_data.size) + 164] = 32
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _5233 + ceil32(return_data.size) + 228] = mem[idx + _5233 + ceil32(return_data.size) + 128]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 32, 30, mem[_5233 + ceil32(return_data.size) + 228 len 30], 0
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                _liquidityTokensToSwap = 0
                                sub_432654c4 = 0
                        uint8(stor55.field_160) = 0
                        emit OwnerForcedSwapBack(block.timestamp);
                    if minimumTokensBeforeSwapAmount > 0x1999999999999999999999999999999999999999999999999999999999999999:
                        revert with 0, 17
                    if not 10 * minimumTokensBeforeSwapAmount:
                        uint8(stor55.field_160) = 0
                        emit OwnerForcedSwapBack(block.timestamp);
                    if not _liquidityTokensToSwap + sub_432654c4:
                        uint8(stor55.field_160) = 0
                        emit OwnerForcedSwapBack(block.timestamp);
                    if 10 * minimumTokensBeforeSwapAmount and _liquidityTokensToSwap > -1 / 10 * minimumTokensBeforeSwapAmount:
                        revert with 0, 17
                    if not _liquidityTokensToSwap + sub_432654c4:
                        revert with 0, 18
                    _5175 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5175] = 30
                    mem[_5175 + 32] = 'SafeMath: subtraction overflow'
                    if 10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2 > 10 * minimumTokensBeforeSwapAmount:
                        _5199 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _5199 + 68] = mem[idx + _5175 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5199 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5199 + -mem[64] + 100
                    if 10 * minimumTokensBeforeSwapAmount < 10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2:
                        revert with 0, 17
                    _5337 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    mem[_5337 + 32 len 64] = call.data[calldata.size len 64]
                    if 0 >= mem[_5337]:
                        revert with 0, 50
                    mem[_5337 + 32] = this.address
                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                            gas gas_remaining wei
                    mem[_5337 + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _5337 + ceil32(return_data.size) + 96
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if 1 >= mem[_5337]:
                        revert with 0, 50
                    mem[_5337 + 64] = ext_call.return_data[12 len 20]
                    if not this.address:
                        revert with 0, 'ERC20: approve from the zero address'
                    if not uniswapV2RouterAddress:
                        revert with 0, 'ERC20: approve to the zero address'
                    mem[0] = uniswapV2RouterAddress
                    mem[32] = sha3(address(this.address), 25)
                    allowance[address(this.address)][stor54] = (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                    emit Approval(((10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)), this.address, uniswapV2RouterAddress);
                    mem[_5337 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                    mem[_5337 + ceil32(return_data.size) + 100] = (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                    mem[_5337 + ceil32(return_data.size) + 132] = 0
                    mem[_5337 + ceil32(return_data.size) + 164] = 160
                    mem[_5337 + ceil32(return_data.size) + 260] = mem[_5337]
                    idx = 0
                    s = _5337 + ceil32(return_data.size) + 292
                    t = _5337 + 32
                    while idx < mem[_5337]:
                        mem[s] = mem[t + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_5337 + ceil32(return_data.size) + 196] = this.address
                    mem[_5337 + ceil32(return_data.size) + 228] = block.timestamp
                    require ext_code.size(uniswapV2RouterAddress)
                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _5337 + ceil32(return_data.size) + (32 * mem[_5337]) + -mem[64] + 288]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _6594 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6594] = 30
                    mem[_6594 + 32] = 'SafeMath: subtraction overflow'
                    if eth.balance(this.address) <= eth.balance(this.address):
                        if eth.balance(this.address) < eth.balance(this.address):
                            revert with 0, 17
                        _liquidityTokensToSwap = 0
                        sub_432654c4 = 0
                        uint8(stor55.field_160) = 0
                        emit OwnerForcedSwapBack(block.timestamp);
                    _6626 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _6626 + 68] = mem[idx + _6594 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6626 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _6626 + -mem[64] + 100
                if idx >= stor30.length:
                    revert with 0, 50
                mem[0] = stor30[idx]
                mem[32] = 24
                if stor24[stor30[idx]] <= s:
                    if idx >= stor30.length:
                        revert with 0, 50
                    mem[0] = stor30[idx]
                    mem[32] = 23
                    _4709 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4709] = 30
                    mem[_4709 + 32] = 'SafeMath: subtraction overflow'
                    if stor23[stor30[idx]] > t:
                        _4740 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _4740 + 68] = mem[idx + _4709 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4740 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _4740 + -mem[64] + 100
                    if t < stor23[stor30[idx]]:
                        revert with 0, 17
                    if idx >= stor30.length:
                        revert with 0, 50
                    mem[0] = stor30[idx]
                    mem[32] = 24
                    _4853 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4853] = 30
                    mem[_4853 + 32] = 'SafeMath: subtraction overflow'
                    if stor24[stor30[idx]] <= s:
                        if s < stor24[stor30[idx]]:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s - stor24[stor30[idx]]
                        t = t - stor23[stor30[idx]]
                        continue 
                    _4917 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _4917 + 68] = mem[idx + _4853 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4917 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _4917 + -mem[64] + 100
                _4710 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4710] = 26
                mem[_4710 + 32] = 'SafeMath: division by zero'
                _4854 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4854] = 26
                mem[_4854 + 32] = 'SafeMath: division by zero'
                if not stor31 / 10^15:
                    _4918 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4918 + 68] = mem[idx + _4854 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4918 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4918 + -mem[64] + 100
                if _liquidityTokensToSwap > !sub_432654c4:
                    revert with 0, 17
                if minimumTokensBeforeSwapAmount > 0x1999999999999999999999999999999999999999999999999999999999999999:
                    revert with 0, 17
                if stor23[address(this.address)] / stor31 / 10^15 >= 10 * minimumTokensBeforeSwapAmount:
                    if minimumTokensBeforeSwapAmount > 0x1999999999999999999999999999999999999999999999999999999999999999:
                        revert with 0, 17
                    if 10 * minimumTokensBeforeSwapAmount:
                        if _liquidityTokensToSwap + sub_432654c4:
                            if 10 * minimumTokensBeforeSwapAmount and _liquidityTokensToSwap > -1 / 10 * minimumTokensBeforeSwapAmount:
                                revert with 0, 17
                            if not _liquidityTokensToSwap + sub_432654c4:
                                revert with 0, 18
                            _5200 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5200] = 30
                            mem[_5200 + 32] = 'SafeMath: subtraction overflow'
                            if 10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2 > 10 * minimumTokensBeforeSwapAmount:
                                _5236 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _5236 + 68] = mem[idx + _5200 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5236 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5236 + -mem[64] + 100
                            if 10 * minimumTokensBeforeSwapAmount < 10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2:
                                revert with 0, 17
                            _5410 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_5410 + 32 len 64] = call.data[calldata.size len 64]
                            if 0 >= mem[_5410]:
                                revert with 0, 50
                            mem[_5410 + 32] = this.address
                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                    gas gas_remaining wei
                            mem[_5410 + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _5410 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            if 1 >= mem[_5410]:
                                revert with 0, 50
                            mem[_5410 + 64] = ext_call.return_data[12 len 20]
                            if not this.address:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not uniswapV2RouterAddress:
                                revert with 0, 'ERC20: approve to the zero address'
                            mem[0] = uniswapV2RouterAddress
                            mem[32] = sha3(address(this.address), 25)
                            allowance[address(this.address)][stor54] = (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                            emit Approval(((10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)), this.address, uniswapV2RouterAddress);
                            mem[_5410 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                            mem[_5410 + ceil32(return_data.size) + 100] = (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                            mem[_5410 + ceil32(return_data.size) + 132] = 0
                            mem[_5410 + ceil32(return_data.size) + 164] = 160
                            mem[_5410 + ceil32(return_data.size) + 260] = mem[_5410]
                            idx = 0
                            s = _5410 + ceil32(return_data.size) + 292
                            t = _5410 + 32
                            while idx < mem[_5410]:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_5410 + ceil32(return_data.size) + 228] = block.timestamp
                            require ext_code.size(uniswapV2RouterAddress)
                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2), 0, 160, address(this.address), block.timestamp, mem[_5410 + ceil32(return_data.size) + 260 len (32 * mem[_5410]) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_5410 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                            if eth.balance(this.address) > eth.balance(this.address):
                                mem[_5410 + ceil32(return_data.size) + 160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_5410 + ceil32(return_data.size) + 164] = 32
                                idx = 0
                                while idx < 30:
                                    mem[idx + _5410 + ceil32(return_data.size) + 228] = mem[idx + _5410 + ceil32(return_data.size) + 128]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 30, mem[_5410 + ceil32(return_data.size) + 228 len 30], 0
                            if eth.balance(this.address) < eth.balance(this.address):
                                revert with 0, 17
                            _liquidityTokensToSwap = 0
                            sub_432654c4 = 0
                    uint8(stor55.field_160) = 0
                    emit OwnerForcedSwapBack(block.timestamp);
                if not stor23[address(this.address)] / stor31 / 10^15:
                    uint8(stor55.field_160) = 0
                    emit OwnerForcedSwapBack(block.timestamp);
                if not _liquidityTokensToSwap + sub_432654c4:
                    uint8(stor55.field_160) = 0
                    emit OwnerForcedSwapBack(block.timestamp);
                if stor23[address(this.address)] / stor31 / 10^15 and _liquidityTokensToSwap > -1 / stor23[address(this.address)] / stor31 / 10^15:
                    revert with 0, 17
                if not _liquidityTokensToSwap + sub_432654c4:
                    revert with 0, 18
                _5156 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5156] = 30
                mem[_5156 + 32] = 'SafeMath: subtraction overflow'
                if stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2 > stor23[address(this.address)] / stor31 / 10^15:
                    _5176 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _5176 + 68] = mem[idx + _5156 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5176 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _5176 + -mem[64] + 100
                if stor23[address(this.address)] / stor31 / 10^15 < stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2:
                    revert with 0, 17
                _5286 = mem[64]
                mem[mem[64]] = 2
                mem[64] = mem[64] + 96
                mem[_5286 + 32 len 64] = call.data[calldata.size len 64]
                if 0 >= mem[_5286]:
                    revert with 0, 50
                mem[_5286 + 32] = this.address
                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                        gas gas_remaining wei
                mem[_5286 + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = _5286 + ceil32(return_data.size) + 96
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                if 1 >= mem[_5286]:
                    revert with 0, 50
                mem[_5286 + 64] = ext_call.return_data[12 len 20]
                if not this.address:
                    revert with 0, 'ERC20: approve from the zero address'
                if not uniswapV2RouterAddress:
                    revert with 0, 'ERC20: approve to the zero address'
                mem[0] = uniswapV2RouterAddress
                mem[32] = sha3(address(this.address), 25)
                allowance[address(this.address)][stor54] = (stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                emit Approval(((stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)), this.address, uniswapV2RouterAddress);
                mem[_5286 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                mem[_5286 + ceil32(return_data.size) + 100] = (stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                mem[_5286 + ceil32(return_data.size) + 132] = 0
                mem[_5286 + ceil32(return_data.size) + 164] = 160
                mem[_5286 + ceil32(return_data.size) + 260] = mem[_5286]
                idx = 0
                s = _5286 + ceil32(return_data.size) + 292
                t = _5286 + 32
                while idx < mem[_5286]:
                    mem[s] = mem[t + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_5286 + ceil32(return_data.size) + 196] = this.address
                mem[_5286 + ceil32(return_data.size) + 228] = block.timestamp
                require ext_code.size(uniswapV2RouterAddress)
                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len _5286 + ceil32(return_data.size) + (32 * mem[_5286]) + -mem[64] + 288]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _6595 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6595] = 30
                mem[_6595 + 32] = 'SafeMath: subtraction overflow'
                if eth.balance(this.address) <= eth.balance(this.address):
                    if eth.balance(this.address) < eth.balance(this.address):
                        revert with 0, 17
                    _liquidityTokensToSwap = 0
                    sub_432654c4 = 0
                    uint8(stor55.field_160) = 0
                    emit OwnerForcedSwapBack(block.timestamp);
                _6627 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _6627 + 68] = mem[idx + _6595 + 32]
                    idx = idx + 32
                    continue 
                mem[_6627 + 98] = 0
                revert with memory
                  from mem[64]
                   len _6627 + -mem[64] + 100
            _4584 = mem[64]
            mem[64] = mem[64] + 64
            mem[_4584] = 26
            mem[_4584 + 32] = 'SafeMath: division by zero'
            if t < stor31 / 10^15:
                _4768 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4768] = 26
                mem[_4768 + 32] = 'SafeMath: division by zero'
                _4952 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4952] = 26
                mem[_4952 + 32] = 'SafeMath: division by zero'
                if not stor31 / 10^15:
                    _4975 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    s = 0
                    while s < 26:
                        mem[s + _4975 + 68] = mem[s + _4952 + 32]
                        s = s + 32
                        continue 
                    mem[_4975 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4975 + -mem[64] + 100
                if _liquidityTokensToSwap > !sub_432654c4:
                    revert with 0, 17
                if minimumTokensBeforeSwapAmount > 0x1999999999999999999999999999999999999999999999999999999999999999:
                    revert with 0, 17
                if stor23[address(this.address)] / stor31 / 10^15 < 10 * minimumTokensBeforeSwapAmount:
                    if stor23[address(this.address)] / stor31 / 10^15:
                        if _liquidityTokensToSwap + sub_432654c4:
                            if stor23[address(this.address)] / stor31 / 10^15 and _liquidityTokensToSwap > -1 / stor23[address(this.address)] / stor31 / 10^15:
                                revert with 0, 17
                            if not _liquidityTokensToSwap + sub_432654c4:
                                revert with 0, 18
                            _5198 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5198] = 30
                            mem[_5198 + 32] = 'SafeMath: subtraction overflow'
                            if stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2 > stor23[address(this.address)] / stor31 / 10^15:
                                _5232 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _5232 + 68] = mem[idx + _5198 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5232 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5232 + -mem[64] + 100
                            if stor23[address(this.address)] / stor31 / 10^15 < stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2:
                                revert with 0, 17
                            _5405 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_5405 + 32 len 64] = call.data[calldata.size len 64]
                            if 0 >= mem[_5405]:
                                revert with 0, 50
                            mem[_5405 + 32] = this.address
                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                    gas gas_remaining wei
                            mem[_5405 + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _5405 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            if 1 >= mem[_5405]:
                                revert with 0, 50
                            mem[_5405 + 64] = ext_call.return_data[12 len 20]
                            if not this.address:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not uniswapV2RouterAddress:
                                revert with 0, 'ERC20: approve to the zero address'
                            mem[0] = uniswapV2RouterAddress
                            mem[32] = sha3(address(this.address), 25)
                            allowance[address(this.address)][stor54] = (stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                            emit Approval(((stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)), this.address, uniswapV2RouterAddress);
                            mem[_5405 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                            mem[_5405 + ceil32(return_data.size) + 100] = (stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                            mem[_5405 + ceil32(return_data.size) + 132] = 0
                            mem[_5405 + ceil32(return_data.size) + 164] = 160
                            mem[_5405 + ceil32(return_data.size) + 260] = mem[_5405]
                            idx = 0
                            s = _5405 + ceil32(return_data.size) + 292
                            t = _5405 + 32
                            while idx < mem[_5405]:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_5405 + ceil32(return_data.size) + 228] = block.timestamp
                            require ext_code.size(uniswapV2RouterAddress)
                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args (stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2), 0, 160, address(this.address), block.timestamp, mem[_5405 + ceil32(return_data.size) + 260 len (32 * mem[_5405]) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_5405 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                            if eth.balance(this.address) > eth.balance(this.address):
                                mem[_5405 + ceil32(return_data.size) + 160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_5405 + ceil32(return_data.size) + 164] = 32
                                idx = 0
                                while idx < 30:
                                    mem[idx + _5405 + ceil32(return_data.size) + 228] = mem[idx + _5405 + ceil32(return_data.size) + 128]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 30, mem[_5405 + ceil32(return_data.size) + 228 len 30], 0
                            if eth.balance(this.address) < eth.balance(this.address):
                                revert with 0, 17
                            _liquidityTokensToSwap = 0
                            sub_432654c4 = 0
                else:
                    if minimumTokensBeforeSwapAmount > 0x1999999999999999999999999999999999999999999999999999999999999999:
                        revert with 0, 17
                    if 10 * minimumTokensBeforeSwapAmount:
                        if _liquidityTokensToSwap + sub_432654c4:
                            if 10 * minimumTokensBeforeSwapAmount and _liquidityTokensToSwap > -1 / 10 * minimumTokensBeforeSwapAmount:
                                revert with 0, 17
                            if not _liquidityTokensToSwap + sub_432654c4:
                                revert with 0, 18
                            _5284 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5284] = 30
                            mem[_5284 + 32] = 'SafeMath: subtraction overflow'
                            if 10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2 > 10 * minimumTokensBeforeSwapAmount:
                                _5335 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _5335 + 68] = mem[idx + _5284 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5335 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5335 + -mem[64] + 100
                            if 10 * minimumTokensBeforeSwapAmount < 10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2:
                                revert with 0, 17
                            _5508 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_5508 + 32 len 64] = call.data[calldata.size len 64]
                            if 0 >= mem[_5508]:
                                revert with 0, 50
                            mem[_5508 + 32] = this.address
                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                    gas gas_remaining wei
                            mem[_5508 + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _5508 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            if 1 >= mem[_5508]:
                                revert with 0, 50
                            mem[_5508 + 64] = ext_call.return_data[12 len 20]
                            if not this.address:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not uniswapV2RouterAddress:
                                revert with 0, 'ERC20: approve to the zero address'
                            mem[0] = uniswapV2RouterAddress
                            mem[32] = sha3(address(this.address), 25)
                            allowance[address(this.address)][stor54] = (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                            emit Approval(((10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)), this.address, uniswapV2RouterAddress);
                            mem[_5508 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                            mem[_5508 + ceil32(return_data.size) + 100] = (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                            mem[_5508 + ceil32(return_data.size) + 132] = 0
                            mem[_5508 + ceil32(return_data.size) + 164] = 160
                            mem[_5508 + ceil32(return_data.size) + 260] = mem[_5508]
                            idx = 0
                            s = _5508 + ceil32(return_data.size) + 292
                            t = _5508 + 32
                            while idx < mem[_5508]:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_5508 + ceil32(return_data.size) + 228] = block.timestamp
                            require ext_code.size(uniswapV2RouterAddress)
                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2), 0, 160, address(this.address), block.timestamp, mem[_5508 + ceil32(return_data.size) + 260 len (32 * mem[_5508]) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_5508 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                            if eth.balance(this.address) > eth.balance(this.address):
                                mem[_5508 + ceil32(return_data.size) + 160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_5508 + ceil32(return_data.size) + 164] = 32
                                idx = 0
                                while idx < 30:
                                    mem[idx + _5508 + ceil32(return_data.size) + 228] = mem[idx + _5508 + ceil32(return_data.size) + 128]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 30, mem[_5508 + ceil32(return_data.size) + 228 len 30], 0
                            if eth.balance(this.address) < eth.balance(this.address):
                                revert with 0, 17
                            _liquidityTokensToSwap = 0
                            sub_432654c4 = 0
            else:
                _4767 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4767] = 26
                mem[_4767 + 32] = 'SafeMath: division by zero'
                if not s:
                    _4798 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4798 + 68] = mem[idx + _4767 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4798 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4798 + -mem[64] + 100
                _4951 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4951] = 26
                mem[_4951 + 32] = 'SafeMath: division by zero'
                if not t / s:
                    _4974 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    s = 0
                    while s < 26:
                        mem[s + _4974 + 68] = mem[s + _4951 + 32]
                        s = s + 32
                        continue 
                    mem[_4974 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4974 + -mem[64] + 100
                if _liquidityTokensToSwap > !sub_432654c4:
                    revert with 0, 17
                if minimumTokensBeforeSwapAmount > 0x1999999999999999999999999999999999999999999999999999999999999999:
                    revert with 0, 17
                if stor23[address(this.address)] / t / s < 10 * minimumTokensBeforeSwapAmount:
                    if stor23[address(this.address)] / t / s:
                        if _liquidityTokensToSwap + sub_432654c4:
                            if stor23[address(this.address)] / t / s and _liquidityTokensToSwap > -1 / stor23[address(this.address)] / t / s:
                                revert with 0, 17
                            if not _liquidityTokensToSwap + sub_432654c4:
                                revert with 0, 18
                            _5197 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5197] = 30
                            mem[_5197 + 32] = 'SafeMath: subtraction overflow'
                            if stor23[address(this.address)] / t / s * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2 > stor23[address(this.address)] / t / s:
                                _5231 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _5231 + 68] = mem[idx + _5197 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5231 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5231 + -mem[64] + 100
                            if stor23[address(this.address)] / t / s < stor23[address(this.address)] / t / s * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2:
                                revert with 0, 17
                            _5402 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_5402 + 32 len 64] = call.data[calldata.size len 64]
                            if 0 >= mem[_5402]:
                                revert with 0, 50
                            mem[_5402 + 32] = this.address
                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                    gas gas_remaining wei
                            mem[_5402 + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _5402 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            if 1 >= mem[_5402]:
                                revert with 0, 50
                            mem[_5402 + 64] = ext_call.return_data[12 len 20]
                            if not this.address:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not uniswapV2RouterAddress:
                                revert with 0, 'ERC20: approve to the zero address'
                            mem[0] = uniswapV2RouterAddress
                            mem[32] = sha3(address(this.address), 25)
                            allowance[address(this.address)][stor54] = (stor23[address(this.address)] / t / s) - (stor23[address(this.address)] / t / s * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                            emit Approval(((stor23[address(this.address)] / t / s) - (stor23[address(this.address)] / t / s * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)), this.address, uniswapV2RouterAddress);
                            mem[_5402 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                            mem[_5402 + ceil32(return_data.size) + 100] = (stor23[address(this.address)] / t / s) - (stor23[address(this.address)] / t / s * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                            mem[_5402 + ceil32(return_data.size) + 132] = 0
                            mem[_5402 + ceil32(return_data.size) + 164] = 160
                            mem[_5402 + ceil32(return_data.size) + 260] = mem[_5402]
                            idx = 0
                            u = _5402 + ceil32(return_data.size) + 292
                            v = _5402 + 32
                            while idx < mem[_5402]:
                                mem[u] = mem[v + 12 len 20]
                                idx = idx + 1
                                u = u + 32
                                v = v + 32
                                continue 
                            mem[_5402 + ceil32(return_data.size) + 228] = block.timestamp
                            require ext_code.size(uniswapV2RouterAddress)
                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args (stor23[address(this.address)] / t / s) - (stor23[address(this.address)] / t / s * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2), 0, 160, address(this.address), block.timestamp, mem[_5402 + ceil32(return_data.size) + 260 len (32 * mem[_5402]) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_5402 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                            if eth.balance(this.address) > eth.balance(this.address):
                                mem[_5402 + ceil32(return_data.size) + 160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_5402 + ceil32(return_data.size) + 164] = 32
                                idx = 0
                                while idx < 30:
                                    mem[idx + _5402 + ceil32(return_data.size) + 228] = mem[idx + _5402 + ceil32(return_data.size) + 128]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 30, mem[_5402 + ceil32(return_data.size) + 228 len 30], 0
                            if eth.balance(this.address) < eth.balance(this.address):
                                revert with 0, 17
                            _liquidityTokensToSwap = 0
                            sub_432654c4 = 0
                else:
                    if minimumTokensBeforeSwapAmount > 0x1999999999999999999999999999999999999999999999999999999999999999:
                        revert with 0, 17
                    if 10 * minimumTokensBeforeSwapAmount:
                        if _liquidityTokensToSwap + sub_432654c4:
                            if 10 * minimumTokensBeforeSwapAmount and _liquidityTokensToSwap > -1 / 10 * minimumTokensBeforeSwapAmount:
                                revert with 0, 17
                            if not _liquidityTokensToSwap + sub_432654c4:
                                revert with 0, 18
                            _5283 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5283] = 30
                            mem[_5283 + 32] = 'SafeMath: subtraction overflow'
                            if 10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2 > 10 * minimumTokensBeforeSwapAmount:
                                _5334 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _5334 + 68] = mem[idx + _5283 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5334 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5334 + -mem[64] + 100
                            if 10 * minimumTokensBeforeSwapAmount < 10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2:
                                revert with 0, 17
                            _5504 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_5504 + 32 len 64] = call.data[calldata.size len 64]
                            if 0 >= mem[_5504]:
                                revert with 0, 50
                            mem[_5504 + 32] = this.address
                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                    gas gas_remaining wei
                            mem[_5504 + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _5504 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            if 1 >= mem[_5504]:
                                revert with 0, 50
                            mem[_5504 + 64] = ext_call.return_data[12 len 20]
                            if not this.address:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not uniswapV2RouterAddress:
                                revert with 0, 'ERC20: approve to the zero address'
                            mem[0] = uniswapV2RouterAddress
                            mem[32] = sha3(address(this.address), 25)
                            allowance[address(this.address)][stor54] = (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                            emit Approval(((10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)), this.address, uniswapV2RouterAddress);
                            mem[_5504 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                            mem[_5504 + ceil32(return_data.size) + 100] = (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                            mem[_5504 + ceil32(return_data.size) + 132] = 0
                            mem[_5504 + ceil32(return_data.size) + 164] = 160
                            mem[_5504 + ceil32(return_data.size) + 260] = mem[_5504]
                            idx = 0
                            s = _5504 + ceil32(return_data.size) + 292
                            t = _5504 + 32
                            while idx < mem[_5504]:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_5504 + ceil32(return_data.size) + 228] = block.timestamp
                            require ext_code.size(uniswapV2RouterAddress)
                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2), 0, 160, address(this.address), block.timestamp, mem[_5504 + ceil32(return_data.size) + 260 len (32 * mem[_5504]) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_5504 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                            if eth.balance(this.address) > eth.balance(this.address):
                                mem[_5504 + ceil32(return_data.size) + 160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_5504 + ceil32(return_data.size) + 164] = 32
                                idx = 0
                                while idx < 30:
                                    mem[idx + _5504 + ceil32(return_data.size) + 228] = mem[idx + _5504 + ceil32(return_data.size) + 128]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 30, mem[_5504 + ceil32(return_data.size) + 228 len 30], 0
                            if eth.balance(this.address) < eth.balance(this.address):
                                revert with 0, 17
                            _liquidityTokensToSwap = 0
                            sub_432654c4 = 0
            uint8(stor55.field_160) = 0
            emit OwnerForcedSwapBack(block.timestamp);
        _2291 = mem[64]
        mem[64] = mem[64] + 64
        mem[_2291] = 26
        mem[_2291 + 32] = 'SafeMath: division by zero'
        if t < stor31 / 10^15:
            _2330 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2330] = 26
            mem[_2330 + 32] = 'SafeMath: division by zero'
            _2386 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2386] = 26
            mem[_2386 + 32] = 'SafeMath: division by zero'
            if not stor31 / 10^15:
                revert with 0, 'SafeMath: division by zero', 0
            if stor23[address(this.address)] / stor31 / 10^15 < 10^11:
                revert with 0, 'Can only swap back if more than .01% of tokens stuck on contract'
            uint8(stor55.field_160) = 1
            mem[0] = this.address
            if stor29[address(this.address)]:
                mem[32] = 24
                if _liquidityTokensToSwap > !sub_432654c4:
                    revert with 0, 17
                if minimumTokensBeforeSwapAmount > 0x1999999999999999999999999999999999999999999999999999999999999999:
                    revert with 0, 17
                if stor24[address(this.address)] < 10 * minimumTokensBeforeSwapAmount:
                    if stor24[address(this.address)]:
                        if _liquidityTokensToSwap + sub_432654c4:
                            if stor24[address(this.address)] and _liquidityTokensToSwap > -1 / stor24[address(this.address)]:
                                revert with 0, 17
                            if not _liquidityTokensToSwap + sub_432654c4:
                                revert with 0, 18
                            _2677 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2677] = 30
                            mem[_2677 + 32] = 'SafeMath: subtraction overflow'
                            if stor24[address(this.address)] * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2 > stor24[address(this.address)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor24[address(this.address)] < stor24[address(this.address)] * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2:
                                revert with 0, 17
                            _2857 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_2857 + 32 len 64] = call.data[calldata.size len 64]
                            if 0 >= mem[_2857]:
                                revert with 0, 50
                            mem[_2857 + 32] = this.address
                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                    gas gas_remaining wei
                            mem[_2857 + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _2857 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            if 1 >= mem[_2857]:
                                revert with 0, 50
                            mem[_2857 + 64] = ext_call.return_data[12 len 20]
                            if not this.address:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not uniswapV2RouterAddress:
                                revert with 0, 'ERC20: approve to the zero address'
                            mem[0] = uniswapV2RouterAddress
                            mem[32] = sha3(address(this.address), 25)
                            allowance[address(this.address)][stor54] = stor24[address(this.address)] - (stor24[address(this.address)] * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                            emit Approval((stor24[address(this.address)] - (stor24[address(this.address)] * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)), this.address, uniswapV2RouterAddress);
                            mem[_2857 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                            mem[_2857 + ceil32(return_data.size) + 100] = stor24[address(this.address)] - (stor24[address(this.address)] * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                            mem[_2857 + ceil32(return_data.size) + 132] = 0
                            mem[_2857 + ceil32(return_data.size) + 164] = 160
                            mem[_2857 + ceil32(return_data.size) + 260] = mem[_2857]
                            idx = 0
                            s = _2857 + ceil32(return_data.size) + 292
                            t = _2857 + 32
                            while idx < mem[_2857]:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_2857 + ceil32(return_data.size) + 196] = this.address
                            mem[_2857 + ceil32(return_data.size) + 228] = block.timestamp
                            require ext_code.size(uniswapV2RouterAddress)
                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _2857 + ceil32(return_data.size) + (32 * mem[_2857]) + -mem[64] + 288]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if eth.balance(this.address) > eth.balance(this.address):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if eth.balance(this.address) < eth.balance(this.address):
                                revert with 0, 17
                            _liquidityTokensToSwap = 0
                            sub_432654c4 = 0
                else:
                    if minimumTokensBeforeSwapAmount > 0x1999999999999999999999999999999999999999999999999999999999999999:
                        revert with 0, 17
                    if 10 * minimumTokensBeforeSwapAmount:
                        if _liquidityTokensToSwap + sub_432654c4:
                            if 10 * minimumTokensBeforeSwapAmount and _liquidityTokensToSwap > -1 / 10 * minimumTokensBeforeSwapAmount:
                                revert with 0, 17
                            if not _liquidityTokensToSwap + sub_432654c4:
                                revert with 0, 18
                            _2764 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2764] = 30
                            mem[_2764 + 32] = 'SafeMath: subtraction overflow'
                            if 10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2 > 10 * minimumTokensBeforeSwapAmount:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 10 * minimumTokensBeforeSwapAmount < 10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2:
                                revert with 0, 17
                            _2930 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_2930 + 32 len 64] = call.data[calldata.size len 64]
                            if 0 >= mem[_2930]:
                                revert with 0, 50
                            mem[_2930 + 32] = this.address
                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                    gas gas_remaining wei
                            mem[_2930 + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _2930 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            if 1 >= mem[_2930]:
                                revert with 0, 50
                            mem[_2930 + 64] = ext_call.return_data[12 len 20]
                            if not this.address:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not uniswapV2RouterAddress:
                                revert with 0, 'ERC20: approve to the zero address'
                            mem[0] = uniswapV2RouterAddress
                            mem[32] = sha3(address(this.address), 25)
                            allowance[address(this.address)][stor54] = (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                            emit Approval(((10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)), this.address, uniswapV2RouterAddress);
                            mem[_2930 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                            mem[_2930 + ceil32(return_data.size) + 100] = (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                            mem[_2930 + ceil32(return_data.size) + 132] = 0
                            mem[_2930 + ceil32(return_data.size) + 164] = 160
                            mem[_2930 + ceil32(return_data.size) + 260] = mem[_2930]
                            idx = 0
                            s = _2930 + ceil32(return_data.size) + 292
                            t = _2930 + 32
                            while idx < mem[_2930]:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_2930 + ceil32(return_data.size) + 196] = this.address
                            mem[_2930 + ceil32(return_data.size) + 228] = block.timestamp
                            require ext_code.size(uniswapV2RouterAddress)
                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _2930 + ceil32(return_data.size) + (32 * mem[_2930]) + -mem[64] + 288]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if eth.balance(this.address) > eth.balance(this.address):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if eth.balance(this.address) < eth.balance(this.address):
                                revert with 0, 17
                            _liquidityTokensToSwap = 0
                            sub_432654c4 = 0
            else:
                mem[32] = 23
                if stor23[address(this.address)] > stor31:
                    revert with 0, 'Amount must be less than total reflections'
                idx = 0
                s = 10^15
                t = stor31
                while idx < stor30.length:
                    mem[0] = stor30[idx]
                    mem[32] = 23
                    if stor23[stor30[idx]] > t:
                        _4672 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4672] = 26
                        mem[_4672 + 32] = 'SafeMath: division by zero'
                        _4813 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4813] = 26
                        mem[_4813 + 32] = 'SafeMath: division by zero'
                        if not stor31 / 10^15:
                            _4840 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4840 + 68] = mem[idx + _4813 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4840 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _4840 + -mem[64] + 100
                        if _liquidityTokensToSwap > !sub_432654c4:
                            revert with 0, 17
                        if minimumTokensBeforeSwapAmount > 0x1999999999999999999999999999999999999999999999999999999999999999:
                            revert with 0, 17
                        if stor23[address(this.address)] / stor31 / 10^15 < 10 * minimumTokensBeforeSwapAmount:
                            if not stor23[address(this.address)] / stor31 / 10^15:
                                uint8(stor55.field_160) = 0
                                emit OwnerForcedSwapBack(block.timestamp);
                            if not _liquidityTokensToSwap + sub_432654c4:
                                uint8(stor55.field_160) = 0
                                emit OwnerForcedSwapBack(block.timestamp);
                            if stor23[address(this.address)] / stor31 / 10^15 and _liquidityTokensToSwap > -1 / stor23[address(this.address)] / stor31 / 10^15:
                                revert with 0, 17
                            if not _liquidityTokensToSwap + sub_432654c4:
                                revert with 0, 18
                            _5122 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5122] = 30
                            mem[_5122 + 32] = 'SafeMath: subtraction overflow'
                            if stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2 > stor23[address(this.address)] / stor31 / 10^15:
                                _5143 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _5143 + 68] = mem[idx + _5122 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5143 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5143 + -mem[64] + 100
                            if stor23[address(this.address)] / stor31 / 10^15 < stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2:
                                revert with 0, 17
                            _5221 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_5221 + 32 len 64] = call.data[calldata.size len 64]
                            if 0 >= mem[_5221]:
                                revert with 0, 50
                            mem[_5221 + 32] = this.address
                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                    gas gas_remaining wei
                            mem[_5221 + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _5221 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            if 1 >= mem[_5221]:
                                revert with 0, 50
                            mem[_5221 + 64] = ext_call.return_data[12 len 20]
                            if not this.address:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not uniswapV2RouterAddress:
                                revert with 0, 'ERC20: approve to the zero address'
                            mem[0] = uniswapV2RouterAddress
                            mem[32] = sha3(address(this.address), 25)
                            allowance[address(this.address)][stor54] = (stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                            emit Approval(((stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)), this.address, uniswapV2RouterAddress);
                            mem[_5221 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                            mem[_5221 + ceil32(return_data.size) + 100] = (stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                            mem[_5221 + ceil32(return_data.size) + 132] = 0
                            mem[_5221 + ceil32(return_data.size) + 164] = 160
                            mem[_5221 + ceil32(return_data.size) + 260] = mem[_5221]
                            idx = 0
                            s = _5221 + ceil32(return_data.size) + 292
                            t = _5221 + 32
                            while idx < mem[_5221]:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_5221 + ceil32(return_data.size) + 196] = this.address
                            mem[_5221 + ceil32(return_data.size) + 228] = block.timestamp
                            require ext_code.size(uniswapV2RouterAddress)
                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _5221 + ceil32(return_data.size) + (32 * mem[_5221]) + -mem[64] + 288]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _6577 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6577] = 30
                            mem[_6577 + 32] = 'SafeMath: subtraction overflow'
                            if eth.balance(this.address) <= eth.balance(this.address):
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                _liquidityTokensToSwap = 0
                                sub_432654c4 = 0
                                uint8(stor55.field_160) = 0
                                emit OwnerForcedSwapBack(block.timestamp);
                            _6609 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _6609 + 68] = mem[idx + _6577 + 32]
                                idx = idx + 32
                                continue 
                            mem[_6609 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _6609 + -mem[64] + 100
                        if minimumTokensBeforeSwapAmount > 0x1999999999999999999999999999999999999999999999999999999999999999:
                            revert with 0, 17
                        if not 10 * minimumTokensBeforeSwapAmount:
                            uint8(stor55.field_160) = 0
                            emit OwnerForcedSwapBack(block.timestamp);
                        if not _liquidityTokensToSwap + sub_432654c4:
                            uint8(stor55.field_160) = 0
                            emit OwnerForcedSwapBack(block.timestamp);
                        if 10 * minimumTokensBeforeSwapAmount and _liquidityTokensToSwap > -1 / 10 * minimumTokensBeforeSwapAmount:
                            revert with 0, 17
                        if not _liquidityTokensToSwap + sub_432654c4:
                            revert with 0, 18
                        _5171 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5171] = 30
                        mem[_5171 + 32] = 'SafeMath: subtraction overflow'
                        if 10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2 > 10 * minimumTokensBeforeSwapAmount:
                            _5191 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _5191 + 68] = mem[idx + _5171 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5191 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5191 + -mem[64] + 100
                        if 10 * minimumTokensBeforeSwapAmount < 10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2:
                            revert with 0, 17
                        _5323 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        mem[_5323 + 32 len 64] = call.data[calldata.size len 64]
                        if 0 >= mem[_5323]:
                            revert with 0, 50
                        mem[_5323 + 32] = this.address
                        staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                gas gas_remaining wei
                        mem[_5323 + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _5323 + ceil32(return_data.size) + 96
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        if 1 >= mem[_5323]:
                            revert with 0, 50
                        mem[_5323 + 64] = ext_call.return_data[12 len 20]
                        if not this.address:
                            revert with 0, 'ERC20: approve from the zero address'
                        if not uniswapV2RouterAddress:
                            revert with 0, 'ERC20: approve to the zero address'
                        mem[0] = uniswapV2RouterAddress
                        mem[32] = sha3(address(this.address), 25)
                        allowance[address(this.address)][stor54] = (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                        emit Approval(((10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)), this.address, uniswapV2RouterAddress);
                        mem[_5323 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                        mem[_5323 + ceil32(return_data.size) + 100] = (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                        mem[_5323 + ceil32(return_data.size) + 132] = 0
                        mem[_5323 + ceil32(return_data.size) + 164] = 160
                        mem[_5323 + ceil32(return_data.size) + 260] = mem[_5323]
                        idx = 0
                        s = _5323 + ceil32(return_data.size) + 292
                        t = _5323 + 32
                        while idx < mem[_5323]:
                            mem[s] = mem[t + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_5323 + ceil32(return_data.size) + 196] = this.address
                        mem[_5323 + ceil32(return_data.size) + 228] = block.timestamp
                        require ext_code.size(uniswapV2RouterAddress)
                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _5323 + ceil32(return_data.size) + (32 * mem[_5323]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6578 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6578] = 30
                        mem[_6578 + 32] = 'SafeMath: subtraction overflow'
                        if eth.balance(this.address) <= eth.balance(this.address):
                            if eth.balance(this.address) < eth.balance(this.address):
                                revert with 0, 17
                            _liquidityTokensToSwap = 0
                            sub_432654c4 = 0
                            uint8(stor55.field_160) = 0
                            emit OwnerForcedSwapBack(block.timestamp);
                        _6610 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _6610 + 68] = mem[idx + _6578 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6610 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _6610 + -mem[64] + 100
                    if idx >= stor30.length:
                        revert with 0, 50
                    mem[0] = stor30[idx]
                    mem[32] = 24
                    if stor24[stor30[idx]] <= s:
                        if idx >= stor30.length:
                            revert with 0, 50
                        mem[0] = stor30[idx]
                        mem[32] = 23
                        _4701 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4701] = 30
                        mem[_4701 + 32] = 'SafeMath: subtraction overflow'
                        if stor23[stor30[idx]] > t:
                            _4738 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _4738 + 68] = mem[idx + _4701 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4738 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4738 + -mem[64] + 100
                        if t < stor23[stor30[idx]]:
                            revert with 0, 17
                        if idx >= stor30.length:
                            revert with 0, 50
                        mem[0] = stor30[idx]
                        mem[32] = 24
                        _4841 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4841] = 30
                        mem[_4841 + 32] = 'SafeMath: subtraction overflow'
                        if stor24[stor30[idx]] <= s:
                            if s < stor24[stor30[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor24[stor30[idx]]
                            t = t - stor23[stor30[idx]]
                            continue 
                        _4907 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _4907 + 68] = mem[idx + _4841 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4907 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _4907 + -mem[64] + 100
                    _4702 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4702] = 26
                    mem[_4702 + 32] = 'SafeMath: division by zero'
                    _4842 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4842] = 26
                    mem[_4842 + 32] = 'SafeMath: division by zero'
                    if not stor31 / 10^15:
                        _4908 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4908 + 68] = mem[idx + _4842 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4908 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4908 + -mem[64] + 100
                    if _liquidityTokensToSwap > !sub_432654c4:
                        revert with 0, 17
                    if minimumTokensBeforeSwapAmount > 0x1999999999999999999999999999999999999999999999999999999999999999:
                        revert with 0, 17
                    if stor23[address(this.address)] / stor31 / 10^15 >= 10 * minimumTokensBeforeSwapAmount:
                        if minimumTokensBeforeSwapAmount > 0x1999999999999999999999999999999999999999999999999999999999999999:
                            revert with 0, 17
                        if 10 * minimumTokensBeforeSwapAmount:
                            if _liquidityTokensToSwap + sub_432654c4:
                                if 10 * minimumTokensBeforeSwapAmount and _liquidityTokensToSwap > -1 / 10 * minimumTokensBeforeSwapAmount:
                                    revert with 0, 17
                                if not _liquidityTokensToSwap + sub_432654c4:
                                    revert with 0, 18
                                _5192 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5192] = 30
                                mem[_5192 + 32] = 'SafeMath: subtraction overflow'
                                if 10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2 > 10 * minimumTokensBeforeSwapAmount:
                                    _5224 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _5224 + 68] = mem[idx + _5192 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5224 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5224 + -mem[64] + 100
                                if 10 * minimumTokensBeforeSwapAmount < 10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2:
                                    revert with 0, 17
                                _5388 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_5388 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_5388]:
                                    revert with 0, 50
                                mem[_5388 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_5388 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _5388 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_5388]:
                                    revert with 0, 50
                                mem[_5388 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                                emit Approval(((10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)), this.address, uniswapV2RouterAddress);
                                mem[_5388 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_5388 + ceil32(return_data.size) + 100] = (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                                mem[_5388 + ceil32(return_data.size) + 132] = 0
                                mem[_5388 + ceil32(return_data.size) + 164] = 160
                                mem[_5388 + ceil32(return_data.size) + 260] = mem[_5388]
                                idx = 0
                                s = _5388 + ceil32(return_data.size) + 292
                                t = _5388 + 32
                                while idx < mem[_5388]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_5388 + ceil32(return_data.size) + 228] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2), 0, 160, address(this.address), block.timestamp, mem[_5388 + ceil32(return_data.size) + 260 len (32 * mem[_5388]) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_5388 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                if eth.balance(this.address) > eth.balance(this.address):
                                    mem[_5388 + ceil32(return_data.size) + 160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_5388 + ceil32(return_data.size) + 164] = 32
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _5388 + ceil32(return_data.size) + 228] = mem[idx + _5388 + ceil32(return_data.size) + 128]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 32, 30, mem[_5388 + ceil32(return_data.size) + 228 len 30], 0
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                _liquidityTokensToSwap = 0
                                sub_432654c4 = 0
                        uint8(stor55.field_160) = 0
                        emit OwnerForcedSwapBack(block.timestamp);
                    if not stor23[address(this.address)] / stor31 / 10^15:
                        uint8(stor55.field_160) = 0
                        emit OwnerForcedSwapBack(block.timestamp);
                    if not _liquidityTokensToSwap + sub_432654c4:
                        uint8(stor55.field_160) = 0
                        emit OwnerForcedSwapBack(block.timestamp);
                    if stor23[address(this.address)] / stor31 / 10^15 and _liquidityTokensToSwap > -1 / stor23[address(this.address)] / stor31 / 10^15:
                        revert with 0, 17
                    if not _liquidityTokensToSwap + sub_432654c4:
                        revert with 0, 18
                    _5144 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5144] = 30
                    mem[_5144 + 32] = 'SafeMath: subtraction overflow'
                    if stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2 > stor23[address(this.address)] / stor31 / 10^15:
                        _5172 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _5172 + 68] = mem[idx + _5144 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5172 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5172 + -mem[64] + 100
                    if stor23[address(this.address)] / stor31 / 10^15 < stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2:
                        revert with 0, 17
                    _5274 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    mem[_5274 + 32 len 64] = call.data[calldata.size len 64]
                    if 0 >= mem[_5274]:
                        revert with 0, 50
                    mem[_5274 + 32] = this.address
                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                            gas gas_remaining wei
                    mem[_5274 + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _5274 + ceil32(return_data.size) + 96
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if 1 >= mem[_5274]:
                        revert with 0, 50
                    mem[_5274 + 64] = ext_call.return_data[12 len 20]
                    if not this.address:
                        revert with 0, 'ERC20: approve from the zero address'
                    if not uniswapV2RouterAddress:
                        revert with 0, 'ERC20: approve to the zero address'
                    mem[0] = uniswapV2RouterAddress
                    mem[32] = sha3(address(this.address), 25)
                    allowance[address(this.address)][stor54] = (stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                    emit Approval(((stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)), this.address, uniswapV2RouterAddress);
                    mem[_5274 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                    mem[_5274 + ceil32(return_data.size) + 100] = (stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                    mem[_5274 + ceil32(return_data.size) + 132] = 0
                    mem[_5274 + ceil32(return_data.size) + 164] = 160
                    mem[_5274 + ceil32(return_data.size) + 260] = mem[_5274]
                    idx = 0
                    s = _5274 + ceil32(return_data.size) + 292
                    t = _5274 + 32
                    while idx < mem[_5274]:
                        mem[s] = mem[t + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_5274 + ceil32(return_data.size) + 196] = this.address
                    mem[_5274 + ceil32(return_data.size) + 228] = block.timestamp
                    require ext_code.size(uniswapV2RouterAddress)
                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _5274 + ceil32(return_data.size) + (32 * mem[_5274]) + -mem[64] + 288]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _6579 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6579] = 30
                    mem[_6579 + 32] = 'SafeMath: subtraction overflow'
                    if eth.balance(this.address) <= eth.balance(this.address):
                        if eth.balance(this.address) < eth.balance(this.address):
                            revert with 0, 17
                        _liquidityTokensToSwap = 0
                        sub_432654c4 = 0
                        uint8(stor55.field_160) = 0
                        emit OwnerForcedSwapBack(block.timestamp);
                    _6611 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _6611 + 68] = mem[idx + _6579 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6611 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _6611 + -mem[64] + 100
                _4574 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4574] = 26
                mem[_4574 + 32] = 'SafeMath: division by zero'
                if t < stor31 / 10^15:
                    _4764 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4764] = 26
                    mem[_4764 + 32] = 'SafeMath: division by zero'
                    _4948 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4948] = 26
                    mem[_4948 + 32] = 'SafeMath: division by zero'
                    if not stor31 / 10^15:
                        revert with 0, 'SafeMath: division by zero', 0
                    if _liquidityTokensToSwap > !sub_432654c4:
                        revert with 0, 17
                    if minimumTokensBeforeSwapAmount > 0x1999999999999999999999999999999999999999999999999999999999999999:
                        revert with 0, 17
                    if stor23[address(this.address)] / stor31 / 10^15 < 10 * minimumTokensBeforeSwapAmount:
                        if stor23[address(this.address)] / stor31 / 10^15:
                            if _liquidityTokensToSwap + sub_432654c4:
                                if stor23[address(this.address)] / stor31 / 10^15 and _liquidityTokensToSwap > -1 / stor23[address(this.address)] / stor31 / 10^15:
                                    revert with 0, 17
                                if not _liquidityTokensToSwap + sub_432654c4:
                                    revert with 0, 18
                                _5190 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5190] = 30
                                mem[_5190 + 32] = 'SafeMath: subtraction overflow'
                                if stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2 > stor23[address(this.address)] / stor31 / 10^15:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor23[address(this.address)] / stor31 / 10^15 < stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2:
                                    revert with 0, 17
                                _5383 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_5383 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_5383]:
                                    revert with 0, 50
                                mem[_5383 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_5383 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _5383 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_5383]:
                                    revert with 0, 50
                                mem[_5383 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = (stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                                emit Approval(((stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)), this.address, uniswapV2RouterAddress);
                                mem[_5383 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_5383 + ceil32(return_data.size) + 100] = (stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                                mem[_5383 + ceil32(return_data.size) + 132] = 0
                                mem[_5383 + ceil32(return_data.size) + 164] = 160
                                mem[_5383 + ceil32(return_data.size) + 260] = mem[_5383]
                                idx = 0
                                s = _5383 + ceil32(return_data.size) + 292
                                t = _5383 + 32
                                while idx < mem[_5383]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args (stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2), 0, 160, address(this.address), block.timestamp, mem[_5383 + ceil32(return_data.size) + 260 len (32 * mem[_5383]) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if eth.balance(this.address) > eth.balance(this.address):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                _liquidityTokensToSwap = 0
                                sub_432654c4 = 0
                    else:
                        if minimumTokensBeforeSwapAmount > 0x1999999999999999999999999999999999999999999999999999999999999999:
                            revert with 0, 17
                        if 10 * minimumTokensBeforeSwapAmount:
                            if _liquidityTokensToSwap + sub_432654c4:
                                if 10 * minimumTokensBeforeSwapAmount and _liquidityTokensToSwap > -1 / 10 * minimumTokensBeforeSwapAmount:
                                    revert with 0, 17
                                if not _liquidityTokensToSwap + sub_432654c4:
                                    revert with 0, 18
                                _5272 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5272] = 30
                                mem[_5272 + 32] = 'SafeMath: subtraction overflow'
                                if 10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2 > 10 * minimumTokensBeforeSwapAmount:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 10 * minimumTokensBeforeSwapAmount < 10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2:
                                    revert with 0, 17
                                _5488 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_5488 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_5488]:
                                    revert with 0, 50
                                mem[_5488 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_5488 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _5488 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_5488]:
                                    revert with 0, 50
                                mem[_5488 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                                emit Approval(((10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)), this.address, uniswapV2RouterAddress);
                                mem[_5488 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_5488 + ceil32(return_data.size) + 100] = (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                                mem[_5488 + ceil32(return_data.size) + 132] = 0
                                mem[_5488 + ceil32(return_data.size) + 164] = 160
                                mem[_5488 + ceil32(return_data.size) + 260] = mem[_5488]
                                idx = 0
                                s = _5488 + ceil32(return_data.size) + 292
                                t = _5488 + 32
                                while idx < mem[_5488]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2), 0, 160, address(this.address), block.timestamp, mem[_5488 + ceil32(return_data.size) + 260 len (32 * mem[_5488]) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if eth.balance(this.address) > eth.balance(this.address):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                _liquidityTokensToSwap = 0
                                sub_432654c4 = 0
                else:
                    _4763 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4763] = 26
                    mem[_4763 + 32] = 'SafeMath: division by zero'
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    _4947 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4947] = 26
                    mem[_4947 + 32] = 'SafeMath: division by zero'
                    if not t / s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if _liquidityTokensToSwap > !sub_432654c4:
                        revert with 0, 17
                    if minimumTokensBeforeSwapAmount > 0x1999999999999999999999999999999999999999999999999999999999999999:
                        revert with 0, 17
                    if stor23[address(this.address)] / t / s >= 10 * minimumTokensBeforeSwapAmount:
                        if minimumTokensBeforeSwapAmount > 0x1999999999999999999999999999999999999999999999999999999999999999:
                            revert with 0, 17
                        if 10 * minimumTokensBeforeSwapAmount:
                            if _liquidityTokensToSwap + sub_432654c4:
                                if 10 * minimumTokensBeforeSwapAmount and _liquidityTokensToSwap > -1 / 10 * minimumTokensBeforeSwapAmount:
                                    revert with 0, 17
                                if not _liquidityTokensToSwap + sub_432654c4:
                                    revert with 0, 18
                                _5271 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5271] = 30
                                mem[_5271 + 32] = 'SafeMath: subtraction overflow'
                                if 10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2 > 10 * minimumTokensBeforeSwapAmount:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 10 * minimumTokensBeforeSwapAmount < 10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2:
                                    revert with 0, 17
                                _5484 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_5484 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_5484]:
                                    revert with 0, 50
                                mem[_5484 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_5484 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _5484 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_5484]:
                                    revert with 0, 50
                                mem[_5484 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                                emit Approval(((10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)), this.address, uniswapV2RouterAddress);
                                mem[_5484 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_5484 + ceil32(return_data.size) + 100] = (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                                mem[_5484 + ceil32(return_data.size) + 132] = 0
                                mem[_5484 + ceil32(return_data.size) + 164] = 160
                                mem[_5484 + ceil32(return_data.size) + 260] = mem[_5484]
                                idx = 0
                                s = _5484 + ceil32(return_data.size) + 292
                                t = _5484 + 32
                                while idx < mem[_5484]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2), 0, 160, address(this.address), block.timestamp, mem[_5484 + ceil32(return_data.size) + 260 len (32 * mem[_5484]) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if eth.balance(this.address) > eth.balance(this.address):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                _liquidityTokensToSwap = 0
                                sub_432654c4 = 0
                    else:
                        if stor23[address(this.address)] / t / s:
                            if _liquidityTokensToSwap + sub_432654c4:
                                if stor23[address(this.address)] / t / s and _liquidityTokensToSwap > -1 / stor23[address(this.address)] / t / s:
                                    revert with 0, 17
                                if not _liquidityTokensToSwap + sub_432654c4:
                                    revert with 0, 18
                                _5189 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5189] = 30
                                mem[_5189 + 32] = 'SafeMath: subtraction overflow'
                                if stor23[address(this.address)] / t / s * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2 > stor23[address(this.address)] / t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor23[address(this.address)] / t / s < stor23[address(this.address)] / t / s * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2:
                                    revert with 0, 17
                                _5380 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_5380 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_5380]:
                                    revert with 0, 50
                                mem[_5380 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_5380 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _5380 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_5380]:
                                    revert with 0, 50
                                mem[_5380 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = (stor23[address(this.address)] / t / s) - (stor23[address(this.address)] / t / s * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                                emit Approval(((stor23[address(this.address)] / t / s) - (stor23[address(this.address)] / t / s * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)), this.address, uniswapV2RouterAddress);
                                mem[_5380 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_5380 + ceil32(return_data.size) + 100] = (stor23[address(this.address)] / t / s) - (stor23[address(this.address)] / t / s * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                                mem[_5380 + ceil32(return_data.size) + 132] = 0
                                mem[_5380 + ceil32(return_data.size) + 164] = 160
                                mem[_5380 + ceil32(return_data.size) + 260] = mem[_5380]
                                idx = 0
                                u = _5380 + ceil32(return_data.size) + 292
                                v = _5380 + 32
                                while idx < mem[_5380]:
                                    mem[u] = mem[v + 12 len 20]
                                    idx = idx + 1
                                    u = u + 32
                                    v = v + 32
                                    continue 
                                mem[_5380 + ceil32(return_data.size) + 196] = this.address
                                mem[_5380 + ceil32(return_data.size) + 228] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _5380 + ceil32(return_data.size) + (32 * mem[_5380]) + -mem[64] + 288]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if eth.balance(this.address) > eth.balance(this.address):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                _liquidityTokensToSwap = 0
                                sub_432654c4 = 0
        else:
            _2329 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2329] = 26
            mem[_2329 + 32] = 'SafeMath: division by zero'
            if not s:
                revert with 0, 'SafeMath: division by zero', 0
            _2385 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2385] = 26
            mem[_2385 + 32] = 'SafeMath: division by zero'
            if not t / s:
                revert with 0, 'SafeMath: division by zero', 0
            if stor23[address(this.address)] / t / s < 10^11:
                revert with 0, 'Can only swap back if more than .01% of tokens stuck on contract'
            uint8(stor55.field_160) = 1
            mem[0] = this.address
            if stor29[address(this.address)]:
                mem[32] = 24
                if _liquidityTokensToSwap > !sub_432654c4:
                    revert with 0, 17
                if minimumTokensBeforeSwapAmount > 0x1999999999999999999999999999999999999999999999999999999999999999:
                    revert with 0, 17
                if stor24[address(this.address)] < 10 * minimumTokensBeforeSwapAmount:
                    if stor24[address(this.address)]:
                        if _liquidityTokensToSwap + sub_432654c4:
                            if stor24[address(this.address)] and _liquidityTokensToSwap > -1 / stor24[address(this.address)]:
                                revert with 0, 17
                            if not _liquidityTokensToSwap + sub_432654c4:
                                revert with 0, 18
                            _2673 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2673] = 30
                            mem[_2673 + 32] = 'SafeMath: subtraction overflow'
                            if stor24[address(this.address)] * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2 > stor24[address(this.address)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor24[address(this.address)] < stor24[address(this.address)] * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2:
                                revert with 0, 17
                            _2850 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_2850 + 32 len 64] = call.data[calldata.size len 64]
                            if 0 >= mem[_2850]:
                                revert with 0, 50
                            mem[_2850 + 32] = this.address
                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                    gas gas_remaining wei
                            mem[_2850 + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _2850 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            if 1 >= mem[_2850]:
                                revert with 0, 50
                            mem[_2850 + 64] = ext_call.return_data[12 len 20]
                            if not this.address:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not uniswapV2RouterAddress:
                                revert with 0, 'ERC20: approve to the zero address'
                            mem[0] = uniswapV2RouterAddress
                            mem[32] = sha3(address(this.address), 25)
                            allowance[address(this.address)][stor54] = stor24[address(this.address)] - (stor24[address(this.address)] * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                            emit Approval((stor24[address(this.address)] - (stor24[address(this.address)] * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)), this.address, uniswapV2RouterAddress);
                            mem[_2850 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                            mem[_2850 + ceil32(return_data.size) + 100] = stor24[address(this.address)] - (stor24[address(this.address)] * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                            mem[_2850 + ceil32(return_data.size) + 132] = 0
                            mem[_2850 + ceil32(return_data.size) + 164] = 160
                            mem[_2850 + ceil32(return_data.size) + 260] = mem[_2850]
                            idx = 0
                            s = _2850 + ceil32(return_data.size) + 292
                            t = _2850 + 32
                            while idx < mem[_2850]:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(uniswapV2RouterAddress)
                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args stor24[address(this.address)] - (stor24[address(this.address)] * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2), 0, 160, address(this.address), block.timestamp, mem[_2850 + ceil32(return_data.size) + 260 len (32 * mem[_2850]) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if eth.balance(this.address) > eth.balance(this.address):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if eth.balance(this.address) < eth.balance(this.address):
                                revert with 0, 17
                            _liquidityTokensToSwap = 0
                            sub_432654c4 = 0
                else:
                    if minimumTokensBeforeSwapAmount > 0x1999999999999999999999999999999999999999999999999999999999999999:
                        revert with 0, 17
                    if 10 * minimumTokensBeforeSwapAmount:
                        if _liquidityTokensToSwap + sub_432654c4:
                            if 10 * minimumTokensBeforeSwapAmount and _liquidityTokensToSwap > -1 / 10 * minimumTokensBeforeSwapAmount:
                                revert with 0, 17
                            if not _liquidityTokensToSwap + sub_432654c4:
                                revert with 0, 18
                            _2760 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2760] = 30
                            mem[_2760 + 32] = 'SafeMath: subtraction overflow'
                            if 10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2 > 10 * minimumTokensBeforeSwapAmount:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 10 * minimumTokensBeforeSwapAmount < 10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2:
                                revert with 0, 17
                            _2924 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_2924 + 32 len 64] = call.data[calldata.size len 64]
                            if 0 >= mem[_2924]:
                                revert with 0, 50
                            mem[_2924 + 32] = this.address
                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                    gas gas_remaining wei
                            mem[_2924 + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _2924 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            if 1 >= mem[_2924]:
                                revert with 0, 50
                            mem[_2924 + 64] = ext_call.return_data[12 len 20]
                            if not this.address:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not uniswapV2RouterAddress:
                                revert with 0, 'ERC20: approve to the zero address'
                            mem[0] = uniswapV2RouterAddress
                            mem[32] = sha3(address(this.address), 25)
                            allowance[address(this.address)][stor54] = (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                            emit Approval(((10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)), this.address, uniswapV2RouterAddress);
                            mem[_2924 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                            mem[_2924 + ceil32(return_data.size) + 100] = (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                            mem[_2924 + ceil32(return_data.size) + 132] = 0
                            mem[_2924 + ceil32(return_data.size) + 164] = 160
                            mem[_2924 + ceil32(return_data.size) + 260] = mem[_2924]
                            idx = 0
                            s = _2924 + ceil32(return_data.size) + 292
                            t = _2924 + 32
                            while idx < mem[_2924]:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(uniswapV2RouterAddress)
                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2), 0, 160, address(this.address), block.timestamp, mem[_2924 + ceil32(return_data.size) + 260 len (32 * mem[_2924]) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if eth.balance(this.address) > eth.balance(this.address):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if eth.balance(this.address) < eth.balance(this.address):
                                revert with 0, 17
                            _liquidityTokensToSwap = 0
                            sub_432654c4 = 0
            else:
                mem[32] = 23
                if stor23[address(this.address)] > stor31:
                    revert with 0, 'Amount must be less than total reflections'
                idx = 0
                s = 10^15
                t = stor31
                while idx < stor30.length:
                    mem[0] = stor30[idx]
                    mem[32] = 23
                    if stor23[stor30[idx]] > t:
                        _4669 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4669] = 26
                        mem[_4669 + 32] = 'SafeMath: division by zero'
                        _4810 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4810] = 26
                        mem[_4810 + 32] = 'SafeMath: division by zero'
                        if not stor31 / 10^15:
                            _4834 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4834 + 68] = mem[idx + _4810 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4834 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _4834 + -mem[64] + 100
                        if _liquidityTokensToSwap > !sub_432654c4:
                            revert with 0, 17
                        if minimumTokensBeforeSwapAmount > 0x1999999999999999999999999999999999999999999999999999999999999999:
                            revert with 0, 17
                        if stor23[address(this.address)] / stor31 / 10^15 < 10 * minimumTokensBeforeSwapAmount:
                            if stor23[address(this.address)] / stor31 / 10^15:
                                if _liquidityTokensToSwap + sub_432654c4:
                                    if stor23[address(this.address)] / stor31 / 10^15 and _liquidityTokensToSwap > -1 / stor23[address(this.address)] / stor31 / 10^15:
                                        revert with 0, 17
                                    if not _liquidityTokensToSwap + sub_432654c4:
                                        revert with 0, 18
                                    _5121 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5121] = 30
                                    mem[_5121 + 32] = 'SafeMath: subtraction overflow'
                                    if stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2 > stor23[address(this.address)] / stor31 / 10^15:
                                        _5137 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _5137 + 68] = mem[idx + _5121 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_5137 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _5137 + -mem[64] + 100
                                    if stor23[address(this.address)] / stor31 / 10^15 < stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2:
                                        revert with 0, 17
                                    _5215 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_5215 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_5215]:
                                        revert with 0, 50
                                    mem[_5215 + 32] = this.address
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_5215 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _5215 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_5215]:
                                        revert with 0, 50
                                    mem[_5215 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 25)
                                    allowance[address(this.address)][stor54] = (stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                                    emit Approval(((stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)), this.address, uniswapV2RouterAddress);
                                    mem[_5215 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_5215 + ceil32(return_data.size) + 100] = (stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                                    mem[_5215 + ceil32(return_data.size) + 132] = 0
                                    mem[_5215 + ceil32(return_data.size) + 164] = 160
                                    mem[_5215 + ceil32(return_data.size) + 260] = mem[_5215]
                                    idx = 0
                                    s = _5215 + ceil32(return_data.size) + 292
                                    t = _5215 + 32
                                    while idx < mem[_5215]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5215 + ceil32(return_data.size) + 228] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args (stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2), 0, 160, address(this.address), block.timestamp, mem[_5215 + ceil32(return_data.size) + 260 len (32 * mem[_5215]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_5215 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        mem[_5215 + ceil32(return_data.size) + 160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[_5215 + ceil32(return_data.size) + 164] = 32
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _5215 + ceil32(return_data.size) + 228] = mem[idx + _5215 + ceil32(return_data.size) + 128]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 32, 30, mem[_5215 + ceil32(return_data.size) + 228 len 30], 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    _liquidityTokensToSwap = 0
                                    sub_432654c4 = 0
                            uint8(stor55.field_160) = 0
                            emit OwnerForcedSwapBack(block.timestamp);
                        if minimumTokensBeforeSwapAmount > 0x1999999999999999999999999999999999999999999999999999999999999999:
                            revert with 0, 17
                        if not 10 * minimumTokensBeforeSwapAmount:
                            uint8(stor55.field_160) = 0
                            emit OwnerForcedSwapBack(block.timestamp);
                        if not _liquidityTokensToSwap + sub_432654c4:
                            uint8(stor55.field_160) = 0
                            emit OwnerForcedSwapBack(block.timestamp);
                        if 10 * minimumTokensBeforeSwapAmount and _liquidityTokensToSwap > -1 / 10 * minimumTokensBeforeSwapAmount:
                            revert with 0, 17
                        if not _liquidityTokensToSwap + sub_432654c4:
                            revert with 0, 18
                        _5169 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5169] = 30
                        mem[_5169 + 32] = 'SafeMath: subtraction overflow'
                        if 10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2 > 10 * minimumTokensBeforeSwapAmount:
                            _5187 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _5187 + 68] = mem[idx + _5169 + 32]
                                idx = idx + 32
                                continue 
                            mem[_5187 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _5187 + -mem[64] + 100
                        if 10 * minimumTokensBeforeSwapAmount < 10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2:
                            revert with 0, 17
                        _5316 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        mem[_5316 + 32 len 64] = call.data[calldata.size len 64]
                        if 0 >= mem[_5316]:
                            revert with 0, 50
                        mem[_5316 + 32] = this.address
                        staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                gas gas_remaining wei
                        mem[_5316 + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _5316 + ceil32(return_data.size) + 96
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        if 1 >= mem[_5316]:
                            revert with 0, 50
                        mem[_5316 + 64] = ext_call.return_data[12 len 20]
                        if not this.address:
                            revert with 0, 'ERC20: approve from the zero address'
                        if not uniswapV2RouterAddress:
                            revert with 0, 'ERC20: approve to the zero address'
                        mem[0] = uniswapV2RouterAddress
                        mem[32] = sha3(address(this.address), 25)
                        allowance[address(this.address)][stor54] = (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                        emit Approval(((10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)), this.address, uniswapV2RouterAddress);
                        mem[_5316 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                        mem[_5316 + ceil32(return_data.size) + 100] = (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                        mem[_5316 + ceil32(return_data.size) + 132] = 0
                        mem[_5316 + ceil32(return_data.size) + 164] = 160
                        mem[_5316 + ceil32(return_data.size) + 260] = mem[_5316]
                        idx = 0
                        s = _5316 + ceil32(return_data.size) + 292
                        t = _5316 + 32
                        while idx < mem[_5316]:
                            mem[s] = mem[t + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_5316 + ceil32(return_data.size) + 196] = this.address
                        mem[_5316 + ceil32(return_data.size) + 228] = block.timestamp
                        require ext_code.size(uniswapV2RouterAddress)
                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _5316 + ceil32(return_data.size) + (32 * mem[_5316]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6570 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6570] = 30
                        mem[_6570 + 32] = 'SafeMath: subtraction overflow'
                        if eth.balance(this.address) <= eth.balance(this.address):
                            if eth.balance(this.address) < eth.balance(this.address):
                                revert with 0, 17
                            _liquidityTokensToSwap = 0
                            sub_432654c4 = 0
                            uint8(stor55.field_160) = 0
                            emit OwnerForcedSwapBack(block.timestamp);
                        _6602 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _6602 + 68] = mem[idx + _6570 + 32]
                            idx = idx + 32
                            continue 
                        mem[_6602 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _6602 + -mem[64] + 100
                    if idx >= stor30.length:
                        revert with 0, 50
                    mem[0] = stor30[idx]
                    mem[32] = 24
                    if stor24[stor30[idx]] <= s:
                        if idx >= stor30.length:
                            revert with 0, 50
                        mem[0] = stor30[idx]
                        mem[32] = 23
                        _4697 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4697] = 30
                        mem[_4697 + 32] = 'SafeMath: subtraction overflow'
                        if stor23[stor30[idx]] > t:
                            _4737 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _4737 + 68] = mem[idx + _4697 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4737 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4737 + -mem[64] + 100
                        if t < stor23[stor30[idx]]:
                            revert with 0, 17
                        if idx >= stor30.length:
                            revert with 0, 50
                        mem[0] = stor30[idx]
                        mem[32] = 24
                        _4835 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4835] = 30
                        mem[_4835 + 32] = 'SafeMath: subtraction overflow'
                        if stor24[stor30[idx]] <= s:
                            if s < stor24[stor30[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor24[stor30[idx]]
                            t = t - stor23[stor30[idx]]
                            continue 
                        _4902 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _4902 + 68] = mem[idx + _4835 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4902 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _4902 + -mem[64] + 100
                    _4698 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4698] = 26
                    mem[_4698 + 32] = 'SafeMath: division by zero'
                    _4836 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4836] = 26
                    mem[_4836 + 32] = 'SafeMath: division by zero'
                    if not stor31 / 10^15:
                        _4903 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4903 + 68] = mem[idx + _4836 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4903 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4903 + -mem[64] + 100
                    if _liquidityTokensToSwap > !sub_432654c4:
                        revert with 0, 17
                    if minimumTokensBeforeSwapAmount > 0x1999999999999999999999999999999999999999999999999999999999999999:
                        revert with 0, 17
                    if stor23[address(this.address)] / stor31 / 10^15 >= 10 * minimumTokensBeforeSwapAmount:
                        if minimumTokensBeforeSwapAmount > 0x1999999999999999999999999999999999999999999999999999999999999999:
                            revert with 0, 17
                        if 10 * minimumTokensBeforeSwapAmount:
                            if _liquidityTokensToSwap + sub_432654c4:
                                if 10 * minimumTokensBeforeSwapAmount and _liquidityTokensToSwap > -1 / 10 * minimumTokensBeforeSwapAmount:
                                    revert with 0, 17
                                if not _liquidityTokensToSwap + sub_432654c4:
                                    revert with 0, 18
                                _5188 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5188] = 30
                                mem[_5188 + 32] = 'SafeMath: subtraction overflow'
                                if 10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2 > 10 * minimumTokensBeforeSwapAmount:
                                    _5218 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _5218 + 68] = mem[idx + _5188 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5218 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5218 + -mem[64] + 100
                                if 10 * minimumTokensBeforeSwapAmount < 10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2:
                                    revert with 0, 17
                                _5377 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_5377 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_5377]:
                                    revert with 0, 50
                                mem[_5377 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_5377 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _5377 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_5377]:
                                    revert with 0, 50
                                mem[_5377 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                                emit Approval(((10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)), this.address, uniswapV2RouterAddress);
                                mem[_5377 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_5377 + ceil32(return_data.size) + 100] = (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                                mem[_5377 + ceil32(return_data.size) + 132] = 0
                                mem[_5377 + ceil32(return_data.size) + 164] = 160
                                mem[_5377 + ceil32(return_data.size) + 260] = mem[_5377]
                                idx = 0
                                s = _5377 + ceil32(return_data.size) + 292
                                t = _5377 + 32
                                while idx < mem[_5377]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_5377 + ceil32(return_data.size) + 228] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2), 0, 160, address(this.address), block.timestamp, mem[_5377 + ceil32(return_data.size) + 260 len (32 * mem[_5377]) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_5377 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                if eth.balance(this.address) > eth.balance(this.address):
                                    mem[_5377 + ceil32(return_data.size) + 160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_5377 + ceil32(return_data.size) + 164] = 32
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _5377 + ceil32(return_data.size) + 228] = mem[idx + _5377 + ceil32(return_data.size) + 128]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 32, 30, mem[_5377 + ceil32(return_data.size) + 228 len 30], 0
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                _liquidityTokensToSwap = 0
                                sub_432654c4 = 0
                        uint8(stor55.field_160) = 0
                        emit OwnerForcedSwapBack(block.timestamp);
                    if not stor23[address(this.address)] / stor31 / 10^15:
                        uint8(stor55.field_160) = 0
                        emit OwnerForcedSwapBack(block.timestamp);
                    if not _liquidityTokensToSwap + sub_432654c4:
                        uint8(stor55.field_160) = 0
                        emit OwnerForcedSwapBack(block.timestamp);
                    if stor23[address(this.address)] / stor31 / 10^15 and _liquidityTokensToSwap > -1 / stor23[address(this.address)] / stor31 / 10^15:
                        revert with 0, 17
                    if not _liquidityTokensToSwap + sub_432654c4:
                        revert with 0, 18
                    _5138 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5138] = 30
                    mem[_5138 + 32] = 'SafeMath: subtraction overflow'
                    if stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2 > stor23[address(this.address)] / stor31 / 10^15:
                        _5170 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _5170 + 68] = mem[idx + _5138 + 32]
                            idx = idx + 32
                            continue 
                        mem[_5170 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5170 + -mem[64] + 100
                    if stor23[address(this.address)] / stor31 / 10^15 < stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2:
                        revert with 0, 17
                    _5268 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    mem[_5268 + 32 len 64] = call.data[calldata.size len 64]
                    if 0 >= mem[_5268]:
                        revert with 0, 50
                    mem[_5268 + 32] = this.address
                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                            gas gas_remaining wei
                    mem[_5268 + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _5268 + ceil32(return_data.size) + 96
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if 1 >= mem[_5268]:
                        revert with 0, 50
                    mem[_5268 + 64] = ext_call.return_data[12 len 20]
                    if not this.address:
                        revert with 0, 'ERC20: approve from the zero address'
                    if not uniswapV2RouterAddress:
                        revert with 0, 'ERC20: approve to the zero address'
                    mem[0] = uniswapV2RouterAddress
                    mem[32] = sha3(address(this.address), 25)
                    allowance[address(this.address)][stor54] = (stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                    emit Approval(((stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)), this.address, uniswapV2RouterAddress);
                    mem[_5268 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                    mem[_5268 + ceil32(return_data.size) + 100] = (stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                    mem[_5268 + ceil32(return_data.size) + 132] = 0
                    mem[_5268 + ceil32(return_data.size) + 164] = 160
                    mem[_5268 + ceil32(return_data.size) + 260] = mem[_5268]
                    idx = 0
                    s = _5268 + ceil32(return_data.size) + 292
                    t = _5268 + 32
                    while idx < mem[_5268]:
                        mem[s] = mem[t + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_5268 + ceil32(return_data.size) + 196] = this.address
                    mem[_5268 + ceil32(return_data.size) + 228] = block.timestamp
                    require ext_code.size(uniswapV2RouterAddress)
                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _5268 + ceil32(return_data.size) + (32 * mem[_5268]) + -mem[64] + 288]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _6571 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6571] = 30
                    mem[_6571 + 32] = 'SafeMath: subtraction overflow'
                    if eth.balance(this.address) <= eth.balance(this.address):
                        if eth.balance(this.address) < eth.balance(this.address):
                            revert with 0, 17
                        _liquidityTokensToSwap = 0
                        sub_432654c4 = 0
                        uint8(stor55.field_160) = 0
                        emit OwnerForcedSwapBack(block.timestamp);
                    _6603 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _6603 + 68] = mem[idx + _6571 + 32]
                        idx = idx + 32
                        continue 
                    mem[_6603 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _6603 + -mem[64] + 100
                _4569 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4569] = 26
                mem[_4569 + 32] = 'SafeMath: division by zero'
                if t < stor31 / 10^15:
                    _4762 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4762] = 26
                    mem[_4762 + 32] = 'SafeMath: division by zero'
                    _4946 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4946] = 26
                    mem[_4946 + 32] = 'SafeMath: division by zero'
                    if not stor31 / 10^15:
                        revert with 0, 'SafeMath: division by zero', 0
                    if _liquidityTokensToSwap > !sub_432654c4:
                        revert with 0, 17
                    if minimumTokensBeforeSwapAmount > 0x1999999999999999999999999999999999999999999999999999999999999999:
                        revert with 0, 17
                    if stor23[address(this.address)] / stor31 / 10^15 >= 10 * minimumTokensBeforeSwapAmount:
                        if minimumTokensBeforeSwapAmount > 0x1999999999999999999999999999999999999999999999999999999999999999:
                            revert with 0, 17
                        if 10 * minimumTokensBeforeSwapAmount:
                            if _liquidityTokensToSwap + sub_432654c4:
                                if 10 * minimumTokensBeforeSwapAmount and _liquidityTokensToSwap > -1 / 10 * minimumTokensBeforeSwapAmount:
                                    revert with 0, 17
                                if not _liquidityTokensToSwap + sub_432654c4:
                                    revert with 0, 18
                                _5266 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5266] = 30
                                mem[_5266 + 32] = 'SafeMath: subtraction overflow'
                                if 10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2 > 10 * minimumTokensBeforeSwapAmount:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 10 * minimumTokensBeforeSwapAmount < 10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2:
                                    revert with 0, 17
                                _5478 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_5478 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_5478]:
                                    revert with 0, 50
                                mem[_5478 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_5478 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _5478 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_5478]:
                                    revert with 0, 50
                                mem[_5478 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                                emit Approval(((10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)), this.address, uniswapV2RouterAddress);
                                mem[_5478 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_5478 + ceil32(return_data.size) + 100] = (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                                mem[_5478 + ceil32(return_data.size) + 132] = 0
                                mem[_5478 + ceil32(return_data.size) + 164] = 160
                                mem[_5478 + ceil32(return_data.size) + 260] = mem[_5478]
                                idx = 0
                                s = _5478 + ceil32(return_data.size) + 292
                                t = _5478 + 32
                                while idx < mem[_5478]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2), 0, 160, address(this.address), block.timestamp, mem[_5478 + ceil32(return_data.size) + 260 len (32 * mem[_5478]) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if eth.balance(this.address) > eth.balance(this.address):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                _liquidityTokensToSwap = 0
                                sub_432654c4 = 0
                    else:
                        if stor23[address(this.address)] / stor31 / 10^15:
                            if _liquidityTokensToSwap + sub_432654c4:
                                if stor23[address(this.address)] / stor31 / 10^15 and _liquidityTokensToSwap > -1 / stor23[address(this.address)] / stor31 / 10^15:
                                    revert with 0, 17
                                if not _liquidityTokensToSwap + sub_432654c4:
                                    revert with 0, 18
                                _5186 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5186] = 30
                                mem[_5186 + 32] = 'SafeMath: subtraction overflow'
                                if stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2 > stor23[address(this.address)] / stor31 / 10^15:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor23[address(this.address)] / stor31 / 10^15 < stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2:
                                    revert with 0, 17
                                _5372 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_5372 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_5372]:
                                    revert with 0, 50
                                mem[_5372 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_5372 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _5372 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_5372]:
                                    revert with 0, 50
                                mem[_5372 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = (stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                                emit Approval(((stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)), this.address, uniswapV2RouterAddress);
                                mem[_5372 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_5372 + ceil32(return_data.size) + 100] = (stor23[address(this.address)] / stor31 / 10^15) - (stor23[address(this.address)] / stor31 / 10^15 * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                                mem[_5372 + ceil32(return_data.size) + 132] = 0
                                mem[_5372 + ceil32(return_data.size) + 164] = 160
                                mem[_5372 + ceil32(return_data.size) + 260] = mem[_5372]
                                idx = 0
                                s = _5372 + ceil32(return_data.size) + 292
                                t = _5372 + 32
                                while idx < mem[_5372]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_5372 + ceil32(return_data.size) + 196] = this.address
                                mem[_5372 + ceil32(return_data.size) + 228] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _5372 + ceil32(return_data.size) + (32 * mem[_5372]) + -mem[64] + 288]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if eth.balance(this.address) > eth.balance(this.address):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                _liquidityTokensToSwap = 0
                                sub_432654c4 = 0
                else:
                    _4761 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4761] = 26
                    mem[_4761 + 32] = 'SafeMath: division by zero'
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    _4945 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4945] = 26
                    mem[_4945 + 32] = 'SafeMath: division by zero'
                    if not t / s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if _liquidityTokensToSwap > !sub_432654c4:
                        revert with 0, 17
                    if minimumTokensBeforeSwapAmount > 0x1999999999999999999999999999999999999999999999999999999999999999:
                        revert with 0, 17
                    if stor23[address(this.address)] / t / s < 10 * minimumTokensBeforeSwapAmount:
                        if stor23[address(this.address)] / t / s:
                            if _liquidityTokensToSwap + sub_432654c4:
                                if stor23[address(this.address)] / t / s and _liquidityTokensToSwap > -1 / stor23[address(this.address)] / t / s:
                                    revert with 0, 17
                                if not _liquidityTokensToSwap + sub_432654c4:
                                    revert with 0, 18
                                _5185 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5185] = 30
                                mem[_5185 + 32] = 'SafeMath: subtraction overflow'
                                if stor23[address(this.address)] / t / s * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2 > stor23[address(this.address)] / t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor23[address(this.address)] / t / s < stor23[address(this.address)] / t / s * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2:
                                    revert with 0, 17
                                _5369 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_5369 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_5369]:
                                    revert with 0, 50
                                mem[_5369 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_5369 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _5369 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_5369]:
                                    revert with 0, 50
                                mem[_5369 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = (stor23[address(this.address)] / t / s) - (stor23[address(this.address)] / t / s * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                                emit Approval(((stor23[address(this.address)] / t / s) - (stor23[address(this.address)] / t / s * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)), this.address, uniswapV2RouterAddress);
                                mem[_5369 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_5369 + ceil32(return_data.size) + 100] = (stor23[address(this.address)] / t / s) - (stor23[address(this.address)] / t / s * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                                mem[_5369 + ceil32(return_data.size) + 132] = 0
                                mem[_5369 + ceil32(return_data.size) + 164] = 160
                                mem[_5369 + ceil32(return_data.size) + 260] = mem[_5369]
                                idx = 0
                                u = _5369 + ceil32(return_data.size) + 292
                                v = _5369 + 32
                                while idx < mem[_5369]:
                                    mem[u] = mem[v + 12 len 20]
                                    idx = idx + 1
                                    u = u + 32
                                    v = v + 32
                                    continue 
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args (stor23[address(this.address)] / t / s) - (stor23[address(this.address)] / t / s * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2), 0, 160, address(this.address), block.timestamp, mem[_5369 + ceil32(return_data.size) + 260 len (32 * mem[_5369]) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if eth.balance(this.address) > eth.balance(this.address):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                _liquidityTokensToSwap = 0
                                sub_432654c4 = 0
                    else:
                        if minimumTokensBeforeSwapAmount > 0x1999999999999999999999999999999999999999999999999999999999999999:
                            revert with 0, 17
                        if 10 * minimumTokensBeforeSwapAmount:
                            if _liquidityTokensToSwap + sub_432654c4:
                                if 10 * minimumTokensBeforeSwapAmount and _liquidityTokensToSwap > -1 / 10 * minimumTokensBeforeSwapAmount:
                                    revert with 0, 17
                                if not _liquidityTokensToSwap + sub_432654c4:
                                    revert with 0, 18
                                _5265 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5265] = 30
                                mem[_5265 + 32] = 'SafeMath: subtraction overflow'
                                if 10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2 > 10 * minimumTokensBeforeSwapAmount:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 10 * minimumTokensBeforeSwapAmount < 10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2:
                                    revert with 0, 17
                                _5474 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_5474 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_5474]:
                                    revert with 0, 50
                                mem[_5474 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_5474 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _5474 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_5474]:
                                    revert with 0, 50
                                mem[_5474 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                                emit Approval(((10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)), this.address, uniswapV2RouterAddress);
                                mem[_5474 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_5474 + ceil32(return_data.size) + 100] = (10 * minimumTokensBeforeSwapAmount) - (10 * minimumTokensBeforeSwapAmount * _liquidityTokensToSwap / _liquidityTokensToSwap + sub_432654c4 / 2)
                                mem[_5474 + ceil32(return_data.size) + 132] = 0
                                mem[_5474 + ceil32(return_data.size) + 164] = 160
                                mem[_5474 + ceil32(return_data.size) + 260] = mem[_5474]
                                idx = 0
                                s = _5474 + ceil32(return_data.size) + 292
                                t = _5474 + 32
                                while idx < mem[_5474]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_5474 + ceil32(return_data.size) + 196] = this.address
                                mem[_5474 + ceil32(return_data.size) + 228] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _5474 + ceil32(return_data.size) + (32 * mem[_5474]) + -mem[64] + 288]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if eth.balance(this.address) > eth.balance(this.address):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                _liquidityTokensToSwap = 0
                                sub_432654c4 = 0
    uint8(stor55.field_160) = 0
    emit OwnerForcedSwapBack(block.timestamp);
}

function manualSwap(uint256 arg1) payable {
    mem[64] = 96
    require not msg.value
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if stor29[address(this.address)]:
        if stor24[address(this.address)] <= 0:
            revert with 0, 'Contract balance is zero'
        if stor29[address(this.address)]:
            if arg1 <= stor24[address(this.address)]:
                mem[128] = this.address
                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                        gas gas_remaining wei
                mem[192] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                mem[160] = ext_call.return_data[12 len 20]
                if not this.address:
                    revert with 0, 'ERC20: approve from the zero address'
                if not uniswapV2RouterAddress:
                    revert with 0, 'ERC20: approve to the zero address'
                allowance[address(this.address)][stor54] = arg1
                emit Approval(arg1, this.address, uniswapV2RouterAddress);
                mem[ceil32(return_data.size) + 192] = 0x762b156200000000000000000000000000000000000000000000000000000000
                mem[ceil32(return_data.size) + 196] = arg1
                idx = 0
                s = ceil32(return_data.size) + 388
                t = 128
                while idx < 2:
                    mem[s] = mem[t + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(uniswapV2RouterAddress)
                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args arg1, 0, 160, address(this.address), block.timestamp, 2, mem[ceil32(return_data.size) + 388 len 64]
            else:
                if stor29[address(this.address)]:
                    mem[128] = this.address
                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                            gas gas_remaining wei
                    mem[192] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    mem[160] = ext_call.return_data[12 len 20]
                    if not this.address:
                        revert with 0, 'ERC20: approve from the zero address'
                    if not uniswapV2RouterAddress:
                        revert with 0, 'ERC20: approve to the zero address'
                    allowance[address(this.address)][stor54] = stor24[address(this.address)]
                    emit Approval(stor24[address(this.address)], this.address, uniswapV2RouterAddress);
                    mem[ceil32(return_data.size) + 192] = 0x762b156200000000000000000000000000000000000000000000000000000000
                    mem[ceil32(return_data.size) + 196] = stor24[address(this.address)]
                    idx = 0
                    s = ceil32(return_data.size) + 388
                    t = 128
                    while idx < 2:
                        mem[s] = mem[t + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    require ext_code.size(uniswapV2RouterAddress)
                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args stor24[address(this.address)], 0, 160, address(this.address), block.timestamp, 2, mem[ceil32(return_data.size) + 388 len 64]
                else:
                    mem[0] = this.address
                    mem[32] = 23
                    if stor23[address(this.address)] > stor31:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
                    idx = 0
                    s = 10^15
                    t = stor31
                    while idx < stor30.length:
                        mem[0] = stor30[idx]
                        mem[32] = 23
                        if stor23[stor30[idx]] > t:
                            _4558 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4558] = 26
                            mem[_4558 + 32] = 'SafeMath: division by zero'
                            _4596 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4596] = 26
                            mem[_4596 + 32] = 'SafeMath: division by zero'
                            if not stor31 / 10^15:
                                _4616 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4616 + 68] = mem[idx + _4596 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4616 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _4616 + -mem[64] + 100
                            _4696 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_4696 + 32 len 64] = call.data[calldata.size len 64]
                            if 0 >= mem[_4696]:
                                revert with 0, 50
                            mem[_4696 + 32] = this.address
                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                    gas gas_remaining wei
                            mem[_4696 + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _4696 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            if 1 >= mem[_4696]:
                                revert with 0, 50
                            mem[_4696 + 64] = ext_call.return_data[12 len 20]
                            if not this.address:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not uniswapV2RouterAddress:
                                revert with 0, 'ERC20: approve to the zero address'
                            mem[0] = uniswapV2RouterAddress
                            mem[32] = sha3(address(this.address), 25)
                            allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                            emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                            mem[_4696 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                            mem[_4696 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                            mem[_4696 + ceil32(return_data.size) + 132] = 0
                            mem[_4696 + ceil32(return_data.size) + 164] = 160
                            mem[_4696 + ceil32(return_data.size) + 260] = mem[_4696]
                            idx = 0
                            s = _4696 + ceil32(return_data.size) + 292
                            t = _4696 + 32
                            while idx < mem[_4696]:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(uniswapV2RouterAddress)
                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args stor23[address(this.address)] / stor31 / 10^15, 0, 160, address(this.address), block.timestamp, mem[_4696 + ceil32(return_data.size) + 260 len (32 * mem[_4696]) + 32]
                        else:
                            if idx >= stor30.length:
                                revert with 0, 50
                            mem[0] = stor30[idx]
                            mem[32] = 24
                            if stor24[stor30[idx]] <= s:
                                if idx >= stor30.length:
                                    revert with 0, 50
                                mem[0] = stor30[idx]
                                mem[32] = 23
                                _4569 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4569] = 30
                                mem[_4569 + 32] = 'SafeMath: subtraction overflow'
                                if stor23[stor30[idx]] > t:
                                    _4573 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4573 + 68] = mem[idx + _4569 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4573 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4573 + -mem[64] + 100
                                if t < stor23[stor30[idx]]:
                                    revert with 0, 17
                                if idx >= stor30.length:
                                    revert with 0, 50
                                mem[0] = stor30[idx]
                                mem[32] = 24
                                _4617 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4617] = 30
                                mem[_4617 + 32] = 'SafeMath: subtraction overflow'
                                if stor24[stor30[idx]] <= s:
                                    if s < stor24[stor30[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor24[stor30[idx]]
                                    t = t - stor23[stor30[idx]]
                                    continue 
                                _4629 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4629 + 68] = mem[idx + _4617 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4629 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4629 + -mem[64] + 100
                            _4570 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4570] = 26
                            mem[_4570 + 32] = 'SafeMath: division by zero'
                            _4618 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4618] = 26
                            mem[_4618 + 32] = 'SafeMath: division by zero'
                            if not stor31 / 10^15:
                                _4630 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4630 + 68] = mem[idx + _4618 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4630 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _4630 + -mem[64] + 100
                            _4720 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_4720 + 32 len 64] = call.data[calldata.size len 64]
                            if 0 >= mem[_4720]:
                                revert with 0, 50
                            mem[_4720 + 32] = this.address
                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                    gas gas_remaining wei
                            mem[_4720 + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _4720 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            if 1 >= mem[_4720]:
                                revert with 0, 50
                            mem[_4720 + 64] = ext_call.return_data[12 len 20]
                            if not this.address:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not uniswapV2RouterAddress:
                                revert with 0, 'ERC20: approve to the zero address'
                            mem[0] = uniswapV2RouterAddress
                            mem[32] = sha3(address(this.address), 25)
                            allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                            emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                            mem[_4720 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                            mem[_4720 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                            mem[_4720 + ceil32(return_data.size) + 132] = 0
                            mem[_4720 + ceil32(return_data.size) + 164] = 160
                            mem[_4720 + ceil32(return_data.size) + 260] = mem[_4720]
                            idx = 0
                            s = _4720 + ceil32(return_data.size) + 292
                            t = _4720 + 32
                            while idx < mem[_4720]:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(uniswapV2RouterAddress)
                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args stor23[address(this.address)] / stor31 / 10^15, 0, 160, address(this.address), block.timestamp, mem[_4720 + ceil32(return_data.size) + 260 len (32 * mem[_4720]) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                    _4546 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4546] = 26
                    mem[_4546 + 32] = 'SafeMath: division by zero'
                    if t >= stor31 / 10^15:
                        _4581 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4581] = 26
                        mem[_4581 + 32] = 'SafeMath: division by zero'
                        if not s:
                            revert with 0, 'SafeMath: division by zero', 0
                        _4647 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4647] = 26
                        mem[_4647 + 32] = 'SafeMath: division by zero'
                        if not t / s:
                            revert with 0, 'SafeMath: division by zero', 0
                        _4778 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        mem[_4778 + 32 len 64] = call.data[calldata.size len 64]
                        if 0 >= mem[_4778]:
                            revert with 0, 50
                        mem[_4778 + 32] = this.address
                        staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                gas gas_remaining wei
                        mem[_4778 + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _4778 + ceil32(return_data.size) + 96
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        if 1 >= mem[_4778]:
                            revert with 0, 50
                        mem[_4778 + 64] = ext_call.return_data[12 len 20]
                        if not this.address:
                            revert with 0, 'ERC20: approve from the zero address'
                        if not uniswapV2RouterAddress:
                            revert with 0, 'ERC20: approve to the zero address'
                        mem[0] = uniswapV2RouterAddress
                        mem[32] = sha3(address(this.address), 25)
                        allowance[address(this.address)][stor54] = stor23[address(this.address)] / t / s
                        emit Approval((stor23[address(this.address)] / t / s), this.address, uniswapV2RouterAddress);
                        mem[_4778 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                        mem[_4778 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / t / s
                        mem[_4778 + ceil32(return_data.size) + 132] = 0
                        mem[_4778 + ceil32(return_data.size) + 164] = 160
                        mem[_4778 + ceil32(return_data.size) + 260] = mem[_4778]
                        idx = 0
                        u = _4778 + ceil32(return_data.size) + 292
                        v = _4778 + 32
                        while idx < mem[_4778]:
                            mem[u] = mem[v + 12 len 20]
                            idx = idx + 1
                            u = u + 32
                            v = v + 32
                            continue 
                        require ext_code.size(uniswapV2RouterAddress)
                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args stor23[address(this.address)] / t / s, 0, 160, address(this.address), block.timestamp, mem[_4778 + ceil32(return_data.size) + 260 len (32 * mem[_4778]) + 32]
                    else:
                        _4582 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4582] = 26
                        mem[_4582 + 32] = 'SafeMath: division by zero'
                        _4648 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4648] = 26
                        mem[_4648 + 32] = 'SafeMath: division by zero'
                        if not stor31 / 10^15:
                            revert with 0, 'SafeMath: division by zero', 0
                        _4780 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        mem[_4780 + 32 len 64] = call.data[calldata.size len 64]
                        if 0 >= mem[_4780]:
                            revert with 0, 50
                        mem[_4780 + 32] = this.address
                        staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                gas gas_remaining wei
                        mem[_4780 + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _4780 + ceil32(return_data.size) + 96
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        if 1 >= mem[_4780]:
                            revert with 0, 50
                        mem[_4780 + 64] = ext_call.return_data[12 len 20]
                        if not this.address:
                            revert with 0, 'ERC20: approve from the zero address'
                        if not uniswapV2RouterAddress:
                            revert with 0, 'ERC20: approve to the zero address'
                        mem[0] = uniswapV2RouterAddress
                        mem[32] = sha3(address(this.address), 25)
                        allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                        emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                        mem[_4780 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                        mem[_4780 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                        mem[_4780 + ceil32(return_data.size) + 132] = 0
                        mem[_4780 + ceil32(return_data.size) + 164] = 160
                        mem[_4780 + ceil32(return_data.size) + 260] = mem[_4780]
                        idx = 0
                        s = _4780 + ceil32(return_data.size) + 292
                        t = _4780 + 32
                        while idx < mem[_4780]:
                            mem[s] = mem[t + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_4780 + ceil32(return_data.size) + 196] = this.address
                        mem[_4780 + ceil32(return_data.size) + 228] = block.timestamp
                        require ext_code.size(uniswapV2RouterAddress)
                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _4780 + ceil32(return_data.size) + (32 * mem[_4780]) + -mem[64] + 288]
        else:
            mem[0] = this.address
            mem[32] = 23
            if stor23[address(this.address)] > stor31:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
            idx = 0
            s = 10^15
            t = stor31
            while idx < stor30.length:
                mem[0] = stor30[idx]
                mem[32] = 23
                if stor23[stor30[idx]] > t:
                    _4557 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4557] = 26
                    mem[_4557 + 32] = 'SafeMath: division by zero'
                    _4593 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4593] = 26
                    mem[_4593 + 32] = 'SafeMath: division by zero'
                    if not stor31 / 10^15:
                        _4612 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4612 + 68] = mem[idx + _4593 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4612 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4612 + -mem[64] + 100
                    if arg1 <= stor23[address(this.address)] / stor31 / 10^15:
                        _4691 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        mem[_4691 + 32 len 64] = call.data[calldata.size len 64]
                        if 0 >= mem[_4691]:
                            revert with 0, 50
                        mem[_4691 + 32] = this.address
                        staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                gas gas_remaining wei
                        mem[_4691 + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _4691 + ceil32(return_data.size) + 96
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        if 1 >= mem[_4691]:
                            revert with 0, 50
                        mem[_4691 + 64] = ext_call.return_data[12 len 20]
                        if not this.address:
                            revert with 0, 'ERC20: approve from the zero address'
                        if not uniswapV2RouterAddress:
                            revert with 0, 'ERC20: approve to the zero address'
                        mem[0] = uniswapV2RouterAddress
                        mem[32] = sha3(address(this.address), 25)
                        allowance[address(this.address)][stor54] = arg1
                        emit Approval(arg1, this.address, uniswapV2RouterAddress);
                        mem[_4691 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                        mem[_4691 + ceil32(return_data.size) + 100] = arg1
                        mem[_4691 + ceil32(return_data.size) + 132] = 0
                        mem[_4691 + ceil32(return_data.size) + 164] = 160
                        mem[_4691 + ceil32(return_data.size) + 260] = mem[_4691]
                        idx = 0
                        s = _4691 + ceil32(return_data.size) + 292
                        t = _4691 + 32
                        while idx < mem[_4691]:
                            mem[s] = mem[t + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        require ext_code.size(uniswapV2RouterAddress)
                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg1, 0, 160, address(this.address), block.timestamp, mem[_4691 + ceil32(return_data.size) + 260 len (32 * mem[_4691]) + 32]
                    else:
                        mem[0] = this.address
                        if stor29[address(this.address)]:
                            mem[32] = 24
                            _4745 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_4745 + 32 len 64] = call.data[calldata.size len 64]
                            if 0 >= mem[_4745]:
                                revert with 0, 50
                            mem[_4745 + 32] = this.address
                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                    gas gas_remaining wei
                            mem[_4745 + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _4745 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            if 1 >= mem[_4745]:
                                revert with 0, 50
                            mem[_4745 + 64] = ext_call.return_data[12 len 20]
                            if not this.address:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not uniswapV2RouterAddress:
                                revert with 0, 'ERC20: approve to the zero address'
                            mem[0] = uniswapV2RouterAddress
                            mem[32] = sha3(address(this.address), 25)
                            allowance[address(this.address)][stor54] = stor24[address(this.address)]
                            emit Approval(stor24[address(this.address)], this.address, uniswapV2RouterAddress);
                            mem[_4745 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                            mem[_4745 + ceil32(return_data.size) + 100] = stor24[address(this.address)]
                            mem[_4745 + ceil32(return_data.size) + 132] = 0
                            mem[_4745 + ceil32(return_data.size) + 164] = 160
                            mem[_4745 + ceil32(return_data.size) + 260] = mem[_4745]
                            idx = 0
                            s = _4745 + ceil32(return_data.size) + 292
                            t = _4745 + 32
                            while idx < mem[_4745]:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(uniswapV2RouterAddress)
                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args stor24[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_4745 + ceil32(return_data.size) + 260 len (32 * mem[_4745]) + 32]
                        else:
                            mem[32] = 23
                            if stor23[address(this.address)] > stor31:
                                revert with 0, 'Amount must be less than total reflections'
                            idx = 0
                            s = 10^15
                            t = stor31
                            while idx < stor30.length:
                                mem[0] = stor30[idx]
                                mem[32] = 23
                                if stor23[stor30[idx]] > t:
                                    _9208 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9208] = 26
                                    mem[_9208 + 32] = 'SafeMath: division by zero'
                                    _9361 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9361] = 26
                                    mem[_9361 + 32] = 'SafeMath: division by zero'
                                    if not stor31 / 10^15:
                                        _9443 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _9443 + 68] = mem[idx + _9361 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_9443 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _9443 + -mem[64] + 100
                                    _9760 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_9760 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_9760]:
                                        revert with 0, 50
                                    mem[_9760 + 32] = this.address
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_9760 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _9760 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_9760]:
                                        revert with 0, 50
                                    mem[_9760 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 25)
                                    allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                    emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                    mem[_9760 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_9760 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                    mem[_9760 + ceil32(return_data.size) + 132] = 0
                                    mem[_9760 + ceil32(return_data.size) + 164] = 160
                                    mem[_9760 + ceil32(return_data.size) + 260] = mem[_9760]
                                    idx = 0
                                    s = _9760 + ceil32(return_data.size) + 292
                                    t = _9760 + 32
                                    while idx < mem[_9760]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_9760 + ceil32(return_data.size) + 196] = this.address
                                    mem[_9760 + ceil32(return_data.size) + 228] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _9760 + ceil32(return_data.size) + (32 * mem[_9760]) + -mem[64] + 288]
                                else:
                                    if idx >= stor30.length:
                                        revert with 0, 50
                                    mem[0] = stor30[idx]
                                    mem[32] = 24
                                    if stor24[stor30[idx]] <= s:
                                        if idx >= stor30.length:
                                            revert with 0, 50
                                        mem[0] = stor30[idx]
                                        mem[32] = 23
                                        _9254 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9254] = 30
                                        mem[_9254 + 32] = 'SafeMath: subtraction overflow'
                                        if stor23[stor30[idx]] > t:
                                            _9268 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _9268 + 68] = mem[idx + _9254 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_9268 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _9268 + -mem[64] + 100
                                        if t < stor23[stor30[idx]]:
                                            revert with 0, 17
                                        if idx >= stor30.length:
                                            revert with 0, 50
                                        mem[0] = stor30[idx]
                                        mem[32] = 24
                                        _9444 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9444] = 30
                                        mem[_9444 + 32] = 'SafeMath: subtraction overflow'
                                        if stor24[stor30[idx]] <= s:
                                            if s < stor24[stor30[idx]]:
                                                revert with 0, 17
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s - stor24[stor30[idx]]
                                            t = t - stor23[stor30[idx]]
                                            continue 
                                        _9493 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _9493 + 68] = mem[idx + _9444 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_9493 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _9493 + -mem[64] + 100
                                    _9255 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9255] = 26
                                    mem[_9255 + 32] = 'SafeMath: division by zero'
                                    _9445 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9445] = 26
                                    mem[_9445 + 32] = 'SafeMath: division by zero'
                                    if not stor31 / 10^15:
                                        _9494 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _9494 + 68] = mem[idx + _9445 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_9494 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _9494 + -mem[64] + 100
                                    _9855 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_9855 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_9855]:
                                        revert with 0, 50
                                    mem[_9855 + 32] = this.address
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_9855 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _9855 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_9855]:
                                        revert with 0, 50
                                    mem[_9855 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 25)
                                    allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                    emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                    mem[_9855 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_9855 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                    mem[_9855 + ceil32(return_data.size) + 132] = 0
                                    mem[_9855 + ceil32(return_data.size) + 164] = 160
                                    mem[_9855 + ceil32(return_data.size) + 260] = mem[_9855]
                                    idx = 0
                                    s = _9855 + ceil32(return_data.size) + 292
                                    t = _9855 + 32
                                    while idx < mem[_9855]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_9855 + ceil32(return_data.size) + 196] = this.address
                                    mem[_9855 + ceil32(return_data.size) + 228] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _9855 + ceil32(return_data.size) + (32 * mem[_9855]) + -mem[64] + 288]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            _9119 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_9119] = 26
                            mem[_9119 + 32] = 'SafeMath: division by zero'
                            if t < stor31 / 10^15:
                                _9303 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9303] = 26
                                mem[_9303 + 32] = 'SafeMath: division by zero'
                                _9567 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9567] = 26
                                mem[_9567 + 32] = 'SafeMath: division by zero'
                                if not stor31 / 10^15:
                                    _9637 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    s = 0
                                    while s < 26:
                                        mem[s + _9637 + 68] = mem[s + _9567 + 32]
                                        s = s + 32
                                        continue 
                                    mem[_9637 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _9637 + -mem[64] + 100
                                _10046 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_10046 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_10046]:
                                    revert with 0, 50
                                mem[_10046 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_10046 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _10046 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_10046]:
                                    revert with 0, 50
                                mem[_10046 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                mem[_10046 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_10046 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                mem[_10046 + ceil32(return_data.size) + 132] = 0
                                mem[_10046 + ceil32(return_data.size) + 164] = 160
                                mem[_10046 + ceil32(return_data.size) + 260] = mem[_10046]
                                idx = 0
                                s = _10046 + ceil32(return_data.size) + 292
                                t = _10046 + 32
                                while idx < mem[_10046]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args stor23[address(this.address)] / stor31 / 10^15, 0, 160, address(this.address), block.timestamp, mem[_10046 + ceil32(return_data.size) + 260 len (32 * mem[_10046]) + 32]
                            else:
                                _9302 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9302] = 26
                                mem[_9302 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    _9328 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _9328 + 68] = mem[idx + _9302 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_9328 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _9328 + -mem[64] + 100
                                _9566 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9566] = 26
                                mem[_9566 + 32] = 'SafeMath: division by zero'
                                if not t / s:
                                    _9636 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    s = 0
                                    while s < 26:
                                        mem[s + _9636 + 68] = mem[s + _9566 + 32]
                                        s = s + 32
                                        continue 
                                    mem[_9636 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _9636 + -mem[64] + 100
                                _10044 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_10044 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_10044]:
                                    revert with 0, 50
                                mem[_10044 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_10044 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _10044 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_10044]:
                                    revert with 0, 50
                                mem[_10044 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = stor23[address(this.address)] / t / s
                                emit Approval((stor23[address(this.address)] / t / s), this.address, uniswapV2RouterAddress);
                                mem[_10044 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_10044 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / t / s
                                mem[_10044 + ceil32(return_data.size) + 132] = 0
                                mem[_10044 + ceil32(return_data.size) + 164] = 160
                                mem[_10044 + ceil32(return_data.size) + 260] = mem[_10044]
                                idx = 0
                                s = _10044 + ceil32(return_data.size) + 292
                                t = _10044 + 32
                                while idx < mem[_10044]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_10044 + ceil32(return_data.size) + 196] = this.address
                                mem[_10044 + ceil32(return_data.size) + 228] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _10044 + ceil32(return_data.size) + (32 * mem[_10044]) + -mem[64] + 288]
                else:
                    if idx >= stor30.length:
                        revert with 0, 50
                    mem[0] = stor30[idx]
                    mem[32] = 24
                    if stor24[stor30[idx]] <= s:
                        if idx >= stor30.length:
                            revert with 0, 50
                        mem[0] = stor30[idx]
                        mem[32] = 23
                        _4567 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4567] = 30
                        mem[_4567 + 32] = 'SafeMath: subtraction overflow'
                        if stor23[stor30[idx]] > t:
                            _4572 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _4572 + 68] = mem[idx + _4567 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4572 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4572 + -mem[64] + 100
                        if t < stor23[stor30[idx]]:
                            revert with 0, 17
                        if idx >= stor30.length:
                            revert with 0, 50
                        mem[0] = stor30[idx]
                        mem[32] = 24
                        _4613 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4613] = 30
                        mem[_4613 + 32] = 'SafeMath: subtraction overflow'
                        if stor24[stor30[idx]] <= s:
                            if s < stor24[stor30[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor24[stor30[idx]]
                            t = t - stor23[stor30[idx]]
                            continue 
                        _4626 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _4626 + 68] = mem[idx + _4613 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4626 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _4626 + -mem[64] + 100
                    _4568 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4568] = 26
                    mem[_4568 + 32] = 'SafeMath: division by zero'
                    _4614 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4614] = 26
                    mem[_4614 + 32] = 'SafeMath: division by zero'
                    if not stor31 / 10^15:
                        _4627 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4627 + 68] = mem[idx + _4614 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4627 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4627 + -mem[64] + 100
                    if arg1 <= stor23[address(this.address)] / stor31 / 10^15:
                        _4714 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        mem[_4714 + 32 len 64] = call.data[calldata.size len 64]
                        if 0 >= mem[_4714]:
                            revert with 0, 50
                        mem[_4714 + 32] = this.address
                        staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                gas gas_remaining wei
                        mem[_4714 + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _4714 + ceil32(return_data.size) + 96
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        if 1 >= mem[_4714]:
                            revert with 0, 50
                        mem[_4714 + 64] = ext_call.return_data[12 len 20]
                        if not this.address:
                            revert with 0, 'ERC20: approve from the zero address'
                        if not uniswapV2RouterAddress:
                            revert with 0, 'ERC20: approve to the zero address'
                        mem[0] = uniswapV2RouterAddress
                        mem[32] = sha3(address(this.address), 25)
                        allowance[address(this.address)][stor54] = arg1
                        emit Approval(arg1, this.address, uniswapV2RouterAddress);
                        mem[_4714 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                        mem[_4714 + ceil32(return_data.size) + 100] = arg1
                        mem[_4714 + ceil32(return_data.size) + 132] = 0
                        mem[_4714 + ceil32(return_data.size) + 164] = 160
                        mem[_4714 + ceil32(return_data.size) + 260] = mem[_4714]
                        idx = 0
                        s = _4714 + ceil32(return_data.size) + 292
                        t = _4714 + 32
                        while idx < mem[_4714]:
                            mem[s] = mem[t + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        require ext_code.size(uniswapV2RouterAddress)
                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg1, 0, 160, address(this.address), block.timestamp, mem[_4714 + ceil32(return_data.size) + 260 len (32 * mem[_4714]) + 32]
                    else:
                        mem[0] = this.address
                        if stor29[address(this.address)]:
                            mem[32] = 24
                            _4776 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_4776 + 32 len 64] = call.data[calldata.size len 64]
                            if 0 >= mem[_4776]:
                                revert with 0, 50
                            mem[_4776 + 32] = this.address
                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                    gas gas_remaining wei
                            mem[_4776 + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _4776 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            if 1 >= mem[_4776]:
                                revert with 0, 50
                            mem[_4776 + 64] = ext_call.return_data[12 len 20]
                            if not this.address:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not uniswapV2RouterAddress:
                                revert with 0, 'ERC20: approve to the zero address'
                            mem[0] = uniswapV2RouterAddress
                            mem[32] = sha3(address(this.address), 25)
                            allowance[address(this.address)][stor54] = stor24[address(this.address)]
                            emit Approval(stor24[address(this.address)], this.address, uniswapV2RouterAddress);
                            mem[_4776 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                            mem[_4776 + ceil32(return_data.size) + 100] = stor24[address(this.address)]
                            mem[_4776 + ceil32(return_data.size) + 132] = 0
                            mem[_4776 + ceil32(return_data.size) + 164] = 160
                            mem[_4776 + ceil32(return_data.size) + 260] = mem[_4776]
                            idx = 0
                            s = _4776 + ceil32(return_data.size) + 292
                            t = _4776 + 32
                            while idx < mem[_4776]:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_4776 + ceil32(return_data.size) + 196] = this.address
                            mem[_4776 + ceil32(return_data.size) + 228] = block.timestamp
                            require ext_code.size(uniswapV2RouterAddress)
                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _4776 + ceil32(return_data.size) + (32 * mem[_4776]) + -mem[64] + 288]
                        else:
                            mem[32] = 23
                            if stor23[address(this.address)] > stor31:
                                revert with 0, 'Amount must be less than total reflections'
                            idx = 0
                            s = 10^15
                            t = stor31
                            while idx < stor30.length:
                                mem[0] = stor30[idx]
                                mem[32] = 23
                                if stor23[stor30[idx]] > t:
                                    _9209 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9209] = 26
                                    mem[_9209 + 32] = 'SafeMath: division by zero'
                                    _9364 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9364] = 26
                                    mem[_9364 + 32] = 'SafeMath: division by zero'
                                    if not stor31 / 10^15:
                                        _9447 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _9447 + 68] = mem[idx + _9364 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_9447 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _9447 + -mem[64] + 100
                                    _9764 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_9764 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_9764]:
                                        revert with 0, 50
                                    mem[_9764 + 32] = this.address
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_9764 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _9764 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_9764]:
                                        revert with 0, 50
                                    mem[_9764 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 25)
                                    allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                    emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                    mem[_9764 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_9764 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                    mem[_9764 + ceil32(return_data.size) + 132] = 0
                                    mem[_9764 + ceil32(return_data.size) + 164] = 160
                                    mem[_9764 + ceil32(return_data.size) + 260] = mem[_9764]
                                    idx = 0
                                    s = _9764 + ceil32(return_data.size) + 292
                                    t = _9764 + 32
                                    while idx < mem[_9764]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args stor23[address(this.address)] / stor31 / 10^15, 0, 160, address(this.address), block.timestamp, mem[_9764 + ceil32(return_data.size) + 260 len (32 * mem[_9764]) + 32]
                                else:
                                    if idx >= stor30.length:
                                        revert with 0, 50
                                    mem[0] = stor30[idx]
                                    mem[32] = 24
                                    if stor24[stor30[idx]] <= s:
                                        if idx >= stor30.length:
                                            revert with 0, 50
                                        mem[0] = stor30[idx]
                                        mem[32] = 23
                                        _9256 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9256] = 30
                                        mem[_9256 + 32] = 'SafeMath: subtraction overflow'
                                        if stor23[stor30[idx]] > t:
                                            _9269 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _9269 + 68] = mem[idx + _9256 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_9269 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _9269 + -mem[64] + 100
                                        if t < stor23[stor30[idx]]:
                                            revert with 0, 17
                                        if idx >= stor30.length:
                                            revert with 0, 50
                                        mem[0] = stor30[idx]
                                        mem[32] = 24
                                        _9448 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9448] = 30
                                        mem[_9448 + 32] = 'SafeMath: subtraction overflow'
                                        if stor24[stor30[idx]] <= s:
                                            if s < stor24[stor30[idx]]:
                                                revert with 0, 17
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s - stor24[stor30[idx]]
                                            t = t - stor23[stor30[idx]]
                                            continue 
                                        _9496 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _9496 + 68] = mem[idx + _9448 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_9496 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _9496 + -mem[64] + 100
                                    _9257 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9257] = 26
                                    mem[_9257 + 32] = 'SafeMath: division by zero'
                                    _9449 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9449] = 26
                                    mem[_9449 + 32] = 'SafeMath: division by zero'
                                    if not stor31 / 10^15:
                                        _9497 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _9497 + 68] = mem[idx + _9449 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_9497 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _9497 + -mem[64] + 100
                                    _9860 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_9860 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_9860]:
                                        revert with 0, 50
                                    mem[_9860 + 32] = this.address
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_9860 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _9860 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_9860]:
                                        revert with 0, 50
                                    mem[_9860 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 25)
                                    allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                    emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                    mem[_9860 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_9860 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                    mem[_9860 + ceil32(return_data.size) + 132] = 0
                                    mem[_9860 + ceil32(return_data.size) + 164] = 160
                                    mem[_9860 + ceil32(return_data.size) + 260] = mem[_9860]
                                    idx = 0
                                    s = _9860 + ceil32(return_data.size) + 292
                                    t = _9860 + 32
                                    while idx < mem[_9860]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_9860 + ceil32(return_data.size) + 196] = this.address
                                    mem[_9860 + ceil32(return_data.size) + 228] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _9860 + ceil32(return_data.size) + (32 * mem[_9860]) + -mem[64] + 288]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            _9124 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_9124] = 26
                            mem[_9124 + 32] = 'SafeMath: division by zero'
                            if t >= stor31 / 10^15:
                                _9304 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9304] = 26
                                mem[_9304 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    _9329 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _9329 + 68] = mem[idx + _9304 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_9329 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _9329 + -mem[64] + 100
                                _9568 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9568] = 26
                                mem[_9568 + 32] = 'SafeMath: division by zero'
                                if not t / s:
                                    _9639 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    s = 0
                                    while s < 26:
                                        mem[s + _9639 + 68] = mem[s + _9568 + 32]
                                        s = s + 32
                                        continue 
                                    mem[_9639 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _9639 + -mem[64] + 100
                                _10049 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_10049 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_10049]:
                                    revert with 0, 50
                                mem[_10049 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_10049 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _10049 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_10049]:
                                    revert with 0, 50
                                mem[_10049 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = stor23[address(this.address)] / t / s
                                emit Approval((stor23[address(this.address)] / t / s), this.address, uniswapV2RouterAddress);
                                mem[_10049 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_10049 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / t / s
                                mem[_10049 + ceil32(return_data.size) + 132] = 0
                                mem[_10049 + ceil32(return_data.size) + 164] = 160
                                mem[_10049 + ceil32(return_data.size) + 260] = mem[_10049]
                                idx = 0
                                u = _10049 + ceil32(return_data.size) + 292
                                v = _10049 + 32
                                while idx < mem[_10049]:
                                    mem[u] = mem[v + 12 len 20]
                                    idx = idx + 1
                                    u = u + 32
                                    v = v + 32
                                    continue 
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args stor23[address(this.address)] / t / s, 0, 160, address(this.address), block.timestamp, mem[_10049 + ceil32(return_data.size) + 260 len (32 * mem[_10049]) + 32]
                            else:
                                _9305 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9305] = 26
                                mem[_9305 + 32] = 'SafeMath: division by zero'
                                _9569 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9569] = 26
                                mem[_9569 + 32] = 'SafeMath: division by zero'
                                if not stor31 / 10^15:
                                    _9640 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    s = 0
                                    while s < 26:
                                        mem[s + _9640 + 68] = mem[s + _9569 + 32]
                                        s = s + 32
                                        continue 
                                    mem[_9640 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _9640 + -mem[64] + 100
                                _10051 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_10051 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_10051]:
                                    revert with 0, 50
                                mem[_10051 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_10051 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _10051 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_10051]:
                                    revert with 0, 50
                                mem[_10051 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                mem[_10051 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_10051 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                mem[_10051 + ceil32(return_data.size) + 132] = 0
                                mem[_10051 + ceil32(return_data.size) + 164] = 160
                                mem[_10051 + ceil32(return_data.size) + 260] = mem[_10051]
                                idx = 0
                                s = _10051 + ceil32(return_data.size) + 292
                                t = _10051 + 32
                                while idx < mem[_10051]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_10051 + ceil32(return_data.size) + 196] = this.address
                                mem[_10051 + ceil32(return_data.size) + 228] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _10051 + ceil32(return_data.size) + (32 * mem[_10051]) + -mem[64] + 288]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
            _4542 = mem[64]
            mem[64] = mem[64] + 64
            mem[_4542] = 26
            mem[_4542 + 32] = 'SafeMath: division by zero'
            if t >= stor31 / 10^15:
                _4579 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4579] = 26
                mem[_4579 + 32] = 'SafeMath: division by zero'
                if not s:
                    revert with 0, 'SafeMath: division by zero', 0
                _4645 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4645] = 26
                mem[_4645 + 32] = 'SafeMath: division by zero'
                if not t / s:
                    revert with 0, 'SafeMath: division by zero', 0
                if arg1 <= stor23[address(this.address)] / t / s:
                    _4767 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    mem[_4767 + 32 len 64] = call.data[calldata.size len 64]
                    if 0 >= mem[_4767]:
                        revert with 0, 50
                    mem[_4767 + 32] = this.address
                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                            gas gas_remaining wei
                    mem[_4767 + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _4767 + ceil32(return_data.size) + 96
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if 1 >= mem[_4767]:
                        revert with 0, 50
                    mem[_4767 + 64] = ext_call.return_data[12 len 20]
                    if not this.address:
                        revert with 0, 'ERC20: approve from the zero address'
                    if not uniswapV2RouterAddress:
                        revert with 0, 'ERC20: approve to the zero address'
                    mem[0] = uniswapV2RouterAddress
                    mem[32] = sha3(address(this.address), 25)
                    allowance[address(this.address)][stor54] = arg1
                    emit Approval(arg1, this.address, uniswapV2RouterAddress);
                    mem[_4767 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                    mem[_4767 + ceil32(return_data.size) + 100] = arg1
                    mem[_4767 + ceil32(return_data.size) + 132] = 0
                    mem[_4767 + ceil32(return_data.size) + 164] = 160
                    mem[_4767 + ceil32(return_data.size) + 260] = mem[_4767]
                    idx = 0
                    s = _4767 + ceil32(return_data.size) + 292
                    t = _4767 + 32
                    while idx < mem[_4767]:
                        mem[s] = mem[t + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    require ext_code.size(uniswapV2RouterAddress)
                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args arg1, 0, 160, address(this.address), block.timestamp, mem[_4767 + ceil32(return_data.size) + 260 len (32 * mem[_4767]) + 32]
                else:
                    mem[0] = this.address
                    if stor29[address(this.address)]:
                        mem[32] = 24
                        _4854 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        mem[_4854 + 32 len 64] = call.data[calldata.size len 64]
                        if 0 >= mem[_4854]:
                            revert with 0, 50
                        mem[_4854 + 32] = this.address
                        staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                gas gas_remaining wei
                        mem[_4854 + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _4854 + ceil32(return_data.size) + 96
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        if 1 >= mem[_4854]:
                            revert with 0, 50
                        mem[_4854 + 64] = ext_call.return_data[12 len 20]
                        if not this.address:
                            revert with 0, 'ERC20: approve from the zero address'
                        if not uniswapV2RouterAddress:
                            revert with 0, 'ERC20: approve to the zero address'
                        mem[0] = uniswapV2RouterAddress
                        mem[32] = sha3(address(this.address), 25)
                        allowance[address(this.address)][stor54] = stor24[address(this.address)]
                        emit Approval(stor24[address(this.address)], this.address, uniswapV2RouterAddress);
                        mem[_4854 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                        mem[_4854 + ceil32(return_data.size) + 100] = stor24[address(this.address)]
                        mem[_4854 + ceil32(return_data.size) + 132] = 0
                        mem[_4854 + ceil32(return_data.size) + 164] = 160
                        mem[_4854 + ceil32(return_data.size) + 260] = mem[_4854]
                        idx = 0
                        s = _4854 + ceil32(return_data.size) + 292
                        t = _4854 + 32
                        while idx < mem[_4854]:
                            mem[s] = mem[t + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_4854 + ceil32(return_data.size) + 196] = this.address
                        mem[_4854 + ceil32(return_data.size) + 228] = block.timestamp
                        require ext_code.size(uniswapV2RouterAddress)
                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _4854 + ceil32(return_data.size) + (32 * mem[_4854]) + -mem[64] + 288]
                    else:
                        mem[32] = 23
                        if stor23[address(this.address)] > stor31:
                            revert with 0, 'Amount must be less than total reflections'
                        idx = 0
                        s = 10^15
                        t = stor31
                        while idx < stor30.length:
                            mem[0] = stor30[idx]
                            mem[32] = 23
                            if stor23[stor30[idx]] > t:
                                _9206 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9206] = 26
                                mem[_9206 + 32] = 'SafeMath: division by zero'
                                _9355 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9355] = 26
                                mem[_9355 + 32] = 'SafeMath: division by zero'
                                if not stor31 / 10^15:
                                    _9435 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _9435 + 68] = mem[idx + _9355 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_9435 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _9435 + -mem[64] + 100
                                _9752 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_9752 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_9752]:
                                    revert with 0, 50
                                mem[_9752 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_9752 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _9752 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_9752]:
                                    revert with 0, 50
                                mem[_9752 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                mem[_9752 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_9752 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                mem[_9752 + ceil32(return_data.size) + 132] = 0
                                mem[_9752 + ceil32(return_data.size) + 164] = 160
                                mem[_9752 + ceil32(return_data.size) + 260] = mem[_9752]
                                idx = 0
                                s = _9752 + ceil32(return_data.size) + 292
                                t = _9752 + 32
                                while idx < mem[_9752]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_9752 + ceil32(return_data.size) + 196] = this.address
                                mem[_9752 + ceil32(return_data.size) + 228] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _9752 + ceil32(return_data.size) + (32 * mem[_9752]) + -mem[64] + 288]
                            else:
                                if idx >= stor30.length:
                                    revert with 0, 50
                                mem[0] = stor30[idx]
                                mem[32] = 24
                                if stor24[stor30[idx]] <= s:
                                    if idx >= stor30.length:
                                        revert with 0, 50
                                    mem[0] = stor30[idx]
                                    mem[32] = 23
                                    _9250 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9250] = 30
                                    mem[_9250 + 32] = 'SafeMath: subtraction overflow'
                                    if stor23[stor30[idx]] > t:
                                        _9266 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _9266 + 68] = mem[idx + _9250 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_9266 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _9266 + -mem[64] + 100
                                    if t < stor23[stor30[idx]]:
                                        revert with 0, 17
                                    if idx >= stor30.length:
                                        revert with 0, 50
                                    mem[0] = stor30[idx]
                                    mem[32] = 24
                                    _9436 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9436] = 30
                                    mem[_9436 + 32] = 'SafeMath: subtraction overflow'
                                    if stor24[stor30[idx]] <= s:
                                        if s < stor24[stor30[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor24[stor30[idx]]
                                        t = t - stor23[stor30[idx]]
                                        continue 
                                    _9487 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _9487 + 68] = mem[idx + _9436 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_9487 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _9487 + -mem[64] + 100
                                _9251 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9251] = 26
                                mem[_9251 + 32] = 'SafeMath: division by zero'
                                _9437 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9437] = 26
                                mem[_9437 + 32] = 'SafeMath: division by zero'
                                if not stor31 / 10^15:
                                    _9488 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _9488 + 68] = mem[idx + _9437 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_9488 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _9488 + -mem[64] + 100
                                _9845 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_9845 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_9845]:
                                    revert with 0, 50
                                mem[_9845 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_9845 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _9845 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_9845]:
                                    revert with 0, 50
                                mem[_9845 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                mem[_9845 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_9845 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                mem[_9845 + ceil32(return_data.size) + 132] = 0
                                mem[_9845 + ceil32(return_data.size) + 164] = 160
                                mem[_9845 + ceil32(return_data.size) + 260] = mem[_9845]
                                idx = 0
                                s = _9845 + ceil32(return_data.size) + 292
                                t = _9845 + 32
                                while idx < mem[_9845]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_9845 + ceil32(return_data.size) + 196] = this.address
                                mem[_9845 + ceil32(return_data.size) + 228] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _9845 + ceil32(return_data.size) + (32 * mem[_9845]) + -mem[64] + 288]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                        _9109 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9109] = 26
                        mem[_9109 + 32] = 'SafeMath: division by zero'
                        if t >= stor31 / 10^15:
                            _9298 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_9298] = 26
                            mem[_9298 + 32] = 'SafeMath: division by zero'
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            _9562 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_9562] = 26
                            mem[_9562 + 32] = 'SafeMath: division by zero'
                            if not t / s:
                                revert with 0, 'SafeMath: division by zero', 0
                            _10034 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_10034 + 32 len 64] = call.data[calldata.size len 64]
                            if 0 >= mem[_10034]:
                                revert with 0, 50
                            mem[_10034 + 32] = this.address
                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                    gas gas_remaining wei
                            mem[_10034 + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _10034 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            if 1 >= mem[_10034]:
                                revert with 0, 50
                            mem[_10034 + 64] = ext_call.return_data[12 len 20]
                            if not this.address:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not uniswapV2RouterAddress:
                                revert with 0, 'ERC20: approve to the zero address'
                            mem[0] = uniswapV2RouterAddress
                            mem[32] = sha3(address(this.address), 25)
                            allowance[address(this.address)][stor54] = stor23[address(this.address)] / t / s
                            emit Approval((stor23[address(this.address)] / t / s), this.address, uniswapV2RouterAddress);
                            mem[_10034 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                            mem[_10034 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / t / s
                            mem[_10034 + ceil32(return_data.size) + 132] = 0
                            mem[_10034 + ceil32(return_data.size) + 164] = 160
                            mem[_10034 + ceil32(return_data.size) + 260] = mem[_10034]
                            idx = 0
                            u = _10034 + ceil32(return_data.size) + 292
                            v = _10034 + 32
                            while idx < mem[_10034]:
                                mem[u] = mem[v + 12 len 20]
                                idx = idx + 1
                                u = u + 32
                                v = v + 32
                                continue 
                            require ext_code.size(uniswapV2RouterAddress)
                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args stor23[address(this.address)] / t / s, 0, 160, address(this.address), block.timestamp, mem[_10034 + ceil32(return_data.size) + 260 len (32 * mem[_10034]) + 32]
                        else:
                            _9299 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_9299] = 26
                            mem[_9299 + 32] = 'SafeMath: division by zero'
                            _9563 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_9563] = 26
                            mem[_9563 + 32] = 'SafeMath: division by zero'
                            if not stor31 / 10^15:
                                revert with 0, 'SafeMath: division by zero', 0
                            _10036 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_10036 + 32 len 64] = call.data[calldata.size len 64]
                            if 0 >= mem[_10036]:
                                revert with 0, 50
                            mem[_10036 + 32] = this.address
                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                    gas gas_remaining wei
                            mem[_10036 + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _10036 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            if 1 >= mem[_10036]:
                                revert with 0, 50
                            mem[_10036 + 64] = ext_call.return_data[12 len 20]
                            if not this.address:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not uniswapV2RouterAddress:
                                revert with 0, 'ERC20: approve to the zero address'
                            mem[0] = uniswapV2RouterAddress
                            mem[32] = sha3(address(this.address), 25)
                            allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                            emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                            mem[_10036 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                            mem[_10036 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                            mem[_10036 + ceil32(return_data.size) + 132] = 0
                            mem[_10036 + ceil32(return_data.size) + 164] = 160
                            mem[_10036 + ceil32(return_data.size) + 260] = mem[_10036]
                            idx = 0
                            s = _10036 + ceil32(return_data.size) + 292
                            t = _10036 + 32
                            while idx < mem[_10036]:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_10036 + ceil32(return_data.size) + 196] = this.address
                            mem[_10036 + ceil32(return_data.size) + 228] = block.timestamp
                            require ext_code.size(uniswapV2RouterAddress)
                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _10036 + ceil32(return_data.size) + (32 * mem[_10036]) + -mem[64] + 288]
            else:
                _4580 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4580] = 26
                mem[_4580 + 32] = 'SafeMath: division by zero'
                _4646 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4646] = 26
                mem[_4646 + 32] = 'SafeMath: division by zero'
                if not stor31 / 10^15:
                    revert with 0, 'SafeMath: division by zero', 0
                if arg1 <= stor23[address(this.address)] / stor31 / 10^15:
                    _4770 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    mem[_4770 + 32 len 64] = call.data[calldata.size len 64]
                    if 0 >= mem[_4770]:
                        revert with 0, 50
                    mem[_4770 + 32] = this.address
                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                            gas gas_remaining wei
                    mem[_4770 + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _4770 + ceil32(return_data.size) + 96
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if 1 >= mem[_4770]:
                        revert with 0, 50
                    mem[_4770 + 64] = ext_call.return_data[12 len 20]
                    if not this.address:
                        revert with 0, 'ERC20: approve from the zero address'
                    if not uniswapV2RouterAddress:
                        revert with 0, 'ERC20: approve to the zero address'
                    mem[0] = uniswapV2RouterAddress
                    mem[32] = sha3(address(this.address), 25)
                    allowance[address(this.address)][stor54] = arg1
                    emit Approval(arg1, this.address, uniswapV2RouterAddress);
                    mem[_4770 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                    mem[_4770 + ceil32(return_data.size) + 100] = arg1
                    mem[_4770 + ceil32(return_data.size) + 132] = 0
                    mem[_4770 + ceil32(return_data.size) + 164] = 160
                    mem[_4770 + ceil32(return_data.size) + 260] = mem[_4770]
                    idx = 0
                    s = _4770 + ceil32(return_data.size) + 292
                    t = _4770 + 32
                    while idx < mem[_4770]:
                        mem[s] = mem[t + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_4770 + ceil32(return_data.size) + 196] = this.address
                    mem[_4770 + ceil32(return_data.size) + 228] = block.timestamp
                    require ext_code.size(uniswapV2RouterAddress)
                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _4770 + ceil32(return_data.size) + (32 * mem[_4770]) + -mem[64] + 288]
                else:
                    mem[0] = this.address
                    if stor29[address(this.address)]:
                        mem[32] = 24
                        _4858 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        mem[_4858 + 32 len 64] = call.data[calldata.size len 64]
                        if 0 >= mem[_4858]:
                            revert with 0, 50
                        mem[_4858 + 32] = this.address
                        staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                gas gas_remaining wei
                        mem[_4858 + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _4858 + ceil32(return_data.size) + 96
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        if 1 >= mem[_4858]:
                            revert with 0, 50
                        mem[_4858 + 64] = ext_call.return_data[12 len 20]
                        if not this.address:
                            revert with 0, 'ERC20: approve from the zero address'
                        if not uniswapV2RouterAddress:
                            revert with 0, 'ERC20: approve to the zero address'
                        mem[0] = uniswapV2RouterAddress
                        mem[32] = sha3(address(this.address), 25)
                        allowance[address(this.address)][stor54] = stor24[address(this.address)]
                        emit Approval(stor24[address(this.address)], this.address, uniswapV2RouterAddress);
                        mem[_4858 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                        mem[_4858 + ceil32(return_data.size) + 100] = stor24[address(this.address)]
                        mem[_4858 + ceil32(return_data.size) + 132] = 0
                        mem[_4858 + ceil32(return_data.size) + 164] = 160
                        mem[_4858 + ceil32(return_data.size) + 260] = mem[_4858]
                        idx = 0
                        s = _4858 + ceil32(return_data.size) + 292
                        t = _4858 + 32
                        while idx < mem[_4858]:
                            mem[s] = mem[t + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        require ext_code.size(uniswapV2RouterAddress)
                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args stor24[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_4858 + ceil32(return_data.size) + 260 len (32 * mem[_4858]) + 32]
                    else:
                        mem[32] = 23
                        if stor23[address(this.address)] > stor31:
                            revert with 0, 'Amount must be less than total reflections'
                        idx = 0
                        s = 10^15
                        t = stor31
                        while idx < stor30.length:
                            mem[0] = stor30[idx]
                            mem[32] = 23
                            if stor23[stor30[idx]] > t:
                                _9207 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9207] = 26
                                mem[_9207 + 32] = 'SafeMath: division by zero'
                                _9358 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9358] = 26
                                mem[_9358 + 32] = 'SafeMath: division by zero'
                                if not stor31 / 10^15:
                                    _9439 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _9439 + 68] = mem[idx + _9358 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_9439 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _9439 + -mem[64] + 100
                                _9756 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_9756 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_9756]:
                                    revert with 0, 50
                                mem[_9756 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_9756 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _9756 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_9756]:
                                    revert with 0, 50
                                mem[_9756 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                mem[_9756 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_9756 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                mem[_9756 + ceil32(return_data.size) + 132] = 0
                                mem[_9756 + ceil32(return_data.size) + 164] = 160
                                mem[_9756 + ceil32(return_data.size) + 260] = mem[_9756]
                                idx = 0
                                s = _9756 + ceil32(return_data.size) + 292
                                t = _9756 + 32
                                while idx < mem[_9756]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args stor23[address(this.address)] / stor31 / 10^15, 0, 160, address(this.address), block.timestamp, mem[_9756 + ceil32(return_data.size) + 260 len (32 * mem[_9756]) + 32]
                            else:
                                if idx >= stor30.length:
                                    revert with 0, 50
                                mem[0] = stor30[idx]
                                mem[32] = 24
                                if stor24[stor30[idx]] <= s:
                                    if idx >= stor30.length:
                                        revert with 0, 50
                                    mem[0] = stor30[idx]
                                    mem[32] = 23
                                    _9252 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9252] = 30
                                    mem[_9252 + 32] = 'SafeMath: subtraction overflow'
                                    if stor23[stor30[idx]] > t:
                                        _9267 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _9267 + 68] = mem[idx + _9252 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_9267 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _9267 + -mem[64] + 100
                                    if t < stor23[stor30[idx]]:
                                        revert with 0, 17
                                    if idx >= stor30.length:
                                        revert with 0, 50
                                    mem[0] = stor30[idx]
                                    mem[32] = 24
                                    _9440 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9440] = 30
                                    mem[_9440 + 32] = 'SafeMath: subtraction overflow'
                                    if stor24[stor30[idx]] <= s:
                                        if s < stor24[stor30[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor24[stor30[idx]]
                                        t = t - stor23[stor30[idx]]
                                        continue 
                                    _9490 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _9490 + 68] = mem[idx + _9440 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_9490 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _9490 + -mem[64] + 100
                                _9253 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9253] = 26
                                mem[_9253 + 32] = 'SafeMath: division by zero'
                                _9441 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9441] = 26
                                mem[_9441 + 32] = 'SafeMath: division by zero'
                                if not stor31 / 10^15:
                                    _9491 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _9491 + 68] = mem[idx + _9441 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_9491 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _9491 + -mem[64] + 100
                                _9850 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_9850 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_9850]:
                                    revert with 0, 50
                                mem[_9850 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_9850 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _9850 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_9850]:
                                    revert with 0, 50
                                mem[_9850 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                mem[_9850 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_9850 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                mem[_9850 + ceil32(return_data.size) + 132] = 0
                                mem[_9850 + ceil32(return_data.size) + 164] = 160
                                mem[_9850 + ceil32(return_data.size) + 260] = mem[_9850]
                                idx = 0
                                s = _9850 + ceil32(return_data.size) + 292
                                t = _9850 + 32
                                while idx < mem[_9850]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_9850 + ceil32(return_data.size) + 196] = this.address
                                mem[_9850 + ceil32(return_data.size) + 228] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _9850 + ceil32(return_data.size) + (32 * mem[_9850]) + -mem[64] + 288]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                        _9114 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9114] = 26
                        mem[_9114 + 32] = 'SafeMath: division by zero'
                        if t < stor31 / 10^15:
                            _9301 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_9301] = 26
                            mem[_9301 + 32] = 'SafeMath: division by zero'
                            _9565 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_9565] = 26
                            mem[_9565 + 32] = 'SafeMath: division by zero'
                            if not stor31 / 10^15:
                                revert with 0, 'SafeMath: division by zero', 0
                            _10041 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_10041 + 32 len 64] = call.data[calldata.size len 64]
                            if 0 >= mem[_10041]:
                                revert with 0, 50
                            mem[_10041 + 32] = this.address
                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                    gas gas_remaining wei
                            mem[_10041 + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _10041 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            if 1 >= mem[_10041]:
                                revert with 0, 50
                            mem[_10041 + 64] = ext_call.return_data[12 len 20]
                            if not this.address:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not uniswapV2RouterAddress:
                                revert with 0, 'ERC20: approve to the zero address'
                            mem[0] = uniswapV2RouterAddress
                            mem[32] = sha3(address(this.address), 25)
                            allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                            emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                            mem[_10041 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                            mem[_10041 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                            mem[_10041 + ceil32(return_data.size) + 132] = 0
                            mem[_10041 + ceil32(return_data.size) + 164] = 160
                            mem[_10041 + ceil32(return_data.size) + 260] = mem[_10041]
                            idx = 0
                            s = _10041 + ceil32(return_data.size) + 292
                            t = _10041 + 32
                            while idx < mem[_10041]:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_10041 + ceil32(return_data.size) + 196] = this.address
                            mem[_10041 + ceil32(return_data.size) + 228] = block.timestamp
                            require ext_code.size(uniswapV2RouterAddress)
                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _10041 + ceil32(return_data.size) + (32 * mem[_10041]) + -mem[64] + 288]
                        else:
                            _9300 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_9300] = 26
                            mem[_9300 + 32] = 'SafeMath: division by zero'
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            _9564 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_9564] = 26
                            mem[_9564 + 32] = 'SafeMath: division by zero'
                            if not t / s:
                                revert with 0, 'SafeMath: division by zero', 0
                            _10039 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_10039 + 32 len 64] = call.data[calldata.size len 64]
                            if 0 >= mem[_10039]:
                                revert with 0, 50
                            mem[_10039 + 32] = this.address
                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                    gas gas_remaining wei
                            mem[_10039 + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _10039 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            if 1 >= mem[_10039]:
                                revert with 0, 50
                            mem[_10039 + 64] = ext_call.return_data[12 len 20]
                            if not this.address:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not uniswapV2RouterAddress:
                                revert with 0, 'ERC20: approve to the zero address'
                            mem[0] = uniswapV2RouterAddress
                            mem[32] = sha3(address(this.address), 25)
                            allowance[address(this.address)][stor54] = stor23[address(this.address)] / t / s
                            emit Approval((stor23[address(this.address)] / t / s), this.address, uniswapV2RouterAddress);
                            mem[_10039 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                            mem[_10039 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / t / s
                            mem[_10039 + ceil32(return_data.size) + 132] = 0
                            mem[_10039 + ceil32(return_data.size) + 164] = 160
                            mem[_10039 + ceil32(return_data.size) + 260] = mem[_10039]
                            idx = 0
                            s = _10039 + ceil32(return_data.size) + 292
                            t = _10039 + 32
                            while idx < mem[_10039]:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_10039 + ceil32(return_data.size) + 196] = this.address
                            mem[_10039 + ceil32(return_data.size) + 228] = block.timestamp
                            require ext_code.size(uniswapV2RouterAddress)
                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _10039 + ceil32(return_data.size) + (32 * mem[_10039]) + -mem[64] + 288]
    else:
        mem[0] = this.address
        mem[32] = 23
        if stor23[address(this.address)] > stor31:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
        idx = 0
        s = 10^15
        t = stor31
        while idx < stor30.length:
            mem[0] = stor30[idx]
            mem[32] = 23
            if stor23[stor30[idx]] > t:
                _4556 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4556] = 26
                mem[_4556 + 32] = 'SafeMath: division by zero'
                _4590 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4590] = 26
                mem[_4590 + 32] = 'SafeMath: division by zero'
                if not stor31 / 10^15:
                    _4608 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4608 + 68] = mem[idx + _4590 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4608 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4608 + -mem[64] + 100
                if stor23[address(this.address)] / stor31 / 10^15 <= 0:
                    revert with 0, 'Contract balance is zero'
                mem[0] = this.address
                if stor29[address(this.address)]:
                    mem[32] = 24
                    if arg1 <= stor24[address(this.address)]:
                        _4740 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        mem[_4740 + 32 len 64] = call.data[calldata.size len 64]
                        if 0 >= mem[_4740]:
                            revert with 0, 50
                        mem[_4740 + 32] = this.address
                        staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                gas gas_remaining wei
                        mem[_4740 + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _4740 + ceil32(return_data.size) + 96
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        if 1 >= mem[_4740]:
                            revert with 0, 50
                        mem[_4740 + 64] = ext_call.return_data[12 len 20]
                        if not this.address:
                            revert with 0, 'ERC20: approve from the zero address'
                        if not uniswapV2RouterAddress:
                            revert with 0, 'ERC20: approve to the zero address'
                        mem[0] = uniswapV2RouterAddress
                        mem[32] = sha3(address(this.address), 25)
                        allowance[address(this.address)][stor54] = arg1
                        emit Approval(arg1, this.address, uniswapV2RouterAddress);
                        mem[_4740 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                        mem[_4740 + ceil32(return_data.size) + 100] = arg1
                        mem[_4740 + ceil32(return_data.size) + 132] = 0
                        mem[_4740 + ceil32(return_data.size) + 164] = 160
                        mem[_4740 + ceil32(return_data.size) + 260] = mem[_4740]
                        idx = 0
                        s = _4740 + ceil32(return_data.size) + 292
                        t = _4740 + 32
                        while idx < mem[_4740]:
                            mem[s] = mem[t + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        require ext_code.size(uniswapV2RouterAddress)
                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg1, 0, 160, address(this.address), block.timestamp, mem[_4740 + ceil32(return_data.size) + 260 len (32 * mem[_4740]) + 32]
                    else:
                        mem[0] = this.address
                        if stor29[address(this.address)]:
                            mem[32] = 24
                            _4813 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_4813 + 32 len 64] = call.data[calldata.size len 64]
                            if 0 >= mem[_4813]:
                                revert with 0, 50
                            mem[_4813 + 32] = this.address
                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                    gas gas_remaining wei
                            mem[_4813 + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _4813 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            if 1 >= mem[_4813]:
                                revert with 0, 50
                            mem[_4813 + 64] = ext_call.return_data[12 len 20]
                            if not this.address:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not uniswapV2RouterAddress:
                                revert with 0, 'ERC20: approve to the zero address'
                            mem[0] = uniswapV2RouterAddress
                            mem[32] = sha3(address(this.address), 25)
                            allowance[address(this.address)][stor54] = stor24[address(this.address)]
                            emit Approval(stor24[address(this.address)], this.address, uniswapV2RouterAddress);
                            mem[_4813 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                            mem[_4813 + ceil32(return_data.size) + 100] = stor24[address(this.address)]
                            mem[_4813 + ceil32(return_data.size) + 132] = 0
                            mem[_4813 + ceil32(return_data.size) + 164] = 160
                            mem[_4813 + ceil32(return_data.size) + 260] = mem[_4813]
                            idx = 0
                            s = _4813 + ceil32(return_data.size) + 292
                            t = _4813 + 32
                            while idx < mem[_4813]:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_4813 + ceil32(return_data.size) + 196] = this.address
                            mem[_4813 + ceil32(return_data.size) + 228] = block.timestamp
                            require ext_code.size(uniswapV2RouterAddress)
                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _4813 + ceil32(return_data.size) + (32 * mem[_4813]) + -mem[64] + 288]
                        else:
                            mem[32] = 23
                            if stor23[address(this.address)] > stor31:
                                revert with 0, 'Amount must be less than total reflections'
                            idx = 0
                            s = 10^15
                            t = stor31
                            while idx < stor30.length:
                                mem[0] = stor30[idx]
                                mem[32] = 23
                                if stor23[stor30[idx]] > t:
                                    _9203 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9203] = 26
                                    mem[_9203 + 32] = 'SafeMath: division by zero'
                                    _9346 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9346] = 26
                                    mem[_9346 + 32] = 'SafeMath: division by zero'
                                    if not stor31 / 10^15:
                                        _9423 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _9423 + 68] = mem[idx + _9346 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_9423 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _9423 + -mem[64] + 100
                                    _9739 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_9739 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_9739]:
                                        revert with 0, 50
                                    mem[_9739 + 32] = this.address
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_9739 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _9739 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_9739]:
                                        revert with 0, 50
                                    mem[_9739 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 25)
                                    allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                    emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                    mem[_9739 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_9739 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                    mem[_9739 + ceil32(return_data.size) + 132] = 0
                                    mem[_9739 + ceil32(return_data.size) + 164] = 160
                                    mem[_9739 + ceil32(return_data.size) + 260] = mem[_9739]
                                    idx = 0
                                    s = _9739 + ceil32(return_data.size) + 292
                                    t = _9739 + 32
                                    while idx < mem[_9739]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args stor23[address(this.address)] / stor31 / 10^15, 0, 160, address(this.address), block.timestamp, mem[_9739 + ceil32(return_data.size) + 260 len (32 * mem[_9739]) + 32]
                                else:
                                    if idx >= stor30.length:
                                        revert with 0, 50
                                    mem[0] = stor30[idx]
                                    mem[32] = 24
                                    if stor24[stor30[idx]] <= s:
                                        if idx >= stor30.length:
                                            revert with 0, 50
                                        mem[0] = stor30[idx]
                                        mem[32] = 23
                                        _9244 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9244] = 30
                                        mem[_9244 + 32] = 'SafeMath: subtraction overflow'
                                        if stor23[stor30[idx]] > t:
                                            _9263 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _9263 + 68] = mem[idx + _9244 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_9263 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _9263 + -mem[64] + 100
                                        if t < stor23[stor30[idx]]:
                                            revert with 0, 17
                                        if idx >= stor30.length:
                                            revert with 0, 50
                                        mem[0] = stor30[idx]
                                        mem[32] = 24
                                        _9424 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9424] = 30
                                        mem[_9424 + 32] = 'SafeMath: subtraction overflow'
                                        if stor24[stor30[idx]] <= s:
                                            if s < stor24[stor30[idx]]:
                                                revert with 0, 17
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s - stor24[stor30[idx]]
                                            t = t - stor23[stor30[idx]]
                                            continue 
                                        _9478 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _9478 + 68] = mem[idx + _9424 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_9478 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _9478 + -mem[64] + 100
                                    _9245 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9245] = 26
                                    mem[_9245 + 32] = 'SafeMath: division by zero'
                                    _9425 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9425] = 26
                                    mem[_9425 + 32] = 'SafeMath: division by zero'
                                    if not stor31 / 10^15:
                                        _9479 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _9479 + 68] = mem[idx + _9425 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_9479 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _9479 + -mem[64] + 100
                                    _9829 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_9829 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_9829]:
                                        revert with 0, 50
                                    mem[_9829 + 32] = this.address
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_9829 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _9829 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_9829]:
                                        revert with 0, 50
                                    mem[_9829 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 25)
                                    allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                    emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                    mem[_9829 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_9829 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                    mem[_9829 + ceil32(return_data.size) + 132] = 0
                                    mem[_9829 + ceil32(return_data.size) + 164] = 160
                                    mem[_9829 + ceil32(return_data.size) + 260] = mem[_9829]
                                    idx = 0
                                    s = _9829 + ceil32(return_data.size) + 292
                                    t = _9829 + 32
                                    while idx < mem[_9829]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args stor23[address(this.address)] / stor31 / 10^15, 0, 160, address(this.address), block.timestamp, mem[_9829 + ceil32(return_data.size) + 260 len (32 * mem[_9829]) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            _9096 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_9096] = 26
                            mem[_9096 + 32] = 'SafeMath: division by zero'
                            if t < stor31 / 10^15:
                                _9293 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9293] = 26
                                mem[_9293 + 32] = 'SafeMath: division by zero'
                                _9557 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9557] = 26
                                mem[_9557 + 32] = 'SafeMath: division by zero'
                                if not stor31 / 10^15:
                                    _9622 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    s = 0
                                    while s < 26:
                                        mem[s + _9622 + 68] = mem[s + _9557 + 32]
                                        s = s + 32
                                        continue 
                                    mem[_9622 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _9622 + -mem[64] + 100
                                _10015 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_10015 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_10015]:
                                    revert with 0, 50
                                mem[_10015 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_10015 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _10015 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_10015]:
                                    revert with 0, 50
                                mem[_10015 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                mem[_10015 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_10015 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                mem[_10015 + ceil32(return_data.size) + 132] = 0
                                mem[_10015 + ceil32(return_data.size) + 164] = 160
                                mem[_10015 + ceil32(return_data.size) + 260] = mem[_10015]
                                idx = 0
                                s = _10015 + ceil32(return_data.size) + 292
                                t = _10015 + 32
                                while idx < mem[_10015]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args stor23[address(this.address)] / stor31 / 10^15, 0, 160, address(this.address), block.timestamp, mem[_10015 + ceil32(return_data.size) + 260 len (32 * mem[_10015]) + 32]
                            else:
                                _9292 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9292] = 26
                                mem[_9292 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    _9323 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _9323 + 68] = mem[idx + _9292 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_9323 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _9323 + -mem[64] + 100
                                _9556 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9556] = 26
                                mem[_9556 + 32] = 'SafeMath: division by zero'
                                if not t / s:
                                    _9621 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    s = 0
                                    while s < 26:
                                        mem[s + _9621 + 68] = mem[s + _9556 + 32]
                                        s = s + 32
                                        continue 
                                    mem[_9621 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _9621 + -mem[64] + 100
                                _10013 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_10013 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_10013]:
                                    revert with 0, 50
                                mem[_10013 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_10013 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _10013 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_10013]:
                                    revert with 0, 50
                                mem[_10013 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = stor23[address(this.address)] / t / s
                                emit Approval((stor23[address(this.address)] / t / s), this.address, uniswapV2RouterAddress);
                                mem[_10013 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_10013 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / t / s
                                mem[_10013 + ceil32(return_data.size) + 132] = 0
                                mem[_10013 + ceil32(return_data.size) + 164] = 160
                                mem[_10013 + ceil32(return_data.size) + 260] = mem[_10013]
                                idx = 0
                                u = _10013 + ceil32(return_data.size) + 292
                                v = _10013 + 32
                                while idx < mem[_10013]:
                                    mem[u] = mem[v + 12 len 20]
                                    idx = idx + 1
                                    u = u + 32
                                    v = v + 32
                                    continue 
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args stor23[address(this.address)] / t / s, 0, 160, address(this.address), block.timestamp, mem[_10013 + ceil32(return_data.size) + 260 len (32 * mem[_10013]) + 32]
                else:
                    mem[32] = 23
                    if stor23[address(this.address)] > stor31:
                        revert with 0, 'Amount must be less than total reflections'
                    idx = 0
                    s = 10^15
                    t = stor31
                    while idx < stor30.length:
                        mem[0] = stor30[idx]
                        mem[32] = 23
                        if stor23[stor30[idx]] > t:
                            _9202 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_9202] = 26
                            mem[_9202 + 32] = 'SafeMath: division by zero'
                            _9343 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_9343] = 26
                            mem[_9343 + 32] = 'SafeMath: division by zero'
                            if not stor31 / 10^15:
                                _9419 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _9419 + 68] = mem[idx + _9343 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_9419 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _9419 + -mem[64] + 100
                            if arg1 <= stor23[address(this.address)] / stor31 / 10^15:
                                _9734 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_9734 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_9734]:
                                    revert with 0, 50
                                mem[_9734 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_9734 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _9734 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_9734]:
                                    revert with 0, 50
                                mem[_9734 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = arg1
                                emit Approval(arg1, this.address, uniswapV2RouterAddress);
                                mem[_9734 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_9734 + ceil32(return_data.size) + 100] = arg1
                                mem[_9734 + ceil32(return_data.size) + 132] = 0
                                mem[_9734 + ceil32(return_data.size) + 164] = 160
                                mem[_9734 + ceil32(return_data.size) + 260] = mem[_9734]
                                idx = 0
                                s = _9734 + ceil32(return_data.size) + 292
                                t = _9734 + 32
                                while idx < mem[_9734]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_9734 + ceil32(return_data.size) + 196] = this.address
                                mem[_9734 + ceil32(return_data.size) + 228] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _9734 + ceil32(return_data.size) + (32 * mem[_9734]) + -mem[64] + 288]
                            else:
                                mem[0] = this.address
                                if stor29[address(this.address)]:
                                    mem[32] = 24
                                    _9938 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_9938 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_9938]:
                                        revert with 0, 50
                                    mem[_9938 + 32] = this.address
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_9938 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _9938 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_9938]:
                                        revert with 0, 50
                                    mem[_9938 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 25)
                                    allowance[address(this.address)][stor54] = stor24[address(this.address)]
                                    emit Approval(stor24[address(this.address)], this.address, uniswapV2RouterAddress);
                                    mem[_9938 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_9938 + ceil32(return_data.size) + 100] = stor24[address(this.address)]
                                    mem[_9938 + ceil32(return_data.size) + 132] = 0
                                    mem[_9938 + ceil32(return_data.size) + 164] = 160
                                    mem[_9938 + ceil32(return_data.size) + 260] = mem[_9938]
                                    idx = 0
                                    s = _9938 + ceil32(return_data.size) + 292
                                    t = _9938 + 32
                                    while idx < mem[_9938]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args stor24[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_9938 + ceil32(return_data.size) + 260 len (32 * mem[_9938]) + 32]
                                else:
                                    mem[32] = 23
                                    if stor23[address(this.address)] > stor31:
                                        revert with 0, 'Amount must be less than total reflections'
                                    idx = 0
                                    s = 10^15
                                    t = stor31
                                    while idx < stor30.length:
                                        mem[0] = stor30[idx]
                                        mem[32] = 23
                                        if stor23[stor30[idx]] > t:
                                            _13552 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13552] = 26
                                            mem[_13552 + 32] = 'SafeMath: division by zero'
                                            _13749 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13749] = 26
                                            mem[_13749 + 32] = 'SafeMath: division by zero'
                                            if not stor31 / 10^15:
                                                _13855 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _13855 + 68] = mem[idx + _13749 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_13855 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _13855 + -mem[64] + 100
                                            _14272 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            mem[_14272 + 32 len 64] = call.data[calldata.size len 64]
                                            if 0 >= mem[_14272]:
                                                revert with 0, 50
                                            mem[_14272 + 32] = this.address
                                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                                    gas gas_remaining wei
                                            mem[_14272 + 96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = _14272 + ceil32(return_data.size) + 96
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                            if 1 >= mem[_14272]:
                                                revert with 0, 50
                                            mem[_14272 + 64] = ext_call.return_data[12 len 20]
                                            if not this.address:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not uniswapV2RouterAddress:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            mem[0] = uniswapV2RouterAddress
                                            mem[32] = sha3(address(this.address), 25)
                                            allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                            emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                            mem[_14272 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                            mem[_14272 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                            mem[_14272 + ceil32(return_data.size) + 132] = 0
                                            mem[_14272 + ceil32(return_data.size) + 164] = 160
                                            mem[_14272 + ceil32(return_data.size) + 260] = mem[_14272]
                                            idx = 0
                                            s = _14272 + ceil32(return_data.size) + 292
                                            t = _14272 + 32
                                            while idx < mem[_14272]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            require ext_code.size(uniswapV2RouterAddress)
                                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                 gas gas_remaining wei
                                                args stor23[address(this.address)] / stor31 / 10^15, 0, 160, address(this.address), block.timestamp, mem[_14272 + ceil32(return_data.size) + 260 len (32 * mem[_14272]) + 32]
                                        else:
                                            if idx >= stor30.length:
                                                revert with 0, 50
                                            mem[0] = stor30[idx]
                                            mem[32] = 24
                                            if stor24[stor30[idx]] <= s:
                                                if idx >= stor30.length:
                                                    revert with 0, 50
                                                mem[0] = stor30[idx]
                                                mem[32] = 23
                                                _13610 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_13610] = 30
                                                mem[_13610 + 32] = 'SafeMath: subtraction overflow'
                                                if stor23[stor30[idx]] > t:
                                                    _13632 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _13632 + 68] = mem[idx + _13610 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_13632 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _13632 + -mem[64] + 100
                                                if t < stor23[stor30[idx]]:
                                                    revert with 0, 17
                                                if idx >= stor30.length:
                                                    revert with 0, 50
                                                mem[0] = stor30[idx]
                                                mem[32] = 24
                                                _13856 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_13856] = 30
                                                mem[_13856 + 32] = 'SafeMath: subtraction overflow'
                                                if stor24[stor30[idx]] <= s:
                                                    if s < stor24[stor30[idx]]:
                                                        revert with 0, 17
                                                    if idx == -1:
                                                        revert with 0, 17
                                                    idx = idx + 1
                                                    s = s - stor24[stor30[idx]]
                                                    t = t - stor23[stor30[idx]]
                                                    continue 
                                                _13925 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _13925 + 68] = mem[idx + _13856 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_13925 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _13925 + -mem[64] + 100
                                            _13611 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13611] = 26
                                            mem[_13611 + 32] = 'SafeMath: division by zero'
                                            _13857 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13857] = 26
                                            mem[_13857 + 32] = 'SafeMath: division by zero'
                                            if not stor31 / 10^15:
                                                _13926 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _13926 + 68] = mem[idx + _13857 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_13926 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _13926 + -mem[64] + 100
                                            _14379 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            mem[_14379 + 32 len 64] = call.data[calldata.size len 64]
                                            if 0 >= mem[_14379]:
                                                revert with 0, 50
                                            mem[_14379 + 32] = this.address
                                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                                    gas gas_remaining wei
                                            mem[_14379 + 96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = _14379 + ceil32(return_data.size) + 96
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                            if 1 >= mem[_14379]:
                                                revert with 0, 50
                                            mem[_14379 + 64] = ext_call.return_data[12 len 20]
                                            if not this.address:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not uniswapV2RouterAddress:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            mem[0] = uniswapV2RouterAddress
                                            mem[32] = sha3(address(this.address), 25)
                                            allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                            emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                            mem[_14379 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                            mem[_14379 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                            mem[_14379 + ceil32(return_data.size) + 132] = 0
                                            mem[_14379 + ceil32(return_data.size) + 164] = 160
                                            mem[_14379 + ceil32(return_data.size) + 260] = mem[_14379]
                                            idx = 0
                                            s = _14379 + ceil32(return_data.size) + 292
                                            t = _14379 + 32
                                            while idx < mem[_14379]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            require ext_code.size(uniswapV2RouterAddress)
                                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                 gas gas_remaining wei
                                                args stor23[address(this.address)] / stor31 / 10^15, 0, 160, address(this.address), block.timestamp, mem[_14379 + ceil32(return_data.size) + 260 len (32 * mem[_14379]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                    _13289 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13289] = 26
                                    mem[_13289 + 32] = 'SafeMath: division by zero'
                                    if t >= stor31 / 10^15:
                                        _13674 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13674] = 26
                                        mem[_13674 + 32] = 'SafeMath: division by zero'
                                        if not s:
                                            _13712 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _13712 + 68] = mem[idx + _13674 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13712 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13712 + -mem[64] + 100
                                        _14026 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14026] = 26
                                        mem[_14026 + 32] = 'SafeMath: division by zero'
                                        if not t / s:
                                            _14116 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            s = 0
                                            while s < 26:
                                                mem[s + _14116 + 68] = mem[s + _14026 + 32]
                                                s = s + 32
                                                continue 
                                            mem[_14116 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14116 + -mem[64] + 100
                                        _14552 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        mem[_14552 + 32 len 64] = call.data[calldata.size len 64]
                                        if 0 >= mem[_14552]:
                                            revert with 0, 50
                                        mem[_14552 + 32] = this.address
                                        staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                                gas gas_remaining wei
                                        mem[_14552 + 96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _14552 + ceil32(return_data.size) + 96
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        if 1 >= mem[_14552]:
                                            revert with 0, 50
                                        mem[_14552 + 64] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 25)
                                        allowance[address(this.address)][stor54] = stor23[address(this.address)] / t / s
                                        emit Approval((stor23[address(this.address)] / t / s), this.address, uniswapV2RouterAddress);
                                        mem[_14552 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_14552 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / t / s
                                        mem[_14552 + ceil32(return_data.size) + 132] = 0
                                        mem[_14552 + ceil32(return_data.size) + 164] = 160
                                        mem[_14552 + ceil32(return_data.size) + 260] = mem[_14552]
                                        idx = 0
                                        u = _14552 + ceil32(return_data.size) + 292
                                        v = _14552 + 32
                                        while idx < mem[_14552]:
                                            mem[u] = mem[v + 12 len 20]
                                            idx = idx + 1
                                            u = u + 32
                                            v = v + 32
                                            continue 
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args stor23[address(this.address)] / t / s, 0, 160, address(this.address), block.timestamp, mem[_14552 + ceil32(return_data.size) + 260 len (32 * mem[_14552]) + 32]
                                    else:
                                        _13675 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13675] = 26
                                        mem[_13675 + 32] = 'SafeMath: division by zero'
                                        _14027 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14027] = 26
                                        mem[_14027 + 32] = 'SafeMath: division by zero'
                                        if not stor31 / 10^15:
                                            _14117 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            s = 0
                                            while s < 26:
                                                mem[s + _14117 + 68] = mem[s + _14027 + 32]
                                                s = s + 32
                                                continue 
                                            mem[_14117 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14117 + -mem[64] + 100
                                        _14554 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        mem[_14554 + 32 len 64] = call.data[calldata.size len 64]
                                        if 0 >= mem[_14554]:
                                            revert with 0, 50
                                        mem[_14554 + 32] = this.address
                                        staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                                gas gas_remaining wei
                                        mem[_14554 + 96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _14554 + ceil32(return_data.size) + 96
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        if 1 >= mem[_14554]:
                                            revert with 0, 50
                                        mem[_14554 + 64] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 25)
                                        allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                        emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                        mem[_14554 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_14554 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                        mem[_14554 + ceil32(return_data.size) + 132] = 0
                                        mem[_14554 + ceil32(return_data.size) + 164] = 160
                                        mem[_14554 + ceil32(return_data.size) + 260] = mem[_14554]
                                        idx = 0
                                        s = _14554 + ceil32(return_data.size) + 292
                                        t = _14554 + 32
                                        while idx < mem[_14554]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_14554 + ceil32(return_data.size) + 196] = this.address
                                        mem[_14554 + ceil32(return_data.size) + 228] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _14554 + ceil32(return_data.size) + (32 * mem[_14554]) + -mem[64] + 288]
                        else:
                            if idx >= stor30.length:
                                revert with 0, 50
                            mem[0] = stor30[idx]
                            mem[32] = 24
                            if stor24[stor30[idx]] <= s:
                                if idx >= stor30.length:
                                    revert with 0, 50
                                mem[0] = stor30[idx]
                                mem[32] = 23
                                _9242 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9242] = 30
                                mem[_9242 + 32] = 'SafeMath: subtraction overflow'
                                if stor23[stor30[idx]] > t:
                                    _9262 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _9262 + 68] = mem[idx + _9242 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_9262 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _9262 + -mem[64] + 100
                                if t < stor23[stor30[idx]]:
                                    revert with 0, 17
                                if idx >= stor30.length:
                                    revert with 0, 50
                                mem[0] = stor30[idx]
                                mem[32] = 24
                                _9420 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9420] = 30
                                mem[_9420 + 32] = 'SafeMath: subtraction overflow'
                                if stor24[stor30[idx]] <= s:
                                    if s < stor24[stor30[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor24[stor30[idx]]
                                    t = t - stor23[stor30[idx]]
                                    continue 
                                _9475 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _9475 + 68] = mem[idx + _9420 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_9475 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _9475 + -mem[64] + 100
                            _9243 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_9243] = 26
                            mem[_9243 + 32] = 'SafeMath: division by zero'
                            _9421 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_9421] = 26
                            mem[_9421 + 32] = 'SafeMath: division by zero'
                            if not stor31 / 10^15:
                                _9476 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _9476 + 68] = mem[idx + _9421 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_9476 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _9476 + -mem[64] + 100
                            if arg1 <= stor23[address(this.address)] / stor31 / 10^15:
                                _9823 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_9823 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_9823]:
                                    revert with 0, 50
                                mem[_9823 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_9823 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _9823 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_9823]:
                                    revert with 0, 50
                                mem[_9823 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = arg1
                                emit Approval(arg1, this.address, uniswapV2RouterAddress);
                                mem[_9823 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_9823 + ceil32(return_data.size) + 100] = arg1
                                mem[_9823 + ceil32(return_data.size) + 132] = 0
                                mem[_9823 + ceil32(return_data.size) + 164] = 160
                                mem[_9823 + ceil32(return_data.size) + 260] = mem[_9823]
                                idx = 0
                                s = _9823 + ceil32(return_data.size) + 292
                                t = _9823 + 32
                                while idx < mem[_9823]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args arg1, 0, 160, address(this.address), block.timestamp, mem[_9823 + ceil32(return_data.size) + 260 len (32 * mem[_9823]) + 32]
                            else:
                                mem[0] = this.address
                                if stor29[address(this.address)]:
                                    mem[32] = 24
                                    _10011 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_10011 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_10011]:
                                        revert with 0, 50
                                    mem[_10011 + 32] = this.address
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_10011 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _10011 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_10011]:
                                        revert with 0, 50
                                    mem[_10011 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 25)
                                    allowance[address(this.address)][stor54] = stor24[address(this.address)]
                                    emit Approval(stor24[address(this.address)], this.address, uniswapV2RouterAddress);
                                    mem[_10011 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_10011 + ceil32(return_data.size) + 100] = stor24[address(this.address)]
                                    mem[_10011 + ceil32(return_data.size) + 132] = 0
                                    mem[_10011 + ceil32(return_data.size) + 164] = 160
                                    mem[_10011 + ceil32(return_data.size) + 260] = mem[_10011]
                                    idx = 0
                                    s = _10011 + ceil32(return_data.size) + 292
                                    t = _10011 + 32
                                    while idx < mem[_10011]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_10011 + ceil32(return_data.size) + 196] = this.address
                                    mem[_10011 + ceil32(return_data.size) + 228] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _10011 + ceil32(return_data.size) + (32 * mem[_10011]) + -mem[64] + 288]
                                else:
                                    mem[32] = 23
                                    if stor23[address(this.address)] > stor31:
                                        revert with 0, 'Amount must be less than total reflections'
                                    idx = 0
                                    s = 10^15
                                    t = stor31
                                    while idx < stor30.length:
                                        mem[0] = stor30[idx]
                                        mem[32] = 23
                                        if stor23[stor30[idx]] > t:
                                            _13553 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13553] = 26
                                            mem[_13553 + 32] = 'SafeMath: division by zero'
                                            _13752 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13752] = 26
                                            mem[_13752 + 32] = 'SafeMath: division by zero'
                                            if not stor31 / 10^15:
                                                _13859 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _13859 + 68] = mem[idx + _13752 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_13859 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _13859 + -mem[64] + 100
                                            _14276 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            mem[_14276 + 32 len 64] = call.data[calldata.size len 64]
                                            if 0 >= mem[_14276]:
                                                revert with 0, 50
                                            mem[_14276 + 32] = this.address
                                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                                    gas gas_remaining wei
                                            mem[_14276 + 96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = _14276 + ceil32(return_data.size) + 96
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                            if 1 >= mem[_14276]:
                                                revert with 0, 50
                                            mem[_14276 + 64] = ext_call.return_data[12 len 20]
                                            if not this.address:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not uniswapV2RouterAddress:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            mem[0] = uniswapV2RouterAddress
                                            mem[32] = sha3(address(this.address), 25)
                                            allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                            emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                            mem[_14276 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                            mem[_14276 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                            mem[_14276 + ceil32(return_data.size) + 132] = 0
                                            mem[_14276 + ceil32(return_data.size) + 164] = 160
                                            mem[_14276 + ceil32(return_data.size) + 260] = mem[_14276]
                                            idx = 0
                                            s = _14276 + ceil32(return_data.size) + 292
                                            t = _14276 + 32
                                            while idx < mem[_14276]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_14276 + ceil32(return_data.size) + 196] = this.address
                                            mem[_14276 + ceil32(return_data.size) + 228] = block.timestamp
                                            require ext_code.size(uniswapV2RouterAddress)
                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _14276 + ceil32(return_data.size) + (32 * mem[_14276]) + -mem[64] + 288]
                                        else:
                                            if idx >= stor30.length:
                                                revert with 0, 50
                                            mem[0] = stor30[idx]
                                            mem[32] = 24
                                            if stor24[stor30[idx]] <= s:
                                                if idx >= stor30.length:
                                                    revert with 0, 50
                                                mem[0] = stor30[idx]
                                                mem[32] = 23
                                                _13612 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_13612] = 30
                                                mem[_13612 + 32] = 'SafeMath: subtraction overflow'
                                                if stor23[stor30[idx]] > t:
                                                    _13633 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _13633 + 68] = mem[idx + _13612 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_13633 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _13633 + -mem[64] + 100
                                                if t < stor23[stor30[idx]]:
                                                    revert with 0, 17
                                                if idx >= stor30.length:
                                                    revert with 0, 50
                                                mem[0] = stor30[idx]
                                                mem[32] = 24
                                                _13860 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_13860] = 30
                                                mem[_13860 + 32] = 'SafeMath: subtraction overflow'
                                                if stor24[stor30[idx]] <= s:
                                                    if s < stor24[stor30[idx]]:
                                                        revert with 0, 17
                                                    if idx == -1:
                                                        revert with 0, 17
                                                    idx = idx + 1
                                                    s = s - stor24[stor30[idx]]
                                                    t = t - stor23[stor30[idx]]
                                                    continue 
                                                _13928 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _13928 + 68] = mem[idx + _13860 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_13928 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _13928 + -mem[64] + 100
                                            _13613 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13613] = 26
                                            mem[_13613 + 32] = 'SafeMath: division by zero'
                                            _13861 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13861] = 26
                                            mem[_13861 + 32] = 'SafeMath: division by zero'
                                            if not stor31 / 10^15:
                                                _13929 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _13929 + 68] = mem[idx + _13861 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_13929 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _13929 + -mem[64] + 100
                                            _14384 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            mem[_14384 + 32 len 64] = call.data[calldata.size len 64]
                                            if 0 >= mem[_14384]:
                                                revert with 0, 50
                                            mem[_14384 + 32] = this.address
                                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                                    gas gas_remaining wei
                                            mem[_14384 + 96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = _14384 + ceil32(return_data.size) + 96
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                            if 1 >= mem[_14384]:
                                                revert with 0, 50
                                            mem[_14384 + 64] = ext_call.return_data[12 len 20]
                                            if not this.address:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not uniswapV2RouterAddress:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            mem[0] = uniswapV2RouterAddress
                                            mem[32] = sha3(address(this.address), 25)
                                            allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                            emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                            mem[_14384 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                            mem[_14384 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                            mem[_14384 + ceil32(return_data.size) + 132] = 0
                                            mem[_14384 + ceil32(return_data.size) + 164] = 160
                                            mem[_14384 + ceil32(return_data.size) + 260] = mem[_14384]
                                            idx = 0
                                            s = _14384 + ceil32(return_data.size) + 292
                                            t = _14384 + 32
                                            while idx < mem[_14384]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            require ext_code.size(uniswapV2RouterAddress)
                                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                 gas gas_remaining wei
                                                args stor23[address(this.address)] / stor31 / 10^15, 0, 160, address(this.address), block.timestamp, mem[_14384 + ceil32(return_data.size) + 260 len (32 * mem[_14384]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                    _13294 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13294] = 26
                                    mem[_13294 + 32] = 'SafeMath: division by zero'
                                    if t < stor31 / 10^15:
                                        _13677 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13677] = 26
                                        mem[_13677 + 32] = 'SafeMath: division by zero'
                                        _14029 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14029] = 26
                                        mem[_14029 + 32] = 'SafeMath: division by zero'
                                        if not stor31 / 10^15:
                                            _14120 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            s = 0
                                            while s < 26:
                                                mem[s + _14120 + 68] = mem[s + _14029 + 32]
                                                s = s + 32
                                                continue 
                                            mem[_14120 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14120 + -mem[64] + 100
                                        _14559 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        mem[_14559 + 32 len 64] = call.data[calldata.size len 64]
                                        if 0 >= mem[_14559]:
                                            revert with 0, 50
                                        mem[_14559 + 32] = this.address
                                        staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                                gas gas_remaining wei
                                        mem[_14559 + 96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _14559 + ceil32(return_data.size) + 96
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        if 1 >= mem[_14559]:
                                            revert with 0, 50
                                        mem[_14559 + 64] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 25)
                                        allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                        emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                        mem[_14559 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_14559 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                        mem[_14559 + ceil32(return_data.size) + 132] = 0
                                        mem[_14559 + ceil32(return_data.size) + 164] = 160
                                        mem[_14559 + ceil32(return_data.size) + 260] = mem[_14559]
                                        idx = 0
                                        s = _14559 + ceil32(return_data.size) + 292
                                        t = _14559 + 32
                                        while idx < mem[_14559]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args stor23[address(this.address)] / stor31 / 10^15, 0, 160, address(this.address), block.timestamp, mem[_14559 + ceil32(return_data.size) + 260 len (32 * mem[_14559]) + 32]
                                    else:
                                        _13676 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13676] = 26
                                        mem[_13676 + 32] = 'SafeMath: division by zero'
                                        if not s:
                                            _13713 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _13713 + 68] = mem[idx + _13676 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13713 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13713 + -mem[64] + 100
                                        _14028 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14028] = 26
                                        mem[_14028 + 32] = 'SafeMath: division by zero'
                                        if not t / s:
                                            _14119 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            s = 0
                                            while s < 26:
                                                mem[s + _14119 + 68] = mem[s + _14028 + 32]
                                                s = s + 32
                                                continue 
                                            mem[_14119 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14119 + -mem[64] + 100
                                        _14557 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        mem[_14557 + 32 len 64] = call.data[calldata.size len 64]
                                        if 0 >= mem[_14557]:
                                            revert with 0, 50
                                        mem[_14557 + 32] = this.address
                                        staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                                gas gas_remaining wei
                                        mem[_14557 + 96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _14557 + ceil32(return_data.size) + 96
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        if 1 >= mem[_14557]:
                                            revert with 0, 50
                                        mem[_14557 + 64] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 25)
                                        allowance[address(this.address)][stor54] = stor23[address(this.address)] / t / s
                                        emit Approval((stor23[address(this.address)] / t / s), this.address, uniswapV2RouterAddress);
                                        mem[_14557 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_14557 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / t / s
                                        mem[_14557 + ceil32(return_data.size) + 132] = 0
                                        mem[_14557 + ceil32(return_data.size) + 164] = 160
                                        mem[_14557 + ceil32(return_data.size) + 260] = mem[_14557]
                                        idx = 0
                                        s = _14557 + ceil32(return_data.size) + 292
                                        t = _14557 + 32
                                        while idx < mem[_14557]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_14557 + ceil32(return_data.size) + 196] = this.address
                                        mem[_14557 + ceil32(return_data.size) + 228] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _14557 + ceil32(return_data.size) + (32 * mem[_14557]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                    _9092 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9092] = 26
                    mem[_9092 + 32] = 'SafeMath: division by zero'
                    if t < stor31 / 10^15:
                        _9291 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9291] = 26
                        mem[_9291 + 32] = 'SafeMath: division by zero'
                        _9555 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9555] = 26
                        mem[_9555 + 32] = 'SafeMath: division by zero'
                        if not stor31 / 10^15:
                            _9619 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            s = 0
                            while s < 26:
                                mem[s + _9619 + 68] = mem[s + _9555 + 32]
                                s = s + 32
                                continue 
                            mem[_9619 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9619 + -mem[64] + 100
                        if arg1 <= stor23[address(this.address)] / stor31 / 10^15:
                            _10005 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_10005 + 32 len 64] = call.data[calldata.size len 64]
                            if 0 >= mem[_10005]:
                                revert with 0, 50
                            mem[_10005 + 32] = this.address
                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                    gas gas_remaining wei
                            mem[_10005 + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _10005 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            if 1 >= mem[_10005]:
                                revert with 0, 50
                            mem[_10005 + 64] = ext_call.return_data[12 len 20]
                            if not this.address:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not uniswapV2RouterAddress:
                                revert with 0, 'ERC20: approve to the zero address'
                            mem[0] = uniswapV2RouterAddress
                            mem[32] = sha3(address(this.address), 25)
                            allowance[address(this.address)][stor54] = arg1
                            emit Approval(arg1, this.address, uniswapV2RouterAddress);
                            mem[_10005 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                            mem[_10005 + ceil32(return_data.size) + 100] = arg1
                            mem[_10005 + ceil32(return_data.size) + 132] = 0
                            mem[_10005 + ceil32(return_data.size) + 164] = 160
                            mem[_10005 + ceil32(return_data.size) + 260] = mem[_10005]
                            idx = 0
                            s = _10005 + ceil32(return_data.size) + 292
                            t = _10005 + 32
                            while idx < mem[_10005]:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_10005 + ceil32(return_data.size) + 196] = this.address
                            mem[_10005 + ceil32(return_data.size) + 228] = block.timestamp
                            require ext_code.size(uniswapV2RouterAddress)
                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _10005 + ceil32(return_data.size) + (32 * mem[_10005]) + -mem[64] + 288]
                        else:
                            mem[0] = this.address
                            if stor29[address(this.address)]:
                                mem[32] = 24
                                _10232 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_10232 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_10232]:
                                    revert with 0, 50
                                mem[_10232 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_10232 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _10232 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_10232]:
                                    revert with 0, 50
                                mem[_10232 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = stor24[address(this.address)]
                                emit Approval(stor24[address(this.address)], this.address, uniswapV2RouterAddress);
                                mem[_10232 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_10232 + ceil32(return_data.size) + 100] = stor24[address(this.address)]
                                mem[_10232 + ceil32(return_data.size) + 132] = 0
                                mem[_10232 + ceil32(return_data.size) + 164] = 160
                                mem[_10232 + ceil32(return_data.size) + 260] = mem[_10232]
                                idx = 0
                                s = _10232 + ceil32(return_data.size) + 292
                                t = _10232 + 32
                                while idx < mem[_10232]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_10232 + ceil32(return_data.size) + 196] = this.address
                                mem[_10232 + ceil32(return_data.size) + 228] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _10232 + ceil32(return_data.size) + (32 * mem[_10232]) + -mem[64] + 288]
                            else:
                                mem[32] = 23
                                if stor23[address(this.address)] > stor31:
                                    revert with 0, 'Amount must be less than total reflections'
                                idx = 0
                                s = 10^15
                                t = stor31
                                while idx < stor30.length:
                                    mem[0] = stor30[idx]
                                    mem[32] = 23
                                    if stor23[stor30[idx]] > t:
                                        _13551 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13551] = 26
                                        mem[_13551 + 32] = 'SafeMath: division by zero'
                                        _13746 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13746] = 26
                                        mem[_13746 + 32] = 'SafeMath: division by zero'
                                        if not stor31 / 10^15:
                                            _13851 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _13851 + 68] = mem[idx + _13746 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13851 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13851 + -mem[64] + 100
                                        _14268 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        mem[_14268 + 32 len 64] = call.data[calldata.size len 64]
                                        if 0 >= mem[_14268]:
                                            revert with 0, 50
                                        mem[_14268 + 32] = this.address
                                        staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                                gas gas_remaining wei
                                        mem[_14268 + 96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _14268 + ceil32(return_data.size) + 96
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        if 1 >= mem[_14268]:
                                            revert with 0, 50
                                        mem[_14268 + 64] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 25)
                                        allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                        emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                        mem[_14268 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_14268 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                        mem[_14268 + ceil32(return_data.size) + 132] = 0
                                        mem[_14268 + ceil32(return_data.size) + 164] = 160
                                        mem[_14268 + ceil32(return_data.size) + 260] = mem[_14268]
                                        idx = 0
                                        s = _14268 + ceil32(return_data.size) + 292
                                        t = _14268 + 32
                                        while idx < mem[_14268]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args stor23[address(this.address)] / stor31 / 10^15, 0, 160, address(this.address), block.timestamp, mem[_14268 + ceil32(return_data.size) + 260 len (32 * mem[_14268]) + 32]
                                    else:
                                        if idx >= stor30.length:
                                            revert with 0, 50
                                        mem[0] = stor30[idx]
                                        mem[32] = 24
                                        if stor24[stor30[idx]] <= s:
                                            if idx >= stor30.length:
                                                revert with 0, 50
                                            mem[0] = stor30[idx]
                                            mem[32] = 23
                                            _13608 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13608] = 30
                                            mem[_13608 + 32] = 'SafeMath: subtraction overflow'
                                            if stor23[stor30[idx]] > t:
                                                _13631 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _13631 + 68] = mem[idx + _13608 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_13631 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _13631 + -mem[64] + 100
                                            if t < stor23[stor30[idx]]:
                                                revert with 0, 17
                                            if idx >= stor30.length:
                                                revert with 0, 50
                                            mem[0] = stor30[idx]
                                            mem[32] = 24
                                            _13852 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13852] = 30
                                            mem[_13852 + 32] = 'SafeMath: subtraction overflow'
                                            if stor24[stor30[idx]] <= s:
                                                if s < stor24[stor30[idx]]:
                                                    revert with 0, 17
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                s = s - stor24[stor30[idx]]
                                                t = t - stor23[stor30[idx]]
                                                continue 
                                            _13922 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13922 + 68] = mem[idx + _13852 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13922 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13922 + -mem[64] + 100
                                        _13609 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13609] = 26
                                        mem[_13609 + 32] = 'SafeMath: division by zero'
                                        _13853 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13853] = 26
                                        mem[_13853 + 32] = 'SafeMath: division by zero'
                                        if not stor31 / 10^15:
                                            _13923 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _13923 + 68] = mem[idx + _13853 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13923 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13923 + -mem[64] + 100
                                        _14374 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        mem[_14374 + 32 len 64] = call.data[calldata.size len 64]
                                        if 0 >= mem[_14374]:
                                            revert with 0, 50
                                        mem[_14374 + 32] = this.address
                                        staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                                gas gas_remaining wei
                                        mem[_14374 + 96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _14374 + ceil32(return_data.size) + 96
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        if 1 >= mem[_14374]:
                                            revert with 0, 50
                                        mem[_14374 + 64] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 25)
                                        allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                        emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                        mem[_14374 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_14374 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                        mem[_14374 + ceil32(return_data.size) + 132] = 0
                                        mem[_14374 + ceil32(return_data.size) + 164] = 160
                                        mem[_14374 + ceil32(return_data.size) + 260] = mem[_14374]
                                        idx = 0
                                        s = _14374 + ceil32(return_data.size) + 292
                                        t = _14374 + 32
                                        while idx < mem[_14374]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args stor23[address(this.address)] / stor31 / 10^15, 0, 160, address(this.address), block.timestamp, mem[_14374 + ceil32(return_data.size) + 260 len (32 * mem[_14374]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                _13284 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13284] = 26
                                mem[_13284 + 32] = 'SafeMath: division by zero'
                                if t < stor31 / 10^15:
                                    _13673 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13673] = 26
                                    mem[_13673 + 32] = 'SafeMath: division by zero'
                                    _14025 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14025] = 26
                                    mem[_14025 + 32] = 'SafeMath: division by zero'
                                    if not stor31 / 10^15:
                                        _14114 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        s = 0
                                        while s < 26:
                                            mem[s + _14114 + 68] = mem[s + _14025 + 32]
                                            s = s + 32
                                            continue 
                                        mem[_14114 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14114 + -mem[64] + 100
                                    _14549 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_14549 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_14549]:
                                        revert with 0, 50
                                    mem[_14549 + 32] = this.address
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_14549 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _14549 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_14549]:
                                        revert with 0, 50
                                    mem[_14549 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 25)
                                    allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                    emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                    mem[_14549 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_14549 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                    mem[_14549 + ceil32(return_data.size) + 132] = 0
                                    mem[_14549 + ceil32(return_data.size) + 164] = 160
                                    mem[_14549 + ceil32(return_data.size) + 260] = mem[_14549]
                                    idx = 0
                                    s = _14549 + ceil32(return_data.size) + 292
                                    t = _14549 + 32
                                    while idx < mem[_14549]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args stor23[address(this.address)] / stor31 / 10^15, 0, 160, address(this.address), block.timestamp, mem[_14549 + ceil32(return_data.size) + 260 len (32 * mem[_14549]) + 32]
                                else:
                                    _13672 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13672] = 26
                                    mem[_13672 + 32] = 'SafeMath: division by zero'
                                    if not s:
                                        _13711 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _13711 + 68] = mem[idx + _13672 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13711 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13711 + -mem[64] + 100
                                    _14024 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14024] = 26
                                    mem[_14024 + 32] = 'SafeMath: division by zero'
                                    if not t / s:
                                        _14113 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        s = 0
                                        while s < 26:
                                            mem[s + _14113 + 68] = mem[s + _14024 + 32]
                                            s = s + 32
                                            continue 
                                        mem[_14113 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14113 + -mem[64] + 100
                                    _14547 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_14547 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_14547]:
                                        revert with 0, 50
                                    mem[_14547 + 32] = this.address
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_14547 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _14547 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_14547]:
                                        revert with 0, 50
                                    mem[_14547 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 25)
                                    allowance[address(this.address)][stor54] = stor23[address(this.address)] / t / s
                                    emit Approval((stor23[address(this.address)] / t / s), this.address, uniswapV2RouterAddress);
                                    mem[_14547 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_14547 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / t / s
                                    mem[_14547 + ceil32(return_data.size) + 132] = 0
                                    mem[_14547 + ceil32(return_data.size) + 164] = 160
                                    mem[_14547 + ceil32(return_data.size) + 260] = mem[_14547]
                                    idx = 0
                                    u = _14547 + ceil32(return_data.size) + 292
                                    v = _14547 + 32
                                    while idx < mem[_14547]:
                                        mem[u] = mem[v + 12 len 20]
                                        idx = idx + 1
                                        u = u + 32
                                        v = v + 32
                                        continue 
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args stor23[address(this.address)] / t / s, 0, 160, address(this.address), block.timestamp, mem[_14547 + ceil32(return_data.size) + 260 len (32 * mem[_14547]) + 32]
                    else:
                        _9290 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9290] = 26
                        mem[_9290 + 32] = 'SafeMath: division by zero'
                        if not s:
                            _9322 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _9322 + 68] = mem[idx + _9290 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9322 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9322 + -mem[64] + 100
                        _9554 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9554] = 26
                        mem[_9554 + 32] = 'SafeMath: division by zero'
                        if not t / s:
                            _9618 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            s = 0
                            while s < 26:
                                mem[s + _9618 + 68] = mem[s + _9554 + 32]
                                s = s + 32
                                continue 
                            mem[_9618 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9618 + -mem[64] + 100
                        if arg1 <= stor23[address(this.address)] / t / s:
                            _10002 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_10002 + 32 len 64] = call.data[calldata.size len 64]
                            if 0 >= mem[_10002]:
                                revert with 0, 50
                            mem[_10002 + 32] = this.address
                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                    gas gas_remaining wei
                            mem[_10002 + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _10002 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            if 1 >= mem[_10002]:
                                revert with 0, 50
                            mem[_10002 + 64] = ext_call.return_data[12 len 20]
                            if not this.address:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not uniswapV2RouterAddress:
                                revert with 0, 'ERC20: approve to the zero address'
                            mem[0] = uniswapV2RouterAddress
                            mem[32] = sha3(address(this.address), 25)
                            allowance[address(this.address)][stor54] = arg1
                            emit Approval(arg1, this.address, uniswapV2RouterAddress);
                            mem[_10002 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                            mem[_10002 + ceil32(return_data.size) + 100] = arg1
                            mem[_10002 + ceil32(return_data.size) + 132] = 0
                            mem[_10002 + ceil32(return_data.size) + 164] = 160
                            mem[_10002 + ceil32(return_data.size) + 260] = mem[_10002]
                            idx = 0
                            s = _10002 + ceil32(return_data.size) + 292
                            t = _10002 + 32
                            while idx < mem[_10002]:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(uniswapV2RouterAddress)
                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args arg1, 0, 160, address(this.address), block.timestamp, mem[_10002 + ceil32(return_data.size) + 260 len (32 * mem[_10002]) + 32]
                        else:
                            mem[0] = this.address
                            if stor29[address(this.address)]:
                                mem[32] = 24
                                _10228 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_10228 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_10228]:
                                    revert with 0, 50
                                mem[_10228 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_10228 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _10228 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_10228]:
                                    revert with 0, 50
                                mem[_10228 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = stor24[address(this.address)]
                                emit Approval(stor24[address(this.address)], this.address, uniswapV2RouterAddress);
                                mem[_10228 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_10228 + ceil32(return_data.size) + 100] = stor24[address(this.address)]
                                mem[_10228 + ceil32(return_data.size) + 132] = 0
                                mem[_10228 + ceil32(return_data.size) + 164] = 160
                                mem[_10228 + ceil32(return_data.size) + 260] = mem[_10228]
                                idx = 0
                                s = _10228 + ceil32(return_data.size) + 292
                                t = _10228 + 32
                                while idx < mem[_10228]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args stor24[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_10228 + ceil32(return_data.size) + 260 len (32 * mem[_10228]) + 32]
                            else:
                                mem[32] = 23
                                if stor23[address(this.address)] > stor31:
                                    revert with 0, 'Amount must be less than total reflections'
                                idx = 0
                                s = 10^15
                                t = stor31
                                while idx < stor30.length:
                                    mem[0] = stor30[idx]
                                    mem[32] = 23
                                    if stor23[stor30[idx]] > t:
                                        _13550 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13550] = 26
                                        mem[_13550 + 32] = 'SafeMath: division by zero'
                                        _13743 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13743] = 26
                                        mem[_13743 + 32] = 'SafeMath: division by zero'
                                        if not stor31 / 10^15:
                                            _13847 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _13847 + 68] = mem[idx + _13743 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13847 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13847 + -mem[64] + 100
                                        _14264 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        mem[_14264 + 32 len 64] = call.data[calldata.size len 64]
                                        if 0 >= mem[_14264]:
                                            revert with 0, 50
                                        mem[_14264 + 32] = this.address
                                        staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                                gas gas_remaining wei
                                        mem[_14264 + 96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _14264 + ceil32(return_data.size) + 96
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        if 1 >= mem[_14264]:
                                            revert with 0, 50
                                        mem[_14264 + 64] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 25)
                                        allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                        emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                        mem[_14264 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_14264 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                        mem[_14264 + ceil32(return_data.size) + 132] = 0
                                        mem[_14264 + ceil32(return_data.size) + 164] = 160
                                        mem[_14264 + ceil32(return_data.size) + 260] = mem[_14264]
                                        idx = 0
                                        s = _14264 + ceil32(return_data.size) + 292
                                        t = _14264 + 32
                                        while idx < mem[_14264]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args stor23[address(this.address)] / stor31 / 10^15, 0, 160, address(this.address), block.timestamp, mem[_14264 + ceil32(return_data.size) + 260 len (32 * mem[_14264]) + 32]
                                    else:
                                        if idx >= stor30.length:
                                            revert with 0, 50
                                        mem[0] = stor30[idx]
                                        mem[32] = 24
                                        if stor24[stor30[idx]] <= s:
                                            if idx >= stor30.length:
                                                revert with 0, 50
                                            mem[0] = stor30[idx]
                                            mem[32] = 23
                                            _13606 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13606] = 30
                                            mem[_13606 + 32] = 'SafeMath: subtraction overflow'
                                            if stor23[stor30[idx]] > t:
                                                _13630 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _13630 + 68] = mem[idx + _13606 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_13630 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _13630 + -mem[64] + 100
                                            if t < stor23[stor30[idx]]:
                                                revert with 0, 17
                                            if idx >= stor30.length:
                                                revert with 0, 50
                                            mem[0] = stor30[idx]
                                            mem[32] = 24
                                            _13848 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13848] = 30
                                            mem[_13848 + 32] = 'SafeMath: subtraction overflow'
                                            if stor24[stor30[idx]] <= s:
                                                if s < stor24[stor30[idx]]:
                                                    revert with 0, 17
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                s = s - stor24[stor30[idx]]
                                                t = t - stor23[stor30[idx]]
                                                continue 
                                            _13919 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13919 + 68] = mem[idx + _13848 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13919 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13919 + -mem[64] + 100
                                        _13607 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13607] = 26
                                        mem[_13607 + 32] = 'SafeMath: division by zero'
                                        _13849 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13849] = 26
                                        mem[_13849 + 32] = 'SafeMath: division by zero'
                                        if not stor31 / 10^15:
                                            _13920 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _13920 + 68] = mem[idx + _13849 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13920 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13920 + -mem[64] + 100
                                        _14369 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        mem[_14369 + 32 len 64] = call.data[calldata.size len 64]
                                        if 0 >= mem[_14369]:
                                            revert with 0, 50
                                        mem[_14369 + 32] = this.address
                                        staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                                gas gas_remaining wei
                                        mem[_14369 + 96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _14369 + ceil32(return_data.size) + 96
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        if 1 >= mem[_14369]:
                                            revert with 0, 50
                                        mem[_14369 + 64] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 25)
                                        allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                        emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                        mem[_14369 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_14369 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                        mem[_14369 + ceil32(return_data.size) + 132] = 0
                                        mem[_14369 + ceil32(return_data.size) + 164] = 160
                                        mem[_14369 + ceil32(return_data.size) + 260] = mem[_14369]
                                        idx = 0
                                        s = _14369 + ceil32(return_data.size) + 292
                                        t = _14369 + 32
                                        while idx < mem[_14369]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args stor23[address(this.address)] / stor31 / 10^15, 0, 160, address(this.address), block.timestamp, mem[_14369 + ceil32(return_data.size) + 260 len (32 * mem[_14369]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                _13279 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13279] = 26
                                mem[_13279 + 32] = 'SafeMath: division by zero'
                                if t < stor31 / 10^15:
                                    _13671 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13671] = 26
                                    mem[_13671 + 32] = 'SafeMath: division by zero'
                                    _14023 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14023] = 26
                                    mem[_14023 + 32] = 'SafeMath: division by zero'
                                    if not stor31 / 10^15:
                                        _14111 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        s = 0
                                        while s < 26:
                                            mem[s + _14111 + 68] = mem[s + _14023 + 32]
                                            s = s + 32
                                            continue 
                                        mem[_14111 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14111 + -mem[64] + 100
                                    _14544 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_14544 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_14544]:
                                        revert with 0, 50
                                    mem[_14544 + 32] = this.address
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_14544 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _14544 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_14544]:
                                        revert with 0, 50
                                    mem[_14544 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 25)
                                    allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                    emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                    mem[_14544 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_14544 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                    mem[_14544 + ceil32(return_data.size) + 132] = 0
                                    mem[_14544 + ceil32(return_data.size) + 164] = 160
                                    mem[_14544 + ceil32(return_data.size) + 260] = mem[_14544]
                                    idx = 0
                                    s = _14544 + ceil32(return_data.size) + 292
                                    t = _14544 + 32
                                    while idx < mem[_14544]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args stor23[address(this.address)] / stor31 / 10^15, 0, 160, address(this.address), block.timestamp, mem[_14544 + ceil32(return_data.size) + 260 len (32 * mem[_14544]) + 32]
                                else:
                                    _13670 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13670] = 26
                                    mem[_13670 + 32] = 'SafeMath: division by zero'
                                    if not s:
                                        _13710 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _13710 + 68] = mem[idx + _13670 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13710 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13710 + -mem[64] + 100
                                    _14022 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14022] = 26
                                    mem[_14022 + 32] = 'SafeMath: division by zero'
                                    if not t / s:
                                        _14110 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        s = 0
                                        while s < 26:
                                            mem[s + _14110 + 68] = mem[s + _14022 + 32]
                                            s = s + 32
                                            continue 
                                        mem[_14110 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14110 + -mem[64] + 100
                                    _14542 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_14542 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_14542]:
                                        revert with 0, 50
                                    mem[_14542 + 32] = this.address
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_14542 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _14542 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_14542]:
                                        revert with 0, 50
                                    mem[_14542 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 25)
                                    allowance[address(this.address)][stor54] = stor23[address(this.address)] / t / s
                                    emit Approval((stor23[address(this.address)] / t / s), this.address, uniswapV2RouterAddress);
                                    mem[_14542 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_14542 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / t / s
                                    mem[_14542 + ceil32(return_data.size) + 132] = 0
                                    mem[_14542 + ceil32(return_data.size) + 164] = 160
                                    mem[_14542 + ceil32(return_data.size) + 260] = mem[_14542]
                                    idx = 0
                                    u = _14542 + ceil32(return_data.size) + 292
                                    v = _14542 + 32
                                    while idx < mem[_14542]:
                                        mem[u] = mem[v + 12 len 20]
                                        idx = idx + 1
                                        u = u + 32
                                        v = v + 32
                                        continue 
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args stor23[address(this.address)] / t / s, 0, 160, address(this.address), block.timestamp, mem[_14542 + ceil32(return_data.size) + 260 len (32 * mem[_14542]) + 32]
            else:
                if idx >= stor30.length:
                    revert with 0, 50
                mem[0] = stor30[idx]
                mem[32] = 24
                if stor24[stor30[idx]] <= s:
                    if idx >= stor30.length:
                        revert with 0, 50
                    mem[0] = stor30[idx]
                    mem[32] = 23
                    _4565 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4565] = 30
                    mem[_4565 + 32] = 'SafeMath: subtraction overflow'
                    if stor23[stor30[idx]] > t:
                        _4571 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _4571 + 68] = mem[idx + _4565 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4571 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _4571 + -mem[64] + 100
                    if t < stor23[stor30[idx]]:
                        revert with 0, 17
                    if idx >= stor30.length:
                        revert with 0, 50
                    mem[0] = stor30[idx]
                    mem[32] = 24
                    _4609 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4609] = 30
                    mem[_4609 + 32] = 'SafeMath: subtraction overflow'
                    if stor24[stor30[idx]] <= s:
                        if s < stor24[stor30[idx]]:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s - stor24[stor30[idx]]
                        t = t - stor23[stor30[idx]]
                        continue 
                    _4623 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _4623 + 68] = mem[idx + _4609 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4623 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _4623 + -mem[64] + 100
                _4566 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4566] = 26
                mem[_4566 + 32] = 'SafeMath: division by zero'
                _4610 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4610] = 26
                mem[_4610 + 32] = 'SafeMath: division by zero'
                if not stor31 / 10^15:
                    _4624 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4624 + 68] = mem[idx + _4610 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4624 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4624 + -mem[64] + 100
                if stor23[address(this.address)] / stor31 / 10^15 <= 0:
                    revert with 0, 'Contract balance is zero'
                mem[0] = this.address
                if stor29[address(this.address)]:
                    mem[32] = 24
                    if arg1 <= stor24[address(this.address)]:
                        _4764 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        mem[_4764 + 32 len 64] = call.data[calldata.size len 64]
                        if 0 >= mem[_4764]:
                            revert with 0, 50
                        mem[_4764 + 32] = this.address
                        staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                gas gas_remaining wei
                        mem[_4764 + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _4764 + ceil32(return_data.size) + 96
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        if 1 >= mem[_4764]:
                            revert with 0, 50
                        mem[_4764 + 64] = ext_call.return_data[12 len 20]
                        if not this.address:
                            revert with 0, 'ERC20: approve from the zero address'
                        if not uniswapV2RouterAddress:
                            revert with 0, 'ERC20: approve to the zero address'
                        mem[0] = uniswapV2RouterAddress
                        mem[32] = sha3(address(this.address), 25)
                        allowance[address(this.address)][stor54] = arg1
                        emit Approval(arg1, this.address, uniswapV2RouterAddress);
                        mem[_4764 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                        mem[_4764 + ceil32(return_data.size) + 100] = arg1
                        mem[_4764 + ceil32(return_data.size) + 132] = 0
                        mem[_4764 + ceil32(return_data.size) + 164] = 160
                        mem[_4764 + ceil32(return_data.size) + 260] = mem[_4764]
                        idx = 0
                        s = _4764 + ceil32(return_data.size) + 292
                        t = _4764 + 32
                        while idx < mem[_4764]:
                            mem[s] = mem[t + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        require ext_code.size(uniswapV2RouterAddress)
                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg1, 0, 160, address(this.address), block.timestamp, mem[_4764 + ceil32(return_data.size) + 260 len (32 * mem[_4764]) + 32]
                    else:
                        mem[0] = this.address
                        if stor29[address(this.address)]:
                            mem[32] = 24
                            _4850 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_4850 + 32 len 64] = call.data[calldata.size len 64]
                            if 0 >= mem[_4850]:
                                revert with 0, 50
                            mem[_4850 + 32] = this.address
                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                    gas gas_remaining wei
                            mem[_4850 + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _4850 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            if 1 >= mem[_4850]:
                                revert with 0, 50
                            mem[_4850 + 64] = ext_call.return_data[12 len 20]
                            if not this.address:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not uniswapV2RouterAddress:
                                revert with 0, 'ERC20: approve to the zero address'
                            mem[0] = uniswapV2RouterAddress
                            mem[32] = sha3(address(this.address), 25)
                            allowance[address(this.address)][stor54] = stor24[address(this.address)]
                            emit Approval(stor24[address(this.address)], this.address, uniswapV2RouterAddress);
                            mem[_4850 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                            mem[_4850 + ceil32(return_data.size) + 100] = stor24[address(this.address)]
                            mem[_4850 + ceil32(return_data.size) + 132] = 0
                            mem[_4850 + ceil32(return_data.size) + 164] = 160
                            mem[_4850 + ceil32(return_data.size) + 260] = mem[_4850]
                            idx = 0
                            s = _4850 + ceil32(return_data.size) + 292
                            t = _4850 + 32
                            while idx < mem[_4850]:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_4850 + ceil32(return_data.size) + 196] = this.address
                            mem[_4850 + ceil32(return_data.size) + 228] = block.timestamp
                            require ext_code.size(uniswapV2RouterAddress)
                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _4850 + ceil32(return_data.size) + (32 * mem[_4850]) + -mem[64] + 288]
                        else:
                            mem[32] = 23
                            if stor23[address(this.address)] > stor31:
                                revert with 0, 'Amount must be less than total reflections'
                            idx = 0
                            s = 10^15
                            t = stor31
                            while idx < stor30.length:
                                mem[0] = stor30[idx]
                                mem[32] = 23
                                if stor23[stor30[idx]] > t:
                                    _9205 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9205] = 26
                                    mem[_9205 + 32] = 'SafeMath: division by zero'
                                    _9352 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9352] = 26
                                    mem[_9352 + 32] = 'SafeMath: division by zero'
                                    if not stor31 / 10^15:
                                        _9431 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _9431 + 68] = mem[idx + _9352 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_9431 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _9431 + -mem[64] + 100
                                    _9748 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_9748 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_9748]:
                                        revert with 0, 50
                                    mem[_9748 + 32] = this.address
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_9748 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _9748 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_9748]:
                                        revert with 0, 50
                                    mem[_9748 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 25)
                                    allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                    emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                    mem[_9748 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_9748 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                    mem[_9748 + ceil32(return_data.size) + 132] = 0
                                    mem[_9748 + ceil32(return_data.size) + 164] = 160
                                    mem[_9748 + ceil32(return_data.size) + 260] = mem[_9748]
                                    idx = 0
                                    s = _9748 + ceil32(return_data.size) + 292
                                    t = _9748 + 32
                                    while idx < mem[_9748]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args stor23[address(this.address)] / stor31 / 10^15, 0, 160, address(this.address), block.timestamp, mem[_9748 + ceil32(return_data.size) + 260 len (32 * mem[_9748]) + 32]
                                else:
                                    if idx >= stor30.length:
                                        revert with 0, 50
                                    mem[0] = stor30[idx]
                                    mem[32] = 24
                                    if stor24[stor30[idx]] <= s:
                                        if idx >= stor30.length:
                                            revert with 0, 50
                                        mem[0] = stor30[idx]
                                        mem[32] = 23
                                        _9248 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9248] = 30
                                        mem[_9248 + 32] = 'SafeMath: subtraction overflow'
                                        if stor23[stor30[idx]] > t:
                                            _9265 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _9265 + 68] = mem[idx + _9248 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_9265 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _9265 + -mem[64] + 100
                                        if t < stor23[stor30[idx]]:
                                            revert with 0, 17
                                        if idx >= stor30.length:
                                            revert with 0, 50
                                        mem[0] = stor30[idx]
                                        mem[32] = 24
                                        _9432 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9432] = 30
                                        mem[_9432 + 32] = 'SafeMath: subtraction overflow'
                                        if stor24[stor30[idx]] <= s:
                                            if s < stor24[stor30[idx]]:
                                                revert with 0, 17
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s - stor24[stor30[idx]]
                                            t = t - stor23[stor30[idx]]
                                            continue 
                                        _9484 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _9484 + 68] = mem[idx + _9432 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_9484 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _9484 + -mem[64] + 100
                                    _9249 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9249] = 26
                                    mem[_9249 + 32] = 'SafeMath: division by zero'
                                    _9433 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9433] = 26
                                    mem[_9433 + 32] = 'SafeMath: division by zero'
                                    if not stor31 / 10^15:
                                        _9485 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _9485 + 68] = mem[idx + _9433 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_9485 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _9485 + -mem[64] + 100
                                    _9840 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_9840 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_9840]:
                                        revert with 0, 50
                                    mem[_9840 + 32] = this.address
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_9840 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _9840 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_9840]:
                                        revert with 0, 50
                                    mem[_9840 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 25)
                                    allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                    emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                    mem[_9840 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_9840 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                    mem[_9840 + ceil32(return_data.size) + 132] = 0
                                    mem[_9840 + ceil32(return_data.size) + 164] = 160
                                    mem[_9840 + ceil32(return_data.size) + 260] = mem[_9840]
                                    idx = 0
                                    s = _9840 + ceil32(return_data.size) + 292
                                    t = _9840 + 32
                                    while idx < mem[_9840]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_9840 + ceil32(return_data.size) + 196] = this.address
                                    mem[_9840 + ceil32(return_data.size) + 228] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _9840 + ceil32(return_data.size) + (32 * mem[_9840]) + -mem[64] + 288]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            _9104 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_9104] = 26
                            mem[_9104 + 32] = 'SafeMath: division by zero'
                            if t < stor31 / 10^15:
                                _9297 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9297] = 26
                                mem[_9297 + 32] = 'SafeMath: division by zero'
                                _9561 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9561] = 26
                                mem[_9561 + 32] = 'SafeMath: division by zero'
                                if not stor31 / 10^15:
                                    _9628 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    s = 0
                                    while s < 26:
                                        mem[s + _9628 + 68] = mem[s + _9561 + 32]
                                        s = s + 32
                                        continue 
                                    mem[_9628 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _9628 + -mem[64] + 100
                                _10031 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_10031 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_10031]:
                                    revert with 0, 50
                                mem[_10031 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_10031 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _10031 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_10031]:
                                    revert with 0, 50
                                mem[_10031 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                mem[_10031 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_10031 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                mem[_10031 + ceil32(return_data.size) + 132] = 0
                                mem[_10031 + ceil32(return_data.size) + 164] = 160
                                mem[_10031 + ceil32(return_data.size) + 260] = mem[_10031]
                                idx = 0
                                s = _10031 + ceil32(return_data.size) + 292
                                t = _10031 + 32
                                while idx < mem[_10031]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args stor23[address(this.address)] / stor31 / 10^15, 0, 160, address(this.address), block.timestamp, mem[_10031 + ceil32(return_data.size) + 260 len (32 * mem[_10031]) + 32]
                            else:
                                _9296 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9296] = 26
                                mem[_9296 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    _9325 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _9325 + 68] = mem[idx + _9296 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_9325 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _9325 + -mem[64] + 100
                                _9560 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9560] = 26
                                mem[_9560 + 32] = 'SafeMath: division by zero'
                                if not t / s:
                                    _9627 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    s = 0
                                    while s < 26:
                                        mem[s + _9627 + 68] = mem[s + _9560 + 32]
                                        s = s + 32
                                        continue 
                                    mem[_9627 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _9627 + -mem[64] + 100
                                _10029 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_10029 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_10029]:
                                    revert with 0, 50
                                mem[_10029 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_10029 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _10029 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_10029]:
                                    revert with 0, 50
                                mem[_10029 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = stor23[address(this.address)] / t / s
                                emit Approval((stor23[address(this.address)] / t / s), this.address, uniswapV2RouterAddress);
                                mem[_10029 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_10029 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / t / s
                                mem[_10029 + ceil32(return_data.size) + 132] = 0
                                mem[_10029 + ceil32(return_data.size) + 164] = 160
                                mem[_10029 + ceil32(return_data.size) + 260] = mem[_10029]
                                idx = 0
                                s = _10029 + ceil32(return_data.size) + 292
                                t = _10029 + 32
                                while idx < mem[_10029]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_10029 + ceil32(return_data.size) + 196] = this.address
                                mem[_10029 + ceil32(return_data.size) + 228] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _10029 + ceil32(return_data.size) + (32 * mem[_10029]) + -mem[64] + 288]
                else:
                    mem[32] = 23
                    if stor23[address(this.address)] > stor31:
                        revert with 0, 'Amount must be less than total reflections'
                    idx = 0
                    s = 10^15
                    t = stor31
                    while idx < stor30.length:
                        mem[0] = stor30[idx]
                        mem[32] = 23
                        if stor23[stor30[idx]] > t:
                            _9204 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_9204] = 26
                            mem[_9204 + 32] = 'SafeMath: division by zero'
                            _9349 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_9349] = 26
                            mem[_9349 + 32] = 'SafeMath: division by zero'
                            if not stor31 / 10^15:
                                _9427 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _9427 + 68] = mem[idx + _9349 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_9427 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _9427 + -mem[64] + 100
                            if arg1 <= stor23[address(this.address)] / stor31 / 10^15:
                                _9743 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_9743 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_9743]:
                                    revert with 0, 50
                                mem[_9743 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_9743 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _9743 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_9743]:
                                    revert with 0, 50
                                mem[_9743 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = arg1
                                emit Approval(arg1, this.address, uniswapV2RouterAddress);
                                mem[_9743 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_9743 + ceil32(return_data.size) + 100] = arg1
                                mem[_9743 + ceil32(return_data.size) + 132] = 0
                                mem[_9743 + ceil32(return_data.size) + 164] = 160
                                mem[_9743 + ceil32(return_data.size) + 260] = mem[_9743]
                                idx = 0
                                s = _9743 + ceil32(return_data.size) + 292
                                t = _9743 + 32
                                while idx < mem[_9743]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_9743 + ceil32(return_data.size) + 196] = this.address
                                mem[_9743 + ceil32(return_data.size) + 228] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _9743 + ceil32(return_data.size) + (32 * mem[_9743]) + -mem[64] + 288]
                            else:
                                mem[0] = this.address
                                if stor29[address(this.address)]:
                                    mem[32] = 24
                                    _9945 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_9945 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_9945]:
                                        revert with 0, 50
                                    mem[_9945 + 32] = this.address
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_9945 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _9945 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_9945]:
                                        revert with 0, 50
                                    mem[_9945 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 25)
                                    allowance[address(this.address)][stor54] = stor24[address(this.address)]
                                    emit Approval(stor24[address(this.address)], this.address, uniswapV2RouterAddress);
                                    mem[_9945 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_9945 + ceil32(return_data.size) + 100] = stor24[address(this.address)]
                                    mem[_9945 + ceil32(return_data.size) + 132] = 0
                                    mem[_9945 + ceil32(return_data.size) + 164] = 160
                                    mem[_9945 + ceil32(return_data.size) + 260] = mem[_9945]
                                    idx = 0
                                    s = _9945 + ceil32(return_data.size) + 292
                                    t = _9945 + 32
                                    while idx < mem[_9945]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_9945 + ceil32(return_data.size) + 196] = this.address
                                    mem[_9945 + ceil32(return_data.size) + 228] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _9945 + ceil32(return_data.size) + (32 * mem[_9945]) + -mem[64] + 288]
                                else:
                                    mem[32] = 23
                                    if stor23[address(this.address)] > stor31:
                                        revert with 0, 'Amount must be less than total reflections'
                                    idx = 0
                                    s = 10^15
                                    t = stor31
                                    while idx < stor30.length:
                                        mem[0] = stor30[idx]
                                        mem[32] = 23
                                        if stor23[stor30[idx]] > t:
                                            _13556 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13556] = 26
                                            mem[_13556 + 32] = 'SafeMath: division by zero'
                                            _13761 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13761] = 26
                                            mem[_13761 + 32] = 'SafeMath: division by zero'
                                            if not stor31 / 10^15:
                                                _13871 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _13871 + 68] = mem[idx + _13761 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_13871 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _13871 + -mem[64] + 100
                                            _14288 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            mem[_14288 + 32 len 64] = call.data[calldata.size len 64]
                                            if 0 >= mem[_14288]:
                                                revert with 0, 50
                                            mem[_14288 + 32] = this.address
                                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                                    gas gas_remaining wei
                                            mem[_14288 + 96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = _14288 + ceil32(return_data.size) + 96
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                            if 1 >= mem[_14288]:
                                                revert with 0, 50
                                            mem[_14288 + 64] = ext_call.return_data[12 len 20]
                                            if not this.address:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not uniswapV2RouterAddress:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            mem[0] = uniswapV2RouterAddress
                                            mem[32] = sha3(address(this.address), 25)
                                            allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                            emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                            mem[_14288 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                            mem[_14288 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                            mem[_14288 + ceil32(return_data.size) + 132] = 0
                                            mem[_14288 + ceil32(return_data.size) + 164] = 160
                                            mem[_14288 + ceil32(return_data.size) + 260] = mem[_14288]
                                            idx = 0
                                            s = _14288 + ceil32(return_data.size) + 292
                                            t = _14288 + 32
                                            while idx < mem[_14288]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_14288 + ceil32(return_data.size) + 196] = this.address
                                            mem[_14288 + ceil32(return_data.size) + 228] = block.timestamp
                                            require ext_code.size(uniswapV2RouterAddress)
                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _14288 + ceil32(return_data.size) + (32 * mem[_14288]) + -mem[64] + 288]
                                        else:
                                            if idx >= stor30.length:
                                                revert with 0, 50
                                            mem[0] = stor30[idx]
                                            mem[32] = 24
                                            if stor24[stor30[idx]] <= s:
                                                if idx >= stor30.length:
                                                    revert with 0, 50
                                                mem[0] = stor30[idx]
                                                mem[32] = 23
                                                _13618 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_13618] = 30
                                                mem[_13618 + 32] = 'SafeMath: subtraction overflow'
                                                if stor23[stor30[idx]] > t:
                                                    _13636 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _13636 + 68] = mem[idx + _13618 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_13636 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _13636 + -mem[64] + 100
                                                if t < stor23[stor30[idx]]:
                                                    revert with 0, 17
                                                if idx >= stor30.length:
                                                    revert with 0, 50
                                                mem[0] = stor30[idx]
                                                mem[32] = 24
                                                _13872 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_13872] = 30
                                                mem[_13872 + 32] = 'SafeMath: subtraction overflow'
                                                if stor24[stor30[idx]] <= s:
                                                    if s < stor24[stor30[idx]]:
                                                        revert with 0, 17
                                                    if idx == -1:
                                                        revert with 0, 17
                                                    idx = idx + 1
                                                    s = s - stor24[stor30[idx]]
                                                    t = t - stor23[stor30[idx]]
                                                    continue 
                                                _13937 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _13937 + 68] = mem[idx + _13872 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_13937 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _13937 + -mem[64] + 100
                                            _13619 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13619] = 26
                                            mem[_13619 + 32] = 'SafeMath: division by zero'
                                            _13873 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13873] = 26
                                            mem[_13873 + 32] = 'SafeMath: division by zero'
                                            if not stor31 / 10^15:
                                                _13938 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _13938 + 68] = mem[idx + _13873 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_13938 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _13938 + -mem[64] + 100
                                            _14399 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            mem[_14399 + 32 len 64] = call.data[calldata.size len 64]
                                            if 0 >= mem[_14399]:
                                                revert with 0, 50
                                            mem[_14399 + 32] = this.address
                                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                                    gas gas_remaining wei
                                            mem[_14399 + 96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = _14399 + ceil32(return_data.size) + 96
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                            if 1 >= mem[_14399]:
                                                revert with 0, 50
                                            mem[_14399 + 64] = ext_call.return_data[12 len 20]
                                            if not this.address:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not uniswapV2RouterAddress:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            mem[0] = uniswapV2RouterAddress
                                            mem[32] = sha3(address(this.address), 25)
                                            allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                            emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                            mem[_14399 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                            mem[_14399 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                            mem[_14399 + ceil32(return_data.size) + 132] = 0
                                            mem[_14399 + ceil32(return_data.size) + 164] = 160
                                            mem[_14399 + ceil32(return_data.size) + 260] = mem[_14399]
                                            idx = 0
                                            s = _14399 + ceil32(return_data.size) + 292
                                            t = _14399 + 32
                                            while idx < mem[_14399]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_14399 + ceil32(return_data.size) + 196] = this.address
                                            mem[_14399 + ceil32(return_data.size) + 228] = block.timestamp
                                            require ext_code.size(uniswapV2RouterAddress)
                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _14399 + ceil32(return_data.size) + (32 * mem[_14399]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                    _13313 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13313] = 26
                                    mem[_13313 + 32] = 'SafeMath: division by zero'
                                    if t < stor31 / 10^15:
                                        _13683 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13683] = 26
                                        mem[_13683 + 32] = 'SafeMath: division by zero'
                                        _14035 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14035] = 26
                                        mem[_14035 + 32] = 'SafeMath: division by zero'
                                        if not stor31 / 10^15:
                                            _14129 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            s = 0
                                            while s < 26:
                                                mem[s + _14129 + 68] = mem[s + _14035 + 32]
                                                s = s + 32
                                                continue 
                                            mem[_14129 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14129 + -mem[64] + 100
                                        _14574 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        mem[_14574 + 32 len 64] = call.data[calldata.size len 64]
                                        if 0 >= mem[_14574]:
                                            revert with 0, 50
                                        mem[_14574 + 32] = this.address
                                        staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                                gas gas_remaining wei
                                        mem[_14574 + 96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _14574 + ceil32(return_data.size) + 96
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        if 1 >= mem[_14574]:
                                            revert with 0, 50
                                        mem[_14574 + 64] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 25)
                                        allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                        emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                        mem[_14574 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_14574 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                        mem[_14574 + ceil32(return_data.size) + 132] = 0
                                        mem[_14574 + ceil32(return_data.size) + 164] = 160
                                        mem[_14574 + ceil32(return_data.size) + 260] = mem[_14574]
                                        idx = 0
                                        s = _14574 + ceil32(return_data.size) + 292
                                        t = _14574 + 32
                                        while idx < mem[_14574]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args stor23[address(this.address)] / stor31 / 10^15, 0, 160, address(this.address), block.timestamp, mem[_14574 + ceil32(return_data.size) + 260 len (32 * mem[_14574]) + 32]
                                    else:
                                        _13682 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13682] = 26
                                        mem[_13682 + 32] = 'SafeMath: division by zero'
                                        if not s:
                                            _13716 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _13716 + 68] = mem[idx + _13682 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13716 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13716 + -mem[64] + 100
                                        _14034 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14034] = 26
                                        mem[_14034 + 32] = 'SafeMath: division by zero'
                                        if not t / s:
                                            _14128 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            s = 0
                                            while s < 26:
                                                mem[s + _14128 + 68] = mem[s + _14034 + 32]
                                                s = s + 32
                                                continue 
                                            mem[_14128 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14128 + -mem[64] + 100
                                        _14572 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        mem[_14572 + 32 len 64] = call.data[calldata.size len 64]
                                        if 0 >= mem[_14572]:
                                            revert with 0, 50
                                        mem[_14572 + 32] = this.address
                                        staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                                gas gas_remaining wei
                                        mem[_14572 + 96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _14572 + ceil32(return_data.size) + 96
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        if 1 >= mem[_14572]:
                                            revert with 0, 50
                                        mem[_14572 + 64] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 25)
                                        allowance[address(this.address)][stor54] = stor23[address(this.address)] / t / s
                                        emit Approval((stor23[address(this.address)] / t / s), this.address, uniswapV2RouterAddress);
                                        mem[_14572 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_14572 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / t / s
                                        mem[_14572 + ceil32(return_data.size) + 132] = 0
                                        mem[_14572 + ceil32(return_data.size) + 164] = 160
                                        mem[_14572 + ceil32(return_data.size) + 260] = mem[_14572]
                                        idx = 0
                                        s = _14572 + ceil32(return_data.size) + 292
                                        t = _14572 + 32
                                        while idx < mem[_14572]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_14572 + ceil32(return_data.size) + 196] = this.address
                                        mem[_14572 + ceil32(return_data.size) + 228] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _14572 + ceil32(return_data.size) + (32 * mem[_14572]) + -mem[64] + 288]
                        else:
                            if idx >= stor30.length:
                                revert with 0, 50
                            mem[0] = stor30[idx]
                            mem[32] = 24
                            if stor24[stor30[idx]] <= s:
                                if idx >= stor30.length:
                                    revert with 0, 50
                                mem[0] = stor30[idx]
                                mem[32] = 23
                                _9246 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9246] = 30
                                mem[_9246 + 32] = 'SafeMath: subtraction overflow'
                                if stor23[stor30[idx]] > t:
                                    _9264 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _9264 + 68] = mem[idx + _9246 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_9264 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _9264 + -mem[64] + 100
                                if t < stor23[stor30[idx]]:
                                    revert with 0, 17
                                if idx >= stor30.length:
                                    revert with 0, 50
                                mem[0] = stor30[idx]
                                mem[32] = 24
                                _9428 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9428] = 30
                                mem[_9428 + 32] = 'SafeMath: subtraction overflow'
                                if stor24[stor30[idx]] <= s:
                                    if s < stor24[stor30[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor24[stor30[idx]]
                                    t = t - stor23[stor30[idx]]
                                    continue 
                                _9481 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _9481 + 68] = mem[idx + _9428 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_9481 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _9481 + -mem[64] + 100
                            _9247 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_9247] = 26
                            mem[_9247 + 32] = 'SafeMath: division by zero'
                            _9429 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_9429] = 26
                            mem[_9429 + 32] = 'SafeMath: division by zero'
                            if not stor31 / 10^15:
                                _9482 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _9482 + 68] = mem[idx + _9429 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_9482 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _9482 + -mem[64] + 100
                            if arg1 <= stor23[address(this.address)] / stor31 / 10^15:
                                _9834 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_9834 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_9834]:
                                    revert with 0, 50
                                mem[_9834 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_9834 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _9834 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_9834]:
                                    revert with 0, 50
                                mem[_9834 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = arg1
                                emit Approval(arg1, this.address, uniswapV2RouterAddress);
                                mem[_9834 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_9834 + ceil32(return_data.size) + 100] = arg1
                                mem[_9834 + ceil32(return_data.size) + 132] = 0
                                mem[_9834 + ceil32(return_data.size) + 164] = 160
                                mem[_9834 + ceil32(return_data.size) + 260] = mem[_9834]
                                idx = 0
                                s = _9834 + ceil32(return_data.size) + 292
                                t = _9834 + 32
                                while idx < mem[_9834]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args arg1, 0, 160, address(this.address), block.timestamp, mem[_9834 + ceil32(return_data.size) + 260 len (32 * mem[_9834]) + 32]
                            else:
                                mem[0] = this.address
                                if stor29[address(this.address)]:
                                    mem[32] = 24
                                    _10027 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_10027 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_10027]:
                                        revert with 0, 50
                                    mem[_10027 + 32] = this.address
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_10027 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _10027 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_10027]:
                                        revert with 0, 50
                                    mem[_10027 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 25)
                                    allowance[address(this.address)][stor54] = stor24[address(this.address)]
                                    emit Approval(stor24[address(this.address)], this.address, uniswapV2RouterAddress);
                                    mem[_10027 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_10027 + ceil32(return_data.size) + 100] = stor24[address(this.address)]
                                    mem[_10027 + ceil32(return_data.size) + 132] = 0
                                    mem[_10027 + ceil32(return_data.size) + 164] = 160
                                    mem[_10027 + ceil32(return_data.size) + 260] = mem[_10027]
                                    idx = 0
                                    s = _10027 + ceil32(return_data.size) + 292
                                    t = _10027 + 32
                                    while idx < mem[_10027]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args stor24[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_10027 + ceil32(return_data.size) + 260 len (32 * mem[_10027]) + 32]
                                else:
                                    mem[32] = 23
                                    if stor23[address(this.address)] > stor31:
                                        revert with 0, 'Amount must be less than total reflections'
                                    idx = 0
                                    s = 10^15
                                    t = stor31
                                    while idx < stor30.length:
                                        mem[0] = stor30[idx]
                                        mem[32] = 23
                                        if stor23[stor30[idx]] > t:
                                            _13557 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13557] = 26
                                            mem[_13557 + 32] = 'SafeMath: division by zero'
                                            _13764 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13764] = 26
                                            mem[_13764 + 32] = 'SafeMath: division by zero'
                                            if not stor31 / 10^15:
                                                _13875 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _13875 + 68] = mem[idx + _13764 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_13875 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _13875 + -mem[64] + 100
                                            _14292 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            mem[_14292 + 32 len 64] = call.data[calldata.size len 64]
                                            if 0 >= mem[_14292]:
                                                revert with 0, 50
                                            mem[_14292 + 32] = this.address
                                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                                    gas gas_remaining wei
                                            mem[_14292 + 96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = _14292 + ceil32(return_data.size) + 96
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                            if 1 >= mem[_14292]:
                                                revert with 0, 50
                                            mem[_14292 + 64] = ext_call.return_data[12 len 20]
                                            if not this.address:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not uniswapV2RouterAddress:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            mem[0] = uniswapV2RouterAddress
                                            mem[32] = sha3(address(this.address), 25)
                                            allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                            emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                            mem[_14292 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                            mem[_14292 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                            mem[_14292 + ceil32(return_data.size) + 132] = 0
                                            mem[_14292 + ceil32(return_data.size) + 164] = 160
                                            mem[_14292 + ceil32(return_data.size) + 260] = mem[_14292]
                                            idx = 0
                                            s = _14292 + ceil32(return_data.size) + 292
                                            t = _14292 + 32
                                            while idx < mem[_14292]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            require ext_code.size(uniswapV2RouterAddress)
                                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                 gas gas_remaining wei
                                                args stor23[address(this.address)] / stor31 / 10^15, 0, 160, address(this.address), block.timestamp, mem[_14292 + ceil32(return_data.size) + 260 len (32 * mem[_14292]) + 32]
                                        else:
                                            if idx >= stor30.length:
                                                revert with 0, 50
                                            mem[0] = stor30[idx]
                                            mem[32] = 24
                                            if stor24[stor30[idx]] <= s:
                                                if idx >= stor30.length:
                                                    revert with 0, 50
                                                mem[0] = stor30[idx]
                                                mem[32] = 23
                                                _13620 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_13620] = 30
                                                mem[_13620 + 32] = 'SafeMath: subtraction overflow'
                                                if stor23[stor30[idx]] > t:
                                                    _13637 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _13637 + 68] = mem[idx + _13620 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_13637 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _13637 + -mem[64] + 100
                                                if t < stor23[stor30[idx]]:
                                                    revert with 0, 17
                                                if idx >= stor30.length:
                                                    revert with 0, 50
                                                mem[0] = stor30[idx]
                                                mem[32] = 24
                                                _13876 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_13876] = 30
                                                mem[_13876 + 32] = 'SafeMath: subtraction overflow'
                                                if stor24[stor30[idx]] <= s:
                                                    if s < stor24[stor30[idx]]:
                                                        revert with 0, 17
                                                    if idx == -1:
                                                        revert with 0, 17
                                                    idx = idx + 1
                                                    s = s - stor24[stor30[idx]]
                                                    t = t - stor23[stor30[idx]]
                                                    continue 
                                                _13940 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _13940 + 68] = mem[idx + _13876 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_13940 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _13940 + -mem[64] + 100
                                            _13621 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13621] = 26
                                            mem[_13621 + 32] = 'SafeMath: division by zero'
                                            _13877 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13877] = 26
                                            mem[_13877 + 32] = 'SafeMath: division by zero'
                                            if not stor31 / 10^15:
                                                _13941 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _13941 + 68] = mem[idx + _13877 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_13941 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _13941 + -mem[64] + 100
                                            _14404 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            mem[_14404 + 32 len 64] = call.data[calldata.size len 64]
                                            if 0 >= mem[_14404]:
                                                revert with 0, 50
                                            mem[_14404 + 32] = this.address
                                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                                    gas gas_remaining wei
                                            mem[_14404 + 96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = _14404 + ceil32(return_data.size) + 96
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                            if 1 >= mem[_14404]:
                                                revert with 0, 50
                                            mem[_14404 + 64] = ext_call.return_data[12 len 20]
                                            if not this.address:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not uniswapV2RouterAddress:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            mem[0] = uniswapV2RouterAddress
                                            mem[32] = sha3(address(this.address), 25)
                                            allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                            emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                            mem[_14404 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                            mem[_14404 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                            mem[_14404 + ceil32(return_data.size) + 132] = 0
                                            mem[_14404 + ceil32(return_data.size) + 164] = 160
                                            mem[_14404 + ceil32(return_data.size) + 260] = mem[_14404]
                                            idx = 0
                                            s = _14404 + ceil32(return_data.size) + 292
                                            t = _14404 + 32
                                            while idx < mem[_14404]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_14404 + ceil32(return_data.size) + 196] = this.address
                                            mem[_14404 + ceil32(return_data.size) + 228] = block.timestamp
                                            require ext_code.size(uniswapV2RouterAddress)
                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _14404 + ceil32(return_data.size) + (32 * mem[_14404]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                    _13318 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13318] = 26
                                    mem[_13318 + 32] = 'SafeMath: division by zero'
                                    if t < stor31 / 10^15:
                                        _13685 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13685] = 26
                                        mem[_13685 + 32] = 'SafeMath: division by zero'
                                        _14037 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14037] = 26
                                        mem[_14037 + 32] = 'SafeMath: division by zero'
                                        if not stor31 / 10^15:
                                            _14132 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            s = 0
                                            while s < 26:
                                                mem[s + _14132 + 68] = mem[s + _14037 + 32]
                                                s = s + 32
                                                continue 
                                            mem[_14132 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14132 + -mem[64] + 100
                                        _14579 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        mem[_14579 + 32 len 64] = call.data[calldata.size len 64]
                                        if 0 >= mem[_14579]:
                                            revert with 0, 50
                                        mem[_14579 + 32] = this.address
                                        staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                                gas gas_remaining wei
                                        mem[_14579 + 96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _14579 + ceil32(return_data.size) + 96
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        if 1 >= mem[_14579]:
                                            revert with 0, 50
                                        mem[_14579 + 64] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 25)
                                        allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                        emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                        mem[_14579 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_14579 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                        mem[_14579 + ceil32(return_data.size) + 132] = 0
                                        mem[_14579 + ceil32(return_data.size) + 164] = 160
                                        mem[_14579 + ceil32(return_data.size) + 260] = mem[_14579]
                                        idx = 0
                                        s = _14579 + ceil32(return_data.size) + 292
                                        t = _14579 + 32
                                        while idx < mem[_14579]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_14579 + ceil32(return_data.size) + 196] = this.address
                                        mem[_14579 + ceil32(return_data.size) + 228] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _14579 + ceil32(return_data.size) + (32 * mem[_14579]) + -mem[64] + 288]
                                    else:
                                        _13684 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13684] = 26
                                        mem[_13684 + 32] = 'SafeMath: division by zero'
                                        if not s:
                                            _13717 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _13717 + 68] = mem[idx + _13684 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13717 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13717 + -mem[64] + 100
                                        _14036 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14036] = 26
                                        mem[_14036 + 32] = 'SafeMath: division by zero'
                                        if not t / s:
                                            _14131 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            s = 0
                                            while s < 26:
                                                mem[s + _14131 + 68] = mem[s + _14036 + 32]
                                                s = s + 32
                                                continue 
                                            mem[_14131 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14131 + -mem[64] + 100
                                        _14577 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        mem[_14577 + 32 len 64] = call.data[calldata.size len 64]
                                        if 0 >= mem[_14577]:
                                            revert with 0, 50
                                        mem[_14577 + 32] = this.address
                                        staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                                gas gas_remaining wei
                                        mem[_14577 + 96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _14577 + ceil32(return_data.size) + 96
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        if 1 >= mem[_14577]:
                                            revert with 0, 50
                                        mem[_14577 + 64] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 25)
                                        allowance[address(this.address)][stor54] = stor23[address(this.address)] / t / s
                                        emit Approval((stor23[address(this.address)] / t / s), this.address, uniswapV2RouterAddress);
                                        mem[_14577 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_14577 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / t / s
                                        mem[_14577 + ceil32(return_data.size) + 132] = 0
                                        mem[_14577 + ceil32(return_data.size) + 164] = 160
                                        mem[_14577 + ceil32(return_data.size) + 260] = mem[_14577]
                                        idx = 0
                                        s = _14577 + ceil32(return_data.size) + 292
                                        t = _14577 + 32
                                        while idx < mem[_14577]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_14577 + ceil32(return_data.size) + 196] = this.address
                                        mem[_14577 + ceil32(return_data.size) + 228] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _14577 + ceil32(return_data.size) + (32 * mem[_14577]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                    _9100 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9100] = 26
                    mem[_9100 + 32] = 'SafeMath: division by zero'
                    if t >= stor31 / 10^15:
                        _9294 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9294] = 26
                        mem[_9294 + 32] = 'SafeMath: division by zero'
                        if not s:
                            _9324 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _9324 + 68] = mem[idx + _9294 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9324 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9324 + -mem[64] + 100
                        _9558 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9558] = 26
                        mem[_9558 + 32] = 'SafeMath: division by zero'
                        if not t / s:
                            _9624 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            s = 0
                            while s < 26:
                                mem[s + _9624 + 68] = mem[s + _9558 + 32]
                                s = s + 32
                                continue 
                            mem[_9624 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9624 + -mem[64] + 100
                        if arg1 <= stor23[address(this.address)] / t / s:
                            _10018 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_10018 + 32 len 64] = call.data[calldata.size len 64]
                            if 0 >= mem[_10018]:
                                revert with 0, 50
                            mem[_10018 + 32] = this.address
                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                    gas gas_remaining wei
                            mem[_10018 + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _10018 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            if 1 >= mem[_10018]:
                                revert with 0, 50
                            mem[_10018 + 64] = ext_call.return_data[12 len 20]
                            if not this.address:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not uniswapV2RouterAddress:
                                revert with 0, 'ERC20: approve to the zero address'
                            mem[0] = uniswapV2RouterAddress
                            mem[32] = sha3(address(this.address), 25)
                            allowance[address(this.address)][stor54] = arg1
                            emit Approval(arg1, this.address, uniswapV2RouterAddress);
                            mem[_10018 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                            mem[_10018 + ceil32(return_data.size) + 100] = arg1
                            mem[_10018 + ceil32(return_data.size) + 132] = 0
                            mem[_10018 + ceil32(return_data.size) + 164] = 160
                            mem[_10018 + ceil32(return_data.size) + 260] = mem[_10018]
                            idx = 0
                            s = _10018 + ceil32(return_data.size) + 292
                            t = _10018 + 32
                            while idx < mem[_10018]:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_10018 + ceil32(return_data.size) + 196] = this.address
                            mem[_10018 + ceil32(return_data.size) + 228] = block.timestamp
                            require ext_code.size(uniswapV2RouterAddress)
                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _10018 + ceil32(return_data.size) + (32 * mem[_10018]) + -mem[64] + 288]
                        else:
                            mem[0] = this.address
                            if stor29[address(this.address)]:
                                mem[32] = 24
                                _10246 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_10246 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_10246]:
                                    revert with 0, 50
                                mem[_10246 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_10246 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _10246 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_10246]:
                                    revert with 0, 50
                                mem[_10246 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = stor24[address(this.address)]
                                emit Approval(stor24[address(this.address)], this.address, uniswapV2RouterAddress);
                                mem[_10246 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_10246 + ceil32(return_data.size) + 100] = stor24[address(this.address)]
                                mem[_10246 + ceil32(return_data.size) + 132] = 0
                                mem[_10246 + ceil32(return_data.size) + 164] = 160
                                mem[_10246 + ceil32(return_data.size) + 260] = mem[_10246]
                                idx = 0
                                s = _10246 + ceil32(return_data.size) + 292
                                t = _10246 + 32
                                while idx < mem[_10246]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args stor24[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_10246 + ceil32(return_data.size) + 260 len (32 * mem[_10246]) + 32]
                            else:
                                mem[32] = 23
                                if stor23[address(this.address)] > stor31:
                                    revert with 0, 'Amount must be less than total reflections'
                                idx = 0
                                s = 10^15
                                t = stor31
                                while idx < stor30.length:
                                    mem[0] = stor30[idx]
                                    mem[32] = 23
                                    if stor23[stor30[idx]] > t:
                                        _13554 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13554] = 26
                                        mem[_13554 + 32] = 'SafeMath: division by zero'
                                        _13755 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13755] = 26
                                        mem[_13755 + 32] = 'SafeMath: division by zero'
                                        if not stor31 / 10^15:
                                            _13863 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _13863 + 68] = mem[idx + _13755 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13863 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13863 + -mem[64] + 100
                                        _14280 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        mem[_14280 + 32 len 64] = call.data[calldata.size len 64]
                                        if 0 >= mem[_14280]:
                                            revert with 0, 50
                                        mem[_14280 + 32] = this.address
                                        staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                                gas gas_remaining wei
                                        mem[_14280 + 96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _14280 + ceil32(return_data.size) + 96
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        if 1 >= mem[_14280]:
                                            revert with 0, 50
                                        mem[_14280 + 64] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 25)
                                        allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                        emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                        mem[_14280 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_14280 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                        mem[_14280 + ceil32(return_data.size) + 132] = 0
                                        mem[_14280 + ceil32(return_data.size) + 164] = 160
                                        mem[_14280 + ceil32(return_data.size) + 260] = mem[_14280]
                                        idx = 0
                                        s = _14280 + ceil32(return_data.size) + 292
                                        t = _14280 + 32
                                        while idx < mem[_14280]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args stor23[address(this.address)] / stor31 / 10^15, 0, 160, address(this.address), block.timestamp, mem[_14280 + ceil32(return_data.size) + 260 len (32 * mem[_14280]) + 32]
                                    else:
                                        if idx >= stor30.length:
                                            revert with 0, 50
                                        mem[0] = stor30[idx]
                                        mem[32] = 24
                                        if stor24[stor30[idx]] <= s:
                                            if idx >= stor30.length:
                                                revert with 0, 50
                                            mem[0] = stor30[idx]
                                            mem[32] = 23
                                            _13614 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13614] = 30
                                            mem[_13614 + 32] = 'SafeMath: subtraction overflow'
                                            if stor23[stor30[idx]] > t:
                                                _13634 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _13634 + 68] = mem[idx + _13614 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_13634 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _13634 + -mem[64] + 100
                                            if t < stor23[stor30[idx]]:
                                                revert with 0, 17
                                            if idx >= stor30.length:
                                                revert with 0, 50
                                            mem[0] = stor30[idx]
                                            mem[32] = 24
                                            _13864 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13864] = 30
                                            mem[_13864 + 32] = 'SafeMath: subtraction overflow'
                                            if stor24[stor30[idx]] <= s:
                                                if s < stor24[stor30[idx]]:
                                                    revert with 0, 17
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                s = s - stor24[stor30[idx]]
                                                t = t - stor23[stor30[idx]]
                                                continue 
                                            _13931 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13931 + 68] = mem[idx + _13864 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13931 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13931 + -mem[64] + 100
                                        _13615 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13615] = 26
                                        mem[_13615 + 32] = 'SafeMath: division by zero'
                                        _13865 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13865] = 26
                                        mem[_13865 + 32] = 'SafeMath: division by zero'
                                        if not stor31 / 10^15:
                                            _13932 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _13932 + 68] = mem[idx + _13865 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13932 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13932 + -mem[64] + 100
                                        _14389 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        mem[_14389 + 32 len 64] = call.data[calldata.size len 64]
                                        if 0 >= mem[_14389]:
                                            revert with 0, 50
                                        mem[_14389 + 32] = this.address
                                        staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                                gas gas_remaining wei
                                        mem[_14389 + 96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _14389 + ceil32(return_data.size) + 96
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        if 1 >= mem[_14389]:
                                            revert with 0, 50
                                        mem[_14389 + 64] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 25)
                                        allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                        emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                        mem[_14389 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_14389 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                        mem[_14389 + ceil32(return_data.size) + 132] = 0
                                        mem[_14389 + ceil32(return_data.size) + 164] = 160
                                        mem[_14389 + ceil32(return_data.size) + 260] = mem[_14389]
                                        idx = 0
                                        s = _14389 + ceil32(return_data.size) + 292
                                        t = _14389 + 32
                                        while idx < mem[_14389]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args stor23[address(this.address)] / stor31 / 10^15, 0, 160, address(this.address), block.timestamp, mem[_14389 + ceil32(return_data.size) + 260 len (32 * mem[_14389]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                _13303 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13303] = 26
                                mem[_13303 + 32] = 'SafeMath: division by zero'
                                if t < stor31 / 10^15:
                                    _13679 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13679] = 26
                                    mem[_13679 + 32] = 'SafeMath: division by zero'
                                    _14031 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14031] = 26
                                    mem[_14031 + 32] = 'SafeMath: division by zero'
                                    if not stor31 / 10^15:
                                        _14123 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        s = 0
                                        while s < 26:
                                            mem[s + _14123 + 68] = mem[s + _14031 + 32]
                                            s = s + 32
                                            continue 
                                        mem[_14123 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14123 + -mem[64] + 100
                                    _14564 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_14564 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_14564]:
                                        revert with 0, 50
                                    mem[_14564 + 32] = this.address
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_14564 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _14564 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_14564]:
                                        revert with 0, 50
                                    mem[_14564 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 25)
                                    allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                    emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                    mem[_14564 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_14564 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                    mem[_14564 + ceil32(return_data.size) + 132] = 0
                                    mem[_14564 + ceil32(return_data.size) + 164] = 160
                                    mem[_14564 + ceil32(return_data.size) + 260] = mem[_14564]
                                    idx = 0
                                    s = _14564 + ceil32(return_data.size) + 292
                                    t = _14564 + 32
                                    while idx < mem[_14564]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args stor23[address(this.address)] / stor31 / 10^15, 0, 160, address(this.address), block.timestamp, mem[_14564 + ceil32(return_data.size) + 260 len (32 * mem[_14564]) + 32]
                                else:
                                    _13678 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13678] = 26
                                    mem[_13678 + 32] = 'SafeMath: division by zero'
                                    if not s:
                                        _13714 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _13714 + 68] = mem[idx + _13678 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13714 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13714 + -mem[64] + 100
                                    _14030 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14030] = 26
                                    mem[_14030 + 32] = 'SafeMath: division by zero'
                                    if not t / s:
                                        _14122 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        s = 0
                                        while s < 26:
                                            mem[s + _14122 + 68] = mem[s + _14030 + 32]
                                            s = s + 32
                                            continue 
                                        mem[_14122 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14122 + -mem[64] + 100
                                    _14562 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_14562 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_14562]:
                                        revert with 0, 50
                                    mem[_14562 + 32] = this.address
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_14562 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _14562 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_14562]:
                                        revert with 0, 50
                                    mem[_14562 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 25)
                                    allowance[address(this.address)][stor54] = stor23[address(this.address)] / t / s
                                    emit Approval((stor23[address(this.address)] / t / s), this.address, uniswapV2RouterAddress);
                                    mem[_14562 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_14562 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / t / s
                                    mem[_14562 + ceil32(return_data.size) + 132] = 0
                                    mem[_14562 + ceil32(return_data.size) + 164] = 160
                                    mem[_14562 + ceil32(return_data.size) + 260] = mem[_14562]
                                    idx = 0
                                    u = _14562 + ceil32(return_data.size) + 292
                                    v = _14562 + 32
                                    while idx < mem[_14562]:
                                        mem[u] = mem[v + 12 len 20]
                                        idx = idx + 1
                                        u = u + 32
                                        v = v + 32
                                        continue 
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args stor23[address(this.address)] / t / s, 0, 160, address(this.address), block.timestamp, mem[_14562 + ceil32(return_data.size) + 260 len (32 * mem[_14562]) + 32]
                    else:
                        _9295 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9295] = 26
                        mem[_9295 + 32] = 'SafeMath: division by zero'
                        _9559 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9559] = 26
                        mem[_9559 + 32] = 'SafeMath: division by zero'
                        if not stor31 / 10^15:
                            _9625 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            s = 0
                            while s < 26:
                                mem[s + _9625 + 68] = mem[s + _9559 + 32]
                                s = s + 32
                                continue 
                            mem[_9625 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9625 + -mem[64] + 100
                        if arg1 <= stor23[address(this.address)] / stor31 / 10^15:
                            _10021 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_10021 + 32 len 64] = call.data[calldata.size len 64]
                            if 0 >= mem[_10021]:
                                revert with 0, 50
                            mem[_10021 + 32] = this.address
                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                    gas gas_remaining wei
                            mem[_10021 + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _10021 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            if 1 >= mem[_10021]:
                                revert with 0, 50
                            mem[_10021 + 64] = ext_call.return_data[12 len 20]
                            if not this.address:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not uniswapV2RouterAddress:
                                revert with 0, 'ERC20: approve to the zero address'
                            mem[0] = uniswapV2RouterAddress
                            mem[32] = sha3(address(this.address), 25)
                            allowance[address(this.address)][stor54] = arg1
                            emit Approval(arg1, this.address, uniswapV2RouterAddress);
                            mem[_10021 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                            mem[_10021 + ceil32(return_data.size) + 100] = arg1
                            mem[_10021 + ceil32(return_data.size) + 132] = 0
                            mem[_10021 + ceil32(return_data.size) + 164] = 160
                            mem[_10021 + ceil32(return_data.size) + 260] = mem[_10021]
                            idx = 0
                            s = _10021 + ceil32(return_data.size) + 292
                            t = _10021 + 32
                            while idx < mem[_10021]:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(uniswapV2RouterAddress)
                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args arg1, 0, 160, address(this.address), block.timestamp, mem[_10021 + ceil32(return_data.size) + 260 len (32 * mem[_10021]) + 32]
                        else:
                            mem[0] = this.address
                            if stor29[address(this.address)]:
                                mem[32] = 24
                                _10250 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_10250 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_10250]:
                                    revert with 0, 50
                                mem[_10250 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_10250 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _10250 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_10250]:
                                    revert with 0, 50
                                mem[_10250 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = stor24[address(this.address)]
                                emit Approval(stor24[address(this.address)], this.address, uniswapV2RouterAddress);
                                mem[_10250 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_10250 + ceil32(return_data.size) + 100] = stor24[address(this.address)]
                                mem[_10250 + ceil32(return_data.size) + 132] = 0
                                mem[_10250 + ceil32(return_data.size) + 164] = 160
                                mem[_10250 + ceil32(return_data.size) + 260] = mem[_10250]
                                idx = 0
                                s = _10250 + ceil32(return_data.size) + 292
                                t = _10250 + 32
                                while idx < mem[_10250]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args stor24[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_10250 + ceil32(return_data.size) + 260 len (32 * mem[_10250]) + 32]
                            else:
                                mem[32] = 23
                                if stor23[address(this.address)] > stor31:
                                    revert with 0, 'Amount must be less than total reflections'
                                idx = 0
                                s = 10^15
                                t = stor31
                                while idx < stor30.length:
                                    mem[0] = stor30[idx]
                                    mem[32] = 23
                                    if stor23[stor30[idx]] > t:
                                        _13555 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13555] = 26
                                        mem[_13555 + 32] = 'SafeMath: division by zero'
                                        _13758 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13758] = 26
                                        mem[_13758 + 32] = 'SafeMath: division by zero'
                                        if not stor31 / 10^15:
                                            _13867 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _13867 + 68] = mem[idx + _13758 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13867 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13867 + -mem[64] + 100
                                        _14284 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        mem[_14284 + 32 len 64] = call.data[calldata.size len 64]
                                        if 0 >= mem[_14284]:
                                            revert with 0, 50
                                        mem[_14284 + 32] = this.address
                                        staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                                gas gas_remaining wei
                                        mem[_14284 + 96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _14284 + ceil32(return_data.size) + 96
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        if 1 >= mem[_14284]:
                                            revert with 0, 50
                                        mem[_14284 + 64] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 25)
                                        allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                        emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                        mem[_14284 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_14284 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                        mem[_14284 + ceil32(return_data.size) + 132] = 0
                                        mem[_14284 + ceil32(return_data.size) + 164] = 160
                                        mem[_14284 + ceil32(return_data.size) + 260] = mem[_14284]
                                        idx = 0
                                        s = _14284 + ceil32(return_data.size) + 292
                                        t = _14284 + 32
                                        while idx < mem[_14284]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_14284 + ceil32(return_data.size) + 196] = this.address
                                        mem[_14284 + ceil32(return_data.size) + 228] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _14284 + ceil32(return_data.size) + (32 * mem[_14284]) + -mem[64] + 288]
                                    else:
                                        if idx >= stor30.length:
                                            revert with 0, 50
                                        mem[0] = stor30[idx]
                                        mem[32] = 24
                                        if stor24[stor30[idx]] <= s:
                                            if idx >= stor30.length:
                                                revert with 0, 50
                                            mem[0] = stor30[idx]
                                            mem[32] = 23
                                            _13616 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13616] = 30
                                            mem[_13616 + 32] = 'SafeMath: subtraction overflow'
                                            if stor23[stor30[idx]] > t:
                                                _13635 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _13635 + 68] = mem[idx + _13616 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_13635 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _13635 + -mem[64] + 100
                                            if t < stor23[stor30[idx]]:
                                                revert with 0, 17
                                            if idx >= stor30.length:
                                                revert with 0, 50
                                            mem[0] = stor30[idx]
                                            mem[32] = 24
                                            _13868 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13868] = 30
                                            mem[_13868 + 32] = 'SafeMath: subtraction overflow'
                                            if stor24[stor30[idx]] <= s:
                                                if s < stor24[stor30[idx]]:
                                                    revert with 0, 17
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                s = s - stor24[stor30[idx]]
                                                t = t - stor23[stor30[idx]]
                                                continue 
                                            _13934 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13934 + 68] = mem[idx + _13868 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13934 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13934 + -mem[64] + 100
                                        _13617 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13617] = 26
                                        mem[_13617 + 32] = 'SafeMath: division by zero'
                                        _13869 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13869] = 26
                                        mem[_13869 + 32] = 'SafeMath: division by zero'
                                        if not stor31 / 10^15:
                                            _13935 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _13935 + 68] = mem[idx + _13869 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13935 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13935 + -mem[64] + 100
                                        _14394 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        mem[_14394 + 32 len 64] = call.data[calldata.size len 64]
                                        if 0 >= mem[_14394]:
                                            revert with 0, 50
                                        mem[_14394 + 32] = this.address
                                        staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                                gas gas_remaining wei
                                        mem[_14394 + 96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _14394 + ceil32(return_data.size) + 96
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        if 1 >= mem[_14394]:
                                            revert with 0, 50
                                        mem[_14394 + 64] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 25)
                                        allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                        emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                        mem[_14394 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_14394 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                        mem[_14394 + ceil32(return_data.size) + 132] = 0
                                        mem[_14394 + ceil32(return_data.size) + 164] = 160
                                        mem[_14394 + ceil32(return_data.size) + 260] = mem[_14394]
                                        idx = 0
                                        s = _14394 + ceil32(return_data.size) + 292
                                        t = _14394 + 32
                                        while idx < mem[_14394]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_14394 + ceil32(return_data.size) + 196] = this.address
                                        mem[_14394 + ceil32(return_data.size) + 228] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _14394 + ceil32(return_data.size) + (32 * mem[_14394]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                _13308 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13308] = 26
                                mem[_13308 + 32] = 'SafeMath: division by zero'
                                if t < stor31 / 10^15:
                                    _13681 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13681] = 26
                                    mem[_13681 + 32] = 'SafeMath: division by zero'
                                    _14033 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14033] = 26
                                    mem[_14033 + 32] = 'SafeMath: division by zero'
                                    if not stor31 / 10^15:
                                        _14126 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        s = 0
                                        while s < 26:
                                            mem[s + _14126 + 68] = mem[s + _14033 + 32]
                                            s = s + 32
                                            continue 
                                        mem[_14126 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14126 + -mem[64] + 100
                                    _14569 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_14569 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_14569]:
                                        revert with 0, 50
                                    mem[_14569 + 32] = this.address
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_14569 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _14569 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_14569]:
                                        revert with 0, 50
                                    mem[_14569 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 25)
                                    allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                    emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                    mem[_14569 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_14569 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                    mem[_14569 + ceil32(return_data.size) + 132] = 0
                                    mem[_14569 + ceil32(return_data.size) + 164] = 160
                                    mem[_14569 + ceil32(return_data.size) + 260] = mem[_14569]
                                    idx = 0
                                    s = _14569 + ceil32(return_data.size) + 292
                                    t = _14569 + 32
                                    while idx < mem[_14569]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_14569 + ceil32(return_data.size) + 196] = this.address
                                    mem[_14569 + ceil32(return_data.size) + 228] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _14569 + ceil32(return_data.size) + (32 * mem[_14569]) + -mem[64] + 288]
                                else:
                                    _13680 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13680] = 26
                                    mem[_13680 + 32] = 'SafeMath: division by zero'
                                    if not s:
                                        _13715 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _13715 + 68] = mem[idx + _13680 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13715 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13715 + -mem[64] + 100
                                    _14032 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14032] = 26
                                    mem[_14032 + 32] = 'SafeMath: division by zero'
                                    if not t / s:
                                        _14125 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        s = 0
                                        while s < 26:
                                            mem[s + _14125 + 68] = mem[s + _14032 + 32]
                                            s = s + 32
                                            continue 
                                        mem[_14125 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14125 + -mem[64] + 100
                                    _14567 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_14567 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_14567]:
                                        revert with 0, 50
                                    mem[_14567 + 32] = this.address
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_14567 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _14567 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_14567]:
                                        revert with 0, 50
                                    mem[_14567 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 25)
                                    allowance[address(this.address)][stor54] = stor23[address(this.address)] / t / s
                                    emit Approval((stor23[address(this.address)] / t / s), this.address, uniswapV2RouterAddress);
                                    mem[_14567 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_14567 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / t / s
                                    mem[_14567 + ceil32(return_data.size) + 132] = 0
                                    mem[_14567 + ceil32(return_data.size) + 164] = 160
                                    mem[_14567 + ceil32(return_data.size) + 260] = mem[_14567]
                                    idx = 0
                                    s = _14567 + ceil32(return_data.size) + 292
                                    t = _14567 + 32
                                    while idx < mem[_14567]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_14567 + ceil32(return_data.size) + 196] = this.address
                                    mem[_14567 + ceil32(return_data.size) + 228] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _14567 + ceil32(return_data.size) + (32 * mem[_14567]) + -mem[64] + 288]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
        _4539 = mem[64]
        mem[64] = mem[64] + 64
        mem[_4539] = 26
        mem[_4539 + 32] = 'SafeMath: division by zero'
        if t < stor31 / 10^15:
            _4578 = mem[64]
            mem[64] = mem[64] + 64
            mem[_4578] = 26
            mem[_4578 + 32] = 'SafeMath: division by zero'
            _4644 = mem[64]
            mem[64] = mem[64] + 64
            mem[_4644] = 26
            mem[_4644 + 32] = 'SafeMath: division by zero'
            if not stor31 / 10^15:
                revert with 0, 'SafeMath: division by zero', 0
            if stor23[address(this.address)] / stor31 / 10^15 <= 0:
                revert with 0, 'Contract balance is zero'
            mem[0] = this.address
            if stor29[address(this.address)]:
                mem[32] = 24
                if arg1 <= stor24[address(this.address)]:
                    _4839 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    mem[_4839 + 32 len 64] = call.data[calldata.size len 64]
                    if 0 >= mem[_4839]:
                        revert with 0, 50
                    mem[_4839 + 32] = this.address
                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                            gas gas_remaining wei
                    mem[_4839 + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _4839 + ceil32(return_data.size) + 96
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if 1 >= mem[_4839]:
                        revert with 0, 50
                    mem[_4839 + 64] = ext_call.return_data[12 len 20]
                    if not this.address:
                        revert with 0, 'ERC20: approve from the zero address'
                    if not uniswapV2RouterAddress:
                        revert with 0, 'ERC20: approve to the zero address'
                    mem[0] = uniswapV2RouterAddress
                    mem[32] = sha3(address(this.address), 25)
                    allowance[address(this.address)][stor54] = arg1
                    emit Approval(arg1, this.address, uniswapV2RouterAddress);
                    mem[_4839 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                    mem[_4839 + ceil32(return_data.size) + 100] = arg1
                    mem[_4839 + ceil32(return_data.size) + 132] = 0
                    mem[_4839 + ceil32(return_data.size) + 164] = 160
                    mem[_4839 + ceil32(return_data.size) + 260] = mem[_4839]
                    idx = 0
                    s = _4839 + ceil32(return_data.size) + 292
                    t = _4839 + 32
                    while idx < mem[_4839]:
                        mem[s] = mem[t + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_4839 + ceil32(return_data.size) + 196] = this.address
                    mem[_4839 + ceil32(return_data.size) + 228] = block.timestamp
                    require ext_code.size(uniswapV2RouterAddress)
                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _4839 + ceil32(return_data.size) + (32 * mem[_4839]) + -mem[64] + 288]
                else:
                    mem[0] = this.address
                    if stor29[address(this.address)]:
                        mem[32] = 24
                        _4939 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        mem[_4939 + 32 len 64] = call.data[calldata.size len 64]
                        if 0 >= mem[_4939]:
                            revert with 0, 50
                        mem[_4939 + 32] = this.address
                        staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                gas gas_remaining wei
                        mem[_4939 + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _4939 + ceil32(return_data.size) + 96
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        if 1 >= mem[_4939]:
                            revert with 0, 50
                        mem[_4939 + 64] = ext_call.return_data[12 len 20]
                        if not this.address:
                            revert with 0, 'ERC20: approve from the zero address'
                        if not uniswapV2RouterAddress:
                            revert with 0, 'ERC20: approve to the zero address'
                        mem[0] = uniswapV2RouterAddress
                        mem[32] = sha3(address(this.address), 25)
                        allowance[address(this.address)][stor54] = stor24[address(this.address)]
                        emit Approval(stor24[address(this.address)], this.address, uniswapV2RouterAddress);
                        mem[_4939 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                        mem[_4939 + ceil32(return_data.size) + 100] = stor24[address(this.address)]
                        mem[_4939 + ceil32(return_data.size) + 132] = 0
                        mem[_4939 + ceil32(return_data.size) + 164] = 160
                        mem[_4939 + ceil32(return_data.size) + 260] = mem[_4939]
                        idx = 0
                        s = _4939 + ceil32(return_data.size) + 292
                        t = _4939 + 32
                        while idx < mem[_4939]:
                            mem[s] = mem[t + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        require ext_code.size(uniswapV2RouterAddress)
                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args stor24[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_4939 + ceil32(return_data.size) + 260 len (32 * mem[_4939]) + 32]
                    else:
                        mem[32] = 23
                        if stor23[address(this.address)] > stor31:
                            revert with 0, 'Amount must be less than total reflections'
                        idx = 0
                        s = 10^15
                        t = stor31
                        while idx < stor30.length:
                            mem[0] = stor30[idx]
                            mem[32] = 23
                            if stor23[stor30[idx]] > t:
                                _9201 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9201] = 26
                                mem[_9201 + 32] = 'SafeMath: division by zero'
                                _9340 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9340] = 26
                                mem[_9340 + 32] = 'SafeMath: division by zero'
                                if not stor31 / 10^15:
                                    _9415 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _9415 + 68] = mem[idx + _9340 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_9415 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _9415 + -mem[64] + 100
                                _9730 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_9730 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_9730]:
                                    revert with 0, 50
                                mem[_9730 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_9730 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _9730 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_9730]:
                                    revert with 0, 50
                                mem[_9730 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                mem[_9730 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_9730 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                mem[_9730 + ceil32(return_data.size) + 132] = 0
                                mem[_9730 + ceil32(return_data.size) + 164] = 160
                                mem[_9730 + ceil32(return_data.size) + 260] = mem[_9730]
                                idx = 0
                                s = _9730 + ceil32(return_data.size) + 292
                                t = _9730 + 32
                                while idx < mem[_9730]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_9730 + ceil32(return_data.size) + 196] = this.address
                                mem[_9730 + ceil32(return_data.size) + 228] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _9730 + ceil32(return_data.size) + (32 * mem[_9730]) + -mem[64] + 288]
                            else:
                                if idx >= stor30.length:
                                    revert with 0, 50
                                mem[0] = stor30[idx]
                                mem[32] = 24
                                if stor24[stor30[idx]] <= s:
                                    if idx >= stor30.length:
                                        revert with 0, 50
                                    mem[0] = stor30[idx]
                                    mem[32] = 23
                                    _9240 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9240] = 30
                                    mem[_9240 + 32] = 'SafeMath: subtraction overflow'
                                    if stor23[stor30[idx]] > t:
                                        _9261 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _9261 + 68] = mem[idx + _9240 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_9261 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _9261 + -mem[64] + 100
                                    if t < stor23[stor30[idx]]:
                                        revert with 0, 17
                                    if idx >= stor30.length:
                                        revert with 0, 50
                                    mem[0] = stor30[idx]
                                    mem[32] = 24
                                    _9416 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9416] = 30
                                    mem[_9416 + 32] = 'SafeMath: subtraction overflow'
                                    if stor24[stor30[idx]] <= s:
                                        if s < stor24[stor30[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor24[stor30[idx]]
                                        t = t - stor23[stor30[idx]]
                                        continue 
                                    _9472 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _9472 + 68] = mem[idx + _9416 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_9472 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _9472 + -mem[64] + 100
                                _9241 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9241] = 26
                                mem[_9241 + 32] = 'SafeMath: division by zero'
                                _9417 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9417] = 26
                                mem[_9417 + 32] = 'SafeMath: division by zero'
                                if not stor31 / 10^15:
                                    _9473 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _9473 + 68] = mem[idx + _9417 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_9473 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _9473 + -mem[64] + 100
                                _9818 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_9818 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_9818]:
                                    revert with 0, 50
                                mem[_9818 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_9818 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _9818 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_9818]:
                                    revert with 0, 50
                                mem[_9818 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                mem[_9818 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_9818 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                mem[_9818 + ceil32(return_data.size) + 132] = 0
                                mem[_9818 + ceil32(return_data.size) + 164] = 160
                                mem[_9818 + ceil32(return_data.size) + 260] = mem[_9818]
                                idx = 0
                                s = _9818 + ceil32(return_data.size) + 292
                                t = _9818 + 32
                                while idx < mem[_9818]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_9818 + ceil32(return_data.size) + 196] = this.address
                                mem[_9818 + ceil32(return_data.size) + 228] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _9818 + ceil32(return_data.size) + (32 * mem[_9818]) + -mem[64] + 288]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                        _9088 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9088] = 26
                        mem[_9088 + 32] = 'SafeMath: division by zero'
                        if t >= stor31 / 10^15:
                            _9288 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_9288] = 26
                            mem[_9288 + 32] = 'SafeMath: division by zero'
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            _9552 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_9552] = 26
                            mem[_9552 + 32] = 'SafeMath: division by zero'
                            if not t / s:
                                revert with 0, 'SafeMath: division by zero', 0
                            _9997 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_9997 + 32 len 64] = call.data[calldata.size len 64]
                            if 0 >= mem[_9997]:
                                revert with 0, 50
                            mem[_9997 + 32] = this.address
                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                    gas gas_remaining wei
                            mem[_9997 + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _9997 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            if 1 >= mem[_9997]:
                                revert with 0, 50
                            mem[_9997 + 64] = ext_call.return_data[12 len 20]
                            if not this.address:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not uniswapV2RouterAddress:
                                revert with 0, 'ERC20: approve to the zero address'
                            mem[0] = uniswapV2RouterAddress
                            mem[32] = sha3(address(this.address), 25)
                            allowance[address(this.address)][stor54] = stor23[address(this.address)] / t / s
                            emit Approval((stor23[address(this.address)] / t / s), this.address, uniswapV2RouterAddress);
                            mem[_9997 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                            mem[_9997 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / t / s
                            mem[_9997 + ceil32(return_data.size) + 132] = 0
                            mem[_9997 + ceil32(return_data.size) + 164] = 160
                            mem[_9997 + ceil32(return_data.size) + 260] = mem[_9997]
                            idx = 0
                            u = _9997 + ceil32(return_data.size) + 292
                            v = _9997 + 32
                            while idx < mem[_9997]:
                                mem[u] = mem[v + 12 len 20]
                                idx = idx + 1
                                u = u + 32
                                v = v + 32
                                continue 
                            require ext_code.size(uniswapV2RouterAddress)
                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args stor23[address(this.address)] / t / s, 0, 160, address(this.address), block.timestamp, mem[_9997 + ceil32(return_data.size) + 260 len (32 * mem[_9997]) + 32]
                        else:
                            _9289 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_9289] = 26
                            mem[_9289 + 32] = 'SafeMath: division by zero'
                            _9553 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_9553] = 26
                            mem[_9553 + 32] = 'SafeMath: division by zero'
                            if not stor31 / 10^15:
                                revert with 0, 'SafeMath: division by zero', 0
                            _9999 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_9999 + 32 len 64] = call.data[calldata.size len 64]
                            if 0 >= mem[_9999]:
                                revert with 0, 50
                            mem[_9999 + 32] = this.address
                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                    gas gas_remaining wei
                            mem[_9999 + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _9999 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            if 1 >= mem[_9999]:
                                revert with 0, 50
                            mem[_9999 + 64] = ext_call.return_data[12 len 20]
                            if not this.address:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not uniswapV2RouterAddress:
                                revert with 0, 'ERC20: approve to the zero address'
                            mem[0] = uniswapV2RouterAddress
                            mem[32] = sha3(address(this.address), 25)
                            allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                            emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                            mem[_9999 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                            mem[_9999 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                            mem[_9999 + ceil32(return_data.size) + 132] = 0
                            mem[_9999 + ceil32(return_data.size) + 164] = 160
                            mem[_9999 + ceil32(return_data.size) + 260] = mem[_9999]
                            idx = 0
                            s = _9999 + ceil32(return_data.size) + 292
                            t = _9999 + 32
                            while idx < mem[_9999]:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_9999 + ceil32(return_data.size) + 196] = this.address
                            mem[_9999 + ceil32(return_data.size) + 228] = block.timestamp
                            require ext_code.size(uniswapV2RouterAddress)
                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _9999 + ceil32(return_data.size) + (32 * mem[_9999]) + -mem[64] + 288]
            else:
                mem[32] = 23
                if stor23[address(this.address)] > stor31:
                    revert with 0, 'Amount must be less than total reflections'
                idx = 0
                s = 10^15
                t = stor31
                while idx < stor30.length:
                    mem[0] = stor30[idx]
                    mem[32] = 23
                    if stor23[stor30[idx]] > t:
                        _9200 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9200] = 26
                        mem[_9200 + 32] = 'SafeMath: division by zero'
                        _9337 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9337] = 26
                        mem[_9337 + 32] = 'SafeMath: division by zero'
                        if not stor31 / 10^15:
                            _9411 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _9411 + 68] = mem[idx + _9337 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9411 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9411 + -mem[64] + 100
                        if arg1 <= stor23[address(this.address)] / stor31 / 10^15:
                            _9725 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_9725 + 32 len 64] = call.data[calldata.size len 64]
                            if 0 >= mem[_9725]:
                                revert with 0, 50
                            mem[_9725 + 32] = this.address
                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                    gas gas_remaining wei
                            mem[_9725 + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _9725 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            if 1 >= mem[_9725]:
                                revert with 0, 50
                            mem[_9725 + 64] = ext_call.return_data[12 len 20]
                            if not this.address:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not uniswapV2RouterAddress:
                                revert with 0, 'ERC20: approve to the zero address'
                            mem[0] = uniswapV2RouterAddress
                            mem[32] = sha3(address(this.address), 25)
                            allowance[address(this.address)][stor54] = arg1
                            emit Approval(arg1, this.address, uniswapV2RouterAddress);
                            mem[_9725 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                            mem[_9725 + ceil32(return_data.size) + 100] = arg1
                            mem[_9725 + ceil32(return_data.size) + 132] = 0
                            mem[_9725 + ceil32(return_data.size) + 164] = 160
                            mem[_9725 + ceil32(return_data.size) + 260] = mem[_9725]
                            idx = 0
                            s = _9725 + ceil32(return_data.size) + 292
                            t = _9725 + 32
                            while idx < mem[_9725]:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(uniswapV2RouterAddress)
                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args arg1, 0, 160, address(this.address), block.timestamp, mem[_9725 + ceil32(return_data.size) + 260 len (32 * mem[_9725]) + 32]
                        else:
                            mem[0] = this.address
                            if stor29[address(this.address)]:
                                mem[32] = 24
                                _9931 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_9931 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_9931]:
                                    revert with 0, 50
                                mem[_9931 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_9931 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _9931 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_9931]:
                                    revert with 0, 50
                                mem[_9931 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = stor24[address(this.address)]
                                emit Approval(stor24[address(this.address)], this.address, uniswapV2RouterAddress);
                                mem[_9931 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_9931 + ceil32(return_data.size) + 100] = stor24[address(this.address)]
                                mem[_9931 + ceil32(return_data.size) + 132] = 0
                                mem[_9931 + ceil32(return_data.size) + 164] = 160
                                mem[_9931 + ceil32(return_data.size) + 260] = mem[_9931]
                                idx = 0
                                s = _9931 + ceil32(return_data.size) + 292
                                t = _9931 + 32
                                while idx < mem[_9931]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args stor24[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_9931 + ceil32(return_data.size) + 260 len (32 * mem[_9931]) + 32]
                            else:
                                mem[32] = 23
                                if stor23[address(this.address)] > stor31:
                                    revert with 0, 'Amount must be less than total reflections'
                                idx = 0
                                s = 10^15
                                t = stor31
                                while idx < stor30.length:
                                    mem[0] = stor30[idx]
                                    mem[32] = 23
                                    if stor23[stor30[idx]] > t:
                                        _13548 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13548] = 26
                                        mem[_13548 + 32] = 'SafeMath: division by zero'
                                        _13737 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13737] = 26
                                        mem[_13737 + 32] = 'SafeMath: division by zero'
                                        if not stor31 / 10^15:
                                            _13839 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _13839 + 68] = mem[idx + _13737 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13839 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13839 + -mem[64] + 100
                                        _14256 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        mem[_14256 + 32 len 64] = call.data[calldata.size len 64]
                                        if 0 >= mem[_14256]:
                                            revert with 0, 50
                                        mem[_14256 + 32] = this.address
                                        staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                                gas gas_remaining wei
                                        mem[_14256 + 96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _14256 + ceil32(return_data.size) + 96
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        if 1 >= mem[_14256]:
                                            revert with 0, 50
                                        mem[_14256 + 64] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 25)
                                        allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                        emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                        mem[_14256 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_14256 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                        mem[_14256 + ceil32(return_data.size) + 132] = 0
                                        mem[_14256 + ceil32(return_data.size) + 164] = 160
                                        mem[_14256 + ceil32(return_data.size) + 260] = mem[_14256]
                                        idx = 0
                                        s = _14256 + ceil32(return_data.size) + 292
                                        t = _14256 + 32
                                        while idx < mem[_14256]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args stor23[address(this.address)] / stor31 / 10^15, 0, 160, address(this.address), block.timestamp, mem[_14256 + ceil32(return_data.size) + 260 len (32 * mem[_14256]) + 32]
                                    else:
                                        if idx >= stor30.length:
                                            revert with 0, 50
                                        mem[0] = stor30[idx]
                                        mem[32] = 24
                                        if stor24[stor30[idx]] <= s:
                                            if idx >= stor30.length:
                                                revert with 0, 50
                                            mem[0] = stor30[idx]
                                            mem[32] = 23
                                            _13602 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13602] = 30
                                            mem[_13602 + 32] = 'SafeMath: subtraction overflow'
                                            if stor23[stor30[idx]] > t:
                                                _13628 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _13628 + 68] = mem[idx + _13602 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_13628 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _13628 + -mem[64] + 100
                                            if t < stor23[stor30[idx]]:
                                                revert with 0, 17
                                            if idx >= stor30.length:
                                                revert with 0, 50
                                            mem[0] = stor30[idx]
                                            mem[32] = 24
                                            _13840 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13840] = 30
                                            mem[_13840 + 32] = 'SafeMath: subtraction overflow'
                                            if stor24[stor30[idx]] <= s:
                                                if s < stor24[stor30[idx]]:
                                                    revert with 0, 17
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                s = s - stor24[stor30[idx]]
                                                t = t - stor23[stor30[idx]]
                                                continue 
                                            _13913 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13913 + 68] = mem[idx + _13840 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13913 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13913 + -mem[64] + 100
                                        _13603 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13603] = 26
                                        mem[_13603 + 32] = 'SafeMath: division by zero'
                                        _13841 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13841] = 26
                                        mem[_13841 + 32] = 'SafeMath: division by zero'
                                        if not stor31 / 10^15:
                                            _13914 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _13914 + 68] = mem[idx + _13841 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13914 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13914 + -mem[64] + 100
                                        _14359 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        mem[_14359 + 32 len 64] = call.data[calldata.size len 64]
                                        if 0 >= mem[_14359]:
                                            revert with 0, 50
                                        mem[_14359 + 32] = this.address
                                        staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                                gas gas_remaining wei
                                        mem[_14359 + 96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _14359 + ceil32(return_data.size) + 96
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        if 1 >= mem[_14359]:
                                            revert with 0, 50
                                        mem[_14359 + 64] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 25)
                                        allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                        emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                        mem[_14359 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_14359 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                        mem[_14359 + ceil32(return_data.size) + 132] = 0
                                        mem[_14359 + ceil32(return_data.size) + 164] = 160
                                        mem[_14359 + ceil32(return_data.size) + 260] = mem[_14359]
                                        idx = 0
                                        s = _14359 + ceil32(return_data.size) + 292
                                        t = _14359 + 32
                                        while idx < mem[_14359]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args stor23[address(this.address)] / stor31 / 10^15, 0, 160, address(this.address), block.timestamp, mem[_14359 + ceil32(return_data.size) + 260 len (32 * mem[_14359]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                _13265 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13265] = 26
                                mem[_13265 + 32] = 'SafeMath: division by zero'
                                if t < stor31 / 10^15:
                                    _13667 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13667] = 26
                                    mem[_13667 + 32] = 'SafeMath: division by zero'
                                    _14019 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14019] = 26
                                    mem[_14019 + 32] = 'SafeMath: division by zero'
                                    if not stor31 / 10^15:
                                        _14105 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        s = 0
                                        while s < 26:
                                            mem[s + _14105 + 68] = mem[s + _14019 + 32]
                                            s = s + 32
                                            continue 
                                        mem[_14105 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14105 + -mem[64] + 100
                                    _14534 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_14534 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_14534]:
                                        revert with 0, 50
                                    mem[_14534 + 32] = this.address
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_14534 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _14534 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_14534]:
                                        revert with 0, 50
                                    mem[_14534 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 25)
                                    allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                    emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                    mem[_14534 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_14534 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                    mem[_14534 + ceil32(return_data.size) + 132] = 0
                                    mem[_14534 + ceil32(return_data.size) + 164] = 160
                                    mem[_14534 + ceil32(return_data.size) + 260] = mem[_14534]
                                    idx = 0
                                    s = _14534 + ceil32(return_data.size) + 292
                                    t = _14534 + 32
                                    while idx < mem[_14534]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args stor23[address(this.address)] / stor31 / 10^15, 0, 160, address(this.address), block.timestamp, mem[_14534 + ceil32(return_data.size) + 260 len (32 * mem[_14534]) + 32]
                                else:
                                    _13666 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13666] = 26
                                    mem[_13666 + 32] = 'SafeMath: division by zero'
                                    if not s:
                                        _13708 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _13708 + 68] = mem[idx + _13666 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13708 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13708 + -mem[64] + 100
                                    _14018 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14018] = 26
                                    mem[_14018 + 32] = 'SafeMath: division by zero'
                                    if not t / s:
                                        _14104 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        s = 0
                                        while s < 26:
                                            mem[s + _14104 + 68] = mem[s + _14018 + 32]
                                            s = s + 32
                                            continue 
                                        mem[_14104 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14104 + -mem[64] + 100
                                    _14532 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_14532 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_14532]:
                                        revert with 0, 50
                                    mem[_14532 + 32] = this.address
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_14532 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _14532 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_14532]:
                                        revert with 0, 50
                                    mem[_14532 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 25)
                                    allowance[address(this.address)][stor54] = stor23[address(this.address)] / t / s
                                    emit Approval((stor23[address(this.address)] / t / s), this.address, uniswapV2RouterAddress);
                                    mem[_14532 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_14532 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / t / s
                                    mem[_14532 + ceil32(return_data.size) + 132] = 0
                                    mem[_14532 + ceil32(return_data.size) + 164] = 160
                                    mem[_14532 + ceil32(return_data.size) + 260] = mem[_14532]
                                    idx = 0
                                    u = _14532 + ceil32(return_data.size) + 292
                                    v = _14532 + 32
                                    while idx < mem[_14532]:
                                        mem[u] = mem[v + 12 len 20]
                                        idx = idx + 1
                                        u = u + 32
                                        v = v + 32
                                        continue 
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args stor23[address(this.address)] / t / s, 0, 160, address(this.address), block.timestamp, mem[_14532 + ceil32(return_data.size) + 260 len (32 * mem[_14532]) + 32]
                    else:
                        if idx >= stor30.length:
                            revert with 0, 50
                        mem[0] = stor30[idx]
                        mem[32] = 24
                        if stor24[stor30[idx]] <= s:
                            if idx >= stor30.length:
                                revert with 0, 50
                            mem[0] = stor30[idx]
                            mem[32] = 23
                            _9238 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_9238] = 30
                            mem[_9238 + 32] = 'SafeMath: subtraction overflow'
                            if stor23[stor30[idx]] > t:
                                _9260 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _9260 + 68] = mem[idx + _9238 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_9260 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _9260 + -mem[64] + 100
                            if t < stor23[stor30[idx]]:
                                revert with 0, 17
                            if idx >= stor30.length:
                                revert with 0, 50
                            mem[0] = stor30[idx]
                            mem[32] = 24
                            _9412 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_9412] = 30
                            mem[_9412 + 32] = 'SafeMath: subtraction overflow'
                            if stor24[stor30[idx]] <= s:
                                if s < stor24[stor30[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor24[stor30[idx]]
                                t = t - stor23[stor30[idx]]
                                continue 
                            _9469 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _9469 + 68] = mem[idx + _9412 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9469 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9469 + -mem[64] + 100
                        _9239 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9239] = 26
                        mem[_9239 + 32] = 'SafeMath: division by zero'
                        _9413 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9413] = 26
                        mem[_9413 + 32] = 'SafeMath: division by zero'
                        if not stor31 / 10^15:
                            _9470 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _9470 + 68] = mem[idx + _9413 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9470 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9470 + -mem[64] + 100
                        if arg1 <= stor23[address(this.address)] / stor31 / 10^15:
                            _9812 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_9812 + 32 len 64] = call.data[calldata.size len 64]
                            if 0 >= mem[_9812]:
                                revert with 0, 50
                            mem[_9812 + 32] = this.address
                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                    gas gas_remaining wei
                            mem[_9812 + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _9812 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            if 1 >= mem[_9812]:
                                revert with 0, 50
                            mem[_9812 + 64] = ext_call.return_data[12 len 20]
                            if not this.address:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not uniswapV2RouterAddress:
                                revert with 0, 'ERC20: approve to the zero address'
                            mem[0] = uniswapV2RouterAddress
                            mem[32] = sha3(address(this.address), 25)
                            allowance[address(this.address)][stor54] = arg1
                            emit Approval(arg1, this.address, uniswapV2RouterAddress);
                            mem[_9812 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                            mem[_9812 + ceil32(return_data.size) + 100] = arg1
                            mem[_9812 + ceil32(return_data.size) + 132] = 0
                            mem[_9812 + ceil32(return_data.size) + 164] = 160
                            mem[_9812 + ceil32(return_data.size) + 260] = mem[_9812]
                            idx = 0
                            s = _9812 + ceil32(return_data.size) + 292
                            t = _9812 + 32
                            while idx < mem[_9812]:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_9812 + ceil32(return_data.size) + 196] = this.address
                            mem[_9812 + ceil32(return_data.size) + 228] = block.timestamp
                            require ext_code.size(uniswapV2RouterAddress)
                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _9812 + ceil32(return_data.size) + (32 * mem[_9812]) + -mem[64] + 288]
                        else:
                            mem[0] = this.address
                            if stor29[address(this.address)]:
                                mem[32] = 24
                                _9995 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_9995 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_9995]:
                                    revert with 0, 50
                                mem[_9995 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_9995 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _9995 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_9995]:
                                    revert with 0, 50
                                mem[_9995 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = stor24[address(this.address)]
                                emit Approval(stor24[address(this.address)], this.address, uniswapV2RouterAddress);
                                mem[_9995 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_9995 + ceil32(return_data.size) + 100] = stor24[address(this.address)]
                                mem[_9995 + ceil32(return_data.size) + 132] = 0
                                mem[_9995 + ceil32(return_data.size) + 164] = 160
                                mem[_9995 + ceil32(return_data.size) + 260] = mem[_9995]
                                idx = 0
                                s = _9995 + ceil32(return_data.size) + 292
                                t = _9995 + 32
                                while idx < mem[_9995]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args stor24[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_9995 + ceil32(return_data.size) + 260 len (32 * mem[_9995]) + 32]
                            else:
                                mem[32] = 23
                                if stor23[address(this.address)] > stor31:
                                    revert with 0, 'Amount must be less than total reflections'
                                idx = 0
                                s = 10^15
                                t = stor31
                                while idx < stor30.length:
                                    mem[0] = stor30[idx]
                                    mem[32] = 23
                                    if stor23[stor30[idx]] > t:
                                        _13549 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13549] = 26
                                        mem[_13549 + 32] = 'SafeMath: division by zero'
                                        _13740 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13740] = 26
                                        mem[_13740 + 32] = 'SafeMath: division by zero'
                                        if not stor31 / 10^15:
                                            _13843 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _13843 + 68] = mem[idx + _13740 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13843 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13843 + -mem[64] + 100
                                        _14260 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        mem[_14260 + 32 len 64] = call.data[calldata.size len 64]
                                        if 0 >= mem[_14260]:
                                            revert with 0, 50
                                        mem[_14260 + 32] = this.address
                                        staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                                gas gas_remaining wei
                                        mem[_14260 + 96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _14260 + ceil32(return_data.size) + 96
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        if 1 >= mem[_14260]:
                                            revert with 0, 50
                                        mem[_14260 + 64] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 25)
                                        allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                        emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                        mem[_14260 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_14260 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                        mem[_14260 + ceil32(return_data.size) + 132] = 0
                                        mem[_14260 + ceil32(return_data.size) + 164] = 160
                                        mem[_14260 + ceil32(return_data.size) + 260] = mem[_14260]
                                        idx = 0
                                        s = _14260 + ceil32(return_data.size) + 292
                                        t = _14260 + 32
                                        while idx < mem[_14260]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args stor23[address(this.address)] / stor31 / 10^15, 0, 160, address(this.address), block.timestamp, mem[_14260 + ceil32(return_data.size) + 260 len (32 * mem[_14260]) + 32]
                                    else:
                                        if idx >= stor30.length:
                                            revert with 0, 50
                                        mem[0] = stor30[idx]
                                        mem[32] = 24
                                        if stor24[stor30[idx]] <= s:
                                            if idx >= stor30.length:
                                                revert with 0, 50
                                            mem[0] = stor30[idx]
                                            mem[32] = 23
                                            _13604 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13604] = 30
                                            mem[_13604 + 32] = 'SafeMath: subtraction overflow'
                                            if stor23[stor30[idx]] > t:
                                                _13629 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _13629 + 68] = mem[idx + _13604 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_13629 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _13629 + -mem[64] + 100
                                            if t < stor23[stor30[idx]]:
                                                revert with 0, 17
                                            if idx >= stor30.length:
                                                revert with 0, 50
                                            mem[0] = stor30[idx]
                                            mem[32] = 24
                                            _13844 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13844] = 30
                                            mem[_13844 + 32] = 'SafeMath: subtraction overflow'
                                            if stor24[stor30[idx]] <= s:
                                                if s < stor24[stor30[idx]]:
                                                    revert with 0, 17
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                s = s - stor24[stor30[idx]]
                                                t = t - stor23[stor30[idx]]
                                                continue 
                                            _13916 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13916 + 68] = mem[idx + _13844 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13916 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13916 + -mem[64] + 100
                                        _13605 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13605] = 26
                                        mem[_13605 + 32] = 'SafeMath: division by zero'
                                        _13845 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13845] = 26
                                        mem[_13845 + 32] = 'SafeMath: division by zero'
                                        if not stor31 / 10^15:
                                            _13917 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _13917 + 68] = mem[idx + _13845 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13917 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13917 + -mem[64] + 100
                                        _14364 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        mem[_14364 + 32 len 64] = call.data[calldata.size len 64]
                                        if 0 >= mem[_14364]:
                                            revert with 0, 50
                                        mem[_14364 + 32] = this.address
                                        staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                                gas gas_remaining wei
                                        mem[_14364 + 96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _14364 + ceil32(return_data.size) + 96
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        if 1 >= mem[_14364]:
                                            revert with 0, 50
                                        mem[_14364 + 64] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 25)
                                        allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                        emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                        mem[_14364 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_14364 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                        mem[_14364 + ceil32(return_data.size) + 132] = 0
                                        mem[_14364 + ceil32(return_data.size) + 164] = 160
                                        mem[_14364 + ceil32(return_data.size) + 260] = mem[_14364]
                                        idx = 0
                                        s = _14364 + ceil32(return_data.size) + 292
                                        t = _14364 + 32
                                        while idx < mem[_14364]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_14364 + ceil32(return_data.size) + 196] = this.address
                                        mem[_14364 + ceil32(return_data.size) + 228] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _14364 + ceil32(return_data.size) + (32 * mem[_14364]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                _13270 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13270] = 26
                                mem[_13270 + 32] = 'SafeMath: division by zero'
                                if t >= stor31 / 10^15:
                                    _13668 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13668] = 26
                                    mem[_13668 + 32] = 'SafeMath: division by zero'
                                    if not s:
                                        _13709 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _13709 + 68] = mem[idx + _13668 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13709 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13709 + -mem[64] + 100
                                    _14020 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14020] = 26
                                    mem[_14020 + 32] = 'SafeMath: division by zero'
                                    if not t / s:
                                        _14107 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        s = 0
                                        while s < 26:
                                            mem[s + _14107 + 68] = mem[s + _14020 + 32]
                                            s = s + 32
                                            continue 
                                        mem[_14107 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14107 + -mem[64] + 100
                                    _14537 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_14537 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_14537]:
                                        revert with 0, 50
                                    mem[_14537 + 32] = this.address
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_14537 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _14537 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_14537]:
                                        revert with 0, 50
                                    mem[_14537 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 25)
                                    allowance[address(this.address)][stor54] = stor23[address(this.address)] / t / s
                                    emit Approval((stor23[address(this.address)] / t / s), this.address, uniswapV2RouterAddress);
                                    mem[_14537 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_14537 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / t / s
                                    mem[_14537 + ceil32(return_data.size) + 132] = 0
                                    mem[_14537 + ceil32(return_data.size) + 164] = 160
                                    mem[_14537 + ceil32(return_data.size) + 260] = mem[_14537]
                                    idx = 0
                                    u = _14537 + ceil32(return_data.size) + 292
                                    v = _14537 + 32
                                    while idx < mem[_14537]:
                                        mem[u] = mem[v + 12 len 20]
                                        idx = idx + 1
                                        u = u + 32
                                        v = v + 32
                                        continue 
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args stor23[address(this.address)] / t / s, 0, 160, address(this.address), block.timestamp, mem[_14537 + ceil32(return_data.size) + 260 len (32 * mem[_14537]) + 32]
                                else:
                                    _13669 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13669] = 26
                                    mem[_13669 + 32] = 'SafeMath: division by zero'
                                    _14021 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14021] = 26
                                    mem[_14021 + 32] = 'SafeMath: division by zero'
                                    if not stor31 / 10^15:
                                        _14108 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        s = 0
                                        while s < 26:
                                            mem[s + _14108 + 68] = mem[s + _14021 + 32]
                                            s = s + 32
                                            continue 
                                        mem[_14108 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14108 + -mem[64] + 100
                                    _14539 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_14539 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_14539]:
                                        revert with 0, 50
                                    mem[_14539 + 32] = this.address
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_14539 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _14539 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_14539]:
                                        revert with 0, 50
                                    mem[_14539 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 25)
                                    allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                    emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                    mem[_14539 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_14539 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                    mem[_14539 + ceil32(return_data.size) + 132] = 0
                                    mem[_14539 + ceil32(return_data.size) + 164] = 160
                                    mem[_14539 + ceil32(return_data.size) + 260] = mem[_14539]
                                    idx = 0
                                    s = _14539 + ceil32(return_data.size) + 292
                                    t = _14539 + 32
                                    while idx < mem[_14539]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_14539 + ceil32(return_data.size) + 196] = this.address
                                    mem[_14539 + ceil32(return_data.size) + 228] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _14539 + ceil32(return_data.size) + (32 * mem[_14539]) + -mem[64] + 288]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                _9084 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9084] = 26
                mem[_9084 + 32] = 'SafeMath: division by zero'
                if t < stor31 / 10^15:
                    _9287 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9287] = 26
                    mem[_9287 + 32] = 'SafeMath: division by zero'
                    _9551 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9551] = 26
                    mem[_9551 + 32] = 'SafeMath: division by zero'
                    if not stor31 / 10^15:
                        revert with 0, 'SafeMath: division by zero', 0
                    if arg1 <= stor23[address(this.address)] / stor31 / 10^15:
                        _9989 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        mem[_9989 + 32 len 64] = call.data[calldata.size len 64]
                        if 0 >= mem[_9989]:
                            revert with 0, 50
                        mem[_9989 + 32] = this.address
                        staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                gas gas_remaining wei
                        mem[_9989 + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _9989 + ceil32(return_data.size) + 96
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        if 1 >= mem[_9989]:
                            revert with 0, 50
                        mem[_9989 + 64] = ext_call.return_data[12 len 20]
                        if not this.address:
                            revert with 0, 'ERC20: approve from the zero address'
                        if not uniswapV2RouterAddress:
                            revert with 0, 'ERC20: approve to the zero address'
                        mem[0] = uniswapV2RouterAddress
                        mem[32] = sha3(address(this.address), 25)
                        allowance[address(this.address)][stor54] = arg1
                        emit Approval(arg1, this.address, uniswapV2RouterAddress);
                        mem[_9989 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                        mem[_9989 + ceil32(return_data.size) + 100] = arg1
                        mem[_9989 + ceil32(return_data.size) + 132] = 0
                        mem[_9989 + ceil32(return_data.size) + 164] = 160
                        mem[_9989 + ceil32(return_data.size) + 260] = mem[_9989]
                        idx = 0
                        s = _9989 + ceil32(return_data.size) + 292
                        t = _9989 + 32
                        while idx < mem[_9989]:
                            mem[s] = mem[t + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_9989 + ceil32(return_data.size) + 196] = this.address
                        mem[_9989 + ceil32(return_data.size) + 228] = block.timestamp
                        require ext_code.size(uniswapV2RouterAddress)
                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _9989 + ceil32(return_data.size) + (32 * mem[_9989]) + -mem[64] + 288]
                    else:
                        mem[0] = this.address
                        if stor29[address(this.address)]:
                            mem[32] = 24
                            _10214 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_10214 + 32 len 64] = call.data[calldata.size len 64]
                            if 0 >= mem[_10214]:
                                revert with 0, 50
                            mem[_10214 + 32] = this.address
                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                    gas gas_remaining wei
                            mem[_10214 + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _10214 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            if 1 >= mem[_10214]:
                                revert with 0, 50
                            mem[_10214 + 64] = ext_call.return_data[12 len 20]
                            if not this.address:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not uniswapV2RouterAddress:
                                revert with 0, 'ERC20: approve to the zero address'
                            mem[0] = uniswapV2RouterAddress
                            mem[32] = sha3(address(this.address), 25)
                            allowance[address(this.address)][stor54] = stor24[address(this.address)]
                            emit Approval(stor24[address(this.address)], this.address, uniswapV2RouterAddress);
                            mem[_10214 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                            mem[_10214 + ceil32(return_data.size) + 100] = stor24[address(this.address)]
                            mem[_10214 + ceil32(return_data.size) + 132] = 0
                            mem[_10214 + ceil32(return_data.size) + 164] = 160
                            mem[_10214 + ceil32(return_data.size) + 260] = mem[_10214]
                            idx = 0
                            s = _10214 + ceil32(return_data.size) + 292
                            t = _10214 + 32
                            while idx < mem[_10214]:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(uniswapV2RouterAddress)
                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args stor24[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_10214 + ceil32(return_data.size) + 260 len (32 * mem[_10214]) + 32]
                        else:
                            mem[32] = 23
                            if stor23[address(this.address)] > stor31:
                                revert with 0, 'Amount must be less than total reflections'
                            idx = 0
                            s = 10^15
                            t = stor31
                            while idx < stor30.length:
                                mem[0] = stor30[idx]
                                mem[32] = 23
                                if stor23[stor30[idx]] > t:
                                    _13547 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13547] = 26
                                    mem[_13547 + 32] = 'SafeMath: division by zero'
                                    _13734 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13734] = 26
                                    mem[_13734 + 32] = 'SafeMath: division by zero'
                                    if not stor31 / 10^15:
                                        _13835 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _13835 + 68] = mem[idx + _13734 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13835 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13835 + -mem[64] + 100
                                    _14252 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_14252 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_14252]:
                                        revert with 0, 50
                                    mem[_14252 + 32] = this.address
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_14252 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _14252 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_14252]:
                                        revert with 0, 50
                                    mem[_14252 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 25)
                                    allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                    emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                    mem[_14252 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_14252 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                    mem[_14252 + ceil32(return_data.size) + 132] = 0
                                    mem[_14252 + ceil32(return_data.size) + 164] = 160
                                    mem[_14252 + ceil32(return_data.size) + 260] = mem[_14252]
                                    idx = 0
                                    s = _14252 + ceil32(return_data.size) + 292
                                    t = _14252 + 32
                                    while idx < mem[_14252]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_14252 + ceil32(return_data.size) + 196] = this.address
                                    mem[_14252 + ceil32(return_data.size) + 228] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _14252 + ceil32(return_data.size) + (32 * mem[_14252]) + -mem[64] + 288]
                                else:
                                    if idx >= stor30.length:
                                        revert with 0, 50
                                    mem[0] = stor30[idx]
                                    mem[32] = 24
                                    if stor24[stor30[idx]] <= s:
                                        if idx >= stor30.length:
                                            revert with 0, 50
                                        mem[0] = stor30[idx]
                                        mem[32] = 23
                                        _13600 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13600] = 30
                                        mem[_13600 + 32] = 'SafeMath: subtraction overflow'
                                        if stor23[stor30[idx]] > t:
                                            _13627 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13627 + 68] = mem[idx + _13600 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13627 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13627 + -mem[64] + 100
                                        if t < stor23[stor30[idx]]:
                                            revert with 0, 17
                                        if idx >= stor30.length:
                                            revert with 0, 50
                                        mem[0] = stor30[idx]
                                        mem[32] = 24
                                        _13836 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13836] = 30
                                        mem[_13836 + 32] = 'SafeMath: subtraction overflow'
                                        if stor24[stor30[idx]] <= s:
                                            if s < stor24[stor30[idx]]:
                                                revert with 0, 17
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s - stor24[stor30[idx]]
                                            t = t - stor23[stor30[idx]]
                                            continue 
                                        _13910 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13910 + 68] = mem[idx + _13836 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13910 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13910 + -mem[64] + 100
                                    _13601 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13601] = 26
                                    mem[_13601 + 32] = 'SafeMath: division by zero'
                                    _13837 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13837] = 26
                                    mem[_13837 + 32] = 'SafeMath: division by zero'
                                    if not stor31 / 10^15:
                                        _13911 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _13911 + 68] = mem[idx + _13837 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13911 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13911 + -mem[64] + 100
                                    _14354 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_14354 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_14354]:
                                        revert with 0, 50
                                    mem[_14354 + 32] = this.address
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_14354 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _14354 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_14354]:
                                        revert with 0, 50
                                    mem[_14354 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 25)
                                    allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                    emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                    mem[_14354 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_14354 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                    mem[_14354 + ceil32(return_data.size) + 132] = 0
                                    mem[_14354 + ceil32(return_data.size) + 164] = 160
                                    mem[_14354 + ceil32(return_data.size) + 260] = mem[_14354]
                                    idx = 0
                                    s = _14354 + ceil32(return_data.size) + 292
                                    t = _14354 + 32
                                    while idx < mem[_14354]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args stor23[address(this.address)] / stor31 / 10^15, 0, 160, address(this.address), block.timestamp, mem[_14354 + ceil32(return_data.size) + 260 len (32 * mem[_14354]) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            _13260 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13260] = 26
                            mem[_13260 + 32] = 'SafeMath: division by zero'
                            if t < stor31 / 10^15:
                                _13665 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13665] = 26
                                mem[_13665 + 32] = 'SafeMath: division by zero'
                                _14017 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14017] = 26
                                mem[_14017 + 32] = 'SafeMath: division by zero'
                                if not stor31 / 10^15:
                                    revert with 0, 'SafeMath: division by zero', 0
                                _14529 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_14529 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_14529]:
                                    revert with 0, 50
                                mem[_14529 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_14529 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _14529 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_14529]:
                                    revert with 0, 50
                                mem[_14529 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                mem[_14529 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_14529 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                mem[_14529 + ceil32(return_data.size) + 132] = 0
                                mem[_14529 + ceil32(return_data.size) + 164] = 160
                                mem[_14529 + ceil32(return_data.size) + 260] = mem[_14529]
                                idx = 0
                                s = _14529 + ceil32(return_data.size) + 292
                                t = _14529 + 32
                                while idx < mem[_14529]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args stor23[address(this.address)] / stor31 / 10^15, 0, 160, address(this.address), block.timestamp, mem[_14529 + ceil32(return_data.size) + 260 len (32 * mem[_14529]) + 32]
                            else:
                                _13664 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13664] = 26
                                mem[_13664 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                _14016 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14016] = 26
                                mem[_14016 + 32] = 'SafeMath: division by zero'
                                if not t / s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                _14527 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_14527 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_14527]:
                                    revert with 0, 50
                                mem[_14527 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_14527 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _14527 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_14527]:
                                    revert with 0, 50
                                mem[_14527 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = stor23[address(this.address)] / t / s
                                emit Approval((stor23[address(this.address)] / t / s), this.address, uniswapV2RouterAddress);
                                mem[_14527 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_14527 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / t / s
                                mem[_14527 + ceil32(return_data.size) + 132] = 0
                                mem[_14527 + ceil32(return_data.size) + 164] = 160
                                mem[_14527 + ceil32(return_data.size) + 260] = mem[_14527]
                                idx = 0
                                u = _14527 + ceil32(return_data.size) + 292
                                v = _14527 + 32
                                while idx < mem[_14527]:
                                    mem[u] = mem[v + 12 len 20]
                                    idx = idx + 1
                                    u = u + 32
                                    v = v + 32
                                    continue 
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args stor23[address(this.address)] / t / s, 0, 160, address(this.address), block.timestamp, mem[_14527 + ceil32(return_data.size) + 260 len (32 * mem[_14527]) + 32]
                else:
                    _9286 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9286] = 26
                    mem[_9286 + 32] = 'SafeMath: division by zero'
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    _9550 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9550] = 26
                    mem[_9550 + 32] = 'SafeMath: division by zero'
                    if not t / s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if arg1 <= stor23[address(this.address)] / t / s:
                        _9986 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        mem[_9986 + 32 len 64] = call.data[calldata.size len 64]
                        if 0 >= mem[_9986]:
                            revert with 0, 50
                        mem[_9986 + 32] = this.address
                        staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                gas gas_remaining wei
                        mem[_9986 + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _9986 + ceil32(return_data.size) + 96
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        if 1 >= mem[_9986]:
                            revert with 0, 50
                        mem[_9986 + 64] = ext_call.return_data[12 len 20]
                        if not this.address:
                            revert with 0, 'ERC20: approve from the zero address'
                        if not uniswapV2RouterAddress:
                            revert with 0, 'ERC20: approve to the zero address'
                        mem[0] = uniswapV2RouterAddress
                        mem[32] = sha3(address(this.address), 25)
                        allowance[address(this.address)][stor54] = arg1
                        emit Approval(arg1, this.address, uniswapV2RouterAddress);
                        mem[_9986 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                        mem[_9986 + ceil32(return_data.size) + 100] = arg1
                        mem[_9986 + ceil32(return_data.size) + 132] = 0
                        mem[_9986 + ceil32(return_data.size) + 164] = 160
                        mem[_9986 + ceil32(return_data.size) + 260] = mem[_9986]
                        idx = 0
                        s = _9986 + ceil32(return_data.size) + 292
                        t = _9986 + 32
                        while idx < mem[_9986]:
                            mem[s] = mem[t + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        require ext_code.size(uniswapV2RouterAddress)
                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg1, 0, 160, address(this.address), block.timestamp, mem[_9986 + ceil32(return_data.size) + 260 len (32 * mem[_9986]) + 32]
                    else:
                        mem[0] = this.address
                        if stor29[address(this.address)]:
                            mem[32] = 24
                            _10210 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_10210 + 32 len 64] = call.data[calldata.size len 64]
                            if 0 >= mem[_10210]:
                                revert with 0, 50
                            mem[_10210 + 32] = this.address
                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                    gas gas_remaining wei
                            mem[_10210 + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _10210 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            if 1 >= mem[_10210]:
                                revert with 0, 50
                            mem[_10210 + 64] = ext_call.return_data[12 len 20]
                            if not this.address:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not uniswapV2RouterAddress:
                                revert with 0, 'ERC20: approve to the zero address'
                            mem[0] = uniswapV2RouterAddress
                            mem[32] = sha3(address(this.address), 25)
                            allowance[address(this.address)][stor54] = stor24[address(this.address)]
                            emit Approval(stor24[address(this.address)], this.address, uniswapV2RouterAddress);
                            mem[_10210 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                            mem[_10210 + ceil32(return_data.size) + 100] = stor24[address(this.address)]
                            mem[_10210 + ceil32(return_data.size) + 132] = 0
                            mem[_10210 + ceil32(return_data.size) + 164] = 160
                            mem[_10210 + ceil32(return_data.size) + 260] = mem[_10210]
                            idx = 0
                            s = _10210 + ceil32(return_data.size) + 292
                            t = _10210 + 32
                            while idx < mem[_10210]:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(uniswapV2RouterAddress)
                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args stor24[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_10210 + ceil32(return_data.size) + 260 len (32 * mem[_10210]) + 32]
                        else:
                            mem[32] = 23
                            if stor23[address(this.address)] > stor31:
                                revert with 0, 'Amount must be less than total reflections'
                            idx = 0
                            s = 10^15
                            t = stor31
                            while idx < stor30.length:
                                mem[0] = stor30[idx]
                                mem[32] = 23
                                if stor23[stor30[idx]] > t:
                                    _13546 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13546] = 26
                                    mem[_13546 + 32] = 'SafeMath: division by zero'
                                    _13731 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13731] = 26
                                    mem[_13731 + 32] = 'SafeMath: division by zero'
                                    if not stor31 / 10^15:
                                        _13831 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _13831 + 68] = mem[idx + _13731 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13831 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13831 + -mem[64] + 100
                                    _14248 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_14248 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_14248]:
                                        revert with 0, 50
                                    mem[_14248 + 32] = this.address
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_14248 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _14248 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_14248]:
                                        revert with 0, 50
                                    mem[_14248 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 25)
                                    allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                    emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                    mem[_14248 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_14248 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                    mem[_14248 + ceil32(return_data.size) + 132] = 0
                                    mem[_14248 + ceil32(return_data.size) + 164] = 160
                                    mem[_14248 + ceil32(return_data.size) + 260] = mem[_14248]
                                    idx = 0
                                    s = _14248 + ceil32(return_data.size) + 292
                                    t = _14248 + 32
                                    while idx < mem[_14248]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args stor23[address(this.address)] / stor31 / 10^15, 0, 160, address(this.address), block.timestamp, mem[_14248 + ceil32(return_data.size) + 260 len (32 * mem[_14248]) + 32]
                                else:
                                    if idx >= stor30.length:
                                        revert with 0, 50
                                    mem[0] = stor30[idx]
                                    mem[32] = 24
                                    if stor24[stor30[idx]] <= s:
                                        if idx >= stor30.length:
                                            revert with 0, 50
                                        mem[0] = stor30[idx]
                                        mem[32] = 23
                                        _13598 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13598] = 30
                                        mem[_13598 + 32] = 'SafeMath: subtraction overflow'
                                        if stor23[stor30[idx]] > t:
                                            _13626 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13626 + 68] = mem[idx + _13598 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13626 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13626 + -mem[64] + 100
                                        if t < stor23[stor30[idx]]:
                                            revert with 0, 17
                                        if idx >= stor30.length:
                                            revert with 0, 50
                                        mem[0] = stor30[idx]
                                        mem[32] = 24
                                        _13832 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13832] = 30
                                        mem[_13832 + 32] = 'SafeMath: subtraction overflow'
                                        if stor24[stor30[idx]] <= s:
                                            if s < stor24[stor30[idx]]:
                                                revert with 0, 17
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s - stor24[stor30[idx]]
                                            t = t - stor23[stor30[idx]]
                                            continue 
                                        _13907 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13907 + 68] = mem[idx + _13832 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13907 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13907 + -mem[64] + 100
                                    _13599 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13599] = 26
                                    mem[_13599 + 32] = 'SafeMath: division by zero'
                                    _13833 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13833] = 26
                                    mem[_13833 + 32] = 'SafeMath: division by zero'
                                    if not stor31 / 10^15:
                                        _13908 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _13908 + 68] = mem[idx + _13833 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13908 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13908 + -mem[64] + 100
                                    _14349 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_14349 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_14349]:
                                        revert with 0, 50
                                    mem[_14349 + 32] = this.address
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_14349 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _14349 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_14349]:
                                        revert with 0, 50
                                    mem[_14349 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 25)
                                    allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                    emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                    mem[_14349 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_14349 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                    mem[_14349 + ceil32(return_data.size) + 132] = 0
                                    mem[_14349 + ceil32(return_data.size) + 164] = 160
                                    mem[_14349 + ceil32(return_data.size) + 260] = mem[_14349]
                                    idx = 0
                                    s = _14349 + ceil32(return_data.size) + 292
                                    t = _14349 + 32
                                    while idx < mem[_14349]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args stor23[address(this.address)] / stor31 / 10^15, 0, 160, address(this.address), block.timestamp, mem[_14349 + ceil32(return_data.size) + 260 len (32 * mem[_14349]) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            _13255 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13255] = 26
                            mem[_13255 + 32] = 'SafeMath: division by zero'
                            if t < stor31 / 10^15:
                                _13663 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13663] = 26
                                mem[_13663 + 32] = 'SafeMath: division by zero'
                                _14015 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14015] = 26
                                mem[_14015 + 32] = 'SafeMath: division by zero'
                                if not stor31 / 10^15:
                                    revert with 0, 'SafeMath: division by zero', 0
                                _14524 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_14524 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_14524]:
                                    revert with 0, 50
                                mem[_14524 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_14524 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _14524 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_14524]:
                                    revert with 0, 50
                                mem[_14524 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                mem[_14524 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_14524 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                mem[_14524 + ceil32(return_data.size) + 132] = 0
                                mem[_14524 + ceil32(return_data.size) + 164] = 160
                                mem[_14524 + ceil32(return_data.size) + 260] = mem[_14524]
                                idx = 0
                                s = _14524 + ceil32(return_data.size) + 292
                                t = _14524 + 32
                                while idx < mem[_14524]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_14524 + ceil32(return_data.size) + 196] = this.address
                                mem[_14524 + ceil32(return_data.size) + 228] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _14524 + ceil32(return_data.size) + (32 * mem[_14524]) + -mem[64] + 288]
                            else:
                                _13662 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13662] = 26
                                mem[_13662 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                _14014 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14014] = 26
                                mem[_14014 + 32] = 'SafeMath: division by zero'
                                if not t / s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                _14522 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_14522 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_14522]:
                                    revert with 0, 50
                                mem[_14522 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_14522 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _14522 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_14522]:
                                    revert with 0, 50
                                mem[_14522 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = stor23[address(this.address)] / t / s
                                emit Approval((stor23[address(this.address)] / t / s), this.address, uniswapV2RouterAddress);
                                mem[_14522 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_14522 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / t / s
                                mem[_14522 + ceil32(return_data.size) + 132] = 0
                                mem[_14522 + ceil32(return_data.size) + 164] = 160
                                mem[_14522 + ceil32(return_data.size) + 260] = mem[_14522]
                                idx = 0
                                s = _14522 + ceil32(return_data.size) + 292
                                t = _14522 + 32
                                while idx < mem[_14522]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_14522 + ceil32(return_data.size) + 196] = this.address
                                mem[_14522 + ceil32(return_data.size) + 228] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _14522 + ceil32(return_data.size) + (32 * mem[_14522]) + -mem[64] + 288]
        else:
            _4577 = mem[64]
            mem[64] = mem[64] + 64
            mem[_4577] = 26
            mem[_4577 + 32] = 'SafeMath: division by zero'
            if not s:
                revert with 0, 'SafeMath: division by zero', 0
            _4643 = mem[64]
            mem[64] = mem[64] + 64
            mem[_4643] = 26
            mem[_4643 + 32] = 'SafeMath: division by zero'
            if not t / s:
                revert with 0, 'SafeMath: division by zero', 0
            if stor23[address(this.address)] / t / s <= 0:
                revert with 0, 'Contract balance is zero'
            mem[0] = this.address
            if stor29[address(this.address)]:
                mem[32] = 24
                if arg1 <= stor24[address(this.address)]:
                    _4835 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    mem[_4835 + 32 len 64] = call.data[calldata.size len 64]
                    if 0 >= mem[_4835]:
                        revert with 0, 50
                    mem[_4835 + 32] = this.address
                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                            gas gas_remaining wei
                    mem[_4835 + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _4835 + ceil32(return_data.size) + 96
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if 1 >= mem[_4835]:
                        revert with 0, 50
                    mem[_4835 + 64] = ext_call.return_data[12 len 20]
                    if not this.address:
                        revert with 0, 'ERC20: approve from the zero address'
                    if not uniswapV2RouterAddress:
                        revert with 0, 'ERC20: approve to the zero address'
                    mem[0] = uniswapV2RouterAddress
                    mem[32] = sha3(address(this.address), 25)
                    allowance[address(this.address)][stor54] = arg1
                    emit Approval(arg1, this.address, uniswapV2RouterAddress);
                    mem[_4835 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                    mem[_4835 + ceil32(return_data.size) + 100] = arg1
                    mem[_4835 + ceil32(return_data.size) + 132] = 0
                    mem[_4835 + ceil32(return_data.size) + 164] = 160
                    mem[_4835 + ceil32(return_data.size) + 260] = mem[_4835]
                    idx = 0
                    s = _4835 + ceil32(return_data.size) + 292
                    t = _4835 + 32
                    while idx < mem[_4835]:
                        mem[s] = mem[t + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    require ext_code.size(uniswapV2RouterAddress)
                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args arg1, 0, 160, address(this.address), block.timestamp, mem[_4835 + ceil32(return_data.size) + 260 len (32 * mem[_4835]) + 32]
                else:
                    mem[0] = this.address
                    if stor29[address(this.address)]:
                        mem[32] = 24
                        _4932 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        mem[_4932 + 32 len 64] = call.data[calldata.size len 64]
                        if 0 >= mem[_4932]:
                            revert with 0, 50
                        mem[_4932 + 32] = this.address
                        staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                gas gas_remaining wei
                        mem[_4932 + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _4932 + ceil32(return_data.size) + 96
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        if 1 >= mem[_4932]:
                            revert with 0, 50
                        mem[_4932 + 64] = ext_call.return_data[12 len 20]
                        if not this.address:
                            revert with 0, 'ERC20: approve from the zero address'
                        if not uniswapV2RouterAddress:
                            revert with 0, 'ERC20: approve to the zero address'
                        mem[0] = uniswapV2RouterAddress
                        mem[32] = sha3(address(this.address), 25)
                        allowance[address(this.address)][stor54] = stor24[address(this.address)]
                        emit Approval(stor24[address(this.address)], this.address, uniswapV2RouterAddress);
                        mem[_4932 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                        mem[_4932 + ceil32(return_data.size) + 100] = stor24[address(this.address)]
                        mem[_4932 + ceil32(return_data.size) + 132] = 0
                        mem[_4932 + ceil32(return_data.size) + 164] = 160
                        mem[_4932 + ceil32(return_data.size) + 260] = mem[_4932]
                        idx = 0
                        s = _4932 + ceil32(return_data.size) + 292
                        t = _4932 + 32
                        while idx < mem[_4932]:
                            mem[s] = mem[t + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        require ext_code.size(uniswapV2RouterAddress)
                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args stor24[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_4932 + ceil32(return_data.size) + 260 len (32 * mem[_4932]) + 32]
                    else:
                        mem[32] = 23
                        if stor23[address(this.address)] > stor31:
                            revert with 0, 'Amount must be less than total reflections'
                        idx = 0
                        s = 10^15
                        t = stor31
                        while idx < stor30.length:
                            mem[0] = stor30[idx]
                            mem[32] = 23
                            if stor23[stor30[idx]] > t:
                                _9199 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9199] = 26
                                mem[_9199 + 32] = 'SafeMath: division by zero'
                                _9334 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9334] = 26
                                mem[_9334 + 32] = 'SafeMath: division by zero'
                                if not stor31 / 10^15:
                                    _9407 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _9407 + 68] = mem[idx + _9334 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_9407 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _9407 + -mem[64] + 100
                                _9721 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_9721 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_9721]:
                                    revert with 0, 50
                                mem[_9721 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_9721 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _9721 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_9721]:
                                    revert with 0, 50
                                mem[_9721 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                mem[_9721 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_9721 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                mem[_9721 + ceil32(return_data.size) + 132] = 0
                                mem[_9721 + ceil32(return_data.size) + 164] = 160
                                mem[_9721 + ceil32(return_data.size) + 260] = mem[_9721]
                                idx = 0
                                s = _9721 + ceil32(return_data.size) + 292
                                t = _9721 + 32
                                while idx < mem[_9721]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_9721 + ceil32(return_data.size) + 196] = this.address
                                mem[_9721 + ceil32(return_data.size) + 228] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _9721 + ceil32(return_data.size) + (32 * mem[_9721]) + -mem[64] + 288]
                            else:
                                if idx >= stor30.length:
                                    revert with 0, 50
                                mem[0] = stor30[idx]
                                mem[32] = 24
                                if stor24[stor30[idx]] <= s:
                                    if idx >= stor30.length:
                                        revert with 0, 50
                                    mem[0] = stor30[idx]
                                    mem[32] = 23
                                    _9236 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9236] = 30
                                    mem[_9236 + 32] = 'SafeMath: subtraction overflow'
                                    if stor23[stor30[idx]] > t:
                                        _9259 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _9259 + 68] = mem[idx + _9236 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_9259 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _9259 + -mem[64] + 100
                                    if t < stor23[stor30[idx]]:
                                        revert with 0, 17
                                    if idx >= stor30.length:
                                        revert with 0, 50
                                    mem[0] = stor30[idx]
                                    mem[32] = 24
                                    _9408 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9408] = 30
                                    mem[_9408 + 32] = 'SafeMath: subtraction overflow'
                                    if stor24[stor30[idx]] <= s:
                                        if s < stor24[stor30[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor24[stor30[idx]]
                                        t = t - stor23[stor30[idx]]
                                        continue 
                                    _9466 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _9466 + 68] = mem[idx + _9408 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_9466 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _9466 + -mem[64] + 100
                                _9237 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9237] = 26
                                mem[_9237 + 32] = 'SafeMath: division by zero'
                                _9409 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_9409] = 26
                                mem[_9409 + 32] = 'SafeMath: division by zero'
                                if not stor31 / 10^15:
                                    _9467 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _9467 + 68] = mem[idx + _9409 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_9467 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _9467 + -mem[64] + 100
                                _9807 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_9807 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_9807]:
                                    revert with 0, 50
                                mem[_9807 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_9807 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _9807 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_9807]:
                                    revert with 0, 50
                                mem[_9807 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                mem[_9807 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_9807 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                mem[_9807 + ceil32(return_data.size) + 132] = 0
                                mem[_9807 + ceil32(return_data.size) + 164] = 160
                                mem[_9807 + ceil32(return_data.size) + 260] = mem[_9807]
                                idx = 0
                                s = _9807 + ceil32(return_data.size) + 292
                                t = _9807 + 32
                                while idx < mem[_9807]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_9807 + ceil32(return_data.size) + 196] = this.address
                                mem[_9807 + ceil32(return_data.size) + 228] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _9807 + ceil32(return_data.size) + (32 * mem[_9807]) + -mem[64] + 288]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                        _9080 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9080] = 26
                        mem[_9080 + 32] = 'SafeMath: division by zero'
                        if t < stor31 / 10^15:
                            _9285 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_9285] = 26
                            mem[_9285 + 32] = 'SafeMath: division by zero'
                            _9549 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_9549] = 26
                            mem[_9549 + 32] = 'SafeMath: division by zero'
                            if not stor31 / 10^15:
                                revert with 0, 'SafeMath: division by zero', 0
                            _9983 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_9983 + 32 len 64] = call.data[calldata.size len 64]
                            if 0 >= mem[_9983]:
                                revert with 0, 50
                            mem[_9983 + 32] = this.address
                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                    gas gas_remaining wei
                            mem[_9983 + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _9983 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            if 1 >= mem[_9983]:
                                revert with 0, 50
                            mem[_9983 + 64] = ext_call.return_data[12 len 20]
                            if not this.address:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not uniswapV2RouterAddress:
                                revert with 0, 'ERC20: approve to the zero address'
                            mem[0] = uniswapV2RouterAddress
                            mem[32] = sha3(address(this.address), 25)
                            allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                            emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                            mem[_9983 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                            mem[_9983 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                            mem[_9983 + ceil32(return_data.size) + 132] = 0
                            mem[_9983 + ceil32(return_data.size) + 164] = 160
                            mem[_9983 + ceil32(return_data.size) + 260] = mem[_9983]
                            idx = 0
                            s = _9983 + ceil32(return_data.size) + 292
                            t = _9983 + 32
                            while idx < mem[_9983]:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(uniswapV2RouterAddress)
                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args stor23[address(this.address)] / stor31 / 10^15, 0, 160, address(this.address), block.timestamp, mem[_9983 + ceil32(return_data.size) + 260 len (32 * mem[_9983]) + 32]
                        else:
                            _9284 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_9284] = 26
                            mem[_9284 + 32] = 'SafeMath: division by zero'
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            _9548 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_9548] = 26
                            mem[_9548 + 32] = 'SafeMath: division by zero'
                            if not t / s:
                                revert with 0, 'SafeMath: division by zero', 0
                            _9981 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_9981 + 32 len 64] = call.data[calldata.size len 64]
                            if 0 >= mem[_9981]:
                                revert with 0, 50
                            mem[_9981 + 32] = this.address
                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                    gas gas_remaining wei
                            mem[_9981 + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _9981 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            if 1 >= mem[_9981]:
                                revert with 0, 50
                            mem[_9981 + 64] = ext_call.return_data[12 len 20]
                            if not this.address:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not uniswapV2RouterAddress:
                                revert with 0, 'ERC20: approve to the zero address'
                            mem[0] = uniswapV2RouterAddress
                            mem[32] = sha3(address(this.address), 25)
                            allowance[address(this.address)][stor54] = stor23[address(this.address)] / t / s
                            emit Approval((stor23[address(this.address)] / t / s), this.address, uniswapV2RouterAddress);
                            mem[_9981 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                            mem[_9981 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / t / s
                            mem[_9981 + ceil32(return_data.size) + 132] = 0
                            mem[_9981 + ceil32(return_data.size) + 164] = 160
                            mem[_9981 + ceil32(return_data.size) + 260] = mem[_9981]
                            idx = 0
                            u = _9981 + ceil32(return_data.size) + 292
                            v = _9981 + 32
                            while idx < mem[_9981]:
                                mem[u] = mem[v + 12 len 20]
                                idx = idx + 1
                                u = u + 32
                                v = v + 32
                                continue 
                            require ext_code.size(uniswapV2RouterAddress)
                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args stor23[address(this.address)] / t / s, 0, 160, address(this.address), block.timestamp, mem[_9981 + ceil32(return_data.size) + 260 len (32 * mem[_9981]) + 32]
            else:
                mem[32] = 23
                if stor23[address(this.address)] > stor31:
                    revert with 0, 'Amount must be less than total reflections'
                idx = 0
                s = 10^15
                t = stor31
                while idx < stor30.length:
                    mem[0] = stor30[idx]
                    mem[32] = 23
                    if stor23[stor30[idx]] > t:
                        _9198 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9198] = 26
                        mem[_9198 + 32] = 'SafeMath: division by zero'
                        _9331 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9331] = 26
                        mem[_9331 + 32] = 'SafeMath: division by zero'
                        if not stor31 / 10^15:
                            _9403 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _9403 + 68] = mem[idx + _9331 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9403 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9403 + -mem[64] + 100
                        if arg1 <= stor23[address(this.address)] / stor31 / 10^15:
                            _9716 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_9716 + 32 len 64] = call.data[calldata.size len 64]
                            if 0 >= mem[_9716]:
                                revert with 0, 50
                            mem[_9716 + 32] = this.address
                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                    gas gas_remaining wei
                            mem[_9716 + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _9716 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            if 1 >= mem[_9716]:
                                revert with 0, 50
                            mem[_9716 + 64] = ext_call.return_data[12 len 20]
                            if not this.address:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not uniswapV2RouterAddress:
                                revert with 0, 'ERC20: approve to the zero address'
                            mem[0] = uniswapV2RouterAddress
                            mem[32] = sha3(address(this.address), 25)
                            allowance[address(this.address)][stor54] = arg1
                            emit Approval(arg1, this.address, uniswapV2RouterAddress);
                            mem[_9716 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                            mem[_9716 + ceil32(return_data.size) + 100] = arg1
                            mem[_9716 + ceil32(return_data.size) + 132] = 0
                            mem[_9716 + ceil32(return_data.size) + 164] = 160
                            mem[_9716 + ceil32(return_data.size) + 260] = mem[_9716]
                            idx = 0
                            s = _9716 + ceil32(return_data.size) + 292
                            t = _9716 + 32
                            while idx < mem[_9716]:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_9716 + ceil32(return_data.size) + 196] = this.address
                            mem[_9716 + ceil32(return_data.size) + 228] = block.timestamp
                            require ext_code.size(uniswapV2RouterAddress)
                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _9716 + ceil32(return_data.size) + (32 * mem[_9716]) + -mem[64] + 288]
                        else:
                            mem[0] = this.address
                            if stor29[address(this.address)]:
                                mem[32] = 24
                                _9924 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_9924 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_9924]:
                                    revert with 0, 50
                                mem[_9924 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_9924 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _9924 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_9924]:
                                    revert with 0, 50
                                mem[_9924 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = stor24[address(this.address)]
                                emit Approval(stor24[address(this.address)], this.address, uniswapV2RouterAddress);
                                mem[_9924 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_9924 + ceil32(return_data.size) + 100] = stor24[address(this.address)]
                                mem[_9924 + ceil32(return_data.size) + 132] = 0
                                mem[_9924 + ceil32(return_data.size) + 164] = 160
                                mem[_9924 + ceil32(return_data.size) + 260] = mem[_9924]
                                idx = 0
                                s = _9924 + ceil32(return_data.size) + 292
                                t = _9924 + 32
                                while idx < mem[_9924]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args stor24[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_9924 + ceil32(return_data.size) + 260 len (32 * mem[_9924]) + 32]
                            else:
                                mem[32] = 23
                                if stor23[address(this.address)] > stor31:
                                    revert with 0, 'Amount must be less than total reflections'
                                idx = 0
                                s = 10^15
                                t = stor31
                                while idx < stor30.length:
                                    mem[0] = stor30[idx]
                                    mem[32] = 23
                                    if stor23[stor30[idx]] > t:
                                        _13544 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13544] = 26
                                        mem[_13544 + 32] = 'SafeMath: division by zero'
                                        _13725 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13725] = 26
                                        mem[_13725 + 32] = 'SafeMath: division by zero'
                                        if not stor31 / 10^15:
                                            _13823 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _13823 + 68] = mem[idx + _13725 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13823 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13823 + -mem[64] + 100
                                        _14240 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        mem[_14240 + 32 len 64] = call.data[calldata.size len 64]
                                        if 0 >= mem[_14240]:
                                            revert with 0, 50
                                        mem[_14240 + 32] = this.address
                                        staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                                gas gas_remaining wei
                                        mem[_14240 + 96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _14240 + ceil32(return_data.size) + 96
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        if 1 >= mem[_14240]:
                                            revert with 0, 50
                                        mem[_14240 + 64] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 25)
                                        allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                        emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                        mem[_14240 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_14240 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                        mem[_14240 + ceil32(return_data.size) + 132] = 0
                                        mem[_14240 + ceil32(return_data.size) + 164] = 160
                                        mem[_14240 + ceil32(return_data.size) + 260] = mem[_14240]
                                        idx = 0
                                        s = _14240 + ceil32(return_data.size) + 292
                                        t = _14240 + 32
                                        while idx < mem[_14240]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args stor23[address(this.address)] / stor31 / 10^15, 0, 160, address(this.address), block.timestamp, mem[_14240 + ceil32(return_data.size) + 260 len (32 * mem[_14240]) + 32]
                                    else:
                                        if idx >= stor30.length:
                                            revert with 0, 50
                                        mem[0] = stor30[idx]
                                        mem[32] = 24
                                        if stor24[stor30[idx]] <= s:
                                            if idx >= stor30.length:
                                                revert with 0, 50
                                            mem[0] = stor30[idx]
                                            mem[32] = 23
                                            _13594 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13594] = 30
                                            mem[_13594 + 32] = 'SafeMath: subtraction overflow'
                                            if stor23[stor30[idx]] > t:
                                                _13624 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _13624 + 68] = mem[idx + _13594 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_13624 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _13624 + -mem[64] + 100
                                            if t < stor23[stor30[idx]]:
                                                revert with 0, 17
                                            if idx >= stor30.length:
                                                revert with 0, 50
                                            mem[0] = stor30[idx]
                                            mem[32] = 24
                                            _13824 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13824] = 30
                                            mem[_13824 + 32] = 'SafeMath: subtraction overflow'
                                            if stor24[stor30[idx]] <= s:
                                                if s < stor24[stor30[idx]]:
                                                    revert with 0, 17
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                s = s - stor24[stor30[idx]]
                                                t = t - stor23[stor30[idx]]
                                                continue 
                                            _13901 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13901 + 68] = mem[idx + _13824 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13901 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13901 + -mem[64] + 100
                                        _13595 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13595] = 26
                                        mem[_13595 + 32] = 'SafeMath: division by zero'
                                        _13825 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13825] = 26
                                        mem[_13825 + 32] = 'SafeMath: division by zero'
                                        if not stor31 / 10^15:
                                            _13902 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _13902 + 68] = mem[idx + _13825 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13902 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13902 + -mem[64] + 100
                                        _14339 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        mem[_14339 + 32 len 64] = call.data[calldata.size len 64]
                                        if 0 >= mem[_14339]:
                                            revert with 0, 50
                                        mem[_14339 + 32] = this.address
                                        staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                                gas gas_remaining wei
                                        mem[_14339 + 96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _14339 + ceil32(return_data.size) + 96
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        if 1 >= mem[_14339]:
                                            revert with 0, 50
                                        mem[_14339 + 64] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 25)
                                        allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                        emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                        mem[_14339 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_14339 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                        mem[_14339 + ceil32(return_data.size) + 132] = 0
                                        mem[_14339 + ceil32(return_data.size) + 164] = 160
                                        mem[_14339 + ceil32(return_data.size) + 260] = mem[_14339]
                                        idx = 0
                                        s = _14339 + ceil32(return_data.size) + 292
                                        t = _14339 + 32
                                        while idx < mem[_14339]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args stor23[address(this.address)] / stor31 / 10^15, 0, 160, address(this.address), block.timestamp, mem[_14339 + ceil32(return_data.size) + 260 len (32 * mem[_14339]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                _13241 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13241] = 26
                                mem[_13241 + 32] = 'SafeMath: division by zero'
                                if t >= stor31 / 10^15:
                                    _13658 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13658] = 26
                                    mem[_13658 + 32] = 'SafeMath: division by zero'
                                    if not s:
                                        _13704 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _13704 + 68] = mem[idx + _13658 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13704 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13704 + -mem[64] + 100
                                    _14010 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14010] = 26
                                    mem[_14010 + 32] = 'SafeMath: division by zero'
                                    if not t / s:
                                        _14092 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        s = 0
                                        while s < 26:
                                            mem[s + _14092 + 68] = mem[s + _14010 + 32]
                                            s = s + 32
                                            continue 
                                        mem[_14092 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14092 + -mem[64] + 100
                                    _14512 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_14512 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_14512]:
                                        revert with 0, 50
                                    mem[_14512 + 32] = this.address
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_14512 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _14512 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_14512]:
                                        revert with 0, 50
                                    mem[_14512 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 25)
                                    allowance[address(this.address)][stor54] = stor23[address(this.address)] / t / s
                                    emit Approval((stor23[address(this.address)] / t / s), this.address, uniswapV2RouterAddress);
                                    mem[_14512 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_14512 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / t / s
                                    mem[_14512 + ceil32(return_data.size) + 132] = 0
                                    mem[_14512 + ceil32(return_data.size) + 164] = 160
                                    mem[_14512 + ceil32(return_data.size) + 260] = mem[_14512]
                                    idx = 0
                                    u = _14512 + ceil32(return_data.size) + 292
                                    v = _14512 + 32
                                    while idx < mem[_14512]:
                                        mem[u] = mem[v + 12 len 20]
                                        idx = idx + 1
                                        u = u + 32
                                        v = v + 32
                                        continue 
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args stor23[address(this.address)] / t / s, 0, 160, address(this.address), block.timestamp, mem[_14512 + ceil32(return_data.size) + 260 len (32 * mem[_14512]) + 32]
                                else:
                                    _13659 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13659] = 26
                                    mem[_13659 + 32] = 'SafeMath: division by zero'
                                    _14011 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14011] = 26
                                    mem[_14011 + 32] = 'SafeMath: division by zero'
                                    if not stor31 / 10^15:
                                        _14093 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        s = 0
                                        while s < 26:
                                            mem[s + _14093 + 68] = mem[s + _14011 + 32]
                                            s = s + 32
                                            continue 
                                        mem[_14093 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14093 + -mem[64] + 100
                                    _14514 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_14514 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_14514]:
                                        revert with 0, 50
                                    mem[_14514 + 32] = this.address
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_14514 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _14514 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_14514]:
                                        revert with 0, 50
                                    mem[_14514 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 25)
                                    allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                    emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                    mem[_14514 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_14514 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                    mem[_14514 + ceil32(return_data.size) + 132] = 0
                                    mem[_14514 + ceil32(return_data.size) + 164] = 160
                                    mem[_14514 + ceil32(return_data.size) + 260] = mem[_14514]
                                    idx = 0
                                    s = _14514 + ceil32(return_data.size) + 292
                                    t = _14514 + 32
                                    while idx < mem[_14514]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_14514 + ceil32(return_data.size) + 196] = this.address
                                    mem[_14514 + ceil32(return_data.size) + 228] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _14514 + ceil32(return_data.size) + (32 * mem[_14514]) + -mem[64] + 288]
                    else:
                        if idx >= stor30.length:
                            revert with 0, 50
                        mem[0] = stor30[idx]
                        mem[32] = 24
                        if stor24[stor30[idx]] <= s:
                            if idx >= stor30.length:
                                revert with 0, 50
                            mem[0] = stor30[idx]
                            mem[32] = 23
                            _9234 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_9234] = 30
                            mem[_9234 + 32] = 'SafeMath: subtraction overflow'
                            if stor23[stor30[idx]] > t:
                                _9258 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _9258 + 68] = mem[idx + _9234 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_9258 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _9258 + -mem[64] + 100
                            if t < stor23[stor30[idx]]:
                                revert with 0, 17
                            if idx >= stor30.length:
                                revert with 0, 50
                            mem[0] = stor30[idx]
                            mem[32] = 24
                            _9404 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_9404] = 30
                            mem[_9404 + 32] = 'SafeMath: subtraction overflow'
                            if stor24[stor30[idx]] <= s:
                                if s < stor24[stor30[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor24[stor30[idx]]
                                t = t - stor23[stor30[idx]]
                                continue 
                            _9463 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _9463 + 68] = mem[idx + _9404 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9463 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9463 + -mem[64] + 100
                        _9235 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9235] = 26
                        mem[_9235 + 32] = 'SafeMath: division by zero'
                        _9405 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9405] = 26
                        mem[_9405 + 32] = 'SafeMath: division by zero'
                        if not stor31 / 10^15:
                            _9464 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _9464 + 68] = mem[idx + _9405 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9464 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9464 + -mem[64] + 100
                        if arg1 <= stor23[address(this.address)] / stor31 / 10^15:
                            _9801 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_9801 + 32 len 64] = call.data[calldata.size len 64]
                            if 0 >= mem[_9801]:
                                revert with 0, 50
                            mem[_9801 + 32] = this.address
                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                    gas gas_remaining wei
                            mem[_9801 + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _9801 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            if 1 >= mem[_9801]:
                                revert with 0, 50
                            mem[_9801 + 64] = ext_call.return_data[12 len 20]
                            if not this.address:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not uniswapV2RouterAddress:
                                revert with 0, 'ERC20: approve to the zero address'
                            mem[0] = uniswapV2RouterAddress
                            mem[32] = sha3(address(this.address), 25)
                            allowance[address(this.address)][stor54] = arg1
                            emit Approval(arg1, this.address, uniswapV2RouterAddress);
                            mem[_9801 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                            mem[_9801 + ceil32(return_data.size) + 100] = arg1
                            mem[_9801 + ceil32(return_data.size) + 132] = 0
                            mem[_9801 + ceil32(return_data.size) + 164] = 160
                            mem[_9801 + ceil32(return_data.size) + 260] = mem[_9801]
                            idx = 0
                            s = _9801 + ceil32(return_data.size) + 292
                            t = _9801 + 32
                            while idx < mem[_9801]:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_9801 + ceil32(return_data.size) + 196] = this.address
                            mem[_9801 + ceil32(return_data.size) + 228] = block.timestamp
                            require ext_code.size(uniswapV2RouterAddress)
                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _9801 + ceil32(return_data.size) + (32 * mem[_9801]) + -mem[64] + 288]
                        else:
                            mem[0] = this.address
                            if stor29[address(this.address)]:
                                mem[32] = 24
                                _9979 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_9979 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_9979]:
                                    revert with 0, 50
                                mem[_9979 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_9979 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _9979 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_9979]:
                                    revert with 0, 50
                                mem[_9979 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = stor24[address(this.address)]
                                emit Approval(stor24[address(this.address)], this.address, uniswapV2RouterAddress);
                                mem[_9979 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_9979 + ceil32(return_data.size) + 100] = stor24[address(this.address)]
                                mem[_9979 + ceil32(return_data.size) + 132] = 0
                                mem[_9979 + ceil32(return_data.size) + 164] = 160
                                mem[_9979 + ceil32(return_data.size) + 260] = mem[_9979]
                                idx = 0
                                s = _9979 + ceil32(return_data.size) + 292
                                t = _9979 + 32
                                while idx < mem[_9979]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args stor24[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_9979 + ceil32(return_data.size) + 260 len (32 * mem[_9979]) + 32]
                            else:
                                mem[32] = 23
                                if stor23[address(this.address)] > stor31:
                                    revert with 0, 'Amount must be less than total reflections'
                                idx = 0
                                s = 10^15
                                t = stor31
                                while idx < stor30.length:
                                    mem[0] = stor30[idx]
                                    mem[32] = 23
                                    if stor23[stor30[idx]] > t:
                                        _13545 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13545] = 26
                                        mem[_13545 + 32] = 'SafeMath: division by zero'
                                        _13728 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13728] = 26
                                        mem[_13728 + 32] = 'SafeMath: division by zero'
                                        if not stor31 / 10^15:
                                            _13827 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _13827 + 68] = mem[idx + _13728 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13827 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13827 + -mem[64] + 100
                                        _14244 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        mem[_14244 + 32 len 64] = call.data[calldata.size len 64]
                                        if 0 >= mem[_14244]:
                                            revert with 0, 50
                                        mem[_14244 + 32] = this.address
                                        staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                                gas gas_remaining wei
                                        mem[_14244 + 96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _14244 + ceil32(return_data.size) + 96
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        if 1 >= mem[_14244]:
                                            revert with 0, 50
                                        mem[_14244 + 64] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 25)
                                        allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                        emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                        mem[_14244 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_14244 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                        mem[_14244 + ceil32(return_data.size) + 132] = 0
                                        mem[_14244 + ceil32(return_data.size) + 164] = 160
                                        mem[_14244 + ceil32(return_data.size) + 260] = mem[_14244]
                                        idx = 0
                                        s = _14244 + ceil32(return_data.size) + 292
                                        t = _14244 + 32
                                        while idx < mem[_14244]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args stor23[address(this.address)] / stor31 / 10^15, 0, 160, address(this.address), block.timestamp, mem[_14244 + ceil32(return_data.size) + 260 len (32 * mem[_14244]) + 32]
                                    else:
                                        if idx >= stor30.length:
                                            revert with 0, 50
                                        mem[0] = stor30[idx]
                                        mem[32] = 24
                                        if stor24[stor30[idx]] <= s:
                                            if idx >= stor30.length:
                                                revert with 0, 50
                                            mem[0] = stor30[idx]
                                            mem[32] = 23
                                            _13596 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13596] = 30
                                            mem[_13596 + 32] = 'SafeMath: subtraction overflow'
                                            if stor23[stor30[idx]] > t:
                                                _13625 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _13625 + 68] = mem[idx + _13596 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_13625 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _13625 + -mem[64] + 100
                                            if t < stor23[stor30[idx]]:
                                                revert with 0, 17
                                            if idx >= stor30.length:
                                                revert with 0, 50
                                            mem[0] = stor30[idx]
                                            mem[32] = 24
                                            _13828 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13828] = 30
                                            mem[_13828 + 32] = 'SafeMath: subtraction overflow'
                                            if stor24[stor30[idx]] <= s:
                                                if s < stor24[stor30[idx]]:
                                                    revert with 0, 17
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                s = s - stor24[stor30[idx]]
                                                t = t - stor23[stor30[idx]]
                                                continue 
                                            _13904 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13904 + 68] = mem[idx + _13828 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13904 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13904 + -mem[64] + 100
                                        _13597 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13597] = 26
                                        mem[_13597 + 32] = 'SafeMath: division by zero'
                                        _13829 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13829] = 26
                                        mem[_13829 + 32] = 'SafeMath: division by zero'
                                        if not stor31 / 10^15:
                                            _13905 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _13905 + 68] = mem[idx + _13829 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13905 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13905 + -mem[64] + 100
                                        _14344 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        mem[_14344 + 32 len 64] = call.data[calldata.size len 64]
                                        if 0 >= mem[_14344]:
                                            revert with 0, 50
                                        mem[_14344 + 32] = this.address
                                        staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                                gas gas_remaining wei
                                        mem[_14344 + 96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _14344 + ceil32(return_data.size) + 96
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        if 1 >= mem[_14344]:
                                            revert with 0, 50
                                        mem[_14344 + 64] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 25)
                                        allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                        emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                        mem[_14344 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                        mem[_14344 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                        mem[_14344 + ceil32(return_data.size) + 132] = 0
                                        mem[_14344 + ceil32(return_data.size) + 164] = 160
                                        mem[_14344 + ceil32(return_data.size) + 260] = mem[_14344]
                                        idx = 0
                                        s = _14344 + ceil32(return_data.size) + 292
                                        t = _14344 + 32
                                        while idx < mem[_14344]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_14344 + ceil32(return_data.size) + 196] = this.address
                                        mem[_14344 + ceil32(return_data.size) + 228] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _14344 + ceil32(return_data.size) + (32 * mem[_14344]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                _13246 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13246] = 26
                                mem[_13246 + 32] = 'SafeMath: division by zero'
                                if t < stor31 / 10^15:
                                    _13661 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13661] = 26
                                    mem[_13661 + 32] = 'SafeMath: division by zero'
                                    _14013 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14013] = 26
                                    mem[_14013 + 32] = 'SafeMath: division by zero'
                                    if not stor31 / 10^15:
                                        _14096 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        s = 0
                                        while s < 26:
                                            mem[s + _14096 + 68] = mem[s + _14013 + 32]
                                            s = s + 32
                                            continue 
                                        mem[_14096 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14096 + -mem[64] + 100
                                    _14519 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_14519 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_14519]:
                                        revert with 0, 50
                                    mem[_14519 + 32] = this.address
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_14519 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _14519 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_14519]:
                                        revert with 0, 50
                                    mem[_14519 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 25)
                                    allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                    emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                    mem[_14519 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_14519 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                    mem[_14519 + ceil32(return_data.size) + 132] = 0
                                    mem[_14519 + ceil32(return_data.size) + 164] = 160
                                    mem[_14519 + ceil32(return_data.size) + 260] = mem[_14519]
                                    idx = 0
                                    s = _14519 + ceil32(return_data.size) + 292
                                    t = _14519 + 32
                                    while idx < mem[_14519]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args stor23[address(this.address)] / stor31 / 10^15, 0, 160, address(this.address), block.timestamp, mem[_14519 + ceil32(return_data.size) + 260 len (32 * mem[_14519]) + 32]
                                else:
                                    _13660 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13660] = 26
                                    mem[_13660 + 32] = 'SafeMath: division by zero'
                                    if not s:
                                        _13705 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _13705 + 68] = mem[idx + _13660 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13705 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13705 + -mem[64] + 100
                                    _14012 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14012] = 26
                                    mem[_14012 + 32] = 'SafeMath: division by zero'
                                    if not t / s:
                                        _14095 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        s = 0
                                        while s < 26:
                                            mem[s + _14095 + 68] = mem[s + _14012 + 32]
                                            s = s + 32
                                            continue 
                                        mem[_14095 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14095 + -mem[64] + 100
                                    _14517 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_14517 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_14517]:
                                        revert with 0, 50
                                    mem[_14517 + 32] = this.address
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_14517 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _14517 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_14517]:
                                        revert with 0, 50
                                    mem[_14517 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 25)
                                    allowance[address(this.address)][stor54] = stor23[address(this.address)] / t / s
                                    emit Approval((stor23[address(this.address)] / t / s), this.address, uniswapV2RouterAddress);
                                    mem[_14517 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_14517 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / t / s
                                    mem[_14517 + ceil32(return_data.size) + 132] = 0
                                    mem[_14517 + ceil32(return_data.size) + 164] = 160
                                    mem[_14517 + ceil32(return_data.size) + 260] = mem[_14517]
                                    idx = 0
                                    u = _14517 + ceil32(return_data.size) + 292
                                    v = _14517 + 32
                                    while idx < mem[_14517]:
                                        mem[u] = mem[v + 12 len 20]
                                        idx = idx + 1
                                        u = u + 32
                                        v = v + 32
                                        continue 
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args stor23[address(this.address)] / t / s, 0, 160, address(this.address), block.timestamp, mem[_14517 + ceil32(return_data.size) + 260 len (32 * mem[_14517]) + 32]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                _9076 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9076] = 26
                mem[_9076 + 32] = 'SafeMath: division by zero'
                if t < stor31 / 10^15:
                    _9283 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9283] = 26
                    mem[_9283 + 32] = 'SafeMath: division by zero'
                    _9547 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9547] = 26
                    mem[_9547 + 32] = 'SafeMath: division by zero'
                    if not stor31 / 10^15:
                        revert with 0, 'SafeMath: division by zero', 0
                    if arg1 <= stor23[address(this.address)] / stor31 / 10^15:
                        _9973 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        mem[_9973 + 32 len 64] = call.data[calldata.size len 64]
                        if 0 >= mem[_9973]:
                            revert with 0, 50
                        mem[_9973 + 32] = this.address
                        staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                gas gas_remaining wei
                        mem[_9973 + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _9973 + ceil32(return_data.size) + 96
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        if 1 >= mem[_9973]:
                            revert with 0, 50
                        mem[_9973 + 64] = ext_call.return_data[12 len 20]
                        if not this.address:
                            revert with 0, 'ERC20: approve from the zero address'
                        if not uniswapV2RouterAddress:
                            revert with 0, 'ERC20: approve to the zero address'
                        mem[0] = uniswapV2RouterAddress
                        mem[32] = sha3(address(this.address), 25)
                        allowance[address(this.address)][stor54] = arg1
                        emit Approval(arg1, this.address, uniswapV2RouterAddress);
                        mem[_9973 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                        mem[_9973 + ceil32(return_data.size) + 100] = arg1
                        mem[_9973 + ceil32(return_data.size) + 132] = 0
                        mem[_9973 + ceil32(return_data.size) + 164] = 160
                        mem[_9973 + ceil32(return_data.size) + 260] = mem[_9973]
                        idx = 0
                        s = _9973 + ceil32(return_data.size) + 292
                        t = _9973 + 32
                        while idx < mem[_9973]:
                            mem[s] = mem[t + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_9973 + ceil32(return_data.size) + 196] = this.address
                        mem[_9973 + ceil32(return_data.size) + 228] = block.timestamp
                        require ext_code.size(uniswapV2RouterAddress)
                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _9973 + ceil32(return_data.size) + (32 * mem[_9973]) + -mem[64] + 288]
                    else:
                        mem[0] = this.address
                        if stor29[address(this.address)]:
                            mem[32] = 24
                            _10196 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_10196 + 32 len 64] = call.data[calldata.size len 64]
                            if 0 >= mem[_10196]:
                                revert with 0, 50
                            mem[_10196 + 32] = this.address
                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                    gas gas_remaining wei
                            mem[_10196 + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _10196 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            if 1 >= mem[_10196]:
                                revert with 0, 50
                            mem[_10196 + 64] = ext_call.return_data[12 len 20]
                            if not this.address:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not uniswapV2RouterAddress:
                                revert with 0, 'ERC20: approve to the zero address'
                            mem[0] = uniswapV2RouterAddress
                            mem[32] = sha3(address(this.address), 25)
                            allowance[address(this.address)][stor54] = stor24[address(this.address)]
                            emit Approval(stor24[address(this.address)], this.address, uniswapV2RouterAddress);
                            mem[_10196 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                            mem[_10196 + ceil32(return_data.size) + 100] = stor24[address(this.address)]
                            mem[_10196 + ceil32(return_data.size) + 132] = 0
                            mem[_10196 + ceil32(return_data.size) + 164] = 160
                            mem[_10196 + ceil32(return_data.size) + 260] = mem[_10196]
                            idx = 0
                            s = _10196 + ceil32(return_data.size) + 292
                            t = _10196 + 32
                            while idx < mem[_10196]:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_10196 + ceil32(return_data.size) + 196] = this.address
                            mem[_10196 + ceil32(return_data.size) + 228] = block.timestamp
                            require ext_code.size(uniswapV2RouterAddress)
                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _10196 + ceil32(return_data.size) + (32 * mem[_10196]) + -mem[64] + 288]
                        else:
                            mem[32] = 23
                            if stor23[address(this.address)] > stor31:
                                revert with 0, 'Amount must be less than total reflections'
                            idx = 0
                            s = 10^15
                            t = stor31
                            while idx < stor30.length:
                                mem[0] = stor30[idx]
                                mem[32] = 23
                                if stor23[stor30[idx]] > t:
                                    _13543 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13543] = 26
                                    mem[_13543 + 32] = 'SafeMath: division by zero'
                                    _13722 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13722] = 26
                                    mem[_13722 + 32] = 'SafeMath: division by zero'
                                    if not stor31 / 10^15:
                                        _13819 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _13819 + 68] = mem[idx + _13722 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13819 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13819 + -mem[64] + 100
                                    _14236 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_14236 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_14236]:
                                        revert with 0, 50
                                    mem[_14236 + 32] = this.address
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_14236 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _14236 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_14236]:
                                        revert with 0, 50
                                    mem[_14236 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 25)
                                    allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                    emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                    mem[_14236 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_14236 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                    mem[_14236 + ceil32(return_data.size) + 132] = 0
                                    mem[_14236 + ceil32(return_data.size) + 164] = 160
                                    mem[_14236 + ceil32(return_data.size) + 260] = mem[_14236]
                                    idx = 0
                                    s = _14236 + ceil32(return_data.size) + 292
                                    t = _14236 + 32
                                    while idx < mem[_14236]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_14236 + ceil32(return_data.size) + 196] = this.address
                                    mem[_14236 + ceil32(return_data.size) + 228] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _14236 + ceil32(return_data.size) + (32 * mem[_14236]) + -mem[64] + 288]
                                else:
                                    if idx >= stor30.length:
                                        revert with 0, 50
                                    mem[0] = stor30[idx]
                                    mem[32] = 24
                                    if stor24[stor30[idx]] <= s:
                                        if idx >= stor30.length:
                                            revert with 0, 50
                                        mem[0] = stor30[idx]
                                        mem[32] = 23
                                        _13592 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13592] = 30
                                        mem[_13592 + 32] = 'SafeMath: subtraction overflow'
                                        if stor23[stor30[idx]] > t:
                                            _13623 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13623 + 68] = mem[idx + _13592 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13623 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13623 + -mem[64] + 100
                                        if t < stor23[stor30[idx]]:
                                            revert with 0, 17
                                        if idx >= stor30.length:
                                            revert with 0, 50
                                        mem[0] = stor30[idx]
                                        mem[32] = 24
                                        _13820 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13820] = 30
                                        mem[_13820 + 32] = 'SafeMath: subtraction overflow'
                                        if stor24[stor30[idx]] <= s:
                                            if s < stor24[stor30[idx]]:
                                                revert with 0, 17
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s - stor24[stor30[idx]]
                                            t = t - stor23[stor30[idx]]
                                            continue 
                                        _13898 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13898 + 68] = mem[idx + _13820 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13898 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13898 + -mem[64] + 100
                                    _13593 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13593] = 26
                                    mem[_13593 + 32] = 'SafeMath: division by zero'
                                    _13821 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13821] = 26
                                    mem[_13821 + 32] = 'SafeMath: division by zero'
                                    if not stor31 / 10^15:
                                        _13899 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _13899 + 68] = mem[idx + _13821 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13899 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13899 + -mem[64] + 100
                                    _14334 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_14334 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_14334]:
                                        revert with 0, 50
                                    mem[_14334 + 32] = this.address
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_14334 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _14334 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_14334]:
                                        revert with 0, 50
                                    mem[_14334 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 25)
                                    allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                    emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                    mem[_14334 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_14334 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                    mem[_14334 + ceil32(return_data.size) + 132] = 0
                                    mem[_14334 + ceil32(return_data.size) + 164] = 160
                                    mem[_14334 + ceil32(return_data.size) + 260] = mem[_14334]
                                    idx = 0
                                    s = _14334 + ceil32(return_data.size) + 292
                                    t = _14334 + 32
                                    while idx < mem[_14334]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_14334 + ceil32(return_data.size) + 196] = this.address
                                    mem[_14334 + ceil32(return_data.size) + 228] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _14334 + ceil32(return_data.size) + (32 * mem[_14334]) + -mem[64] + 288]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            _13236 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13236] = 26
                            mem[_13236 + 32] = 'SafeMath: division by zero'
                            if t < stor31 / 10^15:
                                _13657 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13657] = 26
                                mem[_13657 + 32] = 'SafeMath: division by zero'
                                _14009 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14009] = 26
                                mem[_14009 + 32] = 'SafeMath: division by zero'
                                if not stor31 / 10^15:
                                    revert with 0, 'SafeMath: division by zero', 0
                                _14509 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_14509 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_14509]:
                                    revert with 0, 50
                                mem[_14509 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_14509 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _14509 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_14509]:
                                    revert with 0, 50
                                mem[_14509 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                mem[_14509 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_14509 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                mem[_14509 + ceil32(return_data.size) + 132] = 0
                                mem[_14509 + ceil32(return_data.size) + 164] = 160
                                mem[_14509 + ceil32(return_data.size) + 260] = mem[_14509]
                                idx = 0
                                s = _14509 + ceil32(return_data.size) + 292
                                t = _14509 + 32
                                while idx < mem[_14509]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_14509 + ceil32(return_data.size) + 196] = this.address
                                mem[_14509 + ceil32(return_data.size) + 228] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _14509 + ceil32(return_data.size) + (32 * mem[_14509]) + -mem[64] + 288]
                            else:
                                _13656 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13656] = 26
                                mem[_13656 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                _14008 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14008] = 26
                                mem[_14008 + 32] = 'SafeMath: division by zero'
                                if not t / s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                _14507 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_14507 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_14507]:
                                    revert with 0, 50
                                mem[_14507 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_14507 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _14507 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_14507]:
                                    revert with 0, 50
                                mem[_14507 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = stor23[address(this.address)] / t / s
                                emit Approval((stor23[address(this.address)] / t / s), this.address, uniswapV2RouterAddress);
                                mem[_14507 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_14507 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / t / s
                                mem[_14507 + ceil32(return_data.size) + 132] = 0
                                mem[_14507 + ceil32(return_data.size) + 164] = 160
                                mem[_14507 + ceil32(return_data.size) + 260] = mem[_14507]
                                idx = 0
                                s = _14507 + ceil32(return_data.size) + 292
                                t = _14507 + 32
                                while idx < mem[_14507]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_14507 + ceil32(return_data.size) + 196] = this.address
                                mem[_14507 + ceil32(return_data.size) + 228] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _14507 + ceil32(return_data.size) + (32 * mem[_14507]) + -mem[64] + 288]
                else:
                    _9282 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9282] = 26
                    mem[_9282 + 32] = 'SafeMath: division by zero'
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    _9546 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9546] = 26
                    mem[_9546 + 32] = 'SafeMath: division by zero'
                    if not t / s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if arg1 <= stor23[address(this.address)] / t / s:
                        _9970 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        mem[_9970 + 32 len 64] = call.data[calldata.size len 64]
                        if 0 >= mem[_9970]:
                            revert with 0, 50
                        mem[_9970 + 32] = this.address
                        staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                gas gas_remaining wei
                        mem[_9970 + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _9970 + ceil32(return_data.size) + 96
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        if 1 >= mem[_9970]:
                            revert with 0, 50
                        mem[_9970 + 64] = ext_call.return_data[12 len 20]
                        if not this.address:
                            revert with 0, 'ERC20: approve from the zero address'
                        if not uniswapV2RouterAddress:
                            revert with 0, 'ERC20: approve to the zero address'
                        mem[0] = uniswapV2RouterAddress
                        mem[32] = sha3(address(this.address), 25)
                        allowance[address(this.address)][stor54] = arg1
                        emit Approval(arg1, this.address, uniswapV2RouterAddress);
                        mem[_9970 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                        mem[_9970 + ceil32(return_data.size) + 100] = arg1
                        mem[_9970 + ceil32(return_data.size) + 132] = 0
                        mem[_9970 + ceil32(return_data.size) + 164] = 160
                        mem[_9970 + ceil32(return_data.size) + 260] = mem[_9970]
                        idx = 0
                        s = _9970 + ceil32(return_data.size) + 292
                        t = _9970 + 32
                        while idx < mem[_9970]:
                            mem[s] = mem[t + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        require ext_code.size(uniswapV2RouterAddress)
                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg1, 0, 160, address(this.address), block.timestamp, mem[_9970 + ceil32(return_data.size) + 260 len (32 * mem[_9970]) + 32]
                    else:
                        mem[0] = this.address
                        if stor29[address(this.address)]:
                            mem[32] = 24
                            _10192 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_10192 + 32 len 64] = call.data[calldata.size len 64]
                            if 0 >= mem[_10192]:
                                revert with 0, 50
                            mem[_10192 + 32] = this.address
                            staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                    gas gas_remaining wei
                            mem[_10192 + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _10192 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            if 1 >= mem[_10192]:
                                revert with 0, 50
                            mem[_10192 + 64] = ext_call.return_data[12 len 20]
                            if not this.address:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not uniswapV2RouterAddress:
                                revert with 0, 'ERC20: approve to the zero address'
                            mem[0] = uniswapV2RouterAddress
                            mem[32] = sha3(address(this.address), 25)
                            allowance[address(this.address)][stor54] = stor24[address(this.address)]
                            emit Approval(stor24[address(this.address)], this.address, uniswapV2RouterAddress);
                            mem[_10192 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                            mem[_10192 + ceil32(return_data.size) + 100] = stor24[address(this.address)]
                            mem[_10192 + ceil32(return_data.size) + 132] = 0
                            mem[_10192 + ceil32(return_data.size) + 164] = 160
                            mem[_10192 + ceil32(return_data.size) + 260] = mem[_10192]
                            idx = 0
                            s = _10192 + ceil32(return_data.size) + 292
                            t = _10192 + 32
                            while idx < mem[_10192]:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_10192 + ceil32(return_data.size) + 196] = this.address
                            mem[_10192 + ceil32(return_data.size) + 228] = block.timestamp
                            require ext_code.size(uniswapV2RouterAddress)
                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _10192 + ceil32(return_data.size) + (32 * mem[_10192]) + -mem[64] + 288]
                        else:
                            mem[32] = 23
                            if stor23[address(this.address)] > stor31:
                                revert with 0, 'Amount must be less than total reflections'
                            idx = 0
                            s = 10^15
                            t = stor31
                            while idx < stor30.length:
                                mem[0] = stor30[idx]
                                mem[32] = 23
                                if stor23[stor30[idx]] > t:
                                    _13542 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13542] = 26
                                    mem[_13542 + 32] = 'SafeMath: division by zero'
                                    _13719 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13719] = 26
                                    mem[_13719 + 32] = 'SafeMath: division by zero'
                                    if not stor31 / 10^15:
                                        _13815 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _13815 + 68] = mem[idx + _13719 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13815 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13815 + -mem[64] + 100
                                    _14232 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_14232 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_14232]:
                                        revert with 0, 50
                                    mem[_14232 + 32] = this.address
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_14232 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _14232 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_14232]:
                                        revert with 0, 50
                                    mem[_14232 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 25)
                                    allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                    emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                    mem[_14232 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_14232 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                    mem[_14232 + ceil32(return_data.size) + 132] = 0
                                    mem[_14232 + ceil32(return_data.size) + 164] = 160
                                    mem[_14232 + ceil32(return_data.size) + 260] = mem[_14232]
                                    idx = 0
                                    s = _14232 + ceil32(return_data.size) + 292
                                    t = _14232 + 32
                                    while idx < mem[_14232]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args stor23[address(this.address)] / stor31 / 10^15, 0, 160, address(this.address), block.timestamp, mem[_14232 + ceil32(return_data.size) + 260 len (32 * mem[_14232]) + 32]
                                else:
                                    if idx >= stor30.length:
                                        revert with 0, 50
                                    mem[0] = stor30[idx]
                                    mem[32] = 24
                                    if stor24[stor30[idx]] <= s:
                                        if idx >= stor30.length:
                                            revert with 0, 50
                                        mem[0] = stor30[idx]
                                        mem[32] = 23
                                        _13590 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13590] = 30
                                        mem[_13590 + 32] = 'SafeMath: subtraction overflow'
                                        if stor23[stor30[idx]] > t:
                                            _13622 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13622 + 68] = mem[idx + _13590 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13622 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13622 + -mem[64] + 100
                                        if t < stor23[stor30[idx]]:
                                            revert with 0, 17
                                        if idx >= stor30.length:
                                            revert with 0, 50
                                        mem[0] = stor30[idx]
                                        mem[32] = 24
                                        _13816 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13816] = 30
                                        mem[_13816 + 32] = 'SafeMath: subtraction overflow'
                                        if stor24[stor30[idx]] <= s:
                                            if s < stor24[stor30[idx]]:
                                                revert with 0, 17
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s - stor24[stor30[idx]]
                                            t = t - stor23[stor30[idx]]
                                            continue 
                                        _13895 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13895 + 68] = mem[idx + _13816 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13895 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13895 + -mem[64] + 100
                                    _13591 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13591] = 26
                                    mem[_13591 + 32] = 'SafeMath: division by zero'
                                    _13817 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13817] = 26
                                    mem[_13817 + 32] = 'SafeMath: division by zero'
                                    if not stor31 / 10^15:
                                        _13896 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _13896 + 68] = mem[idx + _13817 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13896 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13896 + -mem[64] + 100
                                    _14329 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_14329 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_14329]:
                                        revert with 0, 50
                                    mem[_14329 + 32] = this.address
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_14329 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _14329 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_14329]:
                                        revert with 0, 50
                                    mem[_14329 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 25)
                                    allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                    emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                    mem[_14329 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_14329 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                    mem[_14329 + ceil32(return_data.size) + 132] = 0
                                    mem[_14329 + ceil32(return_data.size) + 164] = 160
                                    mem[_14329 + ceil32(return_data.size) + 260] = mem[_14329]
                                    idx = 0
                                    s = _14329 + ceil32(return_data.size) + 292
                                    t = _14329 + 32
                                    while idx < mem[_14329]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args stor23[address(this.address)] / stor31 / 10^15, 0, 160, address(this.address), block.timestamp, mem[_14329 + ceil32(return_data.size) + 260 len (32 * mem[_14329]) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            _13231 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13231] = 26
                            mem[_13231 + 32] = 'SafeMath: division by zero'
                            if t < stor31 / 10^15:
                                _13655 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13655] = 26
                                mem[_13655 + 32] = 'SafeMath: division by zero'
                                _14007 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14007] = 26
                                mem[_14007 + 32] = 'SafeMath: division by zero'
                                if not stor31 / 10^15:
                                    revert with 0, 'SafeMath: division by zero', 0
                                _14504 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_14504 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_14504]:
                                    revert with 0, 50
                                mem[_14504 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_14504 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _14504 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_14504]:
                                    revert with 0, 50
                                mem[_14504 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = stor23[address(this.address)] / stor31 / 10^15
                                emit Approval((stor23[address(this.address)] / stor31 / 10^15), this.address, uniswapV2RouterAddress);
                                mem[_14504 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_14504 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / stor31 / 10^15
                                mem[_14504 + ceil32(return_data.size) + 132] = 0
                                mem[_14504 + ceil32(return_data.size) + 164] = 160
                                mem[_14504 + ceil32(return_data.size) + 260] = mem[_14504]
                                idx = 0
                                s = _14504 + ceil32(return_data.size) + 292
                                t = _14504 + 32
                                while idx < mem[_14504]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args stor23[address(this.address)] / stor31 / 10^15, 0, 160, address(this.address), block.timestamp, mem[_14504 + ceil32(return_data.size) + 260 len (32 * mem[_14504]) + 32]
                            else:
                                _13654 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13654] = 26
                                mem[_13654 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                _14006 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14006] = 26
                                mem[_14006 + 32] = 'SafeMath: division by zero'
                                if not t / s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                _14502 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                mem[_14502 + 32 len 64] = call.data[calldata.size len 64]
                                if 0 >= mem[_14502]:
                                    revert with 0, 50
                                mem[_14502 + 32] = this.address
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[_14502 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _14502 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_14502]:
                                    revert with 0, 50
                                mem[_14502 + 64] = ext_call.return_data[12 len 20]
                                if not this.address:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not uniswapV2RouterAddress:
                                    revert with 0, 'ERC20: approve to the zero address'
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 25)
                                allowance[address(this.address)][stor54] = stor23[address(this.address)] / t / s
                                emit Approval((stor23[address(this.address)] / t / s), this.address, uniswapV2RouterAddress);
                                mem[_14502 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[_14502 + ceil32(return_data.size) + 100] = stor23[address(this.address)] / t / s
                                mem[_14502 + ceil32(return_data.size) + 132] = 0
                                mem[_14502 + ceil32(return_data.size) + 164] = 160
                                mem[_14502 + ceil32(return_data.size) + 260] = mem[_14502]
                                idx = 0
                                s = _14502 + ceil32(return_data.size) + 292
                                t = _14502 + 32
                                while idx < mem[_14502]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_14502 + ceil32(return_data.size) + 196] = this.address
                                mem[_14502 + ceil32(return_data.size) + 228] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _14502 + ceil32(return_data.size) + (32 * mem[_14502]) + -mem[64] + 288]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}



}

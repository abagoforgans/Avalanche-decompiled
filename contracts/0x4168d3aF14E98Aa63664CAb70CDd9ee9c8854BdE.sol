contract main {




// =====================  Runtime code  =====================


#
#  - updateEmissionRate(uint256 arg1)
#  - withdraw(uint256 arg1, uint256 arg2)
#  - deposit(uint256 arg1, uint256 arg2, address arg3)
#
const maximumDepositFeeBp = 500

const maxSpherePerBlock = 2 * 10^17

const MAXIMUM_REFERRAL_COMMISSION_RATE = 200


address owner;
uint256 stor1;
address sphereTokenAddress;
address devAddress;
address feeAddress;
uint256 spherePerBlock;
uint256 amountToBurn;
uint256 totalBurned;
address mostBurnedAddress;
uint256 stor8;
mapping of uint256 burnInfo;
array of struct poolInfo;
mapping of struct userInfo;
uint256 totalAllocPoint;
uint256 startBlock;
mapping of uint8 stor14;
uint256 maxEmissionRate;
uint8 stor16;
address usdcAddress; offset 8
address usdcSphereLPAddress;
uint256 topPrice;
uint256 bottomPrice;
uint256 curveRate;
uint256 lastBlockUpdate;
uint256 emissionUpdateInterval;
uint16 referralCommissionRate; offset 160
address referralAddress;
uint256 totalLockedUpRewards;
address stor25;
uint16 stor26;
uint16 lockerRate; offset 160
address sphereLockerAddress;
array of uint256 stor89717814153306320011181716697424560163256864414616650038987186496166826726057;
array of uint256 stor89717814153306320011181716697424560163256864414616650038987186496166826726058;
array of uint256 stor89717814153306320011181716697424560163256864414616650038987186496166826726059;
array of uint16 stor89717814153306320011181716697424560163256864414616650038987186496166826726060;

function poolLength() payable {
    return poolInfo.length
}

function lastBlockUpdate() payable {
    return lastBlockUpdate
}

function maxEmissionRate() payable {
    return maxEmissionRate
}

function poolInfo(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 < poolInfo.length
    return poolInfo[arg1].field_0, 
           poolInfo[arg1].field_256,
           poolInfo[arg1].field_512,
           poolInfo[arg1].field_768,
           poolInfo[arg1].field_1024
}

function totalAllocPoint() payable {
    return totalAllocPoint
}

function Referral() payable {
    return referralAddress
}

function SphereToken() payable {
    return sphereTokenAddress
}

function devAddress() payable {
    return devAddress
}

function usdc() payable {
    return usdcAddress
}

function feeAddress() payable {
    return feeAddress
}

function mostBurnedAddress() payable {
    return address(mostBurnedAddress)
}

function SpherePerBlock() payable {
    return spherePerBlock
}

function totalLockedUpRewards() payable {
    return totalLockedUpRewards
}

function startBlock() payable {
    return startBlock
}

function dynamicEmissionOn() payable {
    return bool(stor16)
}

function lockerRate() payable {
    return lockerRate
}

function emissionUpdateInterval() payable {
    return emissionUpdateInterval
}

function usdcSphereLP() payable {
    return usdcSphereLPAddress
}

function curveRate() payable {
    return curveRate
}

function owner() payable {
    return owner
}

function burnInfo(address arg1) payable {
    require calldata.size - 4 >= 32
    return burnInfo[arg1]
}

function userInfo(uint256 arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    return userInfo[arg1][arg2].field_0, userInfo[arg1][arg2].field_256
}

function sphereLockerAddress() payable {
    return sphereLockerAddress
}

function bottomPrice() payable {
    return bottomPrice
}

function mostBurnedByUser() payable {
    return burnInfo[address(stor8)]
}

function poolExistence(address arg1) payable {
    require calldata.size - 4 >= 32
    return bool(stor14[arg1])
}

function amountToBurn() payable {
    return amountToBurn
}

function topPrice() payable {
    return topPrice
}

function referralCommissionRate() payable {
    return referralCommissionRate
}

function totalBurned() payable {
    return totalBurned
}

function _fallback() payable {
    revert
}

function renounceOwnership() payable {
    if owner != msg.sender:
        revert with 0, 'sOwnable: caller is not the owne'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function setEmissionBool(bool arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'sOwnable: caller is not the owne'
    stor16 = uint8(arg1)
}

function setReferral(address arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'sOwnable: caller is not the owne'
    referralAddress = arg1
}

function setusdcSphereLPAddress(address arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'sOwnable: caller is not the owne'
    usdcSphereLPAddress = arg1
}

function setUSDCAddress(address arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'sOwnable: caller is not the owne'
    require arg1
    usdcAddress = arg1
}

function setSphereLocker(address arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'sOwnable: caller is not the owne'
    stor25 = arg1
    sphereLockerAddress = arg1
    emit 0x7930859a: arg1, msg.sender
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'sOwnable: caller is not the owne'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    38,
                    0x734f776e61626c653a206e6577206f776e657220697320746865207a65726f20616464726573,
                    mem[202 len 26]
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function setLockerRate(uint16 arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'sOwnable: caller is not the owne'
    if arg1 > 2500:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    47,
                    0x777365744c6f636b6572526174653a20696e76616c6964206c6f636b6572207261746520626173697320706f696e74,
                    mem[211 len 17]
    emit LockerRateUpdated(stor26, arg1, msg.sender);
    lockerRate = arg1
}

function setReferralCommissionRate(uint16 arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'sOwnable: caller is not the owne'
    if arg1 > 200:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    72,
                    0x73736574526566657272616c436f6d6d697373696f6e526174653a20696e76616c696420726566657272616c20636f6d6d697373696f6e207261746520626173697320706f696e74,
                    mem[236 len 24]
    referralCommissionRate = arg1
}

function setFeeAddress(address arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'sOwnable: caller is not the owne'
    if devAddress != msg.sender:
        revert with 0, 'setDevAddress: already dev'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    34,
                    0x2e43616e27742073657420666565206164647265737320746f203020616464726573,
                    mem[198 len 30]
    feeAddress = arg1
    emit SetFeeAddress(msg.sender, arg1);
}

function setDevAddress(address arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'sOwnable: caller is not the owne'
    if devAddress != msg.sender:
        revert with 0, 'setDevAddress: already dev'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    34,
                    0x6443616e27742073657420646576206164647265737320746f203020616464726573,
                    mem[198 len 30]
    devAddress = arg1
    emit SetDevAddress(msg.sender, arg1);
}

function updateEmissionParameters(uint256 arg1, uint256 arg2, uint256 arg3, uint256 arg4) payable {
    require calldata.size - 4 >= 128
    if owner != msg.sender:
        revert with 0, 'sOwnable: caller is not the owne'
    if not arg2:
        require not arg1
    else:
        if 10 * arg2 / arg2 != 10:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        require arg1 == 10 * arg2
    require arg3 < 900
    topPrice = arg1
    bottomPrice = arg2
    emissionUpdateInterval = arg3
    curveRate = arg4
}

function getMultiplier(uint256 arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require ext_code.size(sphereTokenAddress)
    staticcall sphereTokenAddress.0xd5abeb01 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(sphereTokenAddress)
    staticcall sphereTokenAddress.0x18160ddd with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] >= ext_call.return_data[0]:
        return 0
    if arg1 > arg2:
        revert with 0, 'SafeMath: subtraction overflow'
    return (arg2 - arg1)
}

function set(uint256 arg1, uint256 arg2, uint16 arg3) payable {
    require calldata.size - 4 >= 96
    if owner != msg.sender:
        revert with 0, 'sOwnable: caller is not the owne'
    if arg3 > 500:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    37,
                    0x737365743a20696e76616c6964206465706f7369742066656520626173697320706f696e74,
                    mem[201 len 27]
    require arg1 < poolInfo.length
    if poolInfo[arg1].field_256 > totalAllocPoint:
        revert with 0, 'SafeMath: subtraction overflow'
    if arg2 < 0:
        revert with 0, 'SafeMath: addition overflow'
    totalAllocPoint = arg2 + totalAllocPoint - poolInfo[arg1].field_256
    require arg1 < poolInfo.length
    poolInfo[arg1].field_256 = arg2
    poolInfo[arg1].field_1024 = arg3
}

function add(uint256 arg1, address arg2, uint16 arg3) payable {
    require calldata.size - 4 >= 96
    if owner != msg.sender:
        revert with 0, 'sOwnable: caller is not the owne'
    if stor14[address(arg2)]:
        revert with 0, 'nonDuplicated: duplicated'
    if arg3 > 500:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    37,
                    0x6164643a20696e76616c6964206465706f7369742066656520626173697320706f696e7400,
                    mem[201 len 27]
    if arg1 + totalAllocPoint < totalAllocPoint:
        revert with 0, 'SafeMath: addition overflow'
    totalAllocPoint += arg1
    stor14[address(arg2)] = 1
    poolInfo.length++
    poolInfo[poolInfo.length].field_0 = arg2
    storC65A[stor10.length] = arg1
    if block.number > startBlock:
        storC65A[stor10.length] = block.number
    else:
        storC65A[stor10.length] = startBlock
    storC65A[stor10.length] = 0
    storC65A[stor10.length] = arg3
}

function getSpherePriceCents() payable {
    require ext_code.size(sphereTokenAddress)
    staticcall sphereTokenAddress.0x70a08231 with:
            gas gas_remaining wei
           args usdcSphereLPAddress
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if not ext_call.return_data[0]:
        return 0
    require ext_code.size(usdcAddress)
    staticcall usdcAddress.0x70a08231 with:
            gas gas_remaining wei
           args usdcSphereLPAddress
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if not ext_call.return_data[0]:
        if not ext_call.return_data[0]:
            revert with 0, 'SafeMath: division by zero'
        return (0 / ext_call.return_data[0])
    if 10^14 * ext_call.return_data[0] / ext_call.return_data[0] != 10^14:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    33,
                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                    mem[197 len 31]
    if not ext_call.return_data[0]:
        revert with 0, 'SafeMath: division by zero'
    return (10^14 * ext_call.return_data[0] / ext_call.return_data[0])
}

function emergencyWithdraw(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if stor1 == 2:
        revert with 0, 'tReentrancyGuard: reentrant call'
    stor1 = 2
    require arg1 < poolInfo.length
    userInfo[arg1][msg.sender].field_0 = 0
    userInfo[arg1][msg.sender].field_256 = 0
    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
        revert with 0, 'Address: call to non-contract'
    if not ext_code.hash(poolInfo[arg1].field_0):
        revert with 0, 'Address: call to non-contract'
    mem[260 len 64] = unknown_0xa9059cbb(?????), msg.sender, userInfo[arg1][msg.sender].field_32
    call poolInfo[arg1].field_0 with:
       funct uint32(msg.sender)
         gas gas_remaining wei
        args userInfo[arg1][msg.sender].field_0, mem[324 len 4]
    if not return_data.size:
        if not ext_call.success:
            revert with unknown_0xa9059cbb(?????), msg.sender, userInfo[arg1][msg.sender].field_0
        if not unknown_0xa9059cbb(?????), Mask(224, 32, msg.sender) >> 32:
            revert with 0, 32, 42, 0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565, mem[370 len 22]
    else:
        mem[292 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            revert with 0, 'SafeERC20: low-level call failed'
        if return_data.size:
            require return_data.size >= 32
            if not mem[292]:
                revert with 0, 
                            32,
                            42,
                            0x645361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                            mem[ceil32(return_data.size) + 371 len 22]
    emit EmergencyWithdraw(userInfo[arg1][msg.sender].field_0, msg.sender, arg1);
    stor1 = 1
}

function getEmissionRatePercent(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if arg1 >= 100 * topPrice:
        return 1
    if arg1 <= 100 * bottomPrice:
        return 100
    if not arg1:
        if not 100 * topPrice:
            revert with 0, 'SafeMath: division by zero'
        require ext_code.size(0xd75dcd756844276df0330ff8f5a02c06c26a44e7)
        delegate 0xd75dcd756844276df0330ff8f5a02c06c26a44e7.reciprocal(int256 rg1) with:
             gas gas_remaining wei
            args curveRate
        if not delegate.return_code:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if 0 / 100 * topPrice > 100:
            revert with 0, 'SafeMath: subtraction overflow'
        require ext_code.size(0xd75dcd756844276df0330ff8f5a02c06c26a44e7)
        delegate 0xd75dcd756844276df0330ff8f5a02c06c26a44e7.multiply(int256 rg1, int256 rg2) with:
             gas gas_remaining wei
            args delegate.return_data[0], -(0 / 100 * topPrice) + 100
        if not delegate.return_code:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(0xd75dcd756844276df0330ff8f5a02c06c26a44e7)
        delegate 0xd75dcd756844276df0330ff8f5a02c06c26a44e7.fromFixed(int256 rg1) with:
             gas gas_remaining wei
            args delegate.return_data[0]
        if not delegate.return_code:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(0xd75dcd756844276df0330ff8f5a02c06c26a44e7)
        delegate 0xd75dcd756844276df0330ff8f5a02c06c26a44e7.divide(int256 rg1, int256 rg2) with:
             gas gas_remaining wei
            args 100, 0 / 100 * topPrice
    else:
        if 100 * arg1 / arg1 != 100:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if not 100 * topPrice:
            revert with 0, 'SafeMath: division by zero'
        require ext_code.size(0xd75dcd756844276df0330ff8f5a02c06c26a44e7)
        delegate 0xd75dcd756844276df0330ff8f5a02c06c26a44e7.reciprocal(int256 rg1) with:
             gas gas_remaining wei
            args curveRate
        if not delegate.return_code:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if 100 * arg1 / 100 * topPrice > 100:
            revert with 0, 'SafeMath: subtraction overflow'
        require ext_code.size(0xd75dcd756844276df0330ff8f5a02c06c26a44e7)
        delegate 0xd75dcd756844276df0330ff8f5a02c06c26a44e7.multiply(int256 rg1, int256 rg2) with:
             gas gas_remaining wei
            args delegate.return_data[0], -(100 * arg1 / 100 * topPrice) + 100
        if not delegate.return_code:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(0xd75dcd756844276df0330ff8f5a02c06c26a44e7)
        delegate 0xd75dcd756844276df0330ff8f5a02c06c26a44e7.fromFixed(int256 rg1) with:
             gas gas_remaining wei
            args delegate.return_data[0]
        if not delegate.return_code:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(0xd75dcd756844276df0330ff8f5a02c06c26a44e7)
        delegate 0xd75dcd756844276df0330ff8f5a02c06c26a44e7.divide(int256 rg1, int256 rg2) with:
             gas gas_remaining wei
            args 100, 100 * arg1 / 100 * topPrice
    if not delegate.return_code:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(0xd75dcd756844276df0330ff8f5a02c06c26a44e7)
    delegate 0xd75dcd756844276df0330ff8f5a02c06c26a44e7.fromFixed(int256 rg1) with:
         gas gas_remaining wei
        args delegate.return_data[0]
    if not delegate.return_code:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return (2 * delegate.return_data[0])
}

function pendingSphere(uint256 arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 < poolInfo.length
    require ext_code.size(poolInfo[arg1].field_0)
    staticcall poolInfo[arg1].field_0.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if block.number <= poolInfo[arg1].field_512:
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256
        if poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if userInfo[arg1][address(arg2)].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / 10^18:
            revert with 0, 'SafeMath: subtraction overflow'
        return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / 10^18) - userInfo[arg1][address(arg2)].field_256)
    if not ext_call.return_data[0]:
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256
        if poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if userInfo[arg1][address(arg2)].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / 10^18:
            revert with 0, 'SafeMath: subtraction overflow'
        return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / 10^18) - userInfo[arg1][address(arg2)].field_256)
    require ext_code.size(sphereTokenAddress)
    staticcall sphereTokenAddress.0xd5abeb01 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(sphereTokenAddress)
    staticcall sphereTokenAddress.0x18160ddd with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] >= ext_call.return_data[0]:
        if not totalAllocPoint:
            revert with 0, 'SafeMath: division by zero'
        if not 0 / totalAllocPoint:
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^18:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^18) - userInfo[arg1][address(arg2)].field_256)
        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
        if not ext_call.return_data[0]:
            revert with 0, 'SafeMath: division by zero'
        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256
        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
        if userInfo[arg1][address(arg2)].field_256 > (10^18 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^18:
            revert with 0, 'SafeMath: subtraction overflow'
        return (((10^18 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^18) - userInfo[arg1][address(arg2)].field_256)
    if poolInfo[arg1].field_512 > block.number:
        revert with 0, 'SafeMath: subtraction overflow'
    if not block.number - poolInfo[arg1].field_512:
        if not totalAllocPoint:
            revert with 0, 'SafeMath: division by zero'
        if not 0 / totalAllocPoint:
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^18:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^18) - userInfo[arg1][address(arg2)].field_256)
        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
        if not ext_call.return_data[0]:
            revert with 0, 'SafeMath: division by zero'
        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256
        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if userInfo[arg1][address(arg2)].field_256 > (10^18 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^18:
            revert with 0, 'SafeMath: subtraction overflow'
        return (((10^18 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^18) - userInfo[arg1][address(arg2)].field_256)
    if (block.number * spherePerBlock) - (poolInfo[arg1].field_512 * spherePerBlock) / block.number - poolInfo[arg1].field_512 != spherePerBlock:
        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
    if not (block.number * spherePerBlock) - (poolInfo[arg1].field_512 * spherePerBlock):
        if not totalAllocPoint:
            revert with 0, 'SafeMath: division by zero'
        if not 0 / totalAllocPoint:
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^18:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^18) - userInfo[arg1][address(arg2)].field_256)
        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
        if not ext_call.return_data[0]:
            revert with 0, 'SafeMath: division by zero'
        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256
        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if userInfo[arg1][address(arg2)].field_256 > (10^18 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^18:
            revert with 0, 'SafeMath: subtraction overflow'
        return (((10^18 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^18) - userInfo[arg1][address(arg2)].field_256)
    if (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / (block.number * spherePerBlock) - (poolInfo[arg1].field_512 * spherePerBlock) != poolInfo[arg1].field_256:
        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
    if not totalAllocPoint:
        revert with 0, 'SafeMath: division by zero'
    if not (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
        if not ext_call.return_data[0]:
            revert with 0, 'SafeMath: division by zero'
        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256
        if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^18:
            revert with 0, 'SafeMath: subtraction overflow'
        return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^18) - userInfo[arg1][address(arg2)].field_256)
    if 10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^18:
        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
    if not ext_call.return_data[0]:
        revert with 0, 'SafeMath: division by zero'
    if (10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
        revert with 0, 'SafeMath: addition overflow'
    if not userInfo[arg1][address(arg2)].field_0:
        if userInfo[arg1][address(arg2)].field_256 > 0:
            revert with 0, 'SafeMath: subtraction overflow'
        return -userInfo[arg1][address(arg2)].field_256
    if (10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
    if userInfo[arg1][address(arg2)].field_256 > (10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^18:
        revert with 0, 'SafeMath: subtraction overflow'
    return (((10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^18) - userInfo[arg1][address(arg2)].field_256)
}

function updatePool(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 < poolInfo.length
    if block.number > poolInfo[arg1].field_512:
        require ext_code.size(poolInfo[arg1].field_0)
        staticcall poolInfo[arg1].field_0.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0]:
            if poolInfo[arg1].field_256:
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] >= ext_call.return_data[0]:
                    if not totalAllocPoint:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0xd5abeb01 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                        revert with 0, 'SafeMath: addition overflow'
                    require ext_code.size(sphereTokenAddress)
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] <= ext_call.return_data[0]:
                        call sphereTokenAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devAddress, 0 / totalAllocPoint / 20
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(sphereTokenAddress)
                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(sphereTokenAddress)
                        staticcall sphereTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                            revert with 0, 'SafeMath: addition overflow'
                        require ext_code.size(sphereTokenAddress)
                        if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                            call sphereTokenAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args address(this.address), 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                revert with 0, 'SafeMath: addition overflow'
                            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                if not 0 / totalAllocPoint:
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                else:
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                            else:
                                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                    revert with 0, 'SafeMath: addition overflow'
                                amountToBurn += 0 / totalAllocPoint / 20
                                if not 0 / totalAllocPoint:
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                else:
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        else:
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            if ext_call.return_data[0] >= ext_call.return_data[0]:
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                    if not 0 / totalAllocPoint:
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                else:
                                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                        revert with 0, 'SafeMath: addition overflow'
                                    amountToBurn += 0 / totalAllocPoint / 20
                                    if not 0 / totalAllocPoint:
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                            else:
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require ext_code.size(sphereTokenAddress)
                                call sphereTokenAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                    if not 0 / totalAllocPoint:
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                else:
                                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                        revert with 0, 'SafeMath: addition overflow'
                                    amountToBurn += 0 / totalAllocPoint / 20
                                    if not 0 / totalAllocPoint:
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                    else:
                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(sphereTokenAddress)
                        staticcall sphereTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(sphereTokenAddress)
                        if ext_call.return_data[0] >= ext_call.return_data[0]:
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                                revert with 0, 'SafeMath: addition overflow'
                            require ext_code.size(sphereTokenAddress)
                            if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                call sphereTokenAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0 / totalAllocPoint
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                    if not 0 / totalAllocPoint:
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                else:
                                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                        revert with 0, 'SafeMath: addition overflow'
                                    amountToBurn += 0 / totalAllocPoint / 20
                                    if not 0 / totalAllocPoint:
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                            else:
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                if ext_call.return_data[0] >= ext_call.return_data[0]:
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not 0 / totalAllocPoint:
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                            revert with 0, 'SafeMath: addition overflow'
                                        amountToBurn += 0 / totalAllocPoint / 20
                                        if not 0 / totalAllocPoint:
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                else:
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(sphereTokenAddress)
                                    call sphereTokenAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not 0 / totalAllocPoint:
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                            revert with 0, 'SafeMath: addition overflow'
                                        amountToBurn += 0 / totalAllocPoint / 20
                                        if not 0 / totalAllocPoint:
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        else:
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0] > ext_call.return_data[0]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            require ext_code.size(sphereTokenAddress)
                            call sphereTokenAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devAddress, 0
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                                revert with 0, 'SafeMath: addition overflow'
                            require ext_code.size(sphereTokenAddress)
                            if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                call sphereTokenAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0 / totalAllocPoint
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                    if not 0 / totalAllocPoint:
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                else:
                                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                        revert with 0, 'SafeMath: addition overflow'
                                    amountToBurn += 0 / totalAllocPoint / 20
                                    if not 0 / totalAllocPoint:
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                            else:
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                if ext_call.return_data[0] >= ext_call.return_data[0]:
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not 0 / totalAllocPoint:
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                            revert with 0, 'SafeMath: addition overflow'
                                        amountToBurn += 0 / totalAllocPoint / 20
                                        if not 0 / totalAllocPoint:
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                else:
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(sphereTokenAddress)
                                    call sphereTokenAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not 0 / totalAllocPoint:
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                            revert with 0, 'SafeMath: addition overflow'
                                        amountToBurn += 0 / totalAllocPoint / 20
                                        if not 0 / totalAllocPoint:
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[581 len 31]
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                else:
                    if poolInfo[arg1].field_512 > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.number - poolInfo[arg1].field_512:
                        if not totalAllocPoint:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_code.size(sphereTokenAddress)
                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(sphereTokenAddress)
                        staticcall sphereTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                            revert with 0, 'SafeMath: addition overflow'
                        require ext_code.size(sphereTokenAddress)
                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] <= ext_call.return_data[0]:
                            call sphereTokenAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devAddress, 0 / totalAllocPoint / 20
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                                revert with 0, 'SafeMath: addition overflow'
                            require ext_code.size(sphereTokenAddress)
                            if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                call sphereTokenAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0 / totalAllocPoint
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                    if not 0 / totalAllocPoint:
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                else:
                                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                        revert with 0, 'SafeMath: addition overflow'
                                    amountToBurn += 0 / totalAllocPoint / 20
                                    if not 0 / totalAllocPoint:
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: division by zero'
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                            else:
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                if ext_call.return_data[0] >= ext_call.return_data[0]:
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not 0 / totalAllocPoint:
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                            revert with 0, 'SafeMath: addition overflow'
                                        amountToBurn += 0 / totalAllocPoint / 20
                                        if not 0 / totalAllocPoint:
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                else:
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(sphereTokenAddress)
                                    call sphereTokenAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not 0 / totalAllocPoint:
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                            revert with 0, 'SafeMath: addition overflow'
                                        amountToBurn += 0 / totalAllocPoint / 20
                                        if not 0 / totalAllocPoint:
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[581 len 31]
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        else:
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            if ext_call.return_data[0] >= ext_call.return_data[0]:
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require ext_code.size(sphereTokenAddress)
                                if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                    call sphereTokenAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not 0 / totalAllocPoint:
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                            revert with 0, 'SafeMath: addition overflow'
                                        amountToBurn += 0 / totalAllocPoint / 20
                                        if not 0 / totalAllocPoint:
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                else:
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    if ext_call.return_data[0] >= ext_call.return_data[0]:
                                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                            if not 0 / totalAllocPoint:
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        else:
                                            if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                                revert with 0, 'SafeMath: addition overflow'
                                            amountToBurn += 0 / totalAllocPoint / 20
                                            if not 0 / totalAllocPoint:
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        staticcall sphereTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require ext_code.size(sphereTokenAddress)
                                        call sphereTokenAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                            if not 0 / totalAllocPoint:
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        else:
                                            if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                                revert with 0, 'SafeMath: addition overflow'
                                            amountToBurn += 0 / totalAllocPoint / 20
                                            if not 0 / totalAllocPoint:
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[581 len 31]
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                            else:
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require ext_code.size(sphereTokenAddress)
                                call sphereTokenAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args devAddress, 0
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require ext_code.size(sphereTokenAddress)
                                if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                    call sphereTokenAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not 0 / totalAllocPoint:
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                            revert with 0, 'SafeMath: addition overflow'
                                        amountToBurn += 0 / totalAllocPoint / 20
                                        if not 0 / totalAllocPoint:
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[581 len 31]
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                else:
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    if ext_call.return_data[0] >= ext_call.return_data[0]:
                                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                            if not 0 / totalAllocPoint:
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        else:
                                            if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                                revert with 0, 'SafeMath: addition overflow'
                                            amountToBurn += 0 / totalAllocPoint / 20
                                            if not 0 / totalAllocPoint:
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[581 len 31]
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        staticcall sphereTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require ext_code.size(sphereTokenAddress)
                                        call sphereTokenAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                            if not 0 / totalAllocPoint:
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[581 len 31]
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        else:
                                            if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                                revert with 0, 'SafeMath: addition overflow'
                                            amountToBurn += 0 / totalAllocPoint / 20
                                            if not 0 / totalAllocPoint:
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[645 len 31]
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                    else:
                        if (block.number * spherePerBlock) - (poolInfo[arg1].field_512 * spherePerBlock) / block.number - poolInfo[arg1].field_512 != spherePerBlock:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                        if not (block.number * spherePerBlock) - (poolInfo[arg1].field_512 * spherePerBlock):
                            if not totalAllocPoint:
                                revert with 0, 'SafeMath: division by zero'
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                revert with 0, 'SafeMath: addition overflow'
                            require ext_code.size(sphereTokenAddress)
                            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                call sphereTokenAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args devAddress, 0 / totalAllocPoint / 20
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require ext_code.size(sphereTokenAddress)
                                if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                    call sphereTokenAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not 0 / totalAllocPoint:
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                            revert with 0, 'SafeMath: addition overflow'
                                        amountToBurn += 0 / totalAllocPoint / 20
                                        if not 0 / totalAllocPoint:
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                else:
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    if ext_call.return_data[0] >= ext_call.return_data[0]:
                                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                            if not 0 / totalAllocPoint:
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        else:
                                            if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                                revert with 0, 'SafeMath: addition overflow'
                                            amountToBurn += 0 / totalAllocPoint / 20
                                            if not 0 / totalAllocPoint:
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        staticcall sphereTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require ext_code.size(sphereTokenAddress)
                                        call sphereTokenAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                            if not 0 / totalAllocPoint:
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        else:
                                            if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                                revert with 0, 'SafeMath: addition overflow'
                                            amountToBurn += 0 / totalAllocPoint / 20
                                            if not 0 / totalAllocPoint:
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[581 len 31]
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                            else:
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                if ext_call.return_data[0] >= ext_call.return_data[0]:
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require ext_code.size(sphereTokenAddress)
                                    if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                        call sphereTokenAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                            if not 0 / totalAllocPoint:
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        else:
                                            if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                                revert with 0, 'SafeMath: addition overflow'
                                            amountToBurn += 0 / totalAllocPoint / 20
                                            if not 0 / totalAllocPoint:
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(sphereTokenAddress)
                                        if ext_call.return_data[0] >= ext_call.return_data[0]:
                                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(sphereTokenAddress)
                                            staticcall sphereTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                                if not 0 / totalAllocPoint:
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            else:
                                                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                amountToBurn += 0 / totalAllocPoint / 20
                                                if not 0 / totalAllocPoint:
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        else:
                                            staticcall sphereTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(sphereTokenAddress)
                                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] > ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require ext_code.size(sphereTokenAddress)
                                            call sphereTokenAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args address(this.address), 0
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(sphereTokenAddress)
                                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(sphereTokenAddress)
                                            staticcall sphereTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                                if not 0 / totalAllocPoint:
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            else:
                                                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                amountToBurn += 0 / totalAllocPoint / 20
                                                if not 0 / totalAllocPoint:
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[581 len 31]
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                else:
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(sphereTokenAddress)
                                    call sphereTokenAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devAddress, 0
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require ext_code.size(sphereTokenAddress)
                                    if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                        call sphereTokenAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                            if not 0 / totalAllocPoint:
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        else:
                                            if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                                revert with 0, 'SafeMath: addition overflow'
                                            amountToBurn += 0 / totalAllocPoint / 20
                                            if not 0 / totalAllocPoint:
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[581 len 31]
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(sphereTokenAddress)
                                        if ext_call.return_data[0] >= ext_call.return_data[0]:
                                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(sphereTokenAddress)
                                            staticcall sphereTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                                if not 0 / totalAllocPoint:
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            else:
                                                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                amountToBurn += 0 / totalAllocPoint / 20
                                                if not 0 / totalAllocPoint:
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[581 len 31]
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        else:
                                            staticcall sphereTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(sphereTokenAddress)
                                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] > ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require ext_code.size(sphereTokenAddress)
                                            call sphereTokenAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args address(this.address), 0
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(sphereTokenAddress)
                                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(sphereTokenAddress)
                                            staticcall sphereTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                                if not 0 / totalAllocPoint:
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[581 len 31]
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            else:
                                                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                amountToBurn += 0 / totalAllocPoint / 20
                                                if not 0 / totalAllocPoint:
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[645 len 31]
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        else:
                            if (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / (block.number * spherePerBlock) - (poolInfo[arg1].field_512 * spherePerBlock) != poolInfo[arg1].field_256:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                            if not totalAllocPoint:
                                revert with 0, 'SafeMath: division by zero'
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ((block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                revert with 0, 'SafeMath: addition overflow'
                            require ext_code.size(sphereTokenAddress)
                            if ((block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                call sphereTokenAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args devAddress, (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 20
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ((block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require ext_code.size(sphereTokenAddress)
                                if ((block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                    call sphereTokenAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ((block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if ((block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            if 10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        if ((block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                            revert with 0, 'SafeMath: addition overflow'
                                        amountToBurn += (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 20
                                        if not (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            if 10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                            if not ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                                else:
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    if ext_call.return_data[0] >= ext_call.return_data[0]:
                                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ((block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if ((block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                            if not (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                                        else:
                                            if ((block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                                revert with 0, 'SafeMath: addition overflow'
                                            amountToBurn += (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 20
                                            if not (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        staticcall sphereTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] > ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require ext_code.size(sphereTokenAddress)
                                        call sphereTokenAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ((block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if ((block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                            if not (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                                        else:
                                            if ((block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                                revert with 0, 'SafeMath: addition overflow'
                                            amountToBurn += (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 20
                                            if not (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[581 len 31]
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                            else:
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                if ext_call.return_data[0] >= ext_call.return_data[0]:
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ((block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require ext_code.size(sphereTokenAddress)
                                    if ((block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                        call sphereTokenAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ((block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if ((block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                            if not (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                                        else:
                                            if ((block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                                revert with 0, 'SafeMath: addition overflow'
                                            amountToBurn += (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 20
                                            if not (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(sphereTokenAddress)
                                        if ext_call.return_data[0] >= ext_call.return_data[0]:
                                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(sphereTokenAddress)
                                            staticcall sphereTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ((block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if ((block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                                if not (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^18:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                                            else:
                                                if ((block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                amountToBurn += (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 20
                                                if not (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^18:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                                        else:
                                            staticcall sphereTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(sphereTokenAddress)
                                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] > ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require ext_code.size(sphereTokenAddress)
                                            call sphereTokenAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args address(this.address), 0
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(sphereTokenAddress)
                                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(sphereTokenAddress)
                                            staticcall sphereTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ((block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if ((block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                                if not (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^18:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                                            else:
                                                if ((block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                amountToBurn += (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 20
                                                if not (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^18:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[581 len 31]
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                                else:
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(sphereTokenAddress)
                                    call sphereTokenAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devAddress, 0
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ((block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require ext_code.size(sphereTokenAddress)
                                    if ((block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                        call sphereTokenAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ((block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if ((block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                            if not (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                                        else:
                                            if ((block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                                revert with 0, 'SafeMath: addition overflow'
                                            amountToBurn += (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 20
                                            if not (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^18:
                                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[581 len 31]
                                                if not ext_call.return_data[0]:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(sphereTokenAddress)
                                        if ext_call.return_data[0] >= ext_call.return_data[0]:
                                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(sphereTokenAddress)
                                            staticcall sphereTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ((block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if ((block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                                if not (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^18:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                                            else:
                                                if ((block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                amountToBurn += (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 20
                                                if not (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^18:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[581 len 31]
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                                        else:
                                            staticcall sphereTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(sphereTokenAddress)
                                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0] > ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require ext_code.size(sphereTokenAddress)
                                            call sphereTokenAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args address(this.address), 0
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(sphereTokenAddress)
                                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(sphereTokenAddress)
                                            staticcall sphereTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ((block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if ((block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                                if not (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^18:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[581 len 31]
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                                            else:
                                                if ((block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                amountToBurn += (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 20
                                                if not (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^18:
                                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[645 len 31]
                                                    if not ext_call.return_data[0]:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * spherePerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
        poolInfo[arg1].field_512 = block.number
}

function massUpdatePools() payable {
    mem[64] = 96
    idx = 0
    while idx < poolInfo.length:
        mem[0] = 10
        if block.number <= poolInfo[idx].field_512:
            idx = idx + 1
            continue 
        mem[mem[64] + 4] = this.address
        require ext_code.size(poolInfo[idx].field_0)
        staticcall poolInfo[idx].field_0.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if not ext_call.return_data[0]:
            poolInfo[idx].field_512 = block.number
            idx = idx + 1
            continue 
        if not poolInfo[idx].field_256:
            poolInfo[idx].field_512 = block.number
            idx = idx + 1
            continue 
        require ext_code.size(sphereTokenAddress)
        staticcall sphereTokenAddress.0xd5abeb01 with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(sphereTokenAddress)
        staticcall sphereTokenAddress.0x18160ddd with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] >= ext_call.return_data[0]:
            _2853 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2853] = 26
            mem[_2853 + 32] = 'SafeMath: division by zero'
            if not totalAllocPoint:
                _2854 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _2854 + 68] = mem[idx + _2853 + 32]
                    idx = idx + 32
                    continue 
                mem[_2854 + 68] = mem[_2854 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _2854 + -mem[64] + 100
            _2868 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2868] = 26
            mem[_2868 + 32] = 'SafeMath: division by zero'
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] <= ext_call.return_data[0]:
                mem[mem[64] + 4] = devAddress
                mem[mem[64] + 36] = 0 / totalAllocPoint / 20
                require ext_code.size(sphereTokenAddress)
                call sphereTokenAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devAddress, 0 / totalAllocPoint / 20
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sphereTokenAddress)
                    call sphereTokenAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0xd5abeb01 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    _3179 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3179] = 26
                    mem[_3179 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                        revert with 0, 'SafeMath: addition overflow'
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                        if not 0 / totalAllocPoint:
                            _3600 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3600] = 26
                            mem[_3600 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3662 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3662 + 68] = mem[idx + _3600 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3662 + 68] = mem[_3662 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3662 + -mem[64] + 100
                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _3632 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3632] = 26
                        mem[_3632 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3695 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _3695 + 68] = mem[idx + _3632 + 32]
                            idx = idx + 32
                            continue 
                        mem[_3695 + 68] = mem[_3695 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3695 + -mem[64] + 100
                    _3475 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3475] = 26
                    mem[_3475 + 32] = 'SafeMath: division by zero'
                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                        revert with 0, 'SafeMath: addition overflow'
                    amountToBurn += 0 / totalAllocPoint / 20
                    if not 0 / totalAllocPoint:
                        _3959 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3959] = 26
                        mem[_3959 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4059 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4059 + 68] = mem[idx + _3959 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4059 + 68] = mem[_4059 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4059 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4012 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4012] = 26
                    mem[_4012 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4115 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4115 + 68] = mem[idx + _4012 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4115 + 68] = mem[_4115 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4115 + -mem[64] + 100
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                if ext_call.return_data[0] >= ext_call.return_data[0]:
                    staticcall sphereTokenAddress.0xd5abeb01 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    _3265 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3265] = 26
                    mem[_3265 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                        revert with 0, 'SafeMath: addition overflow'
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                        if not 0 / totalAllocPoint:
                            _3730 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3730] = 26
                            mem[_3730 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3791 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3791 + 68] = mem[idx + _3730 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3791 + 68] = mem[_3791 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3791 + -mem[64] + 100
                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _3759 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3759] = 26
                        mem[_3759 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3828 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _3828 + 68] = mem[idx + _3759 + 32]
                            idx = idx + 32
                            continue 
                        mem[_3828 + 68] = mem[_3828 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3828 + -mem[64] + 100
                    _3598 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3598] = 26
                    mem[_3598 + 32] = 'SafeMath: division by zero'
                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                        revert with 0, 'SafeMath: addition overflow'
                    amountToBurn += 0 / totalAllocPoint / 20
                    if not 0 / totalAllocPoint:
                        _4168 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4168] = 26
                        mem[_4168 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4281 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4281 + 68] = mem[idx + _4168 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4281 + 68] = mem[_4281 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4281 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4223 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4223] = 26
                    mem[_4223 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4341 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4341 + 68] = mem[idx + _4223 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4341 + 68] = mem[_4341 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4341 + -mem[64] + 100
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3309 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3309] = 30
                mem[_3309 + 32] = 'SafeMath: subtraction overflow'
                if ext_call.return_data[0] > ext_call.return_data[0]:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                    idx = 32
                    while idx < 30:
                        mem[idx + mem[64] + 68] = mem[idx + _3309 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: subtraction overflow'
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0
                require ext_code.size(sphereTokenAddress)
                call sphereTokenAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3599 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3599] = 26
                mem[_3599 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                    if not 0 / totalAllocPoint:
                        _4344 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4344] = 26
                        mem[_4344 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4436 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4436 + 68] = mem[idx + _4344 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4436 + 68] = mem[_4436 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4436 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4389 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4389] = 26
                    mem[_4389 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4492 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4492 + 68] = mem[idx + _4389 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4492 + 68] = mem[_4492 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4492 + -mem[64] + 100
                _4114 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4114] = 26
                mem[_4114 + 32] = 'SafeMath: division by zero'
                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                    revert with 0, 'SafeMath: addition overflow'
                amountToBurn += 0 / totalAllocPoint / 20
                if not 0 / totalAllocPoint:
                    _4893 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4893] = 26
                    mem[_4893 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5004 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5004 + 68] = mem[idx + _4893 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5004 + 68] = mem[_5004 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5004 + -mem[64] + 100
                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _4951 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4951] = 26
                mem[_4951 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5057 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5057 + 68] = mem[idx + _4951 + 32]
                    idx = idx + 32
                    continue 
                mem[_5057 + 68] = mem[_5057 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5057 + -mem[64] + 100
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            if ext_call.return_data[0] >= ext_call.return_data[0]:
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sphereTokenAddress)
                    call sphereTokenAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0xd5abeb01 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    _3263 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3263] = 26
                    mem[_3263 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                        revert with 0, 'SafeMath: addition overflow'
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                        if not 0 / totalAllocPoint:
                            _3727 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3727] = 26
                            mem[_3727 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3787 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3787 + 68] = mem[idx + _3727 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3787 + 68] = mem[_3787 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3787 + -mem[64] + 100
                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _3755 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3755] = 26
                        mem[_3755 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3822 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _3822 + 68] = mem[idx + _3755 + 32]
                            idx = idx + 32
                            continue 
                        mem[_3822 + 68] = mem[_3822 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3822 + -mem[64] + 100
                    _3594 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3594] = 26
                    mem[_3594 + 32] = 'SafeMath: division by zero'
                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                        revert with 0, 'SafeMath: addition overflow'
                    amountToBurn += 0 / totalAllocPoint / 20
                    if not 0 / totalAllocPoint:
                        _4165 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4165] = 26
                        mem[_4165 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4275 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4275 + 68] = mem[idx + _4165 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4275 + 68] = mem[_4275 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4275 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4221 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4221] = 26
                    mem[_4221 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4335 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4335 + 68] = mem[idx + _4221 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4335 + 68] = mem[_4335 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4335 + -mem[64] + 100
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                if ext_call.return_data[0] >= ext_call.return_data[0]:
                    staticcall sphereTokenAddress.0xd5abeb01 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    _3349 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3349] = 26
                    mem[_3349 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                        revert with 0, 'SafeMath: addition overflow'
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                        if not 0 / totalAllocPoint:
                            _3863 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3863] = 26
                            mem[_3863 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3942 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3942 + 68] = mem[idx + _3863 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3942 + 68] = mem[_3942 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3942 + -mem[64] + 100
                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _3901 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3901] = 26
                        mem[_3901 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3997 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _3997 + 68] = mem[idx + _3901 + 32]
                            idx = idx + 32
                            continue 
                        mem[_3997 + 68] = mem[_3997 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3997 + -mem[64] + 100
                    _3725 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3725] = 26
                    mem[_3725 + 32] = 'SafeMath: division by zero'
                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                        revert with 0, 'SafeMath: addition overflow'
                    amountToBurn += 0 / totalAllocPoint / 20
                    if not 0 / totalAllocPoint:
                        _4385 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4385] = 26
                        mem[_4385 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4474 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4474 + 68] = mem[idx + _4385 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4474 + 68] = mem[_4474 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4474 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4426 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4426] = 26
                    mem[_4426 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4538 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4538 + 68] = mem[idx + _4426 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4538 + 68] = mem[_4538 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4538 + -mem[64] + 100
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3396 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3396] = 30
                mem[_3396 + 32] = 'SafeMath: subtraction overflow'
                if ext_call.return_data[0] > ext_call.return_data[0]:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                    idx = 32
                    while idx < 30:
                        mem[idx + mem[64] + 68] = mem[idx + _3396 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: subtraction overflow'
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0
                require ext_code.size(sphereTokenAddress)
                call sphereTokenAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3726 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3726] = 26
                mem[_3726 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                    if not 0 / totalAllocPoint:
                        _4541 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4541] = 26
                        mem[_4541 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4644 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4644 + 68] = mem[idx + _4541 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4644 + 68] = mem[_4644 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4644 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4591 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4591] = 26
                    mem[_4591 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4702 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4702 + 68] = mem[idx + _4591 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4702 + 68] = mem[_4702 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4702 + -mem[64] + 100
                _4334 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4334] = 26
                mem[_4334 + 32] = 'SafeMath: division by zero'
                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                    revert with 0, 'SafeMath: addition overflow'
                amountToBurn += 0 / totalAllocPoint / 20
                if not 0 / totalAllocPoint:
                    _5092 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5092] = 26
                    mem[_5092 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5162 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5162 + 68] = mem[idx + _5092 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5162 + 68] = mem[_5162 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5162 + -mem[64] + 100
                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5126 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5126] = 26
                mem[_5126 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5205 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5205 + 68] = mem[idx + _5126 + 32]
                    idx = idx + 32
                    continue 
                mem[_5205 + 68] = mem[_5205 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5205 + -mem[64] + 100
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _3030 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3030] = 30
            mem[_3030 + 32] = 'SafeMath: subtraction overflow'
            if ext_call.return_data[0] > ext_call.return_data[0]:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                idx = 32
                while idx < 30:
                    mem[idx + mem[64] + 68] = mem[idx + _3030 + 32]
                    idx = idx + 32
                    continue 
                revert with 0, 'SafeMath: subtraction overflow'
            mem[mem[64] + 4] = devAddress
            mem[mem[64] + 36] = 0
            require ext_code.size(sphereTokenAddress)
            call sphereTokenAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args devAddress, 0
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sphereTokenAddress)
                call sphereTokenAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3597 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3597] = 26
                mem[_3597 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                    if not 0 / totalAllocPoint:
                        _4340 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4340] = 26
                        mem[_4340 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4430 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4430 + 68] = mem[idx + _4340 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4430 + 68] = mem[_4430 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4430 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4387 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4387] = 26
                    mem[_4387 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4484 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4484 + 68] = mem[idx + _4387 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4484 + 68] = mem[_4484 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4484 + -mem[64] + 100
                _4111 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4111] = 26
                mem[_4111 + 32] = 'SafeMath: division by zero'
                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                    revert with 0, 'SafeMath: addition overflow'
                amountToBurn += 0 / totalAllocPoint / 20
                if not 0 / totalAllocPoint:
                    _4892 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4892] = 26
                    mem[_4892 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5001 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5001 + 68] = mem[idx + _4892 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5001 + 68] = mem[_5001 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5001 + -mem[64] + 100
                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _4950 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4950] = 26
                mem[_4950 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5054 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5054 + 68] = mem[idx + _4950 + 32]
                    idx = idx + 32
                    continue 
                mem[_5054 + 68] = mem[_5054 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5054 + -mem[64] + 100
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            if ext_call.return_data[0] >= ext_call.return_data[0]:
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3728 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3728] = 26
                mem[_3728 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                    if not 0 / totalAllocPoint:
                        _4545 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4545] = 26
                        mem[_4545 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4647 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4647 + 68] = mem[idx + _4545 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4647 + 68] = mem[_4647 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4647 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4594 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4594] = 26
                    mem[_4594 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4707 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4707 + 68] = mem[idx + _4594 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4707 + 68] = mem[_4707 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4707 + -mem[64] + 100
                _4338 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4338] = 26
                mem[_4338 + 32] = 'SafeMath: division by zero'
                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                    revert with 0, 'SafeMath: addition overflow'
                amountToBurn += 0 / totalAllocPoint / 20
                if not 0 / totalAllocPoint:
                    _5093 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5093] = 26
                    mem[_5093 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5165 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5165 + 68] = mem[idx + _5093 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5165 + 68] = mem[_5165 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5165 + -mem[64] + 100
                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5127 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5127] = 26
                mem[_5127 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5208 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5208 + 68] = mem[idx + _5127 + 32]
                    idx = idx + 32
                    continue 
                mem[_5208 + 68] = mem[_5208 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5208 + -mem[64] + 100
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _3790 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3790] = 30
            mem[_3790 + 32] = 'SafeMath: subtraction overflow'
            if ext_call.return_data[0] > ext_call.return_data[0]:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                idx = 32
                while idx < 30:
                    mem[idx + mem[64] + 68] = mem[idx + _3790 + 32]
                    idx = idx + 32
                    continue 
                revert with 0, 'SafeMath: subtraction overflow'
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = 0
            require ext_code.size(sphereTokenAddress)
            call sphereTokenAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args address(this.address), 0
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _4339 = mem[64]
            mem[64] = mem[64] + 64
            mem[_4339] = 26
            mem[_4339 + 32] = 'SafeMath: division by zero'
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                if not 0 / totalAllocPoint:
                    _5211 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5211] = 26
                    mem[_5211 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5279 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5279 + 68] = mem[idx + _5211 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5279 + 68] = mem[_5279 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5279 + -mem[64] + 100
                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5245 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5245] = 26
                mem[_5245 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5314 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5314 + 68] = mem[idx + _5245 + 32]
                    idx = idx + 32
                    continue 
                mem[_5314 + 68] = mem[_5314 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5314 + -mem[64] + 100
            _5053 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5053] = 26
            mem[_5053 + 32] = 'SafeMath: division by zero'
            if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                revert with 0, 'SafeMath: addition overflow'
            amountToBurn += 0 / totalAllocPoint / 20
            if not 0 / totalAllocPoint:
                _5537 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5537] = 26
                mem[_5537 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5560 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5560 + 68] = mem[idx + _5537 + 32]
                    idx = idx + 32
                    continue 
                mem[_5560 + 68] = mem[_5560 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5560 + -mem[64] + 100
            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _5551 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5551] = 26
            mem[_5551 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0]:
                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _5570 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _5570 + 68] = mem[idx + _5551 + 32]
                idx = idx + 32
                continue 
            mem[_5570 + 68] = mem[_5570 + 74 len 26]
            revert with memory
              from mem[64]
               len _5570 + -mem[64] + 100
        _2839 = mem[64]
        mem[64] = mem[64] + 64
        mem[_2839] = 30
        mem[_2839 + 32] = 'SafeMath: subtraction overflow'
        if poolInfo[idx].field_512 > block.number:
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
            idx = 32
            while idx < 30:
                mem[idx + mem[64] + 68] = mem[idx + _2839 + 32]
                idx = idx + 32
                continue 
            revert with 0, 'SafeMath: subtraction overflow'
        if not block.number - poolInfo[idx].field_512:
            _2859 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2859] = 26
            mem[_2859 + 32] = 'SafeMath: division by zero'
            if not totalAllocPoint:
                _2865 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _2865 + 68] = mem[idx + _2859 + 32]
                    idx = idx + 32
                    continue 
                mem[_2865 + 68] = mem[_2865 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _2865 + -mem[64] + 100
            _2883 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2883] = 26
            mem[_2883 + 32] = 'SafeMath: division by zero'
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] <= ext_call.return_data[0]:
                mem[mem[64] + 4] = devAddress
                mem[mem[64] + 36] = 0 / totalAllocPoint / 20
                require ext_code.size(sphereTokenAddress)
                call sphereTokenAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devAddress, 0 / totalAllocPoint / 20
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sphereTokenAddress)
                    call sphereTokenAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0xd5abeb01 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    _3260 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3260] = 26
                    mem[_3260 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                        revert with 0, 'SafeMath: addition overflow'
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                        if not 0 / totalAllocPoint:
                            _3724 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3724] = 26
                            mem[_3724 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3784 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3784 + 68] = mem[idx + _3724 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3784 + 68] = mem[_3784 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3784 + -mem[64] + 100
                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _3754 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3754] = 26
                        mem[_3754 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3815 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _3815 + 68] = mem[idx + _3754 + 32]
                            idx = idx + 32
                            continue 
                        mem[_3815 + 68] = mem[_3815 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3815 + -mem[64] + 100
                    _3590 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3590] = 26
                    mem[_3590 + 32] = 'SafeMath: division by zero'
                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                        revert with 0, 'SafeMath: addition overflow'
                    amountToBurn += 0 / totalAllocPoint / 20
                    if not 0 / totalAllocPoint:
                        _4159 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4159] = 26
                        mem[_4159 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4270 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4270 + 68] = mem[idx + _4159 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4270 + 68] = mem[_4270 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4270 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4217 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4217] = 26
                    mem[_4217 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4329 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4329 + 68] = mem[idx + _4217 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4329 + 68] = mem[_4329 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4329 + -mem[64] + 100
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                if ext_call.return_data[0] >= ext_call.return_data[0]:
                    staticcall sphereTokenAddress.0xd5abeb01 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    _3347 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3347] = 26
                    mem[_3347 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                        revert with 0, 'SafeMath: addition overflow'
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                        if not 0 / totalAllocPoint:
                            _3861 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3861] = 26
                            mem[_3861 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3936 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3936 + 68] = mem[idx + _3861 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3936 + 68] = mem[_3936 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3936 + -mem[64] + 100
                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _3895 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3895] = 26
                        mem[_3895 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3988 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _3988 + 68] = mem[idx + _3895 + 32]
                            idx = idx + 32
                            continue 
                        mem[_3988 + 68] = mem[_3988 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3988 + -mem[64] + 100
                    _3722 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3722] = 26
                    mem[_3722 + 32] = 'SafeMath: division by zero'
                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                        revert with 0, 'SafeMath: addition overflow'
                    amountToBurn += 0 / totalAllocPoint / 20
                    if not 0 / totalAllocPoint:
                        _4383 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4383] = 26
                        mem[_4383 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4466 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4466 + 68] = mem[idx + _4383 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4466 + 68] = mem[_4466 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4466 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4422 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4422] = 26
                    mem[_4422 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4531 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4531 + 68] = mem[idx + _4422 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4531 + 68] = mem[_4531 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4531 + -mem[64] + 100
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3395 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3395] = 30
                mem[_3395 + 32] = 'SafeMath: subtraction overflow'
                if ext_call.return_data[0] > ext_call.return_data[0]:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                    idx = 32
                    while idx < 30:
                        mem[idx + mem[64] + 68] = mem[idx + _3395 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: subtraction overflow'
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0
                require ext_code.size(sphereTokenAddress)
                call sphereTokenAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3723 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3723] = 26
                mem[_3723 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                    if not 0 / totalAllocPoint:
                        _4534 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4534] = 26
                        mem[_4534 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4638 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4638 + 68] = mem[idx + _4534 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4638 + 68] = mem[_4638 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4638 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4587 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4587] = 26
                    mem[_4587 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4694 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4694 + 68] = mem[idx + _4587 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4694 + 68] = mem[_4694 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4694 + -mem[64] + 100
                _4328 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4328] = 26
                mem[_4328 + 32] = 'SafeMath: division by zero'
                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                    revert with 0, 'SafeMath: addition overflow'
                amountToBurn += 0 / totalAllocPoint / 20
                if not 0 / totalAllocPoint:
                    _5091 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5091] = 26
                    mem[_5091 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5159 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5159 + 68] = mem[idx + _5091 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5159 + 68] = mem[_5159 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5159 + -mem[64] + 100
                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5125 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5125] = 26
                mem[_5125 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5202 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5202 + 68] = mem[idx + _5125 + 32]
                    idx = idx + 32
                    continue 
                mem[_5202 + 68] = mem[_5202 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5202 + -mem[64] + 100
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            if ext_call.return_data[0] >= ext_call.return_data[0]:
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sphereTokenAddress)
                    call sphereTokenAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0xd5abeb01 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    _3345 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3345] = 26
                    mem[_3345 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                        revert with 0, 'SafeMath: addition overflow'
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                        if not 0 / totalAllocPoint:
                            _3858 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3858] = 26
                            mem[_3858 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3932 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3932 + 68] = mem[idx + _3858 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3932 + 68] = mem[_3932 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3932 + -mem[64] + 100
                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _3891 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3891] = 26
                        mem[_3891 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3982 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _3982 + 68] = mem[idx + _3891 + 32]
                            idx = idx + 32
                            continue 
                        mem[_3982 + 68] = mem[_3982 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3982 + -mem[64] + 100
                    _3718 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3718] = 26
                    mem[_3718 + 32] = 'SafeMath: division by zero'
                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                        revert with 0, 'SafeMath: addition overflow'
                    amountToBurn += 0 / totalAllocPoint / 20
                    if not 0 / totalAllocPoint:
                        _4380 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4380] = 26
                        mem[_4380 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4460 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4460 + 68] = mem[idx + _4380 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4460 + 68] = mem[_4460 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4460 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4420 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4420] = 26
                    mem[_4420 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4525 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4525 + 68] = mem[idx + _4420 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4525 + 68] = mem[_4525 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4525 + -mem[64] + 100
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                if ext_call.return_data[0] >= ext_call.return_data[0]:
                    staticcall sphereTokenAddress.0xd5abeb01 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    _3431 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3431] = 26
                    mem[_3431 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                        revert with 0, 'SafeMath: addition overflow'
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                        if not 0 / totalAllocPoint:
                            _4040 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4040] = 26
                            mem[_4040 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _4142 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4142 + 68] = mem[idx + _4040 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4142 + 68] = mem[_4142 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _4142 + -mem[64] + 100
                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _4089 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4089] = 26
                        mem[_4089 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4202 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4202 + 68] = mem[idx + _4089 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4202 + 68] = mem[_4202 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4202 + -mem[64] + 100
                    _3856 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3856] = 26
                    mem[_3856 + 32] = 'SafeMath: division by zero'
                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                        revert with 0, 'SafeMath: addition overflow'
                    amountToBurn += 0 / totalAllocPoint / 20
                    if not 0 / totalAllocPoint:
                        _4583 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4583] = 26
                        mem[_4583 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4676 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4676 + 68] = mem[idx + _4583 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4676 + 68] = mem[_4676 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4676 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4628 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4628] = 26
                    mem[_4628 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4755 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4755 + 68] = mem[idx + _4628 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4755 + 68] = mem[_4755 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4755 + -mem[64] + 100
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3492 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3492] = 30
                mem[_3492 + 32] = 'SafeMath: subtraction overflow'
                if ext_call.return_data[0] > ext_call.return_data[0]:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                    idx = 32
                    while idx < 30:
                        mem[idx + mem[64] + 68] = mem[idx + _3492 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: subtraction overflow'
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0
                require ext_code.size(sphereTokenAddress)
                call sphereTokenAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3857 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3857] = 26
                mem[_3857 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                    if not 0 / totalAllocPoint:
                        _4758 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4758] = 26
                        mem[_4758 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4872 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4872 + 68] = mem[idx + _4758 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4872 + 68] = mem[_4872 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4872 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4815 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4815] = 26
                    mem[_4815 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4927 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4927 + 68] = mem[idx + _4815 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4927 + 68] = mem[_4927 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4927 + -mem[64] + 100
                _4524 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4524] = 26
                mem[_4524 + 32] = 'SafeMath: division by zero'
                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                    revert with 0, 'SafeMath: addition overflow'
                amountToBurn += 0 / totalAllocPoint / 20
                if not 0 / totalAllocPoint:
                    _5239 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5239] = 26
                    mem[_5239 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5294 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5294 + 68] = mem[idx + _5239 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5294 + 68] = mem[_5294 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5294 + -mem[64] + 100
                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5265 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5265] = 26
                mem[_5265 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5341 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5341 + 68] = mem[idx + _5265 + 32]
                    idx = idx + 32
                    continue 
                mem[_5341 + 68] = mem[_5341 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5341 + -mem[64] + 100
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _3079 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3079] = 30
            mem[_3079 + 32] = 'SafeMath: subtraction overflow'
            if ext_call.return_data[0] > ext_call.return_data[0]:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                idx = 32
                while idx < 30:
                    mem[idx + mem[64] + 68] = mem[idx + _3079 + 32]
                    idx = idx + 32
                    continue 
                revert with 0, 'SafeMath: subtraction overflow'
            mem[mem[64] + 4] = devAddress
            mem[mem[64] + 36] = 0
            require ext_code.size(sphereTokenAddress)
            call sphereTokenAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args devAddress, 0
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sphereTokenAddress)
                call sphereTokenAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3721 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3721] = 26
                mem[_3721 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                    if not 0 / totalAllocPoint:
                        _4530 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4530] = 26
                        mem[_4530 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4632 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4632 + 68] = mem[idx + _4530 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4632 + 68] = mem[_4632 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4632 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4585 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4585] = 26
                    mem[_4585 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4686 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4686 + 68] = mem[idx + _4585 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4686 + 68] = mem[_4686 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4686 + -mem[64] + 100
                _4325 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4325] = 26
                mem[_4325 + 32] = 'SafeMath: division by zero'
                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                    revert with 0, 'SafeMath: addition overflow'
                amountToBurn += 0 / totalAllocPoint / 20
                if not 0 / totalAllocPoint:
                    _5090 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5090] = 26
                    mem[_5090 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5156 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5156 + 68] = mem[idx + _5090 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5156 + 68] = mem[_5156 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5156 + -mem[64] + 100
                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5124 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5124] = 26
                mem[_5124 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5199 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5199 + 68] = mem[idx + _5124 + 32]
                    idx = idx + 32
                    continue 
                mem[_5199 + 68] = mem[_5199 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5199 + -mem[64] + 100
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            if ext_call.return_data[0] >= ext_call.return_data[0]:
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3859 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3859] = 26
                mem[_3859 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                    if not 0 / totalAllocPoint:
                        _4762 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4762] = 26
                        mem[_4762 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4875 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4875 + 68] = mem[idx + _4762 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4875 + 68] = mem[_4875 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4875 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4818 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4818] = 26
                    mem[_4818 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4932 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4932 + 68] = mem[idx + _4818 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4932 + 68] = mem[_4932 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4932 + -mem[64] + 100
                _4528 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4528] = 26
                mem[_4528 + 32] = 'SafeMath: division by zero'
                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                    revert with 0, 'SafeMath: addition overflow'
                amountToBurn += 0 / totalAllocPoint / 20
                if not 0 / totalAllocPoint:
                    _5240 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5240] = 26
                    mem[_5240 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5297 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5297 + 68] = mem[idx + _5240 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5297 + 68] = mem[_5297 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5297 + -mem[64] + 100
                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5266 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5266] = 26
                mem[_5266 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5344 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5344 + 68] = mem[idx + _5266 + 32]
                    idx = idx + 32
                    continue 
                mem[_5344 + 68] = mem[_5344 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5344 + -mem[64] + 100
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _3935 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3935] = 30
            mem[_3935 + 32] = 'SafeMath: subtraction overflow'
            if ext_call.return_data[0] > ext_call.return_data[0]:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                idx = 32
                while idx < 30:
                    mem[idx + mem[64] + 68] = mem[idx + _3935 + 32]
                    idx = idx + 32
                    continue 
                revert with 0, 'SafeMath: subtraction overflow'
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = 0
            require ext_code.size(sphereTokenAddress)
            call sphereTokenAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args address(this.address), 0
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _4529 = mem[64]
            mem[64] = mem[64] + 64
            mem[_4529] = 26
            mem[_4529 + 32] = 'SafeMath: division by zero'
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                if not 0 / totalAllocPoint:
                    _5347 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5347] = 26
                    mem[_5347 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5428 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5428 + 68] = mem[idx + _5347 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5428 + 68] = mem[_5428 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5428 + -mem[64] + 100
                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5390 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5390] = 26
                mem[_5390 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5456 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5456 + 68] = mem[idx + _5390 + 32]
                    idx = idx + 32
                    continue 
                mem[_5456 + 68] = mem[_5456 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5456 + -mem[64] + 100
            _5198 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5198] = 26
            mem[_5198 + 32] = 'SafeMath: division by zero'
            if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                revert with 0, 'SafeMath: addition overflow'
            amountToBurn += 0 / totalAllocPoint / 20
            if not 0 / totalAllocPoint:
                _5577 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5577] = 26
                mem[_5577 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5588 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5588 + 68] = mem[idx + _5577 + 32]
                    idx = idx + 32
                    continue 
                mem[_5588 + 68] = mem[_5588 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5588 + -mem[64] + 100
            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _5582 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5582] = 26
            mem[_5582 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0]:
                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _5598 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _5598 + 68] = mem[idx + _5582 + 32]
                idx = idx + 32
                continue 
            mem[_5598 + 68] = mem[_5598 + 74 len 26]
            revert with memory
              from mem[64]
               len _5598 + -mem[64] + 100
        if (block.number * spherePerBlock) - (poolInfo[idx].field_512 * spherePerBlock) / block.number - poolInfo[idx].field_512 != spherePerBlock:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        if not (block.number * spherePerBlock) - (poolInfo[idx].field_512 * spherePerBlock):
            _2861 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2861] = 26
            mem[_2861 + 32] = 'SafeMath: division by zero'
            if not totalAllocPoint:
                _2870 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _2870 + 68] = mem[idx + _2861 + 32]
                    idx = idx + 32
                    continue 
                mem[_2870 + 68] = mem[_2870 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _2870 + -mem[64] + 100
            _2887 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2887] = 26
            mem[_2887 + 32] = 'SafeMath: division by zero'
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] <= ext_call.return_data[0]:
                mem[mem[64] + 4] = devAddress
                mem[mem[64] + 36] = 0 / totalAllocPoint / 20
                require ext_code.size(sphereTokenAddress)
                call sphereTokenAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devAddress, 0 / totalAllocPoint / 20
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sphereTokenAddress)
                    call sphereTokenAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0xd5abeb01 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    _3279 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3279] = 26
                    mem[_3279 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                        revert with 0, 'SafeMath: addition overflow'
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                        if not 0 / totalAllocPoint:
                            _3750 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3750] = 26
                            mem[_3750 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3806 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3806 + 68] = mem[idx + _3750 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3806 + 68] = mem[_3806 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3806 + -mem[64] + 100
                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _3778 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3778] = 26
                        mem[_3778 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3851 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _3851 + 68] = mem[idx + _3778 + 32]
                            idx = idx + 32
                            continue 
                        mem[_3851 + 68] = mem[_3851 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3851 + -mem[64] + 100
                    _3619 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3619] = 26
                    mem[_3619 + 32] = 'SafeMath: division by zero'
                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                        revert with 0, 'SafeMath: addition overflow'
                    amountToBurn += 0 / totalAllocPoint / 20
                    if not 0 / totalAllocPoint:
                        _4201 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4201] = 26
                        mem[_4201 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4314 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4314 + 68] = mem[idx + _4201 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4314 + 68] = mem[_4314 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4314 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4260 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4260] = 26
                    mem[_4260 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4372 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4372 + 68] = mem[idx + _4260 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4372 + 68] = mem[_4372 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4372 + -mem[64] + 100
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                if ext_call.return_data[0] >= ext_call.return_data[0]:
                    staticcall sphereTokenAddress.0xd5abeb01 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    _3363 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3363] = 26
                    mem[_3363 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                        revert with 0, 'SafeMath: addition overflow'
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                        if not 0 / totalAllocPoint:
                            _3889 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3889] = 26
                            mem[_3889 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3974 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3974 + 68] = mem[idx + _3889 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3974 + 68] = mem[_3974 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3974 + -mem[64] + 100
                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _3926 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3926] = 26
                        mem[_3926 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4031 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4031 + 68] = mem[idx + _3926 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4031 + 68] = mem[_4031 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4031 + -mem[64] + 100
                    _3748 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3748] = 26
                    mem[_3748 + 32] = 'SafeMath: division by zero'
                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                        revert with 0, 'SafeMath: addition overflow'
                    amountToBurn += 0 / totalAllocPoint / 20
                    if not 0 / totalAllocPoint:
                        _4415 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4415] = 26
                        mem[_4415 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4514 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4514 + 68] = mem[idx + _4415 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4514 + 68] = mem[_4514 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4514 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4454 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4454] = 26
                    mem[_4454 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4576 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4576 + 68] = mem[idx + _4454 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4576 + 68] = mem[_4576 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4576 + -mem[64] + 100
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3412 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3412] = 30
                mem[_3412 + 32] = 'SafeMath: subtraction overflow'
                if ext_call.return_data[0] > ext_call.return_data[0]:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                    idx = 32
                    while idx < 30:
                        mem[idx + mem[64] + 68] = mem[idx + _3412 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: subtraction overflow'
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0
                require ext_code.size(sphereTokenAddress)
                call sphereTokenAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3749 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3749] = 26
                mem[_3749 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                    if not 0 / totalAllocPoint:
                        _4579 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4579] = 26
                        mem[_4579 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4673 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4673 + 68] = mem[idx + _4579 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4673 + 68] = mem[_4673 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4673 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4625 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4625] = 26
                    mem[_4625 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4750 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4750 + 68] = mem[idx + _4625 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4750 + 68] = mem[_4750 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4750 + -mem[64] + 100
                _4371 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4371] = 26
                mem[_4371 + 32] = 'SafeMath: division by zero'
                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                    revert with 0, 'SafeMath: addition overflow'
                amountToBurn += 0 / totalAllocPoint / 20
                if not 0 / totalAllocPoint:
                    _5117 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5117] = 26
                    mem[_5117 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5191 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5191 + 68] = mem[idx + _5117 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5191 + 68] = mem[_5191 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5191 + -mem[64] + 100
                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5151 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5151] = 26
                mem[_5151 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5236 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5236 + 68] = mem[idx + _5151 + 32]
                    idx = idx + 32
                    continue 
                mem[_5236 + 68] = mem[_5236 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5236 + -mem[64] + 100
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            if ext_call.return_data[0] >= ext_call.return_data[0]:
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sphereTokenAddress)
                    call sphereTokenAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0xd5abeb01 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    _3361 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3361] = 26
                    mem[_3361 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                        revert with 0, 'SafeMath: addition overflow'
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                        if not 0 / totalAllocPoint:
                            _3886 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3886] = 26
                            mem[_3886 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3970 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3970 + 68] = mem[idx + _3886 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3970 + 68] = mem[_3970 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3970 + -mem[64] + 100
                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _3922 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3922] = 26
                        mem[_3922 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4025 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4025 + 68] = mem[idx + _3922 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4025 + 68] = mem[_4025 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4025 + -mem[64] + 100
                    _3744 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3744] = 26
                    mem[_3744 + 32] = 'SafeMath: division by zero'
                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                        revert with 0, 'SafeMath: addition overflow'
                    amountToBurn += 0 / totalAllocPoint / 20
                    if not 0 / totalAllocPoint:
                        _4412 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4412] = 26
                        mem[_4412 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4508 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4508 + 68] = mem[idx + _4412 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4508 + 68] = mem[_4508 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4508 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4452 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4452] = 26
                    mem[_4452 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4570 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4570 + 68] = mem[idx + _4452 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4570 + 68] = mem[_4570 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4570 + -mem[64] + 100
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                if ext_call.return_data[0] >= ext_call.return_data[0]:
                    staticcall sphereTokenAddress.0xd5abeb01 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    _3451 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3451] = 26
                    mem[_3451 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                        revert with 0, 'SafeMath: addition overflow'
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                        if not 0 / totalAllocPoint:
                            _4079 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4079] = 26
                            mem[_4079 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _4184 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4184 + 68] = mem[idx + _4079 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4184 + 68] = mem[_4184 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _4184 + -mem[64] + 100
                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _4128 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4128] = 26
                        mem[_4128 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4245 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4245 + 68] = mem[idx + _4128 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4245 + 68] = mem[_4245 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4245 + -mem[64] + 100
                    _3884 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3884] = 26
                    mem[_3884 + 32] = 'SafeMath: division by zero'
                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                        revert with 0, 'SafeMath: addition overflow'
                    amountToBurn += 0 / totalAllocPoint / 20
                    if not 0 / totalAllocPoint:
                        _4621 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4621] = 26
                        mem[_4621 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4732 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4732 + 68] = mem[idx + _4621 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4732 + 68] = mem[_4732 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4732 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4663 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4663] = 26
                    mem[_4663 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4801 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4801 + 68] = mem[idx + _4663 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4801 + 68] = mem[_4801 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4801 + -mem[64] + 100
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3518 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3518] = 30
                mem[_3518 + 32] = 'SafeMath: subtraction overflow'
                if ext_call.return_data[0] > ext_call.return_data[0]:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                    idx = 32
                    while idx < 30:
                        mem[idx + mem[64] + 68] = mem[idx + _3518 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: subtraction overflow'
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0
                require ext_code.size(sphereTokenAddress)
                call sphereTokenAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3885 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3885] = 26
                mem[_3885 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                    if not 0 / totalAllocPoint:
                        _4804 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4804] = 26
                        mem[_4804 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4912 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4912 + 68] = mem[idx + _4804 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4912 + 68] = mem[_4912 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4912 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4855 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4855] = 26
                    mem[_4855 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4970 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4970 + 68] = mem[idx + _4855 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4970 + 68] = mem[_4970 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4970 + -mem[64] + 100
                _4569 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4569] = 26
                mem[_4569 + 32] = 'SafeMath: division by zero'
                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                    revert with 0, 'SafeMath: addition overflow'
                amountToBurn += 0 / totalAllocPoint / 20
                if not 0 / totalAllocPoint:
                    _5261 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5261] = 26
                    mem[_5261 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5327 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5327 + 68] = mem[idx + _5261 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5327 + 68] = mem[_5327 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5327 + -mem[64] + 100
                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5286 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5286] = 26
                mem[_5286 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5375 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5375 + 68] = mem[idx + _5286 + 32]
                    idx = idx + 32
                    continue 
                mem[_5375 + 68] = mem[_5375 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5375 + -mem[64] + 100
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _3091 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3091] = 30
            mem[_3091 + 32] = 'SafeMath: subtraction overflow'
            if ext_call.return_data[0] > ext_call.return_data[0]:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                idx = 32
                while idx < 30:
                    mem[idx + mem[64] + 68] = mem[idx + _3091 + 32]
                    idx = idx + 32
                    continue 
                revert with 0, 'SafeMath: subtraction overflow'
            mem[mem[64] + 4] = devAddress
            mem[mem[64] + 36] = 0
            require ext_code.size(sphereTokenAddress)
            call sphereTokenAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args devAddress, 0
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sphereTokenAddress)
                call sphereTokenAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3747 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3747] = 26
                mem[_3747 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                    if not 0 / totalAllocPoint:
                        _4575 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4575] = 26
                        mem[_4575 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4667 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4667 + 68] = mem[idx + _4575 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4667 + 68] = mem[_4667 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4667 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4623 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4623] = 26
                    mem[_4623 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4742 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4742 + 68] = mem[idx + _4623 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4742 + 68] = mem[_4742 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4742 + -mem[64] + 100
                _4368 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4368] = 26
                mem[_4368 + 32] = 'SafeMath: division by zero'
                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                    revert with 0, 'SafeMath: addition overflow'
                amountToBurn += 0 / totalAllocPoint / 20
                if not 0 / totalAllocPoint:
                    _5116 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5116] = 26
                    mem[_5116 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5188 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5188 + 68] = mem[idx + _5116 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5188 + 68] = mem[_5188 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5188 + -mem[64] + 100
                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5150 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5150] = 26
                mem[_5150 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5233 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5233 + 68] = mem[idx + _5150 + 32]
                    idx = idx + 32
                    continue 
                mem[_5233 + 68] = mem[_5233 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5233 + -mem[64] + 100
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            if ext_call.return_data[0] >= ext_call.return_data[0]:
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3887 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3887] = 26
                mem[_3887 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                    if not 0 / totalAllocPoint:
                        _4808 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4808] = 26
                        mem[_4808 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4915 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4915 + 68] = mem[idx + _4808 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4915 + 68] = mem[_4915 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4915 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4858 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4858] = 26
                    mem[_4858 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4975 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4975 + 68] = mem[idx + _4858 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4975 + 68] = mem[_4975 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4975 + -mem[64] + 100
                _4573 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4573] = 26
                mem[_4573 + 32] = 'SafeMath: division by zero'
                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                    revert with 0, 'SafeMath: addition overflow'
                amountToBurn += 0 / totalAllocPoint / 20
                if not 0 / totalAllocPoint:
                    _5262 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5262] = 26
                    mem[_5262 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5330 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5330 + 68] = mem[idx + _5262 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5330 + 68] = mem[_5330 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5330 + -mem[64] + 100
                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5287 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5287] = 26
                mem[_5287 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5378 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5378 + 68] = mem[idx + _5287 + 32]
                    idx = idx + 32
                    continue 
                mem[_5378 + 68] = mem[_5378 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5378 + -mem[64] + 100
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _3973 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3973] = 30
            mem[_3973 + 32] = 'SafeMath: subtraction overflow'
            if ext_call.return_data[0] > ext_call.return_data[0]:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                idx = 32
                while idx < 30:
                    mem[idx + mem[64] + 68] = mem[idx + _3973 + 32]
                    idx = idx + 32
                    continue 
                revert with 0, 'SafeMath: subtraction overflow'
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = 0
            require ext_code.size(sphereTokenAddress)
            call sphereTokenAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args address(this.address), 0
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _4574 = mem[64]
            mem[64] = mem[64] + 64
            mem[_4574] = 26
            mem[_4574 + 32] = 'SafeMath: division by zero'
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                if not 0 / totalAllocPoint:
                    _5381 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5381] = 26
                    mem[_5381 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5447 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5447 + 68] = mem[idx + _5381 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5447 + 68] = mem[_5447 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5447 + -mem[64] + 100
                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5417 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5417] = 26
                mem[_5417 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5479 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5479 + 68] = mem[idx + _5417 + 32]
                    idx = idx + 32
                    continue 
                mem[_5479 + 68] = mem[_5479 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5479 + -mem[64] + 100
            _5232 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5232] = 26
            mem[_5232 + 32] = 'SafeMath: division by zero'
            if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                revert with 0, 'SafeMath: addition overflow'
            amountToBurn += 0 / totalAllocPoint / 20
            if not 0 / totalAllocPoint:
                _5581 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5581] = 26
                mem[_5581 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5595 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5595 + 68] = mem[idx + _5581 + 32]
                    idx = idx + 32
                    continue 
                mem[_5595 + 68] = mem[_5595 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5595 + -mem[64] + 100
            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _5587 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5587] = 26
            mem[_5587 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0]:
                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _5607 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _5607 + 68] = mem[idx + _5587 + 32]
                idx = idx + 32
                continue 
            mem[_5607 + 68] = mem[_5607 + 74 len 26]
            revert with memory
              from mem[64]
               len _5607 + -mem[64] + 100
        if (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / (block.number * spherePerBlock) - (poolInfo[idx].field_512 * spherePerBlock) != poolInfo[idx].field_256:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        _2864 = mem[64]
        mem[64] = mem[64] + 64
        mem[_2864] = 26
        mem[_2864 + 32] = 'SafeMath: division by zero'
        if not totalAllocPoint:
            _2873 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _2873 + 68] = mem[idx + _2864 + 32]
                idx = idx + 32
                continue 
            mem[_2873 + 68] = mem[_2873 + 74 len 26]
            revert with memory
              from mem[64]
               len _2873 + -mem[64] + 100
        _2889 = mem[64]
        mem[64] = mem[64] + 64
        mem[_2889] = 26
        mem[_2889 + 32] = 'SafeMath: division by zero'
        require ext_code.size(sphereTokenAddress)
        staticcall sphereTokenAddress.0xd5abeb01 with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(sphereTokenAddress)
        staticcall sphereTokenAddress.0x18160ddd with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
            revert with 0, 'SafeMath: addition overflow'
        if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] <= ext_call.return_data[0]:
            mem[mem[64] + 4] = devAddress
            mem[mem[64] + 36] = (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
            require ext_code.size(sphereTokenAddress)
            call sphereTokenAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args devAddress, (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint
                require ext_code.size(sphereTokenAddress)
                call sphereTokenAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3292 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3292] = 26
                mem[_3292 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                    if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                        _3774 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3774] = 26
                        mem[_3774 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3842 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _3842 + 68] = mem[idx + _3774 + 32]
                            idx = idx + 32
                            continue 
                        mem[_3842 + 68] = mem[_3842 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3842 + -mem[64] + 100
                    if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _3800 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3800] = 26
                    mem[_3800 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3879 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _3879 + 68] = mem[idx + _3800 + 32]
                        idx = idx + 32
                        continue 
                    mem[_3879 + 68] = mem[_3879 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3879 + -mem[64] + 100
                _3641 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3641] = 26
                mem[_3641 + 32] = 'SafeMath: division by zero'
                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                    revert with 0, 'SafeMath: addition overflow'
                amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
                if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                    _4244 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4244] = 26
                    mem[_4244 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4357 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4357 + 68] = mem[idx + _4244 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4357 + 68] = mem[_4357 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4357 + -mem[64] + 100
                if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _4304 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4304] = 26
                mem[_4304 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _4404 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _4404 + 68] = mem[idx + _4304 + 32]
                    idx = idx + 32
                    continue 
                mem[_4404 + 68] = mem[_4404 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _4404 + -mem[64] + 100
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            if ext_call.return_data[0] >= ext_call.return_data[0]:
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3384 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3384] = 26
                mem[_3384 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                    if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                        _3920 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3920] = 26
                        mem[_3920 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4017 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4017 + 68] = mem[idx + _3920 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4017 + 68] = mem[_4017 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4017 + -mem[64] + 100
                    if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _3964 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3964] = 26
                    mem[_3964 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4070 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4070 + 68] = mem[idx + _3964 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4070 + 68] = mem[_4070 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4070 + -mem[64] + 100
                _3772 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3772] = 26
                mem[_3772 + 32] = 'SafeMath: division by zero'
                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                    revert with 0, 'SafeMath: addition overflow'
                amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
                if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                    _4447 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4447] = 26
                    mem[_4447 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4559 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4559 + 68] = mem[idx + _4447 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4559 + 68] = mem[_4559 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4559 + -mem[64] + 100
                if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _4502 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4502] = 26
                mem[_4502 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _4614 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _4614 + 68] = mem[idx + _4502 + 32]
                    idx = idx + 32
                    continue 
                mem[_4614 + 68] = mem[_4614 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _4614 + -mem[64] + 100
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _3426 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3426] = 30
            mem[_3426 + 32] = 'SafeMath: subtraction overflow'
            if ext_call.return_data[0] > ext_call.return_data[0]:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                idx = 32
                while idx < 30:
                    mem[idx + mem[64] + 68] = mem[idx + _3426 + 32]
                    idx = idx + 32
                    continue 
                revert with 0, 'SafeMath: subtraction overflow'
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = 0
            require ext_code.size(sphereTokenAddress)
            call sphereTokenAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args address(this.address), 0
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _3773 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3773] = 26
            mem[_3773 + 32] = 'SafeMath: division by zero'
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                    _4617 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4617] = 26
                    mem[_4617 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4729 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4729 + 68] = mem[idx + _4617 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4729 + 68] = mem[_4729 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4729 + -mem[64] + 100
                if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _4660 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4660] = 26
                mem[_4660 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _4796 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _4796 + 68] = mem[idx + _4660 + 32]
                    idx = idx + 32
                    continue 
                mem[_4796 + 68] = mem[_4796 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _4796 + -mem[64] + 100
            _4403 = mem[64]
            mem[64] = mem[64] + 64
            mem[_4403] = 26
            mem[_4403 + 32] = 'SafeMath: division by zero'
            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                revert with 0, 'SafeMath: addition overflow'
            amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
            if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                _5143 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5143] = 26
                mem[_5143 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5225 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5225 + 68] = mem[idx + _5143 + 32]
                    idx = idx + 32
                    continue 
                mem[_5225 + 68] = mem[_5225 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5225 + -mem[64] + 100
            if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _5183 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5183] = 26
            mem[_5183 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0]:
                if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _5258 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _5258 + 68] = mem[idx + _5183 + 32]
                idx = idx + 32
                continue 
            mem[_5258 + 68] = mem[_5258 + 74 len 26]
            revert with memory
              from mem[64]
               len _5258 + -mem[64] + 100
        require ext_code.size(sphereTokenAddress)
        staticcall sphereTokenAddress.0xd5abeb01 with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(sphereTokenAddress)
        staticcall sphereTokenAddress.0x18160ddd with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(sphereTokenAddress)
        if ext_call.return_data[0] >= ext_call.return_data[0]:
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint
                require ext_code.size(sphereTokenAddress)
                call sphereTokenAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3382 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3382] = 26
                mem[_3382 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                    if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                        _3917 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3917] = 26
                        mem[_3917 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4013 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4013 + 68] = mem[idx + _3917 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4013 + 68] = mem[_4013 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4013 + -mem[64] + 100
                    if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _3960 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3960] = 26
                    mem[_3960 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4064 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4064 + 68] = mem[idx + _3960 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4064 + 68] = mem[_4064 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4064 + -mem[64] + 100
                _3768 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3768] = 26
                mem[_3768 + 32] = 'SafeMath: division by zero'
                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                    revert with 0, 'SafeMath: addition overflow'
                amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
                if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                    _4444 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4444] = 26
                    mem[_4444 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4553 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4553 + 68] = mem[idx + _4444 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4553 + 68] = mem[_4553 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4553 + -mem[64] + 100
                if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _4500 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4500] = 26
                mem[_4500 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _4608 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _4608 + 68] = mem[idx + _4500 + 32]
                    idx = idx + 32
                    continue 
                mem[_4608 + 68] = mem[_4608 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _4608 + -mem[64] + 100
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            if ext_call.return_data[0] >= ext_call.return_data[0]:
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3476 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3476] = 26
                mem[_3476 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                    if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                        _4118 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4118] = 26
                        mem[_4118 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4227 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4227 + 68] = mem[idx + _4118 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4227 + 68] = mem[_4227 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4227 + -mem[64] + 100
                    if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4170 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4170] = 26
                    mem[_4170 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4289 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4289 + 68] = mem[idx + _4170 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4289 + 68] = mem[_4289 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4289 + -mem[64] + 100
                _3915 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3915] = 26
                mem[_3915 + 32] = 'SafeMath: division by zero'
                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                    revert with 0, 'SafeMath: addition overflow'
                amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
                if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                    _4656 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4656] = 26
                    mem[_4656 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4778 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4778 + 68] = mem[idx + _4656 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4778 + 68] = mem[_4778 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4778 + -mem[64] + 100
                if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _4719 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4719] = 26
                mem[_4719 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _4841 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _4841 + 68] = mem[idx + _4719 + 32]
                    idx = idx + 32
                    continue 
                mem[_4841 + 68] = mem[_4841 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _4841 + -mem[64] + 100
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _3536 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3536] = 30
            mem[_3536 + 32] = 'SafeMath: subtraction overflow'
            if ext_call.return_data[0] > ext_call.return_data[0]:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                idx = 32
                while idx < 30:
                    mem[idx + mem[64] + 68] = mem[idx + _3536 + 32]
                    idx = idx + 32
                    continue 
                revert with 0, 'SafeMath: subtraction overflow'
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = 0
            require ext_code.size(sphereTokenAddress)
            call sphereTokenAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args address(this.address), 0
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _3916 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3916] = 26
            mem[_3916 + 32] = 'SafeMath: division by zero'
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                    _4844 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4844] = 26
                    mem[_4844 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4955 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4955 + 68] = mem[idx + _4844 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4955 + 68] = mem[_4955 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4955 + -mem[64] + 100
                if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _4895 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4895] = 26
                mem[_4895 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5010 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5010 + 68] = mem[idx + _4895 + 32]
                    idx = idx + 32
                    continue 
                mem[_5010 + 68] = mem[_5010 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5010 + -mem[64] + 100
            _4607 = mem[64]
            mem[64] = mem[64] + 64
            mem[_4607] = 26
            mem[_4607 + 32] = 'SafeMath: division by zero'
            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                revert with 0, 'SafeMath: addition overflow'
            amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
            if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                _5282 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5282] = 26
                mem[_5282 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5361 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5361 + 68] = mem[idx + _5282 + 32]
                    idx = idx + 32
                    continue 
                mem[_5361 + 68] = mem[_5361 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5361 + -mem[64] + 100
            if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _5319 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5319] = 26
            mem[_5319 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0]:
                if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _5402 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _5402 + 68] = mem[idx + _5319 + 32]
                idx = idx + 32
                continue 
            mem[_5402 + 68] = mem[_5402 + 74 len 26]
            revert with memory
              from mem[64]
               len _5402 + -mem[64] + 100
        staticcall sphereTokenAddress.0x18160ddd with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(sphereTokenAddress)
        staticcall sphereTokenAddress.0xd5abeb01 with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        _3106 = mem[64]
        mem[64] = mem[64] + 64
        mem[_3106] = 30
        mem[_3106 + 32] = 'SafeMath: subtraction overflow'
        if ext_call.return_data[0] > ext_call.return_data[0]:
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
            idx = 32
            while idx < 30:
                mem[idx + mem[64] + 68] = mem[idx + _3106 + 32]
                idx = idx + 32
                continue 
            revert with 0, 'SafeMath: subtraction overflow'
        mem[mem[64] + 4] = devAddress
        mem[mem[64] + 36] = 0
        require ext_code.size(sphereTokenAddress)
        call sphereTokenAddress.0x40c10f19 with:
             gas gas_remaining wei
            args devAddress, 0
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require ext_code.size(sphereTokenAddress)
        staticcall sphereTokenAddress.0xd5abeb01 with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(sphereTokenAddress)
        staticcall sphereTokenAddress.0x18160ddd with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
            revert with 0, 'SafeMath: addition overflow'
        if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint
            require ext_code.size(sphereTokenAddress)
            call sphereTokenAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args address(this.address), (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _3771 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3771] = 26
            mem[_3771 + 32] = 'SafeMath: division by zero'
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                    _4613 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4613] = 26
                    mem[_4613 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4723 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4723 + 68] = mem[idx + _4613 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4723 + 68] = mem[_4723 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4723 + -mem[64] + 100
                if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _4658 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4658] = 26
                mem[_4658 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _4788 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _4788 + 68] = mem[idx + _4658 + 32]
                    idx = idx + 32
                    continue 
                mem[_4788 + 68] = mem[_4788 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _4788 + -mem[64] + 100
            _4400 = mem[64]
            mem[64] = mem[64] + 64
            mem[_4400] = 26
            mem[_4400 + 32] = 'SafeMath: division by zero'
            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                revert with 0, 'SafeMath: addition overflow'
            amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
            if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                _5142 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5142] = 26
                mem[_5142 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5222 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5222 + 68] = mem[idx + _5142 + 32]
                    idx = idx + 32
                    continue 
                mem[_5222 + 68] = mem[_5222 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5222 + -mem[64] + 100
            if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _5182 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5182] = 26
            mem[_5182 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0]:
                if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _5255 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _5255 + 68] = mem[idx + _5182 + 32]
                idx = idx + 32
                continue 
            mem[_5255 + 68] = mem[_5255 + 74 len 26]
            revert with memory
              from mem[64]
               len _5255 + -mem[64] + 100
        require ext_code.size(sphereTokenAddress)
        staticcall sphereTokenAddress.0xd5abeb01 with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(sphereTokenAddress)
        staticcall sphereTokenAddress.0x18160ddd with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(sphereTokenAddress)
        if ext_call.return_data[0] >= ext_call.return_data[0]:
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _3918 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3918] = 26
            mem[_3918 + 32] = 'SafeMath: division by zero'
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                    _4848 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4848] = 26
                    mem[_4848 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4958 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4958 + 68] = mem[idx + _4848 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4958 + 68] = mem[_4958 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4958 + -mem[64] + 100
                if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _4898 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4898] = 26
                mem[_4898 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5015 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5015 + 68] = mem[idx + _4898 + 32]
                    idx = idx + 32
                    continue 
                mem[_5015 + 68] = mem[_5015 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5015 + -mem[64] + 100
            _4611 = mem[64]
            mem[64] = mem[64] + 64
            mem[_4611] = 26
            mem[_4611 + 32] = 'SafeMath: division by zero'
            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                revert with 0, 'SafeMath: addition overflow'
            amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
            if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                _5283 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5283] = 26
                mem[_5283 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5364 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5364 + 68] = mem[idx + _5283 + 32]
                    idx = idx + 32
                    continue 
                mem[_5364 + 68] = mem[_5364 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5364 + -mem[64] + 100
            if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _5320 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5320] = 26
            mem[_5320 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0]:
                if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _5405 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _5405 + 68] = mem[idx + _5320 + 32]
                idx = idx + 32
                continue 
            mem[_5405 + 68] = mem[_5405 + 74 len 26]
            revert with memory
              from mem[64]
               len _5405 + -mem[64] + 100
        staticcall sphereTokenAddress.0x18160ddd with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(sphereTokenAddress)
        staticcall sphereTokenAddress.0xd5abeb01 with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        _4016 = mem[64]
        mem[64] = mem[64] + 64
        mem[_4016] = 30
        mem[_4016 + 32] = 'SafeMath: subtraction overflow'
        if ext_call.return_data[0] > ext_call.return_data[0]:
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
            idx = 32
            while idx < 30:
                mem[idx + mem[64] + 68] = mem[idx + _4016 + 32]
                idx = idx + 32
                continue 
            revert with 0, 'SafeMath: subtraction overflow'
        mem[mem[64] + 4] = this.address
        mem[mem[64] + 36] = 0
        require ext_code.size(sphereTokenAddress)
        call sphereTokenAddress.0x40c10f19 with:
             gas gas_remaining wei
            args address(this.address), 0
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require ext_code.size(sphereTokenAddress)
        staticcall sphereTokenAddress.0xd5abeb01 with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        _4612 = mem[64]
        mem[64] = mem[64] + 64
        mem[_4612] = 26
        mem[_4612 + 32] = 'SafeMath: division by zero'
        require ext_code.size(sphereTokenAddress)
        staticcall sphereTokenAddress.0x18160ddd with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
            revert with 0, 'SafeMath: addition overflow'
        if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
            if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                _5408 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5408] = 26
                mem[_5408 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5470 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5470 + 68] = mem[idx + _5408 + 32]
                    idx = idx + 32
                    continue 
                mem[_5470 + 68] = mem[_5470 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5470 + -mem[64] + 100
            if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _5436 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5436] = 26
            mem[_5436 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0]:
                if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _5499 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _5499 + 68] = mem[idx + _5436 + 32]
                idx = idx + 32
                continue 
            mem[_5499 + 68] = mem[_5499 + 74 len 26]
            revert with memory
              from mem[64]
               len _5499 + -mem[64] + 100
        _5254 = mem[64]
        mem[64] = mem[64] + 64
        mem[_5254] = 26
        mem[_5254 + 32] = 'SafeMath: division by zero'
        if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
            revert with 0, 'SafeMath: addition overflow'
        amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
        if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
            _5586 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5586] = 26
            mem[_5586 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0]:
                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _5604 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _5604 + 68] = mem[idx + _5586 + 32]
                idx = idx + 32
                continue 
            mem[_5604 + 68] = mem[_5604 + 74 len 26]
            revert with memory
              from mem[64]
               len _5604 + -mem[64] + 100
        if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        _5594 = mem[64]
        mem[64] = mem[64] + 64
        mem[_5594] = 26
        mem[_5594 + 32] = 'SafeMath: division by zero'
        if ext_call.return_data[0]:
            if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                revert with 0, 'SafeMath: addition overflow'
            poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
            poolInfo[idx].field_512 = block.number
            idx = idx + 1
            continue 
        _5613 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 26
        idx = 0
        while idx < 26:
            mem[idx + _5613 + 68] = mem[idx + _5594 + 32]
            idx = idx + 32
            continue 
        mem[_5613 + 68] = mem[_5613 + 74 len 26]
        revert with memory
          from mem[64]
           len _5613 + -mem[64] + 100
}

function setStartBlock(uint256 arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'sOwnable: caller is not the owne'
    if block.number >= arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    34,
                    0xfe63616e6e6f742073657420737461727420626c6f636b20696e2074686520706173,
                    mem[198 len 30]
    startBlock = arg1
    idx = 0
    while idx < poolInfo.length:
        mem[0] = 10
        if block.number <= poolInfo[idx].field_512:
            idx = idx + 1
            continue 
        mem[mem[64] + 4] = this.address
        require ext_code.size(poolInfo[idx].field_0)
        staticcall poolInfo[idx].field_0.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if not ext_call.return_data[0]:
            poolInfo[idx].field_512 = block.number
            idx = idx + 1
            continue 
        if not poolInfo[idx].field_256:
            poolInfo[idx].field_512 = block.number
            idx = idx + 1
            continue 
        require ext_code.size(sphereTokenAddress)
        staticcall sphereTokenAddress.0xd5abeb01 with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(sphereTokenAddress)
        staticcall sphereTokenAddress.0x18160ddd with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] >= ext_call.return_data[0]:
            _2860 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2860] = 26
            mem[_2860 + 32] = 'SafeMath: division by zero'
            if not totalAllocPoint:
                _2861 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _2861 + 68] = mem[idx + _2860 + 32]
                    idx = idx + 32
                    continue 
                mem[_2861 + 68] = mem[_2861 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _2861 + -mem[64] + 100
            _2875 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2875] = 26
            mem[_2875 + 32] = 'SafeMath: division by zero'
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] <= ext_call.return_data[0]:
                mem[mem[64] + 4] = devAddress
                mem[mem[64] + 36] = 0 / totalAllocPoint / 20
                require ext_code.size(sphereTokenAddress)
                call sphereTokenAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devAddress, 0 / totalAllocPoint / 20
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sphereTokenAddress)
                    call sphereTokenAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0xd5abeb01 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    _3186 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3186] = 26
                    mem[_3186 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                        revert with 0, 'SafeMath: addition overflow'
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                        if not 0 / totalAllocPoint:
                            _3607 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3607] = 26
                            mem[_3607 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3669 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3669 + 68] = mem[idx + _3607 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3669 + 68] = mem[_3669 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3669 + -mem[64] + 100
                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _3639 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3639] = 26
                        mem[_3639 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3702 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _3702 + 68] = mem[idx + _3639 + 32]
                            idx = idx + 32
                            continue 
                        mem[_3702 + 68] = mem[_3702 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3702 + -mem[64] + 100
                    _3482 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3482] = 26
                    mem[_3482 + 32] = 'SafeMath: division by zero'
                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                        revert with 0, 'SafeMath: addition overflow'
                    amountToBurn += 0 / totalAllocPoint / 20
                    if not 0 / totalAllocPoint:
                        _3966 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3966] = 26
                        mem[_3966 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4066 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4066 + 68] = mem[idx + _3966 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4066 + 68] = mem[_4066 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4066 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4019 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4019] = 26
                    mem[_4019 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4122 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4122 + 68] = mem[idx + _4019 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4122 + 68] = mem[_4122 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4122 + -mem[64] + 100
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                if ext_call.return_data[0] >= ext_call.return_data[0]:
                    staticcall sphereTokenAddress.0xd5abeb01 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    _3272 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3272] = 26
                    mem[_3272 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                        revert with 0, 'SafeMath: addition overflow'
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                        if not 0 / totalAllocPoint:
                            _3737 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3737] = 26
                            mem[_3737 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3798 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3798 + 68] = mem[idx + _3737 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3798 + 68] = mem[_3798 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3798 + -mem[64] + 100
                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _3766 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3766] = 26
                        mem[_3766 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3835 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _3835 + 68] = mem[idx + _3766 + 32]
                            idx = idx + 32
                            continue 
                        mem[_3835 + 68] = mem[_3835 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3835 + -mem[64] + 100
                    _3605 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3605] = 26
                    mem[_3605 + 32] = 'SafeMath: division by zero'
                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                        revert with 0, 'SafeMath: addition overflow'
                    amountToBurn += 0 / totalAllocPoint / 20
                    if not 0 / totalAllocPoint:
                        _4175 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4175] = 26
                        mem[_4175 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4288 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4288 + 68] = mem[idx + _4175 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4288 + 68] = mem[_4288 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4288 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4230 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4230] = 26
                    mem[_4230 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4348 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4348 + 68] = mem[idx + _4230 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4348 + 68] = mem[_4348 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4348 + -mem[64] + 100
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3316 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3316] = 30
                mem[_3316 + 32] = 'SafeMath: subtraction overflow'
                if ext_call.return_data[0] > ext_call.return_data[0]:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                    idx = 32
                    while idx < 30:
                        mem[idx + mem[64] + 68] = mem[idx + _3316 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: subtraction overflow'
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0
                require ext_code.size(sphereTokenAddress)
                call sphereTokenAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3606 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3606] = 26
                mem[_3606 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                    if not 0 / totalAllocPoint:
                        _4351 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4351] = 26
                        mem[_4351 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4443 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4443 + 68] = mem[idx + _4351 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4443 + 68] = mem[_4443 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4443 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4396 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4396] = 26
                    mem[_4396 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4499 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4499 + 68] = mem[idx + _4396 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4499 + 68] = mem[_4499 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4499 + -mem[64] + 100
                _4121 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4121] = 26
                mem[_4121 + 32] = 'SafeMath: division by zero'
                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                    revert with 0, 'SafeMath: addition overflow'
                amountToBurn += 0 / totalAllocPoint / 20
                if not 0 / totalAllocPoint:
                    _4900 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4900] = 26
                    mem[_4900 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5011 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5011 + 68] = mem[idx + _4900 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5011 + 68] = mem[_5011 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5011 + -mem[64] + 100
                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _4958 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4958] = 26
                mem[_4958 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5064 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5064 + 68] = mem[idx + _4958 + 32]
                    idx = idx + 32
                    continue 
                mem[_5064 + 68] = mem[_5064 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5064 + -mem[64] + 100
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            if ext_call.return_data[0] >= ext_call.return_data[0]:
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sphereTokenAddress)
                    call sphereTokenAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0xd5abeb01 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    _3270 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3270] = 26
                    mem[_3270 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                        revert with 0, 'SafeMath: addition overflow'
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                        if not 0 / totalAllocPoint:
                            _3734 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3734] = 26
                            mem[_3734 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3794 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3794 + 68] = mem[idx + _3734 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3794 + 68] = mem[_3794 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3794 + -mem[64] + 100
                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _3762 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3762] = 26
                        mem[_3762 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3829 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _3829 + 68] = mem[idx + _3762 + 32]
                            idx = idx + 32
                            continue 
                        mem[_3829 + 68] = mem[_3829 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3829 + -mem[64] + 100
                    _3601 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3601] = 26
                    mem[_3601 + 32] = 'SafeMath: division by zero'
                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                        revert with 0, 'SafeMath: addition overflow'
                    amountToBurn += 0 / totalAllocPoint / 20
                    if not 0 / totalAllocPoint:
                        _4172 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4172] = 26
                        mem[_4172 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4282 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4282 + 68] = mem[idx + _4172 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4282 + 68] = mem[_4282 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4282 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4228 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4228] = 26
                    mem[_4228 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4342 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4342 + 68] = mem[idx + _4228 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4342 + 68] = mem[_4342 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4342 + -mem[64] + 100
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                if ext_call.return_data[0] >= ext_call.return_data[0]:
                    staticcall sphereTokenAddress.0xd5abeb01 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    _3356 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3356] = 26
                    mem[_3356 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                        revert with 0, 'SafeMath: addition overflow'
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                        if not 0 / totalAllocPoint:
                            _3870 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3870] = 26
                            mem[_3870 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3949 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3949 + 68] = mem[idx + _3870 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3949 + 68] = mem[_3949 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3949 + -mem[64] + 100
                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _3908 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3908] = 26
                        mem[_3908 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4004 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4004 + 68] = mem[idx + _3908 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4004 + 68] = mem[_4004 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4004 + -mem[64] + 100
                    _3732 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3732] = 26
                    mem[_3732 + 32] = 'SafeMath: division by zero'
                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                        revert with 0, 'SafeMath: addition overflow'
                    amountToBurn += 0 / totalAllocPoint / 20
                    if not 0 / totalAllocPoint:
                        _4392 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4392] = 26
                        mem[_4392 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4481 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4481 + 68] = mem[idx + _4392 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4481 + 68] = mem[_4481 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4481 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4433 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4433] = 26
                    mem[_4433 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4545 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4545 + 68] = mem[idx + _4433 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4545 + 68] = mem[_4545 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4545 + -mem[64] + 100
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3403 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3403] = 30
                mem[_3403 + 32] = 'SafeMath: subtraction overflow'
                if ext_call.return_data[0] > ext_call.return_data[0]:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                    idx = 32
                    while idx < 30:
                        mem[idx + mem[64] + 68] = mem[idx + _3403 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: subtraction overflow'
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0
                require ext_code.size(sphereTokenAddress)
                call sphereTokenAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3733 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3733] = 26
                mem[_3733 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                    if not 0 / totalAllocPoint:
                        _4548 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4548] = 26
                        mem[_4548 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4651 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4651 + 68] = mem[idx + _4548 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4651 + 68] = mem[_4651 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4651 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4598 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4598] = 26
                    mem[_4598 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4709 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4709 + 68] = mem[idx + _4598 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4709 + 68] = mem[_4709 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4709 + -mem[64] + 100
                _4341 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4341] = 26
                mem[_4341 + 32] = 'SafeMath: division by zero'
                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                    revert with 0, 'SafeMath: addition overflow'
                amountToBurn += 0 / totalAllocPoint / 20
                if not 0 / totalAllocPoint:
                    _5099 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5099] = 26
                    mem[_5099 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5169 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5169 + 68] = mem[idx + _5099 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5169 + 68] = mem[_5169 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5169 + -mem[64] + 100
                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5133 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5133] = 26
                mem[_5133 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5212 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5212 + 68] = mem[idx + _5133 + 32]
                    idx = idx + 32
                    continue 
                mem[_5212 + 68] = mem[_5212 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5212 + -mem[64] + 100
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _3037 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3037] = 30
            mem[_3037 + 32] = 'SafeMath: subtraction overflow'
            if ext_call.return_data[0] > ext_call.return_data[0]:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                idx = 32
                while idx < 30:
                    mem[idx + mem[64] + 68] = mem[idx + _3037 + 32]
                    idx = idx + 32
                    continue 
                revert with 0, 'SafeMath: subtraction overflow'
            mem[mem[64] + 4] = devAddress
            mem[mem[64] + 36] = 0
            require ext_code.size(sphereTokenAddress)
            call sphereTokenAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args devAddress, 0
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sphereTokenAddress)
                call sphereTokenAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3604 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3604] = 26
                mem[_3604 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                    if not 0 / totalAllocPoint:
                        _4347 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4347] = 26
                        mem[_4347 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4437 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4437 + 68] = mem[idx + _4347 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4437 + 68] = mem[_4437 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4437 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4394 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4394] = 26
                    mem[_4394 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4491 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4491 + 68] = mem[idx + _4394 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4491 + 68] = mem[_4491 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4491 + -mem[64] + 100
                _4118 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4118] = 26
                mem[_4118 + 32] = 'SafeMath: division by zero'
                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                    revert with 0, 'SafeMath: addition overflow'
                amountToBurn += 0 / totalAllocPoint / 20
                if not 0 / totalAllocPoint:
                    _4899 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4899] = 26
                    mem[_4899 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5008 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5008 + 68] = mem[idx + _4899 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5008 + 68] = mem[_5008 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5008 + -mem[64] + 100
                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _4957 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4957] = 26
                mem[_4957 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5061 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5061 + 68] = mem[idx + _4957 + 32]
                    idx = idx + 32
                    continue 
                mem[_5061 + 68] = mem[_5061 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5061 + -mem[64] + 100
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            if ext_call.return_data[0] >= ext_call.return_data[0]:
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3735 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3735] = 26
                mem[_3735 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                    if not 0 / totalAllocPoint:
                        _4552 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4552] = 26
                        mem[_4552 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4654 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4654 + 68] = mem[idx + _4552 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4654 + 68] = mem[_4654 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4654 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4601 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4601] = 26
                    mem[_4601 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4714 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4714 + 68] = mem[idx + _4601 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4714 + 68] = mem[_4714 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4714 + -mem[64] + 100
                _4345 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4345] = 26
                mem[_4345 + 32] = 'SafeMath: division by zero'
                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                    revert with 0, 'SafeMath: addition overflow'
                amountToBurn += 0 / totalAllocPoint / 20
                if not 0 / totalAllocPoint:
                    _5100 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5100] = 26
                    mem[_5100 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5172 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5172 + 68] = mem[idx + _5100 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5172 + 68] = mem[_5172 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5172 + -mem[64] + 100
                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5134 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5134] = 26
                mem[_5134 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5215 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5215 + 68] = mem[idx + _5134 + 32]
                    idx = idx + 32
                    continue 
                mem[_5215 + 68] = mem[_5215 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5215 + -mem[64] + 100
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _3797 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3797] = 30
            mem[_3797 + 32] = 'SafeMath: subtraction overflow'
            if ext_call.return_data[0] > ext_call.return_data[0]:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                idx = 32
                while idx < 30:
                    mem[idx + mem[64] + 68] = mem[idx + _3797 + 32]
                    idx = idx + 32
                    continue 
                revert with 0, 'SafeMath: subtraction overflow'
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = 0
            require ext_code.size(sphereTokenAddress)
            call sphereTokenAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args address(this.address), 0
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _4346 = mem[64]
            mem[64] = mem[64] + 64
            mem[_4346] = 26
            mem[_4346 + 32] = 'SafeMath: division by zero'
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                if not 0 / totalAllocPoint:
                    _5218 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5218] = 26
                    mem[_5218 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5286 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5286 + 68] = mem[idx + _5218 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5286 + 68] = mem[_5286 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5286 + -mem[64] + 100
                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5252 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5252] = 26
                mem[_5252 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5321 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5321 + 68] = mem[idx + _5252 + 32]
                    idx = idx + 32
                    continue 
                mem[_5321 + 68] = mem[_5321 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5321 + -mem[64] + 100
            _5060 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5060] = 26
            mem[_5060 + 32] = 'SafeMath: division by zero'
            if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                revert with 0, 'SafeMath: addition overflow'
            amountToBurn += 0 / totalAllocPoint / 20
            if not 0 / totalAllocPoint:
                _5544 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5544] = 26
                mem[_5544 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5567 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5567 + 68] = mem[idx + _5544 + 32]
                    idx = idx + 32
                    continue 
                mem[_5567 + 68] = mem[_5567 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5567 + -mem[64] + 100
            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _5558 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5558] = 26
            mem[_5558 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0]:
                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _5577 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _5577 + 68] = mem[idx + _5558 + 32]
                idx = idx + 32
                continue 
            mem[_5577 + 68] = mem[_5577 + 74 len 26]
            revert with memory
              from mem[64]
               len _5577 + -mem[64] + 100
        _2846 = mem[64]
        mem[64] = mem[64] + 64
        mem[_2846] = 30
        mem[_2846 + 32] = 'SafeMath: subtraction overflow'
        if poolInfo[idx].field_512 > block.number:
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
            idx = 32
            while idx < 30:
                mem[idx + mem[64] + 68] = mem[idx + _2846 + 32]
                idx = idx + 32
                continue 
            revert with 0, 'SafeMath: subtraction overflow'
        if not block.number - poolInfo[idx].field_512:
            _2866 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2866] = 26
            mem[_2866 + 32] = 'SafeMath: division by zero'
            if not totalAllocPoint:
                _2872 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _2872 + 68] = mem[idx + _2866 + 32]
                    idx = idx + 32
                    continue 
                mem[_2872 + 68] = mem[_2872 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _2872 + -mem[64] + 100
            _2890 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2890] = 26
            mem[_2890 + 32] = 'SafeMath: division by zero'
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] <= ext_call.return_data[0]:
                mem[mem[64] + 4] = devAddress
                mem[mem[64] + 36] = 0 / totalAllocPoint / 20
                require ext_code.size(sphereTokenAddress)
                call sphereTokenAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devAddress, 0 / totalAllocPoint / 20
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sphereTokenAddress)
                    call sphereTokenAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0xd5abeb01 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    _3267 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3267] = 26
                    mem[_3267 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                        revert with 0, 'SafeMath: addition overflow'
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                        if not 0 / totalAllocPoint:
                            _3731 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3731] = 26
                            mem[_3731 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3791 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3791 + 68] = mem[idx + _3731 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3791 + 68] = mem[_3791 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3791 + -mem[64] + 100
                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _3761 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3761] = 26
                        mem[_3761 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3822 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _3822 + 68] = mem[idx + _3761 + 32]
                            idx = idx + 32
                            continue 
                        mem[_3822 + 68] = mem[_3822 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3822 + -mem[64] + 100
                    _3597 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3597] = 26
                    mem[_3597 + 32] = 'SafeMath: division by zero'
                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                        revert with 0, 'SafeMath: addition overflow'
                    amountToBurn += 0 / totalAllocPoint / 20
                    if not 0 / totalAllocPoint:
                        _4166 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4166] = 26
                        mem[_4166 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4277 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4277 + 68] = mem[idx + _4166 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4277 + 68] = mem[_4277 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4277 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4224 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4224] = 26
                    mem[_4224 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4336 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4336 + 68] = mem[idx + _4224 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4336 + 68] = mem[_4336 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4336 + -mem[64] + 100
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                if ext_call.return_data[0] >= ext_call.return_data[0]:
                    staticcall sphereTokenAddress.0xd5abeb01 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    _3354 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3354] = 26
                    mem[_3354 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                        revert with 0, 'SafeMath: addition overflow'
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                        if not 0 / totalAllocPoint:
                            _3868 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3868] = 26
                            mem[_3868 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3943 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3943 + 68] = mem[idx + _3868 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3943 + 68] = mem[_3943 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3943 + -mem[64] + 100
                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _3902 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3902] = 26
                        mem[_3902 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3995 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _3995 + 68] = mem[idx + _3902 + 32]
                            idx = idx + 32
                            continue 
                        mem[_3995 + 68] = mem[_3995 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3995 + -mem[64] + 100
                    _3729 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3729] = 26
                    mem[_3729 + 32] = 'SafeMath: division by zero'
                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                        revert with 0, 'SafeMath: addition overflow'
                    amountToBurn += 0 / totalAllocPoint / 20
                    if not 0 / totalAllocPoint:
                        _4390 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4390] = 26
                        mem[_4390 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4473 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4473 + 68] = mem[idx + _4390 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4473 + 68] = mem[_4473 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4473 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4429 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4429] = 26
                    mem[_4429 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4538 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4538 + 68] = mem[idx + _4429 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4538 + 68] = mem[_4538 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4538 + -mem[64] + 100
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3402 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3402] = 30
                mem[_3402 + 32] = 'SafeMath: subtraction overflow'
                if ext_call.return_data[0] > ext_call.return_data[0]:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                    idx = 32
                    while idx < 30:
                        mem[idx + mem[64] + 68] = mem[idx + _3402 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: subtraction overflow'
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0
                require ext_code.size(sphereTokenAddress)
                call sphereTokenAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3730 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3730] = 26
                mem[_3730 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                    if not 0 / totalAllocPoint:
                        _4541 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4541] = 26
                        mem[_4541 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4645 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4645 + 68] = mem[idx + _4541 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4645 + 68] = mem[_4645 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4645 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4594 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4594] = 26
                    mem[_4594 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4701 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4701 + 68] = mem[idx + _4594 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4701 + 68] = mem[_4701 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4701 + -mem[64] + 100
                _4335 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4335] = 26
                mem[_4335 + 32] = 'SafeMath: division by zero'
                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                    revert with 0, 'SafeMath: addition overflow'
                amountToBurn += 0 / totalAllocPoint / 20
                if not 0 / totalAllocPoint:
                    _5098 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5098] = 26
                    mem[_5098 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5166 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5166 + 68] = mem[idx + _5098 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5166 + 68] = mem[_5166 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5166 + -mem[64] + 100
                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5132 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5132] = 26
                mem[_5132 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5209 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5209 + 68] = mem[idx + _5132 + 32]
                    idx = idx + 32
                    continue 
                mem[_5209 + 68] = mem[_5209 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5209 + -mem[64] + 100
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            if ext_call.return_data[0] >= ext_call.return_data[0]:
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sphereTokenAddress)
                    call sphereTokenAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0xd5abeb01 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    _3352 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3352] = 26
                    mem[_3352 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                        revert with 0, 'SafeMath: addition overflow'
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                        if not 0 / totalAllocPoint:
                            _3865 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3865] = 26
                            mem[_3865 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3939 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3939 + 68] = mem[idx + _3865 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3939 + 68] = mem[_3939 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3939 + -mem[64] + 100
                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _3898 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3898] = 26
                        mem[_3898 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3989 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _3989 + 68] = mem[idx + _3898 + 32]
                            idx = idx + 32
                            continue 
                        mem[_3989 + 68] = mem[_3989 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3989 + -mem[64] + 100
                    _3725 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3725] = 26
                    mem[_3725 + 32] = 'SafeMath: division by zero'
                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                        revert with 0, 'SafeMath: addition overflow'
                    amountToBurn += 0 / totalAllocPoint / 20
                    if not 0 / totalAllocPoint:
                        _4387 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4387] = 26
                        mem[_4387 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4467 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4467 + 68] = mem[idx + _4387 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4467 + 68] = mem[_4467 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4467 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4427 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4427] = 26
                    mem[_4427 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4532 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4532 + 68] = mem[idx + _4427 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4532 + 68] = mem[_4532 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4532 + -mem[64] + 100
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                if ext_call.return_data[0] >= ext_call.return_data[0]:
                    staticcall sphereTokenAddress.0xd5abeb01 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    _3438 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3438] = 26
                    mem[_3438 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                        revert with 0, 'SafeMath: addition overflow'
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                        if not 0 / totalAllocPoint:
                            _4047 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4047] = 26
                            mem[_4047 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _4149 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4149 + 68] = mem[idx + _4047 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4149 + 68] = mem[_4149 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _4149 + -mem[64] + 100
                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _4096 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4096] = 26
                        mem[_4096 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4209 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4209 + 68] = mem[idx + _4096 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4209 + 68] = mem[_4209 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4209 + -mem[64] + 100
                    _3863 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3863] = 26
                    mem[_3863 + 32] = 'SafeMath: division by zero'
                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                        revert with 0, 'SafeMath: addition overflow'
                    amountToBurn += 0 / totalAllocPoint / 20
                    if not 0 / totalAllocPoint:
                        _4590 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4590] = 26
                        mem[_4590 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4683 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4683 + 68] = mem[idx + _4590 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4683 + 68] = mem[_4683 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4683 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4635 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4635] = 26
                    mem[_4635 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4762 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4762 + 68] = mem[idx + _4635 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4762 + 68] = mem[_4762 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4762 + -mem[64] + 100
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3499 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3499] = 30
                mem[_3499 + 32] = 'SafeMath: subtraction overflow'
                if ext_call.return_data[0] > ext_call.return_data[0]:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                    idx = 32
                    while idx < 30:
                        mem[idx + mem[64] + 68] = mem[idx + _3499 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: subtraction overflow'
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0
                require ext_code.size(sphereTokenAddress)
                call sphereTokenAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3864 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3864] = 26
                mem[_3864 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                    if not 0 / totalAllocPoint:
                        _4765 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4765] = 26
                        mem[_4765 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4879 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4879 + 68] = mem[idx + _4765 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4879 + 68] = mem[_4879 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4879 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4822 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4822] = 26
                    mem[_4822 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4934 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4934 + 68] = mem[idx + _4822 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4934 + 68] = mem[_4934 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4934 + -mem[64] + 100
                _4531 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4531] = 26
                mem[_4531 + 32] = 'SafeMath: division by zero'
                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                    revert with 0, 'SafeMath: addition overflow'
                amountToBurn += 0 / totalAllocPoint / 20
                if not 0 / totalAllocPoint:
                    _5246 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5246] = 26
                    mem[_5246 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5301 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5301 + 68] = mem[idx + _5246 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5301 + 68] = mem[_5301 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5301 + -mem[64] + 100
                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5272 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5272] = 26
                mem[_5272 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5348 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5348 + 68] = mem[idx + _5272 + 32]
                    idx = idx + 32
                    continue 
                mem[_5348 + 68] = mem[_5348 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5348 + -mem[64] + 100
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _3086 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3086] = 30
            mem[_3086 + 32] = 'SafeMath: subtraction overflow'
            if ext_call.return_data[0] > ext_call.return_data[0]:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                idx = 32
                while idx < 30:
                    mem[idx + mem[64] + 68] = mem[idx + _3086 + 32]
                    idx = idx + 32
                    continue 
                revert with 0, 'SafeMath: subtraction overflow'
            mem[mem[64] + 4] = devAddress
            mem[mem[64] + 36] = 0
            require ext_code.size(sphereTokenAddress)
            call sphereTokenAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args devAddress, 0
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sphereTokenAddress)
                call sphereTokenAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3728 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3728] = 26
                mem[_3728 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                    if not 0 / totalAllocPoint:
                        _4537 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4537] = 26
                        mem[_4537 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4639 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4639 + 68] = mem[idx + _4537 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4639 + 68] = mem[_4639 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4639 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4592 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4592] = 26
                    mem[_4592 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4693 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4693 + 68] = mem[idx + _4592 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4693 + 68] = mem[_4693 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4693 + -mem[64] + 100
                _4332 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4332] = 26
                mem[_4332 + 32] = 'SafeMath: division by zero'
                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                    revert with 0, 'SafeMath: addition overflow'
                amountToBurn += 0 / totalAllocPoint / 20
                if not 0 / totalAllocPoint:
                    _5097 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5097] = 26
                    mem[_5097 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5163 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5163 + 68] = mem[idx + _5097 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5163 + 68] = mem[_5163 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5163 + -mem[64] + 100
                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5131 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5131] = 26
                mem[_5131 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5206 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5206 + 68] = mem[idx + _5131 + 32]
                    idx = idx + 32
                    continue 
                mem[_5206 + 68] = mem[_5206 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5206 + -mem[64] + 100
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            if ext_call.return_data[0] >= ext_call.return_data[0]:
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3866 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3866] = 26
                mem[_3866 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                    if not 0 / totalAllocPoint:
                        _4769 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4769] = 26
                        mem[_4769 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4882 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4882 + 68] = mem[idx + _4769 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4882 + 68] = mem[_4882 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4882 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4825 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4825] = 26
                    mem[_4825 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4939 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4939 + 68] = mem[idx + _4825 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4939 + 68] = mem[_4939 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4939 + -mem[64] + 100
                _4535 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4535] = 26
                mem[_4535 + 32] = 'SafeMath: division by zero'
                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                    revert with 0, 'SafeMath: addition overflow'
                amountToBurn += 0 / totalAllocPoint / 20
                if not 0 / totalAllocPoint:
                    _5247 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5247] = 26
                    mem[_5247 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5304 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5304 + 68] = mem[idx + _5247 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5304 + 68] = mem[_5304 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5304 + -mem[64] + 100
                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5273 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5273] = 26
                mem[_5273 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5351 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5351 + 68] = mem[idx + _5273 + 32]
                    idx = idx + 32
                    continue 
                mem[_5351 + 68] = mem[_5351 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5351 + -mem[64] + 100
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _3942 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3942] = 30
            mem[_3942 + 32] = 'SafeMath: subtraction overflow'
            if ext_call.return_data[0] > ext_call.return_data[0]:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                idx = 32
                while idx < 30:
                    mem[idx + mem[64] + 68] = mem[idx + _3942 + 32]
                    idx = idx + 32
                    continue 
                revert with 0, 'SafeMath: subtraction overflow'
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = 0
            require ext_code.size(sphereTokenAddress)
            call sphereTokenAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args address(this.address), 0
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _4536 = mem[64]
            mem[64] = mem[64] + 64
            mem[_4536] = 26
            mem[_4536 + 32] = 'SafeMath: division by zero'
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                if not 0 / totalAllocPoint:
                    _5354 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5354] = 26
                    mem[_5354 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5435 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5435 + 68] = mem[idx + _5354 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5435 + 68] = mem[_5435 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5435 + -mem[64] + 100
                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5397 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5397] = 26
                mem[_5397 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5463 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5463 + 68] = mem[idx + _5397 + 32]
                    idx = idx + 32
                    continue 
                mem[_5463 + 68] = mem[_5463 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5463 + -mem[64] + 100
            _5205 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5205] = 26
            mem[_5205 + 32] = 'SafeMath: division by zero'
            if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                revert with 0, 'SafeMath: addition overflow'
            amountToBurn += 0 / totalAllocPoint / 20
            if not 0 / totalAllocPoint:
                _5584 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5584] = 26
                mem[_5584 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5595 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5595 + 68] = mem[idx + _5584 + 32]
                    idx = idx + 32
                    continue 
                mem[_5595 + 68] = mem[_5595 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5595 + -mem[64] + 100
            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _5589 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5589] = 26
            mem[_5589 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0]:
                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _5605 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _5605 + 68] = mem[idx + _5589 + 32]
                idx = idx + 32
                continue 
            mem[_5605 + 68] = mem[_5605 + 74 len 26]
            revert with memory
              from mem[64]
               len _5605 + -mem[64] + 100
        if (block.number * spherePerBlock) - (poolInfo[idx].field_512 * spherePerBlock) / block.number - poolInfo[idx].field_512 != spherePerBlock:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        if not (block.number * spherePerBlock) - (poolInfo[idx].field_512 * spherePerBlock):
            _2868 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2868] = 26
            mem[_2868 + 32] = 'SafeMath: division by zero'
            if not totalAllocPoint:
                _2877 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _2877 + 68] = mem[idx + _2868 + 32]
                    idx = idx + 32
                    continue 
                mem[_2877 + 68] = mem[_2877 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _2877 + -mem[64] + 100
            _2894 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2894] = 26
            mem[_2894 + 32] = 'SafeMath: division by zero'
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] <= ext_call.return_data[0]:
                mem[mem[64] + 4] = devAddress
                mem[mem[64] + 36] = 0 / totalAllocPoint / 20
                require ext_code.size(sphereTokenAddress)
                call sphereTokenAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devAddress, 0 / totalAllocPoint / 20
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sphereTokenAddress)
                    call sphereTokenAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0xd5abeb01 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    _3286 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3286] = 26
                    mem[_3286 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                        revert with 0, 'SafeMath: addition overflow'
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                        if not 0 / totalAllocPoint:
                            _3757 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3757] = 26
                            mem[_3757 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3813 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3813 + 68] = mem[idx + _3757 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3813 + 68] = mem[_3813 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3813 + -mem[64] + 100
                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _3785 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3785] = 26
                        mem[_3785 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3858 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _3858 + 68] = mem[idx + _3785 + 32]
                            idx = idx + 32
                            continue 
                        mem[_3858 + 68] = mem[_3858 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3858 + -mem[64] + 100
                    _3626 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3626] = 26
                    mem[_3626 + 32] = 'SafeMath: division by zero'
                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                        revert with 0, 'SafeMath: addition overflow'
                    amountToBurn += 0 / totalAllocPoint / 20
                    if not 0 / totalAllocPoint:
                        _4208 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4208] = 26
                        mem[_4208 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4321 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4321 + 68] = mem[idx + _4208 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4321 + 68] = mem[_4321 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4321 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4267 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4267] = 26
                    mem[_4267 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4379 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4379 + 68] = mem[idx + _4267 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4379 + 68] = mem[_4379 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4379 + -mem[64] + 100
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                if ext_call.return_data[0] >= ext_call.return_data[0]:
                    staticcall sphereTokenAddress.0xd5abeb01 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    _3370 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3370] = 26
                    mem[_3370 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                        revert with 0, 'SafeMath: addition overflow'
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                        if not 0 / totalAllocPoint:
                            _3896 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3896] = 26
                            mem[_3896 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3981 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3981 + 68] = mem[idx + _3896 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3981 + 68] = mem[_3981 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3981 + -mem[64] + 100
                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _3933 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3933] = 26
                        mem[_3933 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4038 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4038 + 68] = mem[idx + _3933 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4038 + 68] = mem[_4038 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4038 + -mem[64] + 100
                    _3755 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3755] = 26
                    mem[_3755 + 32] = 'SafeMath: division by zero'
                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                        revert with 0, 'SafeMath: addition overflow'
                    amountToBurn += 0 / totalAllocPoint / 20
                    if not 0 / totalAllocPoint:
                        _4422 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4422] = 26
                        mem[_4422 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4521 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4521 + 68] = mem[idx + _4422 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4521 + 68] = mem[_4521 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4521 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4461 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4461] = 26
                    mem[_4461 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4583 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4583 + 68] = mem[idx + _4461 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4583 + 68] = mem[_4583 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4583 + -mem[64] + 100
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3419 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3419] = 30
                mem[_3419 + 32] = 'SafeMath: subtraction overflow'
                if ext_call.return_data[0] > ext_call.return_data[0]:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                    idx = 32
                    while idx < 30:
                        mem[idx + mem[64] + 68] = mem[idx + _3419 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: subtraction overflow'
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0
                require ext_code.size(sphereTokenAddress)
                call sphereTokenAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3756 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3756] = 26
                mem[_3756 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                    if not 0 / totalAllocPoint:
                        _4586 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4586] = 26
                        mem[_4586 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4680 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4680 + 68] = mem[idx + _4586 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4680 + 68] = mem[_4680 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4680 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4632 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4632] = 26
                    mem[_4632 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4757 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4757 + 68] = mem[idx + _4632 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4757 + 68] = mem[_4757 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4757 + -mem[64] + 100
                _4378 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4378] = 26
                mem[_4378 + 32] = 'SafeMath: division by zero'
                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                    revert with 0, 'SafeMath: addition overflow'
                amountToBurn += 0 / totalAllocPoint / 20
                if not 0 / totalAllocPoint:
                    _5124 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5124] = 26
                    mem[_5124 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5198 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5198 + 68] = mem[idx + _5124 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5198 + 68] = mem[_5198 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5198 + -mem[64] + 100
                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5158 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5158] = 26
                mem[_5158 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5243 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5243 + 68] = mem[idx + _5158 + 32]
                    idx = idx + 32
                    continue 
                mem[_5243 + 68] = mem[_5243 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5243 + -mem[64] + 100
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            if ext_call.return_data[0] >= ext_call.return_data[0]:
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sphereTokenAddress)
                    call sphereTokenAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0xd5abeb01 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    _3368 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3368] = 26
                    mem[_3368 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                        revert with 0, 'SafeMath: addition overflow'
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                        if not 0 / totalAllocPoint:
                            _3893 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3893] = 26
                            mem[_3893 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3977 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3977 + 68] = mem[idx + _3893 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3977 + 68] = mem[_3977 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3977 + -mem[64] + 100
                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _3929 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3929] = 26
                        mem[_3929 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4032 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4032 + 68] = mem[idx + _3929 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4032 + 68] = mem[_4032 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4032 + -mem[64] + 100
                    _3751 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3751] = 26
                    mem[_3751 + 32] = 'SafeMath: division by zero'
                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                        revert with 0, 'SafeMath: addition overflow'
                    amountToBurn += 0 / totalAllocPoint / 20
                    if not 0 / totalAllocPoint:
                        _4419 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4419] = 26
                        mem[_4419 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4515 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4515 + 68] = mem[idx + _4419 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4515 + 68] = mem[_4515 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4515 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4459 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4459] = 26
                    mem[_4459 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4577 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4577 + 68] = mem[idx + _4459 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4577 + 68] = mem[_4577 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4577 + -mem[64] + 100
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                if ext_call.return_data[0] >= ext_call.return_data[0]:
                    staticcall sphereTokenAddress.0xd5abeb01 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    _3458 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3458] = 26
                    mem[_3458 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                        revert with 0, 'SafeMath: addition overflow'
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                        if not 0 / totalAllocPoint:
                            _4086 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4086] = 26
                            mem[_4086 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _4191 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4191 + 68] = mem[idx + _4086 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4191 + 68] = mem[_4191 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _4191 + -mem[64] + 100
                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _4135 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4135] = 26
                        mem[_4135 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4252 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4252 + 68] = mem[idx + _4135 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4252 + 68] = mem[_4252 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4252 + -mem[64] + 100
                    _3891 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3891] = 26
                    mem[_3891 + 32] = 'SafeMath: division by zero'
                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                        revert with 0, 'SafeMath: addition overflow'
                    amountToBurn += 0 / totalAllocPoint / 20
                    if not 0 / totalAllocPoint:
                        _4628 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4628] = 26
                        mem[_4628 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4739 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4739 + 68] = mem[idx + _4628 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4739 + 68] = mem[_4739 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4739 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4670 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4670] = 26
                    mem[_4670 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4808 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4808 + 68] = mem[idx + _4670 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4808 + 68] = mem[_4808 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4808 + -mem[64] + 100
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3525 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3525] = 30
                mem[_3525 + 32] = 'SafeMath: subtraction overflow'
                if ext_call.return_data[0] > ext_call.return_data[0]:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                    idx = 32
                    while idx < 30:
                        mem[idx + mem[64] + 68] = mem[idx + _3525 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: subtraction overflow'
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0
                require ext_code.size(sphereTokenAddress)
                call sphereTokenAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3892 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3892] = 26
                mem[_3892 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                    if not 0 / totalAllocPoint:
                        _4811 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4811] = 26
                        mem[_4811 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4919 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4919 + 68] = mem[idx + _4811 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4919 + 68] = mem[_4919 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4919 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4862 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4862] = 26
                    mem[_4862 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4977 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4977 + 68] = mem[idx + _4862 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4977 + 68] = mem[_4977 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4977 + -mem[64] + 100
                _4576 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4576] = 26
                mem[_4576 + 32] = 'SafeMath: division by zero'
                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                    revert with 0, 'SafeMath: addition overflow'
                amountToBurn += 0 / totalAllocPoint / 20
                if not 0 / totalAllocPoint:
                    _5268 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5268] = 26
                    mem[_5268 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5334 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5334 + 68] = mem[idx + _5268 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5334 + 68] = mem[_5334 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5334 + -mem[64] + 100
                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5293 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5293] = 26
                mem[_5293 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5382 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5382 + 68] = mem[idx + _5293 + 32]
                    idx = idx + 32
                    continue 
                mem[_5382 + 68] = mem[_5382 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5382 + -mem[64] + 100
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _3098 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3098] = 30
            mem[_3098 + 32] = 'SafeMath: subtraction overflow'
            if ext_call.return_data[0] > ext_call.return_data[0]:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                idx = 32
                while idx < 30:
                    mem[idx + mem[64] + 68] = mem[idx + _3098 + 32]
                    idx = idx + 32
                    continue 
                revert with 0, 'SafeMath: subtraction overflow'
            mem[mem[64] + 4] = devAddress
            mem[mem[64] + 36] = 0
            require ext_code.size(sphereTokenAddress)
            call sphereTokenAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args devAddress, 0
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sphereTokenAddress)
                call sphereTokenAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3754 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3754] = 26
                mem[_3754 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                    if not 0 / totalAllocPoint:
                        _4582 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4582] = 26
                        mem[_4582 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4674 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4674 + 68] = mem[idx + _4582 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4674 + 68] = mem[_4674 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4674 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4630 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4630] = 26
                    mem[_4630 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4749 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4749 + 68] = mem[idx + _4630 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4749 + 68] = mem[_4749 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4749 + -mem[64] + 100
                _4375 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4375] = 26
                mem[_4375 + 32] = 'SafeMath: division by zero'
                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                    revert with 0, 'SafeMath: addition overflow'
                amountToBurn += 0 / totalAllocPoint / 20
                if not 0 / totalAllocPoint:
                    _5123 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5123] = 26
                    mem[_5123 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5195 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5195 + 68] = mem[idx + _5123 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5195 + 68] = mem[_5195 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5195 + -mem[64] + 100
                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5157 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5157] = 26
                mem[_5157 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5240 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5240 + 68] = mem[idx + _5157 + 32]
                    idx = idx + 32
                    continue 
                mem[_5240 + 68] = mem[_5240 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5240 + -mem[64] + 100
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            if ext_call.return_data[0] >= ext_call.return_data[0]:
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3894 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3894] = 26
                mem[_3894 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                    if not 0 / totalAllocPoint:
                        _4815 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4815] = 26
                        mem[_4815 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4922 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4922 + 68] = mem[idx + _4815 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4922 + 68] = mem[_4922 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4922 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4865 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4865] = 26
                    mem[_4865 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4982 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4982 + 68] = mem[idx + _4865 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4982 + 68] = mem[_4982 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4982 + -mem[64] + 100
                _4580 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4580] = 26
                mem[_4580 + 32] = 'SafeMath: division by zero'
                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                    revert with 0, 'SafeMath: addition overflow'
                amountToBurn += 0 / totalAllocPoint / 20
                if not 0 / totalAllocPoint:
                    _5269 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5269] = 26
                    mem[_5269 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5337 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5337 + 68] = mem[idx + _5269 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5337 + 68] = mem[_5337 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5337 + -mem[64] + 100
                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5294 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5294] = 26
                mem[_5294 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5385 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5385 + 68] = mem[idx + _5294 + 32]
                    idx = idx + 32
                    continue 
                mem[_5385 + 68] = mem[_5385 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5385 + -mem[64] + 100
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _3980 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3980] = 30
            mem[_3980 + 32] = 'SafeMath: subtraction overflow'
            if ext_call.return_data[0] > ext_call.return_data[0]:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                idx = 32
                while idx < 30:
                    mem[idx + mem[64] + 68] = mem[idx + _3980 + 32]
                    idx = idx + 32
                    continue 
                revert with 0, 'SafeMath: subtraction overflow'
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = 0
            require ext_code.size(sphereTokenAddress)
            call sphereTokenAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args address(this.address), 0
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _4581 = mem[64]
            mem[64] = mem[64] + 64
            mem[_4581] = 26
            mem[_4581 + 32] = 'SafeMath: division by zero'
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                if not 0 / totalAllocPoint:
                    _5388 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5388] = 26
                    mem[_5388 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5454 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5454 + 68] = mem[idx + _5388 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5454 + 68] = mem[_5454 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5454 + -mem[64] + 100
                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5424 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5424] = 26
                mem[_5424 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5486 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5486 + 68] = mem[idx + _5424 + 32]
                    idx = idx + 32
                    continue 
                mem[_5486 + 68] = mem[_5486 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5486 + -mem[64] + 100
            _5239 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5239] = 26
            mem[_5239 + 32] = 'SafeMath: division by zero'
            if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                revert with 0, 'SafeMath: addition overflow'
            amountToBurn += 0 / totalAllocPoint / 20
            if not 0 / totalAllocPoint:
                _5588 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5588] = 26
                mem[_5588 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5602 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5602 + 68] = mem[idx + _5588 + 32]
                    idx = idx + 32
                    continue 
                mem[_5602 + 68] = mem[_5602 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5602 + -mem[64] + 100
            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _5594 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5594] = 26
            mem[_5594 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0]:
                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _5614 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _5614 + 68] = mem[idx + _5594 + 32]
                idx = idx + 32
                continue 
            mem[_5614 + 68] = mem[_5614 + 74 len 26]
            revert with memory
              from mem[64]
               len _5614 + -mem[64] + 100
        if (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / (block.number * spherePerBlock) - (poolInfo[idx].field_512 * spherePerBlock) != poolInfo[idx].field_256:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        _2871 = mem[64]
        mem[64] = mem[64] + 64
        mem[_2871] = 26
        mem[_2871 + 32] = 'SafeMath: division by zero'
        if not totalAllocPoint:
            _2880 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _2880 + 68] = mem[idx + _2871 + 32]
                idx = idx + 32
                continue 
            mem[_2880 + 68] = mem[_2880 + 74 len 26]
            revert with memory
              from mem[64]
               len _2880 + -mem[64] + 100
        _2896 = mem[64]
        mem[64] = mem[64] + 64
        mem[_2896] = 26
        mem[_2896 + 32] = 'SafeMath: division by zero'
        require ext_code.size(sphereTokenAddress)
        staticcall sphereTokenAddress.0xd5abeb01 with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(sphereTokenAddress)
        staticcall sphereTokenAddress.0x18160ddd with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
            revert with 0, 'SafeMath: addition overflow'
        if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] <= ext_call.return_data[0]:
            mem[mem[64] + 4] = devAddress
            mem[mem[64] + 36] = (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
            require ext_code.size(sphereTokenAddress)
            call sphereTokenAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args devAddress, (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint
                require ext_code.size(sphereTokenAddress)
                call sphereTokenAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3299 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3299] = 26
                mem[_3299 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                    if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                        _3781 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3781] = 26
                        mem[_3781 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3849 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _3849 + 68] = mem[idx + _3781 + 32]
                            idx = idx + 32
                            continue 
                        mem[_3849 + 68] = mem[_3849 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3849 + -mem[64] + 100
                    if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _3807 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3807] = 26
                    mem[_3807 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3886 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _3886 + 68] = mem[idx + _3807 + 32]
                        idx = idx + 32
                        continue 
                    mem[_3886 + 68] = mem[_3886 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3886 + -mem[64] + 100
                _3648 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3648] = 26
                mem[_3648 + 32] = 'SafeMath: division by zero'
                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                    revert with 0, 'SafeMath: addition overflow'
                amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
                if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                    _4251 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4251] = 26
                    mem[_4251 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4364 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4364 + 68] = mem[idx + _4251 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4364 + 68] = mem[_4364 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4364 + -mem[64] + 100
                if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _4311 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4311] = 26
                mem[_4311 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _4411 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _4411 + 68] = mem[idx + _4311 + 32]
                    idx = idx + 32
                    continue 
                mem[_4411 + 68] = mem[_4411 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _4411 + -mem[64] + 100
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            if ext_call.return_data[0] >= ext_call.return_data[0]:
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3391 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3391] = 26
                mem[_3391 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                    if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                        _3927 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3927] = 26
                        mem[_3927 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4024 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4024 + 68] = mem[idx + _3927 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4024 + 68] = mem[_4024 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4024 + -mem[64] + 100
                    if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _3971 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3971] = 26
                    mem[_3971 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4077 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4077 + 68] = mem[idx + _3971 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4077 + 68] = mem[_4077 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4077 + -mem[64] + 100
                _3779 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3779] = 26
                mem[_3779 + 32] = 'SafeMath: division by zero'
                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                    revert with 0, 'SafeMath: addition overflow'
                amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
                if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                    _4454 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4454] = 26
                    mem[_4454 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4566 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4566 + 68] = mem[idx + _4454 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4566 + 68] = mem[_4566 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4566 + -mem[64] + 100
                if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _4509 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4509] = 26
                mem[_4509 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _4621 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _4621 + 68] = mem[idx + _4509 + 32]
                    idx = idx + 32
                    continue 
                mem[_4621 + 68] = mem[_4621 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _4621 + -mem[64] + 100
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _3433 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3433] = 30
            mem[_3433 + 32] = 'SafeMath: subtraction overflow'
            if ext_call.return_data[0] > ext_call.return_data[0]:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                idx = 32
                while idx < 30:
                    mem[idx + mem[64] + 68] = mem[idx + _3433 + 32]
                    idx = idx + 32
                    continue 
                revert with 0, 'SafeMath: subtraction overflow'
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = 0
            require ext_code.size(sphereTokenAddress)
            call sphereTokenAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args address(this.address), 0
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _3780 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3780] = 26
            mem[_3780 + 32] = 'SafeMath: division by zero'
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                    _4624 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4624] = 26
                    mem[_4624 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4736 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4736 + 68] = mem[idx + _4624 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4736 + 68] = mem[_4736 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4736 + -mem[64] + 100
                if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _4667 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4667] = 26
                mem[_4667 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _4803 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _4803 + 68] = mem[idx + _4667 + 32]
                    idx = idx + 32
                    continue 
                mem[_4803 + 68] = mem[_4803 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _4803 + -mem[64] + 100
            _4410 = mem[64]
            mem[64] = mem[64] + 64
            mem[_4410] = 26
            mem[_4410 + 32] = 'SafeMath: division by zero'
            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                revert with 0, 'SafeMath: addition overflow'
            amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
            if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                _5150 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5150] = 26
                mem[_5150 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5232 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5232 + 68] = mem[idx + _5150 + 32]
                    idx = idx + 32
                    continue 
                mem[_5232 + 68] = mem[_5232 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5232 + -mem[64] + 100
            if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _5190 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5190] = 26
            mem[_5190 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0]:
                if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _5265 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _5265 + 68] = mem[idx + _5190 + 32]
                idx = idx + 32
                continue 
            mem[_5265 + 68] = mem[_5265 + 74 len 26]
            revert with memory
              from mem[64]
               len _5265 + -mem[64] + 100
        require ext_code.size(sphereTokenAddress)
        staticcall sphereTokenAddress.0xd5abeb01 with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(sphereTokenAddress)
        staticcall sphereTokenAddress.0x18160ddd with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(sphereTokenAddress)
        if ext_call.return_data[0] >= ext_call.return_data[0]:
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint
                require ext_code.size(sphereTokenAddress)
                call sphereTokenAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3389 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3389] = 26
                mem[_3389 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                    if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                        _3924 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3924] = 26
                        mem[_3924 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4020 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4020 + 68] = mem[idx + _3924 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4020 + 68] = mem[_4020 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4020 + -mem[64] + 100
                    if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _3967 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3967] = 26
                    mem[_3967 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4071 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4071 + 68] = mem[idx + _3967 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4071 + 68] = mem[_4071 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4071 + -mem[64] + 100
                _3775 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3775] = 26
                mem[_3775 + 32] = 'SafeMath: division by zero'
                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                    revert with 0, 'SafeMath: addition overflow'
                amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
                if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                    _4451 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4451] = 26
                    mem[_4451 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4560 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4560 + 68] = mem[idx + _4451 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4560 + 68] = mem[_4560 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4560 + -mem[64] + 100
                if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _4507 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4507] = 26
                mem[_4507 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _4615 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _4615 + 68] = mem[idx + _4507 + 32]
                    idx = idx + 32
                    continue 
                mem[_4615 + 68] = mem[_4615 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _4615 + -mem[64] + 100
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            if ext_call.return_data[0] >= ext_call.return_data[0]:
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3483 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3483] = 26
                mem[_3483 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                    if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                        _4125 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4125] = 26
                        mem[_4125 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4234 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4234 + 68] = mem[idx + _4125 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4234 + 68] = mem[_4234 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4234 + -mem[64] + 100
                    if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4177 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4177] = 26
                    mem[_4177 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4296 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4296 + 68] = mem[idx + _4177 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4296 + 68] = mem[_4296 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4296 + -mem[64] + 100
                _3922 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3922] = 26
                mem[_3922 + 32] = 'SafeMath: division by zero'
                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                    revert with 0, 'SafeMath: addition overflow'
                amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
                if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                    _4663 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4663] = 26
                    mem[_4663 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4785 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4785 + 68] = mem[idx + _4663 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4785 + 68] = mem[_4785 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4785 + -mem[64] + 100
                if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _4726 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4726] = 26
                mem[_4726 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _4848 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _4848 + 68] = mem[idx + _4726 + 32]
                    idx = idx + 32
                    continue 
                mem[_4848 + 68] = mem[_4848 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _4848 + -mem[64] + 100
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _3543 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3543] = 30
            mem[_3543 + 32] = 'SafeMath: subtraction overflow'
            if ext_call.return_data[0] > ext_call.return_data[0]:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                idx = 32
                while idx < 30:
                    mem[idx + mem[64] + 68] = mem[idx + _3543 + 32]
                    idx = idx + 32
                    continue 
                revert with 0, 'SafeMath: subtraction overflow'
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = 0
            require ext_code.size(sphereTokenAddress)
            call sphereTokenAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args address(this.address), 0
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _3923 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3923] = 26
            mem[_3923 + 32] = 'SafeMath: division by zero'
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                    _4851 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4851] = 26
                    mem[_4851 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4962 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4962 + 68] = mem[idx + _4851 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4962 + 68] = mem[_4962 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4962 + -mem[64] + 100
                if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _4902 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4902] = 26
                mem[_4902 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5017 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5017 + 68] = mem[idx + _4902 + 32]
                    idx = idx + 32
                    continue 
                mem[_5017 + 68] = mem[_5017 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5017 + -mem[64] + 100
            _4614 = mem[64]
            mem[64] = mem[64] + 64
            mem[_4614] = 26
            mem[_4614 + 32] = 'SafeMath: division by zero'
            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                revert with 0, 'SafeMath: addition overflow'
            amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
            if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                _5289 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5289] = 26
                mem[_5289 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5368 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5368 + 68] = mem[idx + _5289 + 32]
                    idx = idx + 32
                    continue 
                mem[_5368 + 68] = mem[_5368 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5368 + -mem[64] + 100
            if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _5326 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5326] = 26
            mem[_5326 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0]:
                if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _5409 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _5409 + 68] = mem[idx + _5326 + 32]
                idx = idx + 32
                continue 
            mem[_5409 + 68] = mem[_5409 + 74 len 26]
            revert with memory
              from mem[64]
               len _5409 + -mem[64] + 100
        staticcall sphereTokenAddress.0x18160ddd with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(sphereTokenAddress)
        staticcall sphereTokenAddress.0xd5abeb01 with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        _3113 = mem[64]
        mem[64] = mem[64] + 64
        mem[_3113] = 30
        mem[_3113 + 32] = 'SafeMath: subtraction overflow'
        if ext_call.return_data[0] > ext_call.return_data[0]:
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
            idx = 32
            while idx < 30:
                mem[idx + mem[64] + 68] = mem[idx + _3113 + 32]
                idx = idx + 32
                continue 
            revert with 0, 'SafeMath: subtraction overflow'
        mem[mem[64] + 4] = devAddress
        mem[mem[64] + 36] = 0
        require ext_code.size(sphereTokenAddress)
        call sphereTokenAddress.0x40c10f19 with:
             gas gas_remaining wei
            args devAddress, 0
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require ext_code.size(sphereTokenAddress)
        staticcall sphereTokenAddress.0xd5abeb01 with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(sphereTokenAddress)
        staticcall sphereTokenAddress.0x18160ddd with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
            revert with 0, 'SafeMath: addition overflow'
        if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint
            require ext_code.size(sphereTokenAddress)
            call sphereTokenAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args address(this.address), (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _3778 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3778] = 26
            mem[_3778 + 32] = 'SafeMath: division by zero'
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                    _4620 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4620] = 26
                    mem[_4620 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4730 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4730 + 68] = mem[idx + _4620 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4730 + 68] = mem[_4730 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4730 + -mem[64] + 100
                if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _4665 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4665] = 26
                mem[_4665 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _4795 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _4795 + 68] = mem[idx + _4665 + 32]
                    idx = idx + 32
                    continue 
                mem[_4795 + 68] = mem[_4795 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _4795 + -mem[64] + 100
            _4407 = mem[64]
            mem[64] = mem[64] + 64
            mem[_4407] = 26
            mem[_4407 + 32] = 'SafeMath: division by zero'
            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                revert with 0, 'SafeMath: addition overflow'
            amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
            if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                _5149 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5149] = 26
                mem[_5149 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5229 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5229 + 68] = mem[idx + _5149 + 32]
                    idx = idx + 32
                    continue 
                mem[_5229 + 68] = mem[_5229 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5229 + -mem[64] + 100
            if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _5189 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5189] = 26
            mem[_5189 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0]:
                if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _5262 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _5262 + 68] = mem[idx + _5189 + 32]
                idx = idx + 32
                continue 
            mem[_5262 + 68] = mem[_5262 + 74 len 26]
            revert with memory
              from mem[64]
               len _5262 + -mem[64] + 100
        require ext_code.size(sphereTokenAddress)
        staticcall sphereTokenAddress.0xd5abeb01 with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(sphereTokenAddress)
        staticcall sphereTokenAddress.0x18160ddd with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(sphereTokenAddress)
        if ext_call.return_data[0] >= ext_call.return_data[0]:
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _3925 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3925] = 26
            mem[_3925 + 32] = 'SafeMath: division by zero'
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                    _4855 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4855] = 26
                    mem[_4855 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4965 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4965 + 68] = mem[idx + _4855 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4965 + 68] = mem[_4965 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4965 + -mem[64] + 100
                if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _4905 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4905] = 26
                mem[_4905 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5022 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5022 + 68] = mem[idx + _4905 + 32]
                    idx = idx + 32
                    continue 
                mem[_5022 + 68] = mem[_5022 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5022 + -mem[64] + 100
            _4618 = mem[64]
            mem[64] = mem[64] + 64
            mem[_4618] = 26
            mem[_4618 + 32] = 'SafeMath: division by zero'
            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                revert with 0, 'SafeMath: addition overflow'
            amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
            if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                _5290 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5290] = 26
                mem[_5290 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5371 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5371 + 68] = mem[idx + _5290 + 32]
                    idx = idx + 32
                    continue 
                mem[_5371 + 68] = mem[_5371 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5371 + -mem[64] + 100
            if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _5327 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5327] = 26
            mem[_5327 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0]:
                if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _5412 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _5412 + 68] = mem[idx + _5327 + 32]
                idx = idx + 32
                continue 
            mem[_5412 + 68] = mem[_5412 + 74 len 26]
            revert with memory
              from mem[64]
               len _5412 + -mem[64] + 100
        staticcall sphereTokenAddress.0x18160ddd with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(sphereTokenAddress)
        staticcall sphereTokenAddress.0xd5abeb01 with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        _4023 = mem[64]
        mem[64] = mem[64] + 64
        mem[_4023] = 30
        mem[_4023 + 32] = 'SafeMath: subtraction overflow'
        if ext_call.return_data[0] > ext_call.return_data[0]:
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
            idx = 32
            while idx < 30:
                mem[idx + mem[64] + 68] = mem[idx + _4023 + 32]
                idx = idx + 32
                continue 
            revert with 0, 'SafeMath: subtraction overflow'
        mem[mem[64] + 4] = this.address
        mem[mem[64] + 36] = 0
        require ext_code.size(sphereTokenAddress)
        call sphereTokenAddress.0x40c10f19 with:
             gas gas_remaining wei
            args address(this.address), 0
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require ext_code.size(sphereTokenAddress)
        staticcall sphereTokenAddress.0xd5abeb01 with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        _4619 = mem[64]
        mem[64] = mem[64] + 64
        mem[_4619] = 26
        mem[_4619 + 32] = 'SafeMath: division by zero'
        require ext_code.size(sphereTokenAddress)
        staticcall sphereTokenAddress.0x18160ddd with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
            revert with 0, 'SafeMath: addition overflow'
        if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
            if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                _5415 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5415] = 26
                mem[_5415 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5477 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5477 + 68] = mem[idx + _5415 + 32]
                    idx = idx + 32
                    continue 
                mem[_5477 + 68] = mem[_5477 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5477 + -mem[64] + 100
            if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _5443 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5443] = 26
            mem[_5443 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0]:
                if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _5506 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _5506 + 68] = mem[idx + _5443 + 32]
                idx = idx + 32
                continue 
            mem[_5506 + 68] = mem[_5506 + 74 len 26]
            revert with memory
              from mem[64]
               len _5506 + -mem[64] + 100
        _5261 = mem[64]
        mem[64] = mem[64] + 64
        mem[_5261] = 26
        mem[_5261 + 32] = 'SafeMath: division by zero'
        if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
            revert with 0, 'SafeMath: addition overflow'
        amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
        if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
            _5593 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5593] = 26
            mem[_5593 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0]:
                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _5611 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _5611 + 68] = mem[idx + _5593 + 32]
                idx = idx + 32
                continue 
            mem[_5611 + 68] = mem[_5611 + 74 len 26]
            revert with memory
              from mem[64]
               len _5611 + -mem[64] + 100
        if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        _5601 = mem[64]
        mem[64] = mem[64] + 64
        mem[_5601] = 26
        mem[_5601 + 32] = 'SafeMath: division by zero'
        if ext_call.return_data[0]:
            if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                revert with 0, 'SafeMath: addition overflow'
            poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
            poolInfo[idx].field_512 = block.number
            idx = idx + 1
            continue 
        _5620 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 26
        idx = 0
        while idx < 26:
            mem[idx + _5620 + 68] = mem[idx + _5601 + 32]
            idx = idx + 32
            continue 
        mem[_5620 + 68] = mem[_5620 + 74 len 26]
        revert with memory
          from mem[64]
           len _5620 + -mem[64] + 100
    s = 0
    while s < poolInfo.length:
        mem[0] = 10
        poolInfo[s].field_512 = startBlock
        s = s + 1
        continue 
}

function fixMaxSupplyFarmEnd() payable {
    mem[64] = 96
    if owner != msg.sender:
        revert with 0, 'sOwnable: caller is not the owne'
    require ext_code.size(sphereTokenAddress)
    staticcall sphereTokenAddress.0xd5abeb01 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(sphereTokenAddress)
    staticcall sphereTokenAddress.0x18160ddd with:
            gas gas_remaining wei
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] < ext_call.return_data[0]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    40,
                    0x736d6178537570706c793a20696e76616c696420746f20757365206265666f726520726561636865,
                    mem[204 len 24]
    idx = 0
    while idx < poolInfo.length:
        mem[0] = 10
        _32 = mem[64]
        mem[64] = mem[64] + 64
        mem[_32] = 30
        mem[_32 + 32] = 'SafeMath: subtraction overflow'
        if poolInfo[idx].field_256 <= totalAllocPoint:
            totalAllocPoint -= poolInfo[idx].field_256
            require idx < poolInfo.length
            mem[0] = 10
            poolInfo[idx].field_256 = 0
            idx = idx + 1
            continue 
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 30
        mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
        idx = 32
        while idx < 30:
            mem[idx + mem[64] + 68] = mem[idx + _32 + 32]
            idx = idx + 32
            continue 
        revert with 0, 'SafeMath: subtraction overflow'
    idx = 0
    while idx < poolInfo.length:
        mem[0] = 10
        if block.number <= poolInfo[idx].field_512:
            idx = idx + 1
            continue 
        mem[mem[64] + 4] = this.address
        require ext_code.size(poolInfo[idx].field_0)
        staticcall poolInfo[idx].field_0.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if not ext_call.return_data[0]:
            poolInfo[idx].field_512 = block.number
            idx = idx + 1
            continue 
        if not poolInfo[idx].field_256:
            poolInfo[idx].field_512 = block.number
            idx = idx + 1
            continue 
        require ext_code.size(sphereTokenAddress)
        staticcall sphereTokenAddress.0xd5abeb01 with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(sphereTokenAddress)
        staticcall sphereTokenAddress.0x18160ddd with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] >= ext_call.return_data[0]:
            _2903 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2903] = 26
            mem[_2903 + 32] = 'SafeMath: division by zero'
            if not totalAllocPoint:
                _2904 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _2904 + 68] = mem[idx + _2903 + 32]
                    idx = idx + 32
                    continue 
                mem[_2904 + 68] = mem[_2904 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _2904 + -mem[64] + 100
            _2918 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2918] = 26
            mem[_2918 + 32] = 'SafeMath: division by zero'
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] <= ext_call.return_data[0]:
                mem[mem[64] + 4] = devAddress
                mem[mem[64] + 36] = 0 / totalAllocPoint / 20
                require ext_code.size(sphereTokenAddress)
                call sphereTokenAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devAddress, 0 / totalAllocPoint / 20
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sphereTokenAddress)
                    call sphereTokenAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0xd5abeb01 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    _3229 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3229] = 26
                    mem[_3229 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                        revert with 0, 'SafeMath: addition overflow'
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                        if not 0 / totalAllocPoint:
                            _3650 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3650] = 26
                            mem[_3650 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3712 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3712 + 68] = mem[idx + _3650 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3712 + 68] = mem[_3712 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3712 + -mem[64] + 100
                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _3682 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3682] = 26
                        mem[_3682 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3745 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _3745 + 68] = mem[idx + _3682 + 32]
                            idx = idx + 32
                            continue 
                        mem[_3745 + 68] = mem[_3745 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3745 + -mem[64] + 100
                    _3525 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3525] = 26
                    mem[_3525 + 32] = 'SafeMath: division by zero'
                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                        revert with 0, 'SafeMath: addition overflow'
                    amountToBurn += 0 / totalAllocPoint / 20
                    if not 0 / totalAllocPoint:
                        _4009 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4009] = 26
                        mem[_4009 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4109 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4109 + 68] = mem[idx + _4009 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4109 + 68] = mem[_4109 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4109 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4062 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4062] = 26
                    mem[_4062 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4165 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4165 + 68] = mem[idx + _4062 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4165 + 68] = mem[_4165 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4165 + -mem[64] + 100
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                if ext_call.return_data[0] >= ext_call.return_data[0]:
                    staticcall sphereTokenAddress.0xd5abeb01 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    _3315 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3315] = 26
                    mem[_3315 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                        revert with 0, 'SafeMath: addition overflow'
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                        if not 0 / totalAllocPoint:
                            _3780 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3780] = 26
                            mem[_3780 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3841 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3841 + 68] = mem[idx + _3780 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3841 + 68] = mem[_3841 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3841 + -mem[64] + 100
                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _3809 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3809] = 26
                        mem[_3809 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3878 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _3878 + 68] = mem[idx + _3809 + 32]
                            idx = idx + 32
                            continue 
                        mem[_3878 + 68] = mem[_3878 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3878 + -mem[64] + 100
                    _3648 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3648] = 26
                    mem[_3648 + 32] = 'SafeMath: division by zero'
                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                        revert with 0, 'SafeMath: addition overflow'
                    amountToBurn += 0 / totalAllocPoint / 20
                    if not 0 / totalAllocPoint:
                        _4218 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4218] = 26
                        mem[_4218 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4331 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4331 + 68] = mem[idx + _4218 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4331 + 68] = mem[_4331 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4331 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4273 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4273] = 26
                    mem[_4273 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4391 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4391 + 68] = mem[idx + _4273 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4391 + 68] = mem[_4391 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4391 + -mem[64] + 100
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3359 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3359] = 30
                mem[_3359 + 32] = 'SafeMath: subtraction overflow'
                if ext_call.return_data[0] > ext_call.return_data[0]:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                    idx = 32
                    while idx < 30:
                        mem[idx + mem[64] + 68] = mem[idx + _3359 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: subtraction overflow'
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0
                require ext_code.size(sphereTokenAddress)
                call sphereTokenAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3649 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3649] = 26
                mem[_3649 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                    if not 0 / totalAllocPoint:
                        _4394 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4394] = 26
                        mem[_4394 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4486 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4486 + 68] = mem[idx + _4394 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4486 + 68] = mem[_4486 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4486 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4439 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4439] = 26
                    mem[_4439 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4542 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4542 + 68] = mem[idx + _4439 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4542 + 68] = mem[_4542 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4542 + -mem[64] + 100
                _4164 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4164] = 26
                mem[_4164 + 32] = 'SafeMath: division by zero'
                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                    revert with 0, 'SafeMath: addition overflow'
                amountToBurn += 0 / totalAllocPoint / 20
                if not 0 / totalAllocPoint:
                    _4943 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4943] = 26
                    mem[_4943 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5054 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5054 + 68] = mem[idx + _4943 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5054 + 68] = mem[_5054 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5054 + -mem[64] + 100
                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5001 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5001] = 26
                mem[_5001 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5107 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5107 + 68] = mem[idx + _5001 + 32]
                    idx = idx + 32
                    continue 
                mem[_5107 + 68] = mem[_5107 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5107 + -mem[64] + 100
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            if ext_call.return_data[0] >= ext_call.return_data[0]:
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sphereTokenAddress)
                    call sphereTokenAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0xd5abeb01 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    _3313 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3313] = 26
                    mem[_3313 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                        revert with 0, 'SafeMath: addition overflow'
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                        if not 0 / totalAllocPoint:
                            _3777 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3777] = 26
                            mem[_3777 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3837 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3837 + 68] = mem[idx + _3777 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3837 + 68] = mem[_3837 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3837 + -mem[64] + 100
                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _3805 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3805] = 26
                        mem[_3805 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3872 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _3872 + 68] = mem[idx + _3805 + 32]
                            idx = idx + 32
                            continue 
                        mem[_3872 + 68] = mem[_3872 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3872 + -mem[64] + 100
                    _3644 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3644] = 26
                    mem[_3644 + 32] = 'SafeMath: division by zero'
                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                        revert with 0, 'SafeMath: addition overflow'
                    amountToBurn += 0 / totalAllocPoint / 20
                    if not 0 / totalAllocPoint:
                        _4215 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4215] = 26
                        mem[_4215 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4325 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4325 + 68] = mem[idx + _4215 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4325 + 68] = mem[_4325 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4325 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4271 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4271] = 26
                    mem[_4271 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4385 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4385 + 68] = mem[idx + _4271 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4385 + 68] = mem[_4385 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4385 + -mem[64] + 100
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                if ext_call.return_data[0] >= ext_call.return_data[0]:
                    staticcall sphereTokenAddress.0xd5abeb01 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    _3399 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3399] = 26
                    mem[_3399 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                        revert with 0, 'SafeMath: addition overflow'
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                        if not 0 / totalAllocPoint:
                            _3913 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3913] = 26
                            mem[_3913 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3992 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3992 + 68] = mem[idx + _3913 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3992 + 68] = mem[_3992 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3992 + -mem[64] + 100
                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _3951 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3951] = 26
                        mem[_3951 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4047 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4047 + 68] = mem[idx + _3951 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4047 + 68] = mem[_4047 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4047 + -mem[64] + 100
                    _3775 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3775] = 26
                    mem[_3775 + 32] = 'SafeMath: division by zero'
                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                        revert with 0, 'SafeMath: addition overflow'
                    amountToBurn += 0 / totalAllocPoint / 20
                    if not 0 / totalAllocPoint:
                        _4435 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4435] = 26
                        mem[_4435 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4524 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4524 + 68] = mem[idx + _4435 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4524 + 68] = mem[_4524 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4524 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4476 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4476] = 26
                    mem[_4476 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4588 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4588 + 68] = mem[idx + _4476 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4588 + 68] = mem[_4588 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4588 + -mem[64] + 100
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3446 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3446] = 30
                mem[_3446 + 32] = 'SafeMath: subtraction overflow'
                if ext_call.return_data[0] > ext_call.return_data[0]:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                    idx = 32
                    while idx < 30:
                        mem[idx + mem[64] + 68] = mem[idx + _3446 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: subtraction overflow'
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0
                require ext_code.size(sphereTokenAddress)
                call sphereTokenAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3776 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3776] = 26
                mem[_3776 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                    if not 0 / totalAllocPoint:
                        _4591 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4591] = 26
                        mem[_4591 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4694 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4694 + 68] = mem[idx + _4591 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4694 + 68] = mem[_4694 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4694 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4641 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4641] = 26
                    mem[_4641 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4752 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4752 + 68] = mem[idx + _4641 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4752 + 68] = mem[_4752 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4752 + -mem[64] + 100
                _4384 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4384] = 26
                mem[_4384 + 32] = 'SafeMath: division by zero'
                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                    revert with 0, 'SafeMath: addition overflow'
                amountToBurn += 0 / totalAllocPoint / 20
                if not 0 / totalAllocPoint:
                    _5142 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5142] = 26
                    mem[_5142 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5212 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5212 + 68] = mem[idx + _5142 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5212 + 68] = mem[_5212 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5212 + -mem[64] + 100
                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5176 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5176] = 26
                mem[_5176 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5255 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5255 + 68] = mem[idx + _5176 + 32]
                    idx = idx + 32
                    continue 
                mem[_5255 + 68] = mem[_5255 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5255 + -mem[64] + 100
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _3080 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3080] = 30
            mem[_3080 + 32] = 'SafeMath: subtraction overflow'
            if ext_call.return_data[0] > ext_call.return_data[0]:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                idx = 32
                while idx < 30:
                    mem[idx + mem[64] + 68] = mem[idx + _3080 + 32]
                    idx = idx + 32
                    continue 
                revert with 0, 'SafeMath: subtraction overflow'
            mem[mem[64] + 4] = devAddress
            mem[mem[64] + 36] = 0
            require ext_code.size(sphereTokenAddress)
            call sphereTokenAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args devAddress, 0
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sphereTokenAddress)
                call sphereTokenAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3647 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3647] = 26
                mem[_3647 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                    if not 0 / totalAllocPoint:
                        _4390 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4390] = 26
                        mem[_4390 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4480 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4480 + 68] = mem[idx + _4390 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4480 + 68] = mem[_4480 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4480 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4437 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4437] = 26
                    mem[_4437 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4534 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4534 + 68] = mem[idx + _4437 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4534 + 68] = mem[_4534 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4534 + -mem[64] + 100
                _4161 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4161] = 26
                mem[_4161 + 32] = 'SafeMath: division by zero'
                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                    revert with 0, 'SafeMath: addition overflow'
                amountToBurn += 0 / totalAllocPoint / 20
                if not 0 / totalAllocPoint:
                    _4942 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4942] = 26
                    mem[_4942 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5051 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5051 + 68] = mem[idx + _4942 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5051 + 68] = mem[_5051 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5051 + -mem[64] + 100
                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5000 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5000] = 26
                mem[_5000 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5104 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5104 + 68] = mem[idx + _5000 + 32]
                    idx = idx + 32
                    continue 
                mem[_5104 + 68] = mem[_5104 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5104 + -mem[64] + 100
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            if ext_call.return_data[0] >= ext_call.return_data[0]:
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3778 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3778] = 26
                mem[_3778 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                    if not 0 / totalAllocPoint:
                        _4595 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4595] = 26
                        mem[_4595 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4697 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4697 + 68] = mem[idx + _4595 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4697 + 68] = mem[_4697 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4697 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4644 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4644] = 26
                    mem[_4644 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4757 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4757 + 68] = mem[idx + _4644 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4757 + 68] = mem[_4757 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4757 + -mem[64] + 100
                _4388 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4388] = 26
                mem[_4388 + 32] = 'SafeMath: division by zero'
                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                    revert with 0, 'SafeMath: addition overflow'
                amountToBurn += 0 / totalAllocPoint / 20
                if not 0 / totalAllocPoint:
                    _5143 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5143] = 26
                    mem[_5143 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5215 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5215 + 68] = mem[idx + _5143 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5215 + 68] = mem[_5215 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5215 + -mem[64] + 100
                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5177 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5177] = 26
                mem[_5177 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5258 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5258 + 68] = mem[idx + _5177 + 32]
                    idx = idx + 32
                    continue 
                mem[_5258 + 68] = mem[_5258 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5258 + -mem[64] + 100
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _3840 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3840] = 30
            mem[_3840 + 32] = 'SafeMath: subtraction overflow'
            if ext_call.return_data[0] > ext_call.return_data[0]:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                idx = 32
                while idx < 30:
                    mem[idx + mem[64] + 68] = mem[idx + _3840 + 32]
                    idx = idx + 32
                    continue 
                revert with 0, 'SafeMath: subtraction overflow'
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = 0
            require ext_code.size(sphereTokenAddress)
            call sphereTokenAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args address(this.address), 0
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _4389 = mem[64]
            mem[64] = mem[64] + 64
            mem[_4389] = 26
            mem[_4389 + 32] = 'SafeMath: division by zero'
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                if not 0 / totalAllocPoint:
                    _5261 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5261] = 26
                    mem[_5261 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5329 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5329 + 68] = mem[idx + _5261 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5329 + 68] = mem[_5329 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5329 + -mem[64] + 100
                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5295 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5295] = 26
                mem[_5295 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5364 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5364 + 68] = mem[idx + _5295 + 32]
                    idx = idx + 32
                    continue 
                mem[_5364 + 68] = mem[_5364 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5364 + -mem[64] + 100
            _5103 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5103] = 26
            mem[_5103 + 32] = 'SafeMath: division by zero'
            if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                revert with 0, 'SafeMath: addition overflow'
            amountToBurn += 0 / totalAllocPoint / 20
            if not 0 / totalAllocPoint:
                _5587 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5587] = 26
                mem[_5587 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5610 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5610 + 68] = mem[idx + _5587 + 32]
                    idx = idx + 32
                    continue 
                mem[_5610 + 68] = mem[_5610 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5610 + -mem[64] + 100
            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _5601 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5601] = 26
            mem[_5601 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0]:
                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _5620 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _5620 + 68] = mem[idx + _5601 + 32]
                idx = idx + 32
                continue 
            mem[_5620 + 68] = mem[_5620 + 74 len 26]
            revert with memory
              from mem[64]
               len _5620 + -mem[64] + 100
        _2889 = mem[64]
        mem[64] = mem[64] + 64
        mem[_2889] = 30
        mem[_2889 + 32] = 'SafeMath: subtraction overflow'
        if poolInfo[idx].field_512 > block.number:
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
            idx = 32
            while idx < 30:
                mem[idx + mem[64] + 68] = mem[idx + _2889 + 32]
                idx = idx + 32
                continue 
            revert with 0, 'SafeMath: subtraction overflow'
        if not block.number - poolInfo[idx].field_512:
            _2909 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2909] = 26
            mem[_2909 + 32] = 'SafeMath: division by zero'
            if not totalAllocPoint:
                _2915 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _2915 + 68] = mem[idx + _2909 + 32]
                    idx = idx + 32
                    continue 
                mem[_2915 + 68] = mem[_2915 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _2915 + -mem[64] + 100
            _2933 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2933] = 26
            mem[_2933 + 32] = 'SafeMath: division by zero'
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] <= ext_call.return_data[0]:
                mem[mem[64] + 4] = devAddress
                mem[mem[64] + 36] = 0 / totalAllocPoint / 20
                require ext_code.size(sphereTokenAddress)
                call sphereTokenAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devAddress, 0 / totalAllocPoint / 20
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sphereTokenAddress)
                    call sphereTokenAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0xd5abeb01 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    _3310 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3310] = 26
                    mem[_3310 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                        revert with 0, 'SafeMath: addition overflow'
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                        if not 0 / totalAllocPoint:
                            _3774 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3774] = 26
                            mem[_3774 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3834 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3834 + 68] = mem[idx + _3774 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3834 + 68] = mem[_3834 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3834 + -mem[64] + 100
                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _3804 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3804] = 26
                        mem[_3804 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3865 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _3865 + 68] = mem[idx + _3804 + 32]
                            idx = idx + 32
                            continue 
                        mem[_3865 + 68] = mem[_3865 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3865 + -mem[64] + 100
                    _3640 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3640] = 26
                    mem[_3640 + 32] = 'SafeMath: division by zero'
                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                        revert with 0, 'SafeMath: addition overflow'
                    amountToBurn += 0 / totalAllocPoint / 20
                    if not 0 / totalAllocPoint:
                        _4209 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4209] = 26
                        mem[_4209 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4320 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4320 + 68] = mem[idx + _4209 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4320 + 68] = mem[_4320 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4320 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4267 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4267] = 26
                    mem[_4267 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4379 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4379 + 68] = mem[idx + _4267 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4379 + 68] = mem[_4379 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4379 + -mem[64] + 100
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                if ext_call.return_data[0] >= ext_call.return_data[0]:
                    staticcall sphereTokenAddress.0xd5abeb01 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    _3397 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3397] = 26
                    mem[_3397 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                        revert with 0, 'SafeMath: addition overflow'
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                        if not 0 / totalAllocPoint:
                            _3911 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3911] = 26
                            mem[_3911 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3986 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3986 + 68] = mem[idx + _3911 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3986 + 68] = mem[_3986 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3986 + -mem[64] + 100
                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _3945 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3945] = 26
                        mem[_3945 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4038 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4038 + 68] = mem[idx + _3945 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4038 + 68] = mem[_4038 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4038 + -mem[64] + 100
                    _3772 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3772] = 26
                    mem[_3772 + 32] = 'SafeMath: division by zero'
                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                        revert with 0, 'SafeMath: addition overflow'
                    amountToBurn += 0 / totalAllocPoint / 20
                    if not 0 / totalAllocPoint:
                        _4433 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4433] = 26
                        mem[_4433 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4516 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4516 + 68] = mem[idx + _4433 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4516 + 68] = mem[_4516 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4516 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4472 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4472] = 26
                    mem[_4472 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4581 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4581 + 68] = mem[idx + _4472 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4581 + 68] = mem[_4581 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4581 + -mem[64] + 100
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3445 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3445] = 30
                mem[_3445 + 32] = 'SafeMath: subtraction overflow'
                if ext_call.return_data[0] > ext_call.return_data[0]:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                    idx = 32
                    while idx < 30:
                        mem[idx + mem[64] + 68] = mem[idx + _3445 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: subtraction overflow'
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0
                require ext_code.size(sphereTokenAddress)
                call sphereTokenAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3773 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3773] = 26
                mem[_3773 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                    if not 0 / totalAllocPoint:
                        _4584 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4584] = 26
                        mem[_4584 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4688 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4688 + 68] = mem[idx + _4584 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4688 + 68] = mem[_4688 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4688 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4637 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4637] = 26
                    mem[_4637 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4744 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4744 + 68] = mem[idx + _4637 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4744 + 68] = mem[_4744 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4744 + -mem[64] + 100
                _4378 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4378] = 26
                mem[_4378 + 32] = 'SafeMath: division by zero'
                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                    revert with 0, 'SafeMath: addition overflow'
                amountToBurn += 0 / totalAllocPoint / 20
                if not 0 / totalAllocPoint:
                    _5141 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5141] = 26
                    mem[_5141 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5209 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5209 + 68] = mem[idx + _5141 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5209 + 68] = mem[_5209 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5209 + -mem[64] + 100
                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5175 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5175] = 26
                mem[_5175 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5252 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5252 + 68] = mem[idx + _5175 + 32]
                    idx = idx + 32
                    continue 
                mem[_5252 + 68] = mem[_5252 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5252 + -mem[64] + 100
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            if ext_call.return_data[0] >= ext_call.return_data[0]:
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sphereTokenAddress)
                    call sphereTokenAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0xd5abeb01 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    _3395 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3395] = 26
                    mem[_3395 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                        revert with 0, 'SafeMath: addition overflow'
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                        if not 0 / totalAllocPoint:
                            _3908 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3908] = 26
                            mem[_3908 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3982 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3982 + 68] = mem[idx + _3908 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3982 + 68] = mem[_3982 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3982 + -mem[64] + 100
                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _3941 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3941] = 26
                        mem[_3941 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4032 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4032 + 68] = mem[idx + _3941 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4032 + 68] = mem[_4032 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4032 + -mem[64] + 100
                    _3768 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3768] = 26
                    mem[_3768 + 32] = 'SafeMath: division by zero'
                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                        revert with 0, 'SafeMath: addition overflow'
                    amountToBurn += 0 / totalAllocPoint / 20
                    if not 0 / totalAllocPoint:
                        _4430 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4430] = 26
                        mem[_4430 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4510 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4510 + 68] = mem[idx + _4430 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4510 + 68] = mem[_4510 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4510 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4470 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4470] = 26
                    mem[_4470 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4575 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4575 + 68] = mem[idx + _4470 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4575 + 68] = mem[_4575 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4575 + -mem[64] + 100
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                if ext_call.return_data[0] >= ext_call.return_data[0]:
                    staticcall sphereTokenAddress.0xd5abeb01 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    _3481 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3481] = 26
                    mem[_3481 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                        revert with 0, 'SafeMath: addition overflow'
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                        if not 0 / totalAllocPoint:
                            _4090 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4090] = 26
                            mem[_4090 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _4192 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4192 + 68] = mem[idx + _4090 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4192 + 68] = mem[_4192 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _4192 + -mem[64] + 100
                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _4139 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4139] = 26
                        mem[_4139 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4252 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4252 + 68] = mem[idx + _4139 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4252 + 68] = mem[_4252 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4252 + -mem[64] + 100
                    _3906 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3906] = 26
                    mem[_3906 + 32] = 'SafeMath: division by zero'
                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                        revert with 0, 'SafeMath: addition overflow'
                    amountToBurn += 0 / totalAllocPoint / 20
                    if not 0 / totalAllocPoint:
                        _4633 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4633] = 26
                        mem[_4633 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4726 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4726 + 68] = mem[idx + _4633 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4726 + 68] = mem[_4726 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4726 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4678 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4678] = 26
                    mem[_4678 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4805 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4805 + 68] = mem[idx + _4678 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4805 + 68] = mem[_4805 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4805 + -mem[64] + 100
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3542 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3542] = 30
                mem[_3542 + 32] = 'SafeMath: subtraction overflow'
                if ext_call.return_data[0] > ext_call.return_data[0]:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                    idx = 32
                    while idx < 30:
                        mem[idx + mem[64] + 68] = mem[idx + _3542 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: subtraction overflow'
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0
                require ext_code.size(sphereTokenAddress)
                call sphereTokenAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3907 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3907] = 26
                mem[_3907 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                    if not 0 / totalAllocPoint:
                        _4808 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4808] = 26
                        mem[_4808 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4922 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4922 + 68] = mem[idx + _4808 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4922 + 68] = mem[_4922 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4922 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4865 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4865] = 26
                    mem[_4865 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4977 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4977 + 68] = mem[idx + _4865 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4977 + 68] = mem[_4977 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4977 + -mem[64] + 100
                _4574 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4574] = 26
                mem[_4574 + 32] = 'SafeMath: division by zero'
                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                    revert with 0, 'SafeMath: addition overflow'
                amountToBurn += 0 / totalAllocPoint / 20
                if not 0 / totalAllocPoint:
                    _5289 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5289] = 26
                    mem[_5289 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5344 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5344 + 68] = mem[idx + _5289 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5344 + 68] = mem[_5344 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5344 + -mem[64] + 100
                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5315 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5315] = 26
                mem[_5315 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5391 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5391 + 68] = mem[idx + _5315 + 32]
                    idx = idx + 32
                    continue 
                mem[_5391 + 68] = mem[_5391 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5391 + -mem[64] + 100
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _3129 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3129] = 30
            mem[_3129 + 32] = 'SafeMath: subtraction overflow'
            if ext_call.return_data[0] > ext_call.return_data[0]:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                idx = 32
                while idx < 30:
                    mem[idx + mem[64] + 68] = mem[idx + _3129 + 32]
                    idx = idx + 32
                    continue 
                revert with 0, 'SafeMath: subtraction overflow'
            mem[mem[64] + 4] = devAddress
            mem[mem[64] + 36] = 0
            require ext_code.size(sphereTokenAddress)
            call sphereTokenAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args devAddress, 0
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sphereTokenAddress)
                call sphereTokenAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3771 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3771] = 26
                mem[_3771 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                    if not 0 / totalAllocPoint:
                        _4580 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4580] = 26
                        mem[_4580 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4682 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4682 + 68] = mem[idx + _4580 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4682 + 68] = mem[_4682 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4682 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4635 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4635] = 26
                    mem[_4635 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4736 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4736 + 68] = mem[idx + _4635 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4736 + 68] = mem[_4736 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4736 + -mem[64] + 100
                _4375 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4375] = 26
                mem[_4375 + 32] = 'SafeMath: division by zero'
                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                    revert with 0, 'SafeMath: addition overflow'
                amountToBurn += 0 / totalAllocPoint / 20
                if not 0 / totalAllocPoint:
                    _5140 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5140] = 26
                    mem[_5140 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5206 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5206 + 68] = mem[idx + _5140 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5206 + 68] = mem[_5206 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5206 + -mem[64] + 100
                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5174 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5174] = 26
                mem[_5174 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5249 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5249 + 68] = mem[idx + _5174 + 32]
                    idx = idx + 32
                    continue 
                mem[_5249 + 68] = mem[_5249 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5249 + -mem[64] + 100
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            if ext_call.return_data[0] >= ext_call.return_data[0]:
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3909 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3909] = 26
                mem[_3909 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                    if not 0 / totalAllocPoint:
                        _4812 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4812] = 26
                        mem[_4812 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4925 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4925 + 68] = mem[idx + _4812 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4925 + 68] = mem[_4925 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4925 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4868 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4868] = 26
                    mem[_4868 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4982 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4982 + 68] = mem[idx + _4868 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4982 + 68] = mem[_4982 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4982 + -mem[64] + 100
                _4578 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4578] = 26
                mem[_4578 + 32] = 'SafeMath: division by zero'
                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                    revert with 0, 'SafeMath: addition overflow'
                amountToBurn += 0 / totalAllocPoint / 20
                if not 0 / totalAllocPoint:
                    _5290 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5290] = 26
                    mem[_5290 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5347 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5347 + 68] = mem[idx + _5290 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5347 + 68] = mem[_5347 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5347 + -mem[64] + 100
                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5316 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5316] = 26
                mem[_5316 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5394 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5394 + 68] = mem[idx + _5316 + 32]
                    idx = idx + 32
                    continue 
                mem[_5394 + 68] = mem[_5394 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5394 + -mem[64] + 100
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _3985 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3985] = 30
            mem[_3985 + 32] = 'SafeMath: subtraction overflow'
            if ext_call.return_data[0] > ext_call.return_data[0]:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                idx = 32
                while idx < 30:
                    mem[idx + mem[64] + 68] = mem[idx + _3985 + 32]
                    idx = idx + 32
                    continue 
                revert with 0, 'SafeMath: subtraction overflow'
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = 0
            require ext_code.size(sphereTokenAddress)
            call sphereTokenAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args address(this.address), 0
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _4579 = mem[64]
            mem[64] = mem[64] + 64
            mem[_4579] = 26
            mem[_4579 + 32] = 'SafeMath: division by zero'
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                if not 0 / totalAllocPoint:
                    _5397 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5397] = 26
                    mem[_5397 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5478 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5478 + 68] = mem[idx + _5397 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5478 + 68] = mem[_5478 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5478 + -mem[64] + 100
                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5440 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5440] = 26
                mem[_5440 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5506 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5506 + 68] = mem[idx + _5440 + 32]
                    idx = idx + 32
                    continue 
                mem[_5506 + 68] = mem[_5506 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5506 + -mem[64] + 100
            _5248 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5248] = 26
            mem[_5248 + 32] = 'SafeMath: division by zero'
            if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                revert with 0, 'SafeMath: addition overflow'
            amountToBurn += 0 / totalAllocPoint / 20
            if not 0 / totalAllocPoint:
                _5627 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5627] = 26
                mem[_5627 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5638 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5638 + 68] = mem[idx + _5627 + 32]
                    idx = idx + 32
                    continue 
                mem[_5638 + 68] = mem[_5638 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5638 + -mem[64] + 100
            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _5632 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5632] = 26
            mem[_5632 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0]:
                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _5648 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _5648 + 68] = mem[idx + _5632 + 32]
                idx = idx + 32
                continue 
            mem[_5648 + 68] = mem[_5648 + 74 len 26]
            revert with memory
              from mem[64]
               len _5648 + -mem[64] + 100
        if (block.number * spherePerBlock) - (poolInfo[idx].field_512 * spherePerBlock) / block.number - poolInfo[idx].field_512 != spherePerBlock:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        if not (block.number * spherePerBlock) - (poolInfo[idx].field_512 * spherePerBlock):
            _2911 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2911] = 26
            mem[_2911 + 32] = 'SafeMath: division by zero'
            if not totalAllocPoint:
                _2920 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _2920 + 68] = mem[idx + _2911 + 32]
                    idx = idx + 32
                    continue 
                mem[_2920 + 68] = mem[_2920 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _2920 + -mem[64] + 100
            _2937 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2937] = 26
            mem[_2937 + 32] = 'SafeMath: division by zero'
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] <= ext_call.return_data[0]:
                mem[mem[64] + 4] = devAddress
                mem[mem[64] + 36] = 0 / totalAllocPoint / 20
                require ext_code.size(sphereTokenAddress)
                call sphereTokenAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devAddress, 0 / totalAllocPoint / 20
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sphereTokenAddress)
                    call sphereTokenAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0xd5abeb01 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    _3329 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3329] = 26
                    mem[_3329 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                        revert with 0, 'SafeMath: addition overflow'
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                        if not 0 / totalAllocPoint:
                            _3800 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3800] = 26
                            mem[_3800 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3856 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3856 + 68] = mem[idx + _3800 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3856 + 68] = mem[_3856 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3856 + -mem[64] + 100
                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _3828 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3828] = 26
                        mem[_3828 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3901 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _3901 + 68] = mem[idx + _3828 + 32]
                            idx = idx + 32
                            continue 
                        mem[_3901 + 68] = mem[_3901 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3901 + -mem[64] + 100
                    _3669 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3669] = 26
                    mem[_3669 + 32] = 'SafeMath: division by zero'
                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                        revert with 0, 'SafeMath: addition overflow'
                    amountToBurn += 0 / totalAllocPoint / 20
                    if not 0 / totalAllocPoint:
                        _4251 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4251] = 26
                        mem[_4251 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4364 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4364 + 68] = mem[idx + _4251 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4364 + 68] = mem[_4364 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4364 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4310 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4310] = 26
                    mem[_4310 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4422 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4422 + 68] = mem[idx + _4310 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4422 + 68] = mem[_4422 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4422 + -mem[64] + 100
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                if ext_call.return_data[0] >= ext_call.return_data[0]:
                    staticcall sphereTokenAddress.0xd5abeb01 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    _3413 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3413] = 26
                    mem[_3413 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                        revert with 0, 'SafeMath: addition overflow'
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                        if not 0 / totalAllocPoint:
                            _3939 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3939] = 26
                            mem[_3939 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _4024 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4024 + 68] = mem[idx + _3939 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4024 + 68] = mem[_4024 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _4024 + -mem[64] + 100
                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _3976 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3976] = 26
                        mem[_3976 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4081 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4081 + 68] = mem[idx + _3976 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4081 + 68] = mem[_4081 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4081 + -mem[64] + 100
                    _3798 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3798] = 26
                    mem[_3798 + 32] = 'SafeMath: division by zero'
                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                        revert with 0, 'SafeMath: addition overflow'
                    amountToBurn += 0 / totalAllocPoint / 20
                    if not 0 / totalAllocPoint:
                        _4465 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4465] = 26
                        mem[_4465 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4564 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4564 + 68] = mem[idx + _4465 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4564 + 68] = mem[_4564 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4564 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4504 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4504] = 26
                    mem[_4504 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4626 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4626 + 68] = mem[idx + _4504 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4626 + 68] = mem[_4626 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4626 + -mem[64] + 100
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3462 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3462] = 30
                mem[_3462 + 32] = 'SafeMath: subtraction overflow'
                if ext_call.return_data[0] > ext_call.return_data[0]:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                    idx = 32
                    while idx < 30:
                        mem[idx + mem[64] + 68] = mem[idx + _3462 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: subtraction overflow'
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0
                require ext_code.size(sphereTokenAddress)
                call sphereTokenAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3799 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3799] = 26
                mem[_3799 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                    if not 0 / totalAllocPoint:
                        _4629 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4629] = 26
                        mem[_4629 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4723 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4723 + 68] = mem[idx + _4629 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4723 + 68] = mem[_4723 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4723 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4675 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4675] = 26
                    mem[_4675 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4800 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4800 + 68] = mem[idx + _4675 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4800 + 68] = mem[_4800 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4800 + -mem[64] + 100
                _4421 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4421] = 26
                mem[_4421 + 32] = 'SafeMath: division by zero'
                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                    revert with 0, 'SafeMath: addition overflow'
                amountToBurn += 0 / totalAllocPoint / 20
                if not 0 / totalAllocPoint:
                    _5167 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5167] = 26
                    mem[_5167 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5241 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5241 + 68] = mem[idx + _5167 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5241 + 68] = mem[_5241 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5241 + -mem[64] + 100
                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5201 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5201] = 26
                mem[_5201 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5286 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5286 + 68] = mem[idx + _5201 + 32]
                    idx = idx + 32
                    continue 
                mem[_5286 + 68] = mem[_5286 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5286 + -mem[64] + 100
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            if ext_call.return_data[0] >= ext_call.return_data[0]:
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sphereTokenAddress)
                    call sphereTokenAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0xd5abeb01 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    _3411 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3411] = 26
                    mem[_3411 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                        revert with 0, 'SafeMath: addition overflow'
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                        if not 0 / totalAllocPoint:
                            _3936 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3936] = 26
                            mem[_3936 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _4020 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4020 + 68] = mem[idx + _3936 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4020 + 68] = mem[_4020 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _4020 + -mem[64] + 100
                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _3972 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3972] = 26
                        mem[_3972 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4075 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4075 + 68] = mem[idx + _3972 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4075 + 68] = mem[_4075 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4075 + -mem[64] + 100
                    _3794 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3794] = 26
                    mem[_3794 + 32] = 'SafeMath: division by zero'
                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                        revert with 0, 'SafeMath: addition overflow'
                    amountToBurn += 0 / totalAllocPoint / 20
                    if not 0 / totalAllocPoint:
                        _4462 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4462] = 26
                        mem[_4462 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4558 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4558 + 68] = mem[idx + _4462 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4558 + 68] = mem[_4558 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4558 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4502 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4502] = 26
                    mem[_4502 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4620 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4620 + 68] = mem[idx + _4502 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4620 + 68] = mem[_4620 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4620 + -mem[64] + 100
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                if ext_call.return_data[0] >= ext_call.return_data[0]:
                    staticcall sphereTokenAddress.0xd5abeb01 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    _3501 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3501] = 26
                    mem[_3501 + 32] = 'SafeMath: division by zero'
                    require ext_code.size(sphereTokenAddress)
                    staticcall sphereTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                        revert with 0, 'SafeMath: addition overflow'
                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                        if not 0 / totalAllocPoint:
                            _4129 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4129] = 26
                            mem[_4129 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _4234 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4234 + 68] = mem[idx + _4129 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4234 + 68] = mem[_4234 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _4234 + -mem[64] + 100
                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _4178 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4178] = 26
                        mem[_4178 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4295 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4295 + 68] = mem[idx + _4178 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4295 + 68] = mem[_4295 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4295 + -mem[64] + 100
                    _3934 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3934] = 26
                    mem[_3934 + 32] = 'SafeMath: division by zero'
                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                        revert with 0, 'SafeMath: addition overflow'
                    amountToBurn += 0 / totalAllocPoint / 20
                    if not 0 / totalAllocPoint:
                        _4671 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4671] = 26
                        mem[_4671 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4782 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4782 + 68] = mem[idx + _4671 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4782 + 68] = mem[_4782 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4782 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4713 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4713] = 26
                    mem[_4713 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4851 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4851 + 68] = mem[idx + _4713 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4851 + 68] = mem[_4851 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4851 + -mem[64] + 100
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3568 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3568] = 30
                mem[_3568 + 32] = 'SafeMath: subtraction overflow'
                if ext_call.return_data[0] > ext_call.return_data[0]:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                    idx = 32
                    while idx < 30:
                        mem[idx + mem[64] + 68] = mem[idx + _3568 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: subtraction overflow'
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0
                require ext_code.size(sphereTokenAddress)
                call sphereTokenAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3935 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3935] = 26
                mem[_3935 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                    if not 0 / totalAllocPoint:
                        _4854 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4854] = 26
                        mem[_4854 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4962 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4962 + 68] = mem[idx + _4854 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4962 + 68] = mem[_4962 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4962 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4905 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4905] = 26
                    mem[_4905 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5020 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5020 + 68] = mem[idx + _4905 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5020 + 68] = mem[_5020 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5020 + -mem[64] + 100
                _4619 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4619] = 26
                mem[_4619 + 32] = 'SafeMath: division by zero'
                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                    revert with 0, 'SafeMath: addition overflow'
                amountToBurn += 0 / totalAllocPoint / 20
                if not 0 / totalAllocPoint:
                    _5311 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5311] = 26
                    mem[_5311 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5377 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5377 + 68] = mem[idx + _5311 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5377 + 68] = mem[_5377 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5377 + -mem[64] + 100
                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5336 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5336] = 26
                mem[_5336 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5425 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5425 + 68] = mem[idx + _5336 + 32]
                    idx = idx + 32
                    continue 
                mem[_5425 + 68] = mem[_5425 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5425 + -mem[64] + 100
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _3141 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3141] = 30
            mem[_3141 + 32] = 'SafeMath: subtraction overflow'
            if ext_call.return_data[0] > ext_call.return_data[0]:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                idx = 32
                while idx < 30:
                    mem[idx + mem[64] + 68] = mem[idx + _3141 + 32]
                    idx = idx + 32
                    continue 
                revert with 0, 'SafeMath: subtraction overflow'
            mem[mem[64] + 4] = devAddress
            mem[mem[64] + 36] = 0
            require ext_code.size(sphereTokenAddress)
            call sphereTokenAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args devAddress, 0
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sphereTokenAddress)
                call sphereTokenAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3797 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3797] = 26
                mem[_3797 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                    if not 0 / totalAllocPoint:
                        _4625 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4625] = 26
                        mem[_4625 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4717 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4717 + 68] = mem[idx + _4625 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4717 + 68] = mem[_4717 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4717 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4673 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4673] = 26
                    mem[_4673 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4792 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4792 + 68] = mem[idx + _4673 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4792 + 68] = mem[_4792 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4792 + -mem[64] + 100
                _4418 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4418] = 26
                mem[_4418 + 32] = 'SafeMath: division by zero'
                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                    revert with 0, 'SafeMath: addition overflow'
                amountToBurn += 0 / totalAllocPoint / 20
                if not 0 / totalAllocPoint:
                    _5166 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5166] = 26
                    mem[_5166 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5238 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5238 + 68] = mem[idx + _5166 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5238 + 68] = mem[_5238 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5238 + -mem[64] + 100
                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5200 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5200] = 26
                mem[_5200 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5283 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5283 + 68] = mem[idx + _5200 + 32]
                    idx = idx + 32
                    continue 
                mem[_5283 + 68] = mem[_5283 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5283 + -mem[64] + 100
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            if ext_call.return_data[0] >= ext_call.return_data[0]:
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3937 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3937] = 26
                mem[_3937 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                    if not 0 / totalAllocPoint:
                        _4858 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4858] = 26
                        mem[_4858 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4965 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4965 + 68] = mem[idx + _4858 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4965 + 68] = mem[_4965 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4965 + -mem[64] + 100
                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4908 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4908] = 26
                    mem[_4908 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5025 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5025 + 68] = mem[idx + _4908 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5025 + 68] = mem[_5025 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5025 + -mem[64] + 100
                _4623 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4623] = 26
                mem[_4623 + 32] = 'SafeMath: division by zero'
                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                    revert with 0, 'SafeMath: addition overflow'
                amountToBurn += 0 / totalAllocPoint / 20
                if not 0 / totalAllocPoint:
                    _5312 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5312] = 26
                    mem[_5312 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5380 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5380 + 68] = mem[idx + _5312 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5380 + 68] = mem[_5380 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5380 + -mem[64] + 100
                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5337 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5337] = 26
                mem[_5337 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5428 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5428 + 68] = mem[idx + _5337 + 32]
                    idx = idx + 32
                    continue 
                mem[_5428 + 68] = mem[_5428 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5428 + -mem[64] + 100
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _4023 = mem[64]
            mem[64] = mem[64] + 64
            mem[_4023] = 30
            mem[_4023 + 32] = 'SafeMath: subtraction overflow'
            if ext_call.return_data[0] > ext_call.return_data[0]:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                idx = 32
                while idx < 30:
                    mem[idx + mem[64] + 68] = mem[idx + _4023 + 32]
                    idx = idx + 32
                    continue 
                revert with 0, 'SafeMath: subtraction overflow'
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = 0
            require ext_code.size(sphereTokenAddress)
            call sphereTokenAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args address(this.address), 0
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _4624 = mem[64]
            mem[64] = mem[64] + 64
            mem[_4624] = 26
            mem[_4624 + 32] = 'SafeMath: division by zero'
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                if not 0 / totalAllocPoint:
                    _5431 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5431] = 26
                    mem[_5431 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5497 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5497 + 68] = mem[idx + _5431 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5497 + 68] = mem[_5497 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5497 + -mem[64] + 100
                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _5467 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5467] = 26
                mem[_5467 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5529 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5529 + 68] = mem[idx + _5467 + 32]
                    idx = idx + 32
                    continue 
                mem[_5529 + 68] = mem[_5529 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5529 + -mem[64] + 100
            _5282 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5282] = 26
            mem[_5282 + 32] = 'SafeMath: division by zero'
            if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                revert with 0, 'SafeMath: addition overflow'
            amountToBurn += 0 / totalAllocPoint / 20
            if not 0 / totalAllocPoint:
                _5631 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5631] = 26
                mem[_5631 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5645 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5645 + 68] = mem[idx + _5631 + 32]
                    idx = idx + 32
                    continue 
                mem[_5645 + 68] = mem[_5645 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5645 + -mem[64] + 100
            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _5637 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5637] = 26
            mem[_5637 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0]:
                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _5657 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _5657 + 68] = mem[idx + _5637 + 32]
                idx = idx + 32
                continue 
            mem[_5657 + 68] = mem[_5657 + 74 len 26]
            revert with memory
              from mem[64]
               len _5657 + -mem[64] + 100
        if (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / (block.number * spherePerBlock) - (poolInfo[idx].field_512 * spherePerBlock) != poolInfo[idx].field_256:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        _2914 = mem[64]
        mem[64] = mem[64] + 64
        mem[_2914] = 26
        mem[_2914 + 32] = 'SafeMath: division by zero'
        if not totalAllocPoint:
            _2923 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _2923 + 68] = mem[idx + _2914 + 32]
                idx = idx + 32
                continue 
            mem[_2923 + 68] = mem[_2923 + 74 len 26]
            revert with memory
              from mem[64]
               len _2923 + -mem[64] + 100
        _2939 = mem[64]
        mem[64] = mem[64] + 64
        mem[_2939] = 26
        mem[_2939 + 32] = 'SafeMath: division by zero'
        require ext_code.size(sphereTokenAddress)
        staticcall sphereTokenAddress.0xd5abeb01 with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(sphereTokenAddress)
        staticcall sphereTokenAddress.0x18160ddd with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
            revert with 0, 'SafeMath: addition overflow'
        if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] <= ext_call.return_data[0]:
            mem[mem[64] + 4] = devAddress
            mem[mem[64] + 36] = (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
            require ext_code.size(sphereTokenAddress)
            call sphereTokenAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args devAddress, (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint
                require ext_code.size(sphereTokenAddress)
                call sphereTokenAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3342 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3342] = 26
                mem[_3342 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                    if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                        _3824 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3824] = 26
                        mem[_3824 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3892 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _3892 + 68] = mem[idx + _3824 + 32]
                            idx = idx + 32
                            continue 
                        mem[_3892 + 68] = mem[_3892 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3892 + -mem[64] + 100
                    if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _3850 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3850] = 26
                    mem[_3850 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3929 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _3929 + 68] = mem[idx + _3850 + 32]
                        idx = idx + 32
                        continue 
                    mem[_3929 + 68] = mem[_3929 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3929 + -mem[64] + 100
                _3691 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3691] = 26
                mem[_3691 + 32] = 'SafeMath: division by zero'
                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                    revert with 0, 'SafeMath: addition overflow'
                amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
                if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                    _4294 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4294] = 26
                    mem[_4294 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4407 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4407 + 68] = mem[idx + _4294 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4407 + 68] = mem[_4407 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4407 + -mem[64] + 100
                if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _4354 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4354] = 26
                mem[_4354 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _4454 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _4454 + 68] = mem[idx + _4354 + 32]
                    idx = idx + 32
                    continue 
                mem[_4454 + 68] = mem[_4454 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _4454 + -mem[64] + 100
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            if ext_call.return_data[0] >= ext_call.return_data[0]:
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3434 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3434] = 26
                mem[_3434 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                    if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                        _3970 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3970] = 26
                        mem[_3970 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4067 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4067 + 68] = mem[idx + _3970 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4067 + 68] = mem[_4067 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4067 + -mem[64] + 100
                    if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4014 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4014] = 26
                    mem[_4014 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4120 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4120 + 68] = mem[idx + _4014 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4120 + 68] = mem[_4120 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4120 + -mem[64] + 100
                _3822 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3822] = 26
                mem[_3822 + 32] = 'SafeMath: division by zero'
                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                    revert with 0, 'SafeMath: addition overflow'
                amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
                if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                    _4497 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4497] = 26
                    mem[_4497 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4609 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4609 + 68] = mem[idx + _4497 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4609 + 68] = mem[_4609 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4609 + -mem[64] + 100
                if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _4552 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4552] = 26
                mem[_4552 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _4664 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _4664 + 68] = mem[idx + _4552 + 32]
                    idx = idx + 32
                    continue 
                mem[_4664 + 68] = mem[_4664 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _4664 + -mem[64] + 100
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _3476 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3476] = 30
            mem[_3476 + 32] = 'SafeMath: subtraction overflow'
            if ext_call.return_data[0] > ext_call.return_data[0]:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                idx = 32
                while idx < 30:
                    mem[idx + mem[64] + 68] = mem[idx + _3476 + 32]
                    idx = idx + 32
                    continue 
                revert with 0, 'SafeMath: subtraction overflow'
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = 0
            require ext_code.size(sphereTokenAddress)
            call sphereTokenAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args address(this.address), 0
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _3823 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3823] = 26
            mem[_3823 + 32] = 'SafeMath: division by zero'
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                    _4667 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4667] = 26
                    mem[_4667 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4779 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4779 + 68] = mem[idx + _4667 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4779 + 68] = mem[_4779 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4779 + -mem[64] + 100
                if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _4710 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4710] = 26
                mem[_4710 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _4846 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _4846 + 68] = mem[idx + _4710 + 32]
                    idx = idx + 32
                    continue 
                mem[_4846 + 68] = mem[_4846 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _4846 + -mem[64] + 100
            _4453 = mem[64]
            mem[64] = mem[64] + 64
            mem[_4453] = 26
            mem[_4453 + 32] = 'SafeMath: division by zero'
            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                revert with 0, 'SafeMath: addition overflow'
            amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
            if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                _5193 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5193] = 26
                mem[_5193 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5275 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5275 + 68] = mem[idx + _5193 + 32]
                    idx = idx + 32
                    continue 
                mem[_5275 + 68] = mem[_5275 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5275 + -mem[64] + 100
            if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _5233 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5233] = 26
            mem[_5233 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0]:
                if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _5308 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _5308 + 68] = mem[idx + _5233 + 32]
                idx = idx + 32
                continue 
            mem[_5308 + 68] = mem[_5308 + 74 len 26]
            revert with memory
              from mem[64]
               len _5308 + -mem[64] + 100
        require ext_code.size(sphereTokenAddress)
        staticcall sphereTokenAddress.0xd5abeb01 with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(sphereTokenAddress)
        staticcall sphereTokenAddress.0x18160ddd with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(sphereTokenAddress)
        if ext_call.return_data[0] >= ext_call.return_data[0]:
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint
                require ext_code.size(sphereTokenAddress)
                call sphereTokenAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3432 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3432] = 26
                mem[_3432 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                    if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                        _3967 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3967] = 26
                        mem[_3967 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4063 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4063 + 68] = mem[idx + _3967 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4063 + 68] = mem[_4063 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4063 + -mem[64] + 100
                    if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4010 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4010] = 26
                    mem[_4010 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4114 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4114 + 68] = mem[idx + _4010 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4114 + 68] = mem[_4114 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4114 + -mem[64] + 100
                _3818 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3818] = 26
                mem[_3818 + 32] = 'SafeMath: division by zero'
                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                    revert with 0, 'SafeMath: addition overflow'
                amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
                if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                    _4494 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4494] = 26
                    mem[_4494 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4603 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4603 + 68] = mem[idx + _4494 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4603 + 68] = mem[_4603 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4603 + -mem[64] + 100
                if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _4550 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4550] = 26
                mem[_4550 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _4658 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _4658 + 68] = mem[idx + _4550 + 32]
                    idx = idx + 32
                    continue 
                mem[_4658 + 68] = mem[_4658 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _4658 + -mem[64] + 100
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            if ext_call.return_data[0] >= ext_call.return_data[0]:
                staticcall sphereTokenAddress.0xd5abeb01 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                _3526 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3526] = 26
                mem[_3526 + 32] = 'SafeMath: division by zero'
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                    if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                        _4168 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4168] = 26
                        mem[_4168 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _4277 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4277 + 68] = mem[idx + _4168 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4277 + 68] = mem[_4277 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _4277 + -mem[64] + 100
                    if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _4220 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4220] = 26
                    mem[_4220 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4339 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4339 + 68] = mem[idx + _4220 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4339 + 68] = mem[_4339 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4339 + -mem[64] + 100
                _3965 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3965] = 26
                mem[_3965 + 32] = 'SafeMath: division by zero'
                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                    revert with 0, 'SafeMath: addition overflow'
                amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
                if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                    _4706 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4706] = 26
                    mem[_4706 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4828 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4828 + 68] = mem[idx + _4706 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4828 + 68] = mem[_4828 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4828 + -mem[64] + 100
                if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _4769 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4769] = 26
                mem[_4769 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _4891 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _4891 + 68] = mem[idx + _4769 + 32]
                    idx = idx + 32
                    continue 
                mem[_4891 + 68] = mem[_4891 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _4891 + -mem[64] + 100
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _3586 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3586] = 30
            mem[_3586 + 32] = 'SafeMath: subtraction overflow'
            if ext_call.return_data[0] > ext_call.return_data[0]:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                idx = 32
                while idx < 30:
                    mem[idx + mem[64] + 68] = mem[idx + _3586 + 32]
                    idx = idx + 32
                    continue 
                revert with 0, 'SafeMath: subtraction overflow'
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = 0
            require ext_code.size(sphereTokenAddress)
            call sphereTokenAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args address(this.address), 0
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _3966 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3966] = 26
            mem[_3966 + 32] = 'SafeMath: division by zero'
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                    _4894 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4894] = 26
                    mem[_4894 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5005 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5005 + 68] = mem[idx + _4894 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5005 + 68] = mem[_5005 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5005 + -mem[64] + 100
                if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _4945 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4945] = 26
                mem[_4945 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5060 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5060 + 68] = mem[idx + _4945 + 32]
                    idx = idx + 32
                    continue 
                mem[_5060 + 68] = mem[_5060 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5060 + -mem[64] + 100
            _4657 = mem[64]
            mem[64] = mem[64] + 64
            mem[_4657] = 26
            mem[_4657 + 32] = 'SafeMath: division by zero'
            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                revert with 0, 'SafeMath: addition overflow'
            amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
            if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                _5332 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5332] = 26
                mem[_5332 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5411 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5411 + 68] = mem[idx + _5332 + 32]
                    idx = idx + 32
                    continue 
                mem[_5411 + 68] = mem[_5411 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5411 + -mem[64] + 100
            if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _5369 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5369] = 26
            mem[_5369 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0]:
                if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _5452 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _5452 + 68] = mem[idx + _5369 + 32]
                idx = idx + 32
                continue 
            mem[_5452 + 68] = mem[_5452 + 74 len 26]
            revert with memory
              from mem[64]
               len _5452 + -mem[64] + 100
        staticcall sphereTokenAddress.0x18160ddd with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(sphereTokenAddress)
        staticcall sphereTokenAddress.0xd5abeb01 with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        _3156 = mem[64]
        mem[64] = mem[64] + 64
        mem[_3156] = 30
        mem[_3156 + 32] = 'SafeMath: subtraction overflow'
        if ext_call.return_data[0] > ext_call.return_data[0]:
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
            idx = 32
            while idx < 30:
                mem[idx + mem[64] + 68] = mem[idx + _3156 + 32]
                idx = idx + 32
                continue 
            revert with 0, 'SafeMath: subtraction overflow'
        mem[mem[64] + 4] = devAddress
        mem[mem[64] + 36] = 0
        require ext_code.size(sphereTokenAddress)
        call sphereTokenAddress.0x40c10f19 with:
             gas gas_remaining wei
            args devAddress, 0
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require ext_code.size(sphereTokenAddress)
        staticcall sphereTokenAddress.0xd5abeb01 with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(sphereTokenAddress)
        staticcall sphereTokenAddress.0x18160ddd with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
            revert with 0, 'SafeMath: addition overflow'
        if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint
            require ext_code.size(sphereTokenAddress)
            call sphereTokenAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args address(this.address), (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _3821 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3821] = 26
            mem[_3821 + 32] = 'SafeMath: division by zero'
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                    _4663 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4663] = 26
                    mem[_4663 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4773 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _4773 + 68] = mem[idx + _4663 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4773 + 68] = mem[_4773 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4773 + -mem[64] + 100
                if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _4708 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4708] = 26
                mem[_4708 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _4838 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _4838 + 68] = mem[idx + _4708 + 32]
                    idx = idx + 32
                    continue 
                mem[_4838 + 68] = mem[_4838 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _4838 + -mem[64] + 100
            _4450 = mem[64]
            mem[64] = mem[64] + 64
            mem[_4450] = 26
            mem[_4450 + 32] = 'SafeMath: division by zero'
            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                revert with 0, 'SafeMath: addition overflow'
            amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
            if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                _5192 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5192] = 26
                mem[_5192 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5272 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5272 + 68] = mem[idx + _5192 + 32]
                    idx = idx + 32
                    continue 
                mem[_5272 + 68] = mem[_5272 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5272 + -mem[64] + 100
            if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _5232 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5232] = 26
            mem[_5232 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0]:
                if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _5305 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _5305 + 68] = mem[idx + _5232 + 32]
                idx = idx + 32
                continue 
            mem[_5305 + 68] = mem[_5305 + 74 len 26]
            revert with memory
              from mem[64]
               len _5305 + -mem[64] + 100
        require ext_code.size(sphereTokenAddress)
        staticcall sphereTokenAddress.0xd5abeb01 with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(sphereTokenAddress)
        staticcall sphereTokenAddress.0x18160ddd with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(sphereTokenAddress)
        if ext_call.return_data[0] >= ext_call.return_data[0]:
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _3968 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3968] = 26
            mem[_3968 + 32] = 'SafeMath: division by zero'
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                    _4898 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4898] = 26
                    mem[_4898 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0]:
                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _5008 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5008 + 68] = mem[idx + _4898 + 32]
                        idx = idx + 32
                        continue 
                    mem[_5008 + 68] = mem[_5008 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _5008 + -mem[64] + 100
                if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _4948 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4948] = 26
                mem[_4948 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5065 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5065 + 68] = mem[idx + _4948 + 32]
                    idx = idx + 32
                    continue 
                mem[_5065 + 68] = mem[_5065 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5065 + -mem[64] + 100
            _4661 = mem[64]
            mem[64] = mem[64] + 64
            mem[_4661] = 26
            mem[_4661 + 32] = 'SafeMath: division by zero'
            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                revert with 0, 'SafeMath: addition overflow'
            amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
            if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                _5333 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5333] = 26
                mem[_5333 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5414 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5414 + 68] = mem[idx + _5333 + 32]
                    idx = idx + 32
                    continue 
                mem[_5414 + 68] = mem[_5414 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5414 + -mem[64] + 100
            if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _5370 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5370] = 26
            mem[_5370 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0]:
                if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _5455 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _5455 + 68] = mem[idx + _5370 + 32]
                idx = idx + 32
                continue 
            mem[_5455 + 68] = mem[_5455 + 74 len 26]
            revert with memory
              from mem[64]
               len _5455 + -mem[64] + 100
        staticcall sphereTokenAddress.0x18160ddd with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(sphereTokenAddress)
        staticcall sphereTokenAddress.0xd5abeb01 with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        _4066 = mem[64]
        mem[64] = mem[64] + 64
        mem[_4066] = 30
        mem[_4066 + 32] = 'SafeMath: subtraction overflow'
        if ext_call.return_data[0] > ext_call.return_data[0]:
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
            idx = 32
            while idx < 30:
                mem[idx + mem[64] + 68] = mem[idx + _4066 + 32]
                idx = idx + 32
                continue 
            revert with 0, 'SafeMath: subtraction overflow'
        mem[mem[64] + 4] = this.address
        mem[mem[64] + 36] = 0
        require ext_code.size(sphereTokenAddress)
        call sphereTokenAddress.0x40c10f19 with:
             gas gas_remaining wei
            args address(this.address), 0
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require ext_code.size(sphereTokenAddress)
        staticcall sphereTokenAddress.0xd5abeb01 with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        _4662 = mem[64]
        mem[64] = mem[64] + 64
        mem[_4662] = 26
        mem[_4662 + 32] = 'SafeMath: division by zero'
        require ext_code.size(sphereTokenAddress)
        staticcall sphereTokenAddress.0x18160ddd with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
            revert with 0, 'SafeMath: addition overflow'
        if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
            if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                _5458 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5458] = 26
                mem[_5458 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0]:
                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _5520 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5520 + 68] = mem[idx + _5458 + 32]
                    idx = idx + 32
                    continue 
                mem[_5520 + 68] = mem[_5520 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _5520 + -mem[64] + 100
            if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _5486 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5486] = 26
            mem[_5486 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0]:
                if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _5549 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _5549 + 68] = mem[idx + _5486 + 32]
                idx = idx + 32
                continue 
            mem[_5549 + 68] = mem[_5549 + 74 len 26]
            revert with memory
              from mem[64]
               len _5549 + -mem[64] + 100
        _5304 = mem[64]
        mem[64] = mem[64] + 64
        mem[_5304] = 26
        mem[_5304 + 32] = 'SafeMath: division by zero'
        if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
            revert with 0, 'SafeMath: addition overflow'
        amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
        if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
            _5636 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5636] = 26
            mem[_5636 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0]:
                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _5654 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _5654 + 68] = mem[idx + _5636 + 32]
                idx = idx + 32
                continue 
            mem[_5654 + 68] = mem[_5654 + 74 len 26]
            revert with memory
              from mem[64]
               len _5654 + -mem[64] + 100
        if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        _5644 = mem[64]
        mem[64] = mem[64] + 64
        mem[_5644] = 26
        mem[_5644 + 32] = 'SafeMath: division by zero'
        if ext_call.return_data[0]:
            if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                revert with 0, 'SafeMath: addition overflow'
            poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
            poolInfo[idx].field_512 = block.number
            idx = idx + 1
            continue 
        _5663 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 26
        idx = 0
        while idx < 26:
            mem[idx + _5663 + 68] = mem[idx + _5644 + 32]
            idx = idx + 32
            continue 
        mem[_5663 + 68] = mem[_5663 + 74 len 26]
        revert with memory
          from mem[64]
           len _5663 + -mem[64] + 100
    spherePerBlock = 0
}

function burnInPool() payable {
    mem[64] = 96
    if stor1 == 2:
        revert with 0, 'tReentrancyGuard: reentrant call'
    stor1 = 2
    if 10^17 >= amountToBurn:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    38,
                    0x734275726e696e6720616d6f756e742068617320746f206265203e20302e3120546f6b656e73,
                    mem[202 len 26]
    if stor16:
        if not stor16:
            revert with 0, 'Dynamic emissions turned off.'
        if usdcSphereLPAddress:
            if block.number - lastBlockUpdate > emissionUpdateInterval:
                lastBlockUpdate = block.number
                mem[100] = usdcSphereLPAddress
                require ext_code.size(sphereTokenAddress)
                staticcall sphereTokenAddress.0x70a08231 with:
                        gas gas_remaining wei
                       args usdcSphereLPAddress
                mem[96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if not ext_call.return_data[0]:
                    idx = 0
                    while idx < poolInfo.length:
                        mem[0] = 10
                        if block.number <= poolInfo[idx].field_512:
                            idx = idx + 1
                            continue 
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(poolInfo[idx].field_0)
                        staticcall poolInfo[idx].field_0.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        if not poolInfo[idx].field_256:
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        require ext_code.size(sphereTokenAddress)
                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(sphereTokenAddress)
                        staticcall sphereTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ext_call.return_data[0] >= ext_call.return_data[0]:
                            _19507 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19507] = 26
                            mem[_19507 + 32] = 'SafeMath: division by zero'
                            if not totalAllocPoint:
                                _19557 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _19557 + 68] = mem[idx + _19507 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19557 + 68] = mem[_19557 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _19557 + -mem[64] + 100
                            _19733 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19733] = 26
                            mem[_19733 + 32] = 'SafeMath: division by zero'
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                revert with 0, 'SafeMath: addition overflow'
                            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                mem[mem[64] + 4] = devAddress
                                mem[mem[64] + 36] = 0 / totalAllocPoint / 20
                                require ext_code.size(sphereTokenAddress)
                                call sphereTokenAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args devAddress, 0 / totalAllocPoint / 20
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = 0 / totalAllocPoint
                                    require ext_code.size(sphereTokenAddress)
                                    call sphereTokenAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _24050 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24050] = 26
                                    mem[_24050 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not 0 / totalAllocPoint:
                                            _27766 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_27766] = 26
                                            mem[_27766 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _28292 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _28292 + 68] = mem[idx + _27766 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_28292 + 68] = mem[_28292 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _28292 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _28040 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28040] = 26
                                        mem[_28040 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _28525 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _28525 + 68] = mem[idx + _28040 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_28525 + 68] = mem[_28525 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _28525 + -mem[64] + 100
                                    _26763 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26763] = 26
                                    mem[_26763 + 32] = 'SafeMath: division by zero'
                                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                        revert with 0, 'SafeMath: addition overflow'
                                    amountToBurn += 0 / totalAllocPoint / 20
                                    if not 0 / totalAllocPoint:
                                        _30022 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30022] = 26
                                        mem[_30022 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _30507 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _30507 + 68] = mem[idx + _30022 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_30507 + 68] = mem[_30507 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _30507 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _30257 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30257] = 26
                                    mem[_30257 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _30775 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _30775 + 68] = mem[idx + _30257 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_30775 + 68] = mem[_30775 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _30775 + -mem[64] + 100
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                if ext_call.return_data[0] >= ext_call.return_data[0]:
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _24937 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24937] = 26
                                    mem[_24937 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not 0 / totalAllocPoint:
                                            _28736 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_28736] = 26
                                            mem[_28736 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _29191 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _29191 + 68] = mem[idx + _28736 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_29191 + 68] = mem[_29191 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _29191 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _28947 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28947] = 26
                                        mem[_28947 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _29410 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _29410 + 68] = mem[idx + _28947 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_29410 + 68] = mem[_29410 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _29410 + -mem[64] + 100
                                    _27764 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27764] = 26
                                    mem[_27764 + 32] = 'SafeMath: division by zero'
                                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                        revert with 0, 'SafeMath: addition overflow'
                                    amountToBurn += 0 / totalAllocPoint / 20
                                    if not 0 / totalAllocPoint:
                                        _31058 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31058] = 26
                                        mem[_31058 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _31623 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _31623 + 68] = mem[idx + _31058 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_31623 + 68] = mem[_31623 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _31623 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _31333 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31333] = 26
                                    mem[_31333 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _31919 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _31919 + 68] = mem[idx + _31333 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_31919 + 68] = mem[_31919 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _31919 + -mem[64] + 100
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _25420 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25420] = 30
                                mem[_25420 + 32] = 'SafeMath: subtraction overflow'
                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _25420 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[mem[64] + 4] = this.address
                                mem[mem[64] + 36] = 0
                                require ext_code.size(sphereTokenAddress)
                                call sphereTokenAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _27765 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27765] = 26
                                mem[_27765 + 32] = 'SafeMath: division by zero'
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                    if not 0 / totalAllocPoint:
                                        _31922 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31922] = 26
                                        mem[_31922 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _32457 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _32457 + 68] = mem[idx + _31922 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_32457 + 68] = mem[_32457 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _32457 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _32199 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32199] = 26
                                    mem[_32199 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _32708 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _32708 + 68] = mem[idx + _32199 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_32708 + 68] = mem[_32708 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _32708 + -mem[64] + 100
                                _30774 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_30774] = 26
                                mem[_30774 + 32] = 'SafeMath: division by zero'
                                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                    revert with 0, 'SafeMath: addition overflow'
                                amountToBurn += 0 / totalAllocPoint / 20
                                if not 0 / totalAllocPoint:
                                    _34236 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34236] = 26
                                    mem[_34236 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _34632 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _34632 + 68] = mem[idx + _34236 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_34632 + 68] = mem[_34632 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _34632 + -mem[64] + 100
                                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _34425 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34425] = 26
                                mem[_34425 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _34847 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _34847 + 68] = mem[idx + _34425 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_34847 + 68] = mem[_34847 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _34847 + -mem[64] + 100
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            if ext_call.return_data[0] >= ext_call.return_data[0]:
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = 0 / totalAllocPoint
                                    require ext_code.size(sphereTokenAddress)
                                    call sphereTokenAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _24935 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24935] = 26
                                    mem[_24935 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not 0 / totalAllocPoint:
                                            _28733 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_28733] = 26
                                            mem[_28733 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _29187 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _29187 + 68] = mem[idx + _28733 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_29187 + 68] = mem[_29187 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _29187 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _28943 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28943] = 26
                                        mem[_28943 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _29404 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _29404 + 68] = mem[idx + _28943 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_29404 + 68] = mem[_29404 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _29404 + -mem[64] + 100
                                    _27760 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27760] = 26
                                    mem[_27760 + 32] = 'SafeMath: division by zero'
                                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                        revert with 0, 'SafeMath: addition overflow'
                                    amountToBurn += 0 / totalAllocPoint / 20
                                    if not 0 / totalAllocPoint:
                                        _31055 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31055] = 26
                                        mem[_31055 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _31617 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _31617 + 68] = mem[idx + _31055 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_31617 + 68] = mem[_31617 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _31617 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _31331 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31331] = 26
                                    mem[_31331 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _31913 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _31913 + 68] = mem[idx + _31331 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_31913 + 68] = mem[_31913 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _31913 + -mem[64] + 100
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                if ext_call.return_data[0] >= ext_call.return_data[0]:
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _25819 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_25819] = 26
                                    mem[_25819 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not 0 / totalAllocPoint:
                                            _29600 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_29600] = 26
                                            mem[_29600 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _30005 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _30005 + 68] = mem[idx + _29600 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_30005 + 68] = mem[_30005 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _30005 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _29787 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29787] = 26
                                        mem[_29787 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _30242 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _30242 + 68] = mem[idx + _29787 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_30242 + 68] = mem[_30242 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _30242 + -mem[64] + 100
                                    _28731 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28731] = 26
                                    mem[_28731 + 32] = 'SafeMath: division by zero'
                                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                        revert with 0, 'SafeMath: addition overflow'
                                    amountToBurn += 0 / totalAllocPoint / 20
                                    if not 0 / totalAllocPoint:
                                        _32195 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32195] = 26
                                        mem[_32195 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _32690 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _32690 + 68] = mem[idx + _32195 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_32690 + 68] = mem[_32690 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _32690 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _32447 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32447] = 26
                                    mem[_32447 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _32933 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _32933 + 68] = mem[idx + _32447 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_32933 + 68] = mem[_32933 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _32933 + -mem[64] + 100
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _26246 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26246] = 30
                                mem[_26246 + 32] = 'SafeMath: subtraction overflow'
                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _26246 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[mem[64] + 4] = this.address
                                mem[mem[64] + 36] = 0
                                require ext_code.size(sphereTokenAddress)
                                call sphereTokenAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _28732 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28732] = 26
                                mem[_28732 + 32] = 'SafeMath: division by zero'
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                    if not 0 / totalAllocPoint:
                                        _32936 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32936] = 26
                                        mem[_32936 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _33387 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _33387 + 68] = mem[idx + _32936 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33387 + 68] = mem[_33387 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _33387 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _33153 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33153] = 26
                                    mem[_33153 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _33604 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _33604 + 68] = mem[idx + _33153 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33604 + 68] = mem[_33604 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _33604 + -mem[64] + 100
                                _31912 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31912] = 26
                                mem[_31912 + 32] = 'SafeMath: division by zero'
                                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                    revert with 0, 'SafeMath: addition overflow'
                                amountToBurn += 0 / totalAllocPoint / 20
                                if not 0 / totalAllocPoint:
                                    _35049 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35049] = 26
                                    mem[_35049 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _35371 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _35371 + 68] = mem[idx + _35049 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35371 + 68] = mem[_35371 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _35371 + -mem[64] + 100
                                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _35214 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35214] = 26
                                mem[_35214 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _35527 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _35527 + 68] = mem[idx + _35214 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35527 + 68] = mem[_35527 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _35527 + -mem[64] + 100
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            _22462 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22462] = 30
                            mem[_22462 + 32] = 'SafeMath: subtraction overflow'
                            if ext_call.return_data[0] > ext_call.return_data[0]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                idx = 32
                                while idx < 30:
                                    mem[idx + mem[64] + 68] = mem[idx + _22462 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: subtraction overflow'
                            mem[mem[64] + 4] = devAddress
                            mem[mem[64] + 36] = 0
                            require ext_code.size(sphereTokenAddress)
                            call sphereTokenAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devAddress, 0
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                                revert with 0, 'SafeMath: addition overflow'
                            if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                mem[mem[64] + 4] = this.address
                                mem[mem[64] + 36] = 0 / totalAllocPoint
                                require ext_code.size(sphereTokenAddress)
                                call sphereTokenAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0 / totalAllocPoint
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _27763 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27763] = 26
                                mem[_27763 + 32] = 'SafeMath: division by zero'
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                    if not 0 / totalAllocPoint:
                                        _31918 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31918] = 26
                                        mem[_31918 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _32451 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _32451 + 68] = mem[idx + _31918 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_32451 + 68] = mem[_32451 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _32451 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _32197 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32197] = 26
                                    mem[_32197 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _32700 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _32700 + 68] = mem[idx + _32197 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_32700 + 68] = mem[_32700 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _32700 + -mem[64] + 100
                                _30771 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_30771] = 26
                                mem[_30771 + 32] = 'SafeMath: division by zero'
                                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                    revert with 0, 'SafeMath: addition overflow'
                                amountToBurn += 0 / totalAllocPoint / 20
                                if not 0 / totalAllocPoint:
                                    _34235 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34235] = 26
                                    mem[_34235 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _34629 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _34629 + 68] = mem[idx + _34235 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_34629 + 68] = mem[_34629 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _34629 + -mem[64] + 100
                                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _34424 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34424] = 26
                                mem[_34424 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _34844 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _34844 + 68] = mem[idx + _34424 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_34844 + 68] = mem[_34844 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _34844 + -mem[64] + 100
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            if ext_call.return_data[0] >= ext_call.return_data[0]:
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _28734 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28734] = 26
                                mem[_28734 + 32] = 'SafeMath: division by zero'
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                    if not 0 / totalAllocPoint:
                                        _32940 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32940] = 26
                                        mem[_32940 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _33390 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _33390 + 68] = mem[idx + _32940 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33390 + 68] = mem[_33390 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _33390 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _33156 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33156] = 26
                                    mem[_33156 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _33609 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _33609 + 68] = mem[idx + _33156 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33609 + 68] = mem[_33609 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _33609 + -mem[64] + 100
                                _31916 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31916] = 26
                                mem[_31916 + 32] = 'SafeMath: division by zero'
                                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                    revert with 0, 'SafeMath: addition overflow'
                                amountToBurn += 0 / totalAllocPoint / 20
                                if not 0 / totalAllocPoint:
                                    _35050 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35050] = 26
                                    mem[_35050 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _35374 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _35374 + 68] = mem[idx + _35050 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35374 + 68] = mem[_35374 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _35374 + -mem[64] + 100
                                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _35215 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35215] = 26
                                mem[_35215 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _35530 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _35530 + 68] = mem[idx + _35215 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35530 + 68] = mem[_35530 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _35530 + -mem[64] + 100
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            _29190 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29190] = 30
                            mem[_29190 + 32] = 'SafeMath: subtraction overflow'
                            if ext_call.return_data[0] > ext_call.return_data[0]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                idx = 32
                                while idx < 30:
                                    mem[idx + mem[64] + 68] = mem[idx + _29190 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: subtraction overflow'
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0
                            require ext_code.size(sphereTokenAddress)
                            call sphereTokenAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args address(this.address), 0
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            _31917 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31917] = 26
                            mem[_31917 + 32] = 'SafeMath: division by zero'
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                revert with 0, 'SafeMath: addition overflow'
                            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                if not 0 / totalAllocPoint:
                                    _35533 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35533] = 26
                                    mem[_35533 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _35790 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _35790 + 68] = mem[idx + _35533 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35790 + 68] = mem[_35790 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _35790 + -mem[64] + 100
                                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _35672 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35672] = 26
                                mem[_35672 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _35903 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _35903 + 68] = mem[idx + _35672 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35903 + 68] = mem[_35903 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _35903 + -mem[64] + 100
                            _34843 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_34843] = 26
                            mem[_34843 + 32] = 'SafeMath: division by zero'
                            if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                revert with 0, 'SafeMath: addition overflow'
                            amountToBurn += 0 / totalAllocPoint / 20
                            if not 0 / totalAllocPoint:
                                _36606 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_36606] = 26
                                mem[_36606 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _36693 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _36693 + 68] = mem[idx + _36606 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_36693 + 68] = mem[_36693 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _36693 + -mem[64] + 100
                            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _36656 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_36656] = 26
                            mem[_36656 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _36725 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _36725 + 68] = mem[idx + _36656 + 32]
                                idx = idx + 32
                                continue 
                            mem[_36725 + 68] = mem[_36725 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _36725 + -mem[64] + 100
                        _19268 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19268] = 30
                        mem[_19268 + 32] = 'SafeMath: subtraction overflow'
                        if poolInfo[idx].field_512 > block.number:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                            idx = 32
                            while idx < 30:
                                mem[idx + mem[64] + 68] = mem[idx + _19268 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.number - poolInfo[idx].field_512:
                            _19635 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19635] = 26
                            mem[_19635 + 32] = 'SafeMath: division by zero'
                            if not totalAllocPoint:
                                _19730 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _19730 + 68] = mem[idx + _19635 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19730 + 68] = mem[_19730 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _19730 + -mem[64] + 100
                            _19872 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19872] = 26
                            mem[_19872 + 32] = 'SafeMath: division by zero'
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                revert with 0, 'SafeMath: addition overflow'
                            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                mem[mem[64] + 4] = devAddress
                                mem[mem[64] + 36] = 0 / totalAllocPoint / 20
                                require ext_code.size(sphereTokenAddress)
                                call sphereTokenAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args devAddress, 0 / totalAllocPoint / 20
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = 0 / totalAllocPoint
                                    require ext_code.size(sphereTokenAddress)
                                    call sphereTokenAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _24932 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24932] = 26
                                    mem[_24932 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not 0 / totalAllocPoint:
                                            _28730 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_28730] = 26
                                            mem[_28730 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _29184 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _29184 + 68] = mem[idx + _28730 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_29184 + 68] = mem[_29184 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _29184 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _28942 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28942] = 26
                                        mem[_28942 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _29397 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _29397 + 68] = mem[idx + _28942 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_29397 + 68] = mem[_29397 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _29397 + -mem[64] + 100
                                    _27756 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27756] = 26
                                    mem[_27756 + 32] = 'SafeMath: division by zero'
                                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                        revert with 0, 'SafeMath: addition overflow'
                                    amountToBurn += 0 / totalAllocPoint / 20
                                    if not 0 / totalAllocPoint:
                                        _31049 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31049] = 26
                                        mem[_31049 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _31612 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _31612 + 68] = mem[idx + _31049 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_31612 + 68] = mem[_31612 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _31612 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _31327 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31327] = 26
                                    mem[_31327 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _31907 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _31907 + 68] = mem[idx + _31327 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_31907 + 68] = mem[_31907 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _31907 + -mem[64] + 100
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                if ext_call.return_data[0] >= ext_call.return_data[0]:
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _25817 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_25817] = 26
                                    mem[_25817 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not 0 / totalAllocPoint:
                                            _29598 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_29598] = 26
                                            mem[_29598 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _29999 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _29999 + 68] = mem[idx + _29598 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_29999 + 68] = mem[_29999 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _29999 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _29781 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29781] = 26
                                        mem[_29781 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _30233 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _30233 + 68] = mem[idx + _29781 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_30233 + 68] = mem[_30233 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _30233 + -mem[64] + 100
                                    _28728 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28728] = 26
                                    mem[_28728 + 32] = 'SafeMath: division by zero'
                                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                        revert with 0, 'SafeMath: addition overflow'
                                    amountToBurn += 0 / totalAllocPoint / 20
                                    if not 0 / totalAllocPoint:
                                        _32193 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32193] = 26
                                        mem[_32193 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _32682 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _32682 + 68] = mem[idx + _32193 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_32682 + 68] = mem[_32682 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _32682 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _32443 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32443] = 26
                                    mem[_32443 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _32926 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _32926 + 68] = mem[idx + _32443 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_32926 + 68] = mem[_32926 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _32926 + -mem[64] + 100
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _26245 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26245] = 30
                                mem[_26245 + 32] = 'SafeMath: subtraction overflow'
                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _26245 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[mem[64] + 4] = this.address
                                mem[mem[64] + 36] = 0
                                require ext_code.size(sphereTokenAddress)
                                call sphereTokenAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _28729 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28729] = 26
                                mem[_28729 + 32] = 'SafeMath: division by zero'
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                    if not 0 / totalAllocPoint:
                                        _32929 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32929] = 26
                                        mem[_32929 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _33381 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _33381 + 68] = mem[idx + _32929 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33381 + 68] = mem[_33381 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _33381 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _33149 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33149] = 26
                                    mem[_33149 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _33596 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _33596 + 68] = mem[idx + _33149 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33596 + 68] = mem[_33596 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _33596 + -mem[64] + 100
                                _31906 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31906] = 26
                                mem[_31906 + 32] = 'SafeMath: division by zero'
                                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                    revert with 0, 'SafeMath: addition overflow'
                                amountToBurn += 0 / totalAllocPoint / 20
                                if not 0 / totalAllocPoint:
                                    _35048 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35048] = 26
                                    mem[_35048 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _35368 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _35368 + 68] = mem[idx + _35048 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35368 + 68] = mem[_35368 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _35368 + -mem[64] + 100
                                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _35213 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35213] = 26
                                mem[_35213 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _35524 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _35524 + 68] = mem[idx + _35213 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35524 + 68] = mem[_35524 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _35524 + -mem[64] + 100
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            if ext_call.return_data[0] >= ext_call.return_data[0]:
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = 0 / totalAllocPoint
                                    require ext_code.size(sphereTokenAddress)
                                    call sphereTokenAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _25815 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_25815] = 26
                                    mem[_25815 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not 0 / totalAllocPoint:
                                            _29595 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_29595] = 26
                                            mem[_29595 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _29995 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _29995 + 68] = mem[idx + _29595 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_29995 + 68] = mem[_29995 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _29995 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _29777 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29777] = 26
                                        mem[_29777 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _30227 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _30227 + 68] = mem[idx + _29777 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_30227 + 68] = mem[_30227 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _30227 + -mem[64] + 100
                                    _28724 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28724] = 26
                                    mem[_28724 + 32] = 'SafeMath: division by zero'
                                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                        revert with 0, 'SafeMath: addition overflow'
                                    amountToBurn += 0 / totalAllocPoint / 20
                                    if not 0 / totalAllocPoint:
                                        _32190 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32190] = 26
                                        mem[_32190 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _32676 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _32676 + 68] = mem[idx + _32190 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_32676 + 68] = mem[_32676 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _32676 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _32441 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32441] = 26
                                    mem[_32441 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _32920 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _32920 + 68] = mem[idx + _32441 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_32920 + 68] = mem[_32920 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _32920 + -mem[64] + 100
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                if ext_call.return_data[0] >= ext_call.return_data[0]:
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _26564 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26564] = 26
                                    mem[_26564 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not 0 / totalAllocPoint:
                                            _30488 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_30488] = 26
                                            mem[_30488 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _31032 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _31032 + 68] = mem[idx + _30488 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_31032 + 68] = mem[_31032 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _31032 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _30749 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30749] = 26
                                        mem[_30749 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _31312 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _31312 + 68] = mem[idx + _30749 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_31312 + 68] = mem[_31312 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _31312 + -mem[64] + 100
                                    _29593 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29593] = 26
                                    mem[_29593 + 32] = 'SafeMath: division by zero'
                                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                        revert with 0, 'SafeMath: addition overflow'
                                    amountToBurn += 0 / totalAllocPoint / 20
                                    if not 0 / totalAllocPoint:
                                        _33145 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33145] = 26
                                        mem[_33145 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _33578 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _33578 + 68] = mem[idx + _33145 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33578 + 68] = mem[_33578 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _33578 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _33371 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33371] = 26
                                    mem[_33371 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _33812 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _33812 + 68] = mem[idx + _33371 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33812 + 68] = mem[_33812 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _33812 + -mem[64] + 100
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _26956 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26956] = 30
                                mem[_26956 + 32] = 'SafeMath: subtraction overflow'
                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _26956 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[mem[64] + 4] = this.address
                                mem[mem[64] + 36] = 0
                                require ext_code.size(sphereTokenAddress)
                                call sphereTokenAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _29594 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29594] = 26
                                mem[_29594 + 32] = 'SafeMath: division by zero'
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                    if not 0 / totalAllocPoint:
                                        _33815 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33815] = 26
                                        mem[_33815 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _34215 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _34215 + 68] = mem[idx + _33815 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_34215 + 68] = mem[_34215 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _34215 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _34011 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34011] = 26
                                    mem[_34011 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _34401 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _34401 + 68] = mem[idx + _34011 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_34401 + 68] = mem[_34401 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _34401 + -mem[64] + 100
                                _32919 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32919] = 26
                                mem[_32919 + 32] = 'SafeMath: division by zero'
                                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                    revert with 0, 'SafeMath: addition overflow'
                                amountToBurn += 0 / totalAllocPoint / 20
                                if not 0 / totalAllocPoint:
                                    _35666 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35666] = 26
                                    mem[_35666 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _35883 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _35883 + 68] = mem[idx + _35666 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35883 + 68] = mem[_35883 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _35883 + -mem[64] + 100
                                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _35776 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35776] = 26
                                mem[_35776 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _36008 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _36008 + 68] = mem[idx + _35776 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_36008 + 68] = mem[_36008 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _36008 + -mem[64] + 100
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            _23099 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23099] = 30
                            mem[_23099 + 32] = 'SafeMath: subtraction overflow'
                            if ext_call.return_data[0] > ext_call.return_data[0]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                idx = 32
                                while idx < 30:
                                    mem[idx + mem[64] + 68] = mem[idx + _23099 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: subtraction overflow'
                            mem[mem[64] + 4] = devAddress
                            mem[mem[64] + 36] = 0
                            require ext_code.size(sphereTokenAddress)
                            call sphereTokenAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devAddress, 0
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                                revert with 0, 'SafeMath: addition overflow'
                            if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                mem[mem[64] + 4] = this.address
                                mem[mem[64] + 36] = 0 / totalAllocPoint
                                require ext_code.size(sphereTokenAddress)
                                call sphereTokenAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0 / totalAllocPoint
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _28727 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28727] = 26
                                mem[_28727 + 32] = 'SafeMath: division by zero'
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                    if not 0 / totalAllocPoint:
                                        _32925 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32925] = 26
                                        mem[_32925 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _33375 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _33375 + 68] = mem[idx + _32925 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33375 + 68] = mem[_33375 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _33375 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _33147 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33147] = 26
                                    mem[_33147 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _33588 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _33588 + 68] = mem[idx + _33147 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33588 + 68] = mem[_33588 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _33588 + -mem[64] + 100
                                _31903 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31903] = 26
                                mem[_31903 + 32] = 'SafeMath: division by zero'
                                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                    revert with 0, 'SafeMath: addition overflow'
                                amountToBurn += 0 / totalAllocPoint / 20
                                if not 0 / totalAllocPoint:
                                    _35047 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35047] = 26
                                    mem[_35047 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _35365 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _35365 + 68] = mem[idx + _35047 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35365 + 68] = mem[_35365 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _35365 + -mem[64] + 100
                                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _35212 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35212] = 26
                                mem[_35212 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _35521 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _35521 + 68] = mem[idx + _35212 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35521 + 68] = mem[_35521 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _35521 + -mem[64] + 100
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            if ext_call.return_data[0] >= ext_call.return_data[0]:
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _29596 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29596] = 26
                                mem[_29596 + 32] = 'SafeMath: division by zero'
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                    if not 0 / totalAllocPoint:
                                        _33819 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33819] = 26
                                        mem[_33819 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _34218 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _34218 + 68] = mem[idx + _33819 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_34218 + 68] = mem[_34218 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _34218 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _34014 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34014] = 26
                                    mem[_34014 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _34406 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _34406 + 68] = mem[idx + _34014 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_34406 + 68] = mem[_34406 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _34406 + -mem[64] + 100
                                _32923 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32923] = 26
                                mem[_32923 + 32] = 'SafeMath: division by zero'
                                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                    revert with 0, 'SafeMath: addition overflow'
                                amountToBurn += 0 / totalAllocPoint / 20
                                if not 0 / totalAllocPoint:
                                    _35667 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35667] = 26
                                    mem[_35667 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _35886 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _35886 + 68] = mem[idx + _35667 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35886 + 68] = mem[_35886 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _35886 + -mem[64] + 100
                                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _35777 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35777] = 26
                                mem[_35777 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _36011 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _36011 + 68] = mem[idx + _35777 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_36011 + 68] = mem[_36011 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _36011 + -mem[64] + 100
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            _29998 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29998] = 30
                            mem[_29998 + 32] = 'SafeMath: subtraction overflow'
                            if ext_call.return_data[0] > ext_call.return_data[0]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                idx = 32
                                while idx < 30:
                                    mem[idx + mem[64] + 68] = mem[idx + _29998 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: subtraction overflow'
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0
                            require ext_code.size(sphereTokenAddress)
                            call sphereTokenAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args address(this.address), 0
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            _32924 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_32924] = 26
                            mem[_32924 + 32] = 'SafeMath: division by zero'
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                revert with 0, 'SafeMath: addition overflow'
                            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                if not 0 / totalAllocPoint:
                                    _36014 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_36014] = 26
                                    mem[_36014 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _36261 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _36261 + 68] = mem[idx + _36014 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36261 + 68] = mem[_36261 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _36261 + -mem[64] + 100
                                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _36141 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_36141] = 26
                                mem[_36141 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _36353 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _36353 + 68] = mem[idx + _36141 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_36353 + 68] = mem[_36353 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _36353 + -mem[64] + 100
                            _35520 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35520] = 26
                            mem[_35520 + 32] = 'SafeMath: division by zero'
                            if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                revert with 0, 'SafeMath: addition overflow'
                            amountToBurn += 0 / totalAllocPoint / 20
                            if not 0 / totalAllocPoint:
                                _36752 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_36752] = 26
                                mem[_36752 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _36789 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _36789 + 68] = mem[idx + _36752 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_36789 + 68] = mem[_36789 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _36789 + -mem[64] + 100
                            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _36769 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_36769] = 26
                            mem[_36769 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _36815 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _36815 + 68] = mem[idx + _36769 + 32]
                                idx = idx + 32
                                continue 
                            mem[_36815 + 68] = mem[_36815 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _36815 + -mem[64] + 100
                        if (block.number * spherePerBlock) - (poolInfo[idx].field_512 * spherePerBlock) / block.number - poolInfo[idx].field_512 != spherePerBlock:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not (block.number * spherePerBlock) - (poolInfo[idx].field_512 * spherePerBlock):
                            _19687 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19687] = 26
                            mem[_19687 + 32] = 'SafeMath: division by zero'
                            if not totalAllocPoint:
                                _19772 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _19772 + 68] = mem[idx + _19687 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19772 + 68] = mem[_19772 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _19772 + -mem[64] + 100
                            _19922 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19922] = 26
                            mem[_19922 + 32] = 'SafeMath: division by zero'
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                revert with 0, 'SafeMath: addition overflow'
                            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                mem[mem[64] + 4] = devAddress
                                mem[mem[64] + 36] = 0 / totalAllocPoint / 20
                                require ext_code.size(sphereTokenAddress)
                                call sphereTokenAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args devAddress, 0 / totalAllocPoint / 20
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = 0 / totalAllocPoint
                                    require ext_code.size(sphereTokenAddress)
                                    call sphereTokenAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _25178 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_25178] = 26
                                    mem[_25178 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not 0 / totalAllocPoint:
                                            _28938 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_28938] = 26
                                            mem[_28938 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _29388 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _29388 + 68] = mem[idx + _28938 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_29388 + 68] = mem[_29388 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _29388 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _29178 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29178] = 26
                                        mem[_29178 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _29588 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _29588 + 68] = mem[idx + _29178 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_29588 + 68] = mem[_29588 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _29588 + -mem[64] + 100
                                    _28027 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28027] = 26
                                    mem[_28027 + 32] = 'SafeMath: division by zero'
                                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                        revert with 0, 'SafeMath: addition overflow'
                                    amountToBurn += 0 / totalAllocPoint / 20
                                    if not 0 / totalAllocPoint:
                                        _31311 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31311] = 26
                                        mem[_31311 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _31892 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _31892 + 68] = mem[idx + _31311 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_31892 + 68] = mem[_31892 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _31892 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _31602 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31602] = 26
                                    mem[_31602 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _32182 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _32182 + 68] = mem[idx + _31602 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_32182 + 68] = mem[_32182 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _32182 + -mem[64] + 100
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                if ext_call.return_data[0] >= ext_call.return_data[0]:
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _26031 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26031] = 26
                                    mem[_26031 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not 0 / totalAllocPoint:
                                            _29775 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_29775] = 26
                                            mem[_29775 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _30219 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _30219 + 68] = mem[idx + _29775 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_30219 + 68] = mem[_30219 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _30219 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _29989 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29989] = 26
                                        mem[_29989 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _30479 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _30479 + 68] = mem[idx + _29989 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_30479 + 68] = mem[_30479 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _30479 + -mem[64] + 100
                                    _28936 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28936] = 26
                                    mem[_28936 + 32] = 'SafeMath: division by zero'
                                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                        revert with 0, 'SafeMath: addition overflow'
                                    amountToBurn += 0 / totalAllocPoint / 20
                                    if not 0 / totalAllocPoint:
                                        _32436 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32436] = 26
                                        mem[_32436 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _32909 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _32909 + 68] = mem[idx + _32436 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_32909 + 68] = mem[_32909 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _32909 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _32670 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32670] = 26
                                    mem[_32670 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _33138 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _33138 + 68] = mem[idx + _32670 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33138 + 68] = mem[_33138 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _33138 + -mem[64] + 100
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _26411 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26411] = 30
                                mem[_26411 + 32] = 'SafeMath: subtraction overflow'
                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _26411 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[mem[64] + 4] = this.address
                                mem[mem[64] + 36] = 0
                                require ext_code.size(sphereTokenAddress)
                                call sphereTokenAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _28937 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28937] = 26
                                mem[_28937 + 32] = 'SafeMath: division by zero'
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                    if not 0 / totalAllocPoint:
                                        _33141 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33141] = 26
                                        mem[_33141 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _33575 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _33575 + 68] = mem[idx + _33141 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33575 + 68] = mem[_33575 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _33575 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _33368 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33368] = 26
                                    mem[_33368 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _33807 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _33807 + 68] = mem[idx + _33368 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33807 + 68] = mem[_33807 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _33807 + -mem[64] + 100
                                _32181 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32181] = 26
                                mem[_32181 + 32] = 'SafeMath: division by zero'
                                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                    revert with 0, 'SafeMath: addition overflow'
                                amountToBurn += 0 / totalAllocPoint / 20
                                if not 0 / totalAllocPoint:
                                    _35205 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35205] = 26
                                    mem[_35205 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _35513 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _35513 + 68] = mem[idx + _35205 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35513 + 68] = mem[_35513 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _35513 + -mem[64] + 100
                                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _35360 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35360] = 26
                                mem[_35360 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _35663 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _35663 + 68] = mem[idx + _35360 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35663 + 68] = mem[_35663 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _35663 + -mem[64] + 100
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            if ext_call.return_data[0] >= ext_call.return_data[0]:
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = 0 / totalAllocPoint
                                    require ext_code.size(sphereTokenAddress)
                                    call sphereTokenAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _26029 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26029] = 26
                                    mem[_26029 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not 0 / totalAllocPoint:
                                            _29772 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_29772] = 26
                                            mem[_29772 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _30215 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _30215 + 68] = mem[idx + _29772 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_30215 + 68] = mem[_30215 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _30215 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _29985 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29985] = 26
                                        mem[_29985 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _30473 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _30473 + 68] = mem[idx + _29985 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_30473 + 68] = mem[_30473 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _30473 + -mem[64] + 100
                                    _28932 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28932] = 26
                                    mem[_28932 + 32] = 'SafeMath: division by zero'
                                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                        revert with 0, 'SafeMath: addition overflow'
                                    amountToBurn += 0 / totalAllocPoint / 20
                                    if not 0 / totalAllocPoint:
                                        _32433 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32433] = 26
                                        mem[_32433 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _32903 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _32903 + 68] = mem[idx + _32433 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_32903 + 68] = mem[_32903 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _32903 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _32668 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32668] = 26
                                    mem[_32668 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _33132 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _33132 + 68] = mem[idx + _32668 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33132 + 68] = mem[_33132 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _33132 + -mem[64] + 100
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                if ext_call.return_data[0] >= ext_call.return_data[0]:
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _26739 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26739] = 26
                                    mem[_26739 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not 0 / totalAllocPoint:
                                            _30739 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_30739] = 26
                                            mem[_30739 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _31294 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _31294 + 68] = mem[idx + _30739 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_31294 + 68] = mem[_31294 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _31294 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _31018 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31018] = 26
                                        mem[_31018 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _31587 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _31587 + 68] = mem[idx + _31018 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_31587 + 68] = mem[_31587 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _31587 + -mem[64] + 100
                                    _29770 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29770] = 26
                                    mem[_29770 + 32] = 'SafeMath: division by zero'
                                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                        revert with 0, 'SafeMath: addition overflow'
                                    amountToBurn += 0 / totalAllocPoint / 20
                                    if not 0 / totalAllocPoint:
                                        _33364 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33364] = 26
                                        mem[_33364 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _33789 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _33789 + 68] = mem[idx + _33364 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33789 + 68] = mem[_33789 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _33789 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _33565 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33565] = 26
                                    mem[_33565 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _33997 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _33997 + 68] = mem[idx + _33565 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33997 + 68] = mem[_33997 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _33997 + -mem[64] + 100
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _27192 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27192] = 30
                                mem[_27192 + 32] = 'SafeMath: subtraction overflow'
                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _27192 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[mem[64] + 4] = this.address
                                mem[mem[64] + 36] = 0
                                require ext_code.size(sphereTokenAddress)
                                call sphereTokenAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _29771 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29771] = 26
                                mem[_29771 + 32] = 'SafeMath: division by zero'
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                    if not 0 / totalAllocPoint:
                                        _34000 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34000] = 26
                                        mem[_34000 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _34386 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _34386 + 68] = mem[idx + _34000 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_34386 + 68] = mem[_34386 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _34386 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _34198 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34198] = 26
                                    mem[_34198 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _34598 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _34598 + 68] = mem[idx + _34198 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_34598 + 68] = mem[_34598 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _34598 + -mem[64] + 100
                                _33131 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33131] = 26
                                mem[_33131 + 32] = 'SafeMath: division by zero'
                                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                    revert with 0, 'SafeMath: addition overflow'
                                amountToBurn += 0 / totalAllocPoint / 20
                                if not 0 / totalAllocPoint:
                                    _35772 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35772] = 26
                                    mem[_35772 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _35994 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _35994 + 68] = mem[idx + _35772 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35994 + 68] = mem[_35994 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _35994 + -mem[64] + 100
                                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _35875 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35875] = 26
                                mem[_35875 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _36126 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _36126 + 68] = mem[idx + _35875 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_36126 + 68] = mem[_36126 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _36126 + -mem[64] + 100
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            _23260 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23260] = 30
                            mem[_23260 + 32] = 'SafeMath: subtraction overflow'
                            if ext_call.return_data[0] > ext_call.return_data[0]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                idx = 32
                                while idx < 30:
                                    mem[idx + mem[64] + 68] = mem[idx + _23260 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: subtraction overflow'
                            mem[mem[64] + 4] = devAddress
                            mem[mem[64] + 36] = 0
                            require ext_code.size(sphereTokenAddress)
                            call sphereTokenAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devAddress, 0
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                                revert with 0, 'SafeMath: addition overflow'
                            if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                mem[mem[64] + 4] = this.address
                                mem[mem[64] + 36] = 0 / totalAllocPoint
                                require ext_code.size(sphereTokenAddress)
                                call sphereTokenAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0 / totalAllocPoint
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _28935 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28935] = 26
                                mem[_28935 + 32] = 'SafeMath: division by zero'
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                    if not 0 / totalAllocPoint:
                                        _33137 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33137] = 26
                                        mem[_33137 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _33569 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _33569 + 68] = mem[idx + _33137 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33569 + 68] = mem[_33569 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _33569 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _33366 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33366] = 26
                                    mem[_33366 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _33799 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _33799 + 68] = mem[idx + _33366 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33799 + 68] = mem[_33799 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _33799 + -mem[64] + 100
                                _32178 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32178] = 26
                                mem[_32178 + 32] = 'SafeMath: division by zero'
                                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                    revert with 0, 'SafeMath: addition overflow'
                                amountToBurn += 0 / totalAllocPoint / 20
                                if not 0 / totalAllocPoint:
                                    _35204 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35204] = 26
                                    mem[_35204 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _35510 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _35510 + 68] = mem[idx + _35204 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35510 + 68] = mem[_35510 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _35510 + -mem[64] + 100
                                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _35359 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35359] = 26
                                mem[_35359 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _35660 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _35660 + 68] = mem[idx + _35359 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35660 + 68] = mem[_35660 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _35660 + -mem[64] + 100
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            if ext_call.return_data[0] >= ext_call.return_data[0]:
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _29773 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29773] = 26
                                mem[_29773 + 32] = 'SafeMath: division by zero'
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                    if not 0 / totalAllocPoint:
                                        _34004 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34004] = 26
                                        mem[_34004 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _34389 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _34389 + 68] = mem[idx + _34004 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_34389 + 68] = mem[_34389 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _34389 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _34201 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34201] = 26
                                    mem[_34201 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _34603 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _34603 + 68] = mem[idx + _34201 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_34603 + 68] = mem[_34603 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _34603 + -mem[64] + 100
                                _33135 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33135] = 26
                                mem[_33135 + 32] = 'SafeMath: division by zero'
                                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                    revert with 0, 'SafeMath: addition overflow'
                                amountToBurn += 0 / totalAllocPoint / 20
                                if not 0 / totalAllocPoint:
                                    _35773 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35773] = 26
                                    mem[_35773 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _35997 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _35997 + 68] = mem[idx + _35773 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35997 + 68] = mem[_35997 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _35997 + -mem[64] + 100
                                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _35876 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35876] = 26
                                mem[_35876 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _36129 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _36129 + 68] = mem[idx + _35876 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_36129 + 68] = mem[_36129 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _36129 + -mem[64] + 100
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            _30218 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_30218] = 30
                            mem[_30218 + 32] = 'SafeMath: subtraction overflow'
                            if ext_call.return_data[0] > ext_call.return_data[0]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                idx = 32
                                while idx < 30:
                                    mem[idx + mem[64] + 68] = mem[idx + _30218 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: subtraction overflow'
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0
                            require ext_code.size(sphereTokenAddress)
                            call sphereTokenAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args address(this.address), 0
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            _33136 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_33136] = 26
                            mem[_33136 + 32] = 'SafeMath: division by zero'
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                revert with 0, 'SafeMath: addition overflow'
                            if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                if not 0 / totalAllocPoint:
                                    _36132 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_36132] = 26
                                    mem[_36132 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _36344 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _36344 + 68] = mem[idx + _36132 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36344 + 68] = mem[_36344 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _36344 + -mem[64] + 100
                                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _36250 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_36250] = 26
                                mem[_36250 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _36436 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _36436 + 68] = mem[idx + _36250 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_36436 + 68] = mem[_36436 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _36436 + -mem[64] + 100
                            _35659 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35659] = 26
                            mem[_35659 + 32] = 'SafeMath: division by zero'
                            if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                revert with 0, 'SafeMath: addition overflow'
                            amountToBurn += 0 / totalAllocPoint / 20
                            if not 0 / totalAllocPoint:
                                _36768 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_36768] = 26
                                mem[_36768 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _36812 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _36812 + 68] = mem[idx + _36768 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_36812 + 68] = mem[_36812 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _36812 + -mem[64] + 100
                            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _36788 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_36788] = 26
                            mem[_36788 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _36844 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _36844 + 68] = mem[idx + _36788 + 32]
                                idx = idx + 32
                                continue 
                            mem[_36844 + 68] = mem[_36844 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _36844 + -mem[64] + 100
                        if (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / (block.number * spherePerBlock) - (poolInfo[idx].field_512 * spherePerBlock) != poolInfo[idx].field_256:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _19729 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19729] = 26
                        mem[_19729 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            _19801 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _19801 + 68] = mem[idx + _19729 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19801 + 68] = mem[_19801 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _19801 + -mem[64] + 100
                        _19973 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19973] = 26
                        mem[_19973 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sphereTokenAddress)
                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(sphereTokenAddress)
                        staticcall sphereTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                            revert with 0, 'SafeMath: addition overflow'
                        if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] <= ext_call.return_data[0]:
                            mem[mem[64] + 4] = devAddress
                            mem[mem[64] + 36] = (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
                            require ext_code.size(sphereTokenAddress)
                            call sphereTokenAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devAddress, (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                                revert with 0, 'SafeMath: addition overflow'
                            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                mem[mem[64] + 4] = this.address
                                mem[mem[64] + 36] = (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                require ext_code.size(sphereTokenAddress)
                                call sphereTokenAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _25403 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25403] = 26
                                mem[_25403 + 32] = 'SafeMath: division by zero'
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                    if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                        _29174 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29174] = 26
                                        mem[_29174 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _29579 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _29579 + 68] = mem[idx + _29174 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_29579 + 68] = mem[_29579 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _29579 + -mem[64] + 100
                                    if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _29382 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29382] = 26
                                    mem[_29382 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _29765 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _29765 + 68] = mem[idx + _29382 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29765 + 68] = mem[_29765 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _29765 + -mem[64] + 100
                                _28271 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28271] = 26
                                mem[_28271 + 32] = 'SafeMath: division by zero'
                                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                    revert with 0, 'SafeMath: addition overflow'
                                amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
                                if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                    _31586 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31586] = 26
                                    mem[_31586 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _32167 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _32167 + 68] = mem[idx + _31586 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_32167 + 68] = mem[_32167 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _32167 + -mem[64] + 100
                                if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _31882 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31882] = 26
                                mem[_31882 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _32425 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _32425 + 68] = mem[idx + _31882 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_32425 + 68] = mem[_32425 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _32425 + -mem[64] + 100
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            if ext_call.return_data[0] >= ext_call.return_data[0]:
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _26234 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26234] = 26
                                mem[_26234 + 32] = 'SafeMath: division by zero'
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                    if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                        _29983 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29983] = 26
                                        mem[_29983 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _30465 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _30465 + 68] = mem[idx + _29983 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_30465 + 68] = mem[_30465 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _30465 + -mem[64] + 100
                                    if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _30209 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30209] = 26
                                    mem[_30209 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _30730 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _30730 + 68] = mem[idx + _30209 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_30730 + 68] = mem[_30730 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _30730 + -mem[64] + 100
                                _29172 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29172] = 26
                                mem[_29172 + 32] = 'SafeMath: division by zero'
                                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                    revert with 0, 'SafeMath: addition overflow'
                                amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
                                if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                    _32663 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32663] = 26
                                    mem[_32663 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _33121 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _33121 + 68] = mem[idx + _32663 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33121 + 68] = mem[_33121 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _33121 + -mem[64] + 100
                                if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _32897 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32897] = 26
                                mem[_32897 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _33357 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _33357 + 68] = mem[idx + _32897 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_33357 + 68] = mem[_33357 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _33357 + -mem[64] + 100
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            _26559 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26559] = 30
                            mem[_26559 + 32] = 'SafeMath: subtraction overflow'
                            if ext_call.return_data[0] > ext_call.return_data[0]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                idx = 32
                                while idx < 30:
                                    mem[idx + mem[64] + 68] = mem[idx + _26559 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: subtraction overflow'
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0
                            require ext_code.size(sphereTokenAddress)
                            call sphereTokenAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args address(this.address), 0
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            _29173 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29173] = 26
                            mem[_29173 + 32] = 'SafeMath: division by zero'
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                revert with 0, 'SafeMath: addition overflow'
                            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                    _33360 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33360] = 26
                                    mem[_33360 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _33786 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _33786 + 68] = mem[idx + _33360 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33786 + 68] = mem[_33786 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _33786 + -mem[64] + 100
                                if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _33562 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33562] = 26
                                mem[_33562 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _33992 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _33992 + 68] = mem[idx + _33562 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_33992 + 68] = mem[_33992 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _33992 + -mem[64] + 100
                            _32424 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_32424] = 26
                            mem[_32424 + 32] = 'SafeMath: division by zero'
                            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                revert with 0, 'SafeMath: addition overflow'
                            amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
                            if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                _35352 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35352] = 26
                                mem[_35352 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _35652 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _35652 + 68] = mem[idx + _35352 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35652 + 68] = mem[_35652 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _35652 + -mem[64] + 100
                            if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _35505 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35505] = 26
                            mem[_35505 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _35769 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _35769 + 68] = mem[idx + _35505 + 32]
                                idx = idx + 32
                                continue 
                            mem[_35769 + 68] = mem[_35769 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _35769 + -mem[64] + 100
                        require ext_code.size(sphereTokenAddress)
                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(sphereTokenAddress)
                        staticcall sphereTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(sphereTokenAddress)
                        if ext_call.return_data[0] >= ext_call.return_data[0]:
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                                revert with 0, 'SafeMath: addition overflow'
                            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                mem[mem[64] + 4] = this.address
                                mem[mem[64] + 36] = (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                require ext_code.size(sphereTokenAddress)
                                call sphereTokenAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _26232 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26232] = 26
                                mem[_26232 + 32] = 'SafeMath: division by zero'
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                    if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                        _29980 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29980] = 26
                                        mem[_29980 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _30461 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _30461 + 68] = mem[idx + _29980 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_30461 + 68] = mem[_30461 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _30461 + -mem[64] + 100
                                    if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _30205 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30205] = 26
                                    mem[_30205 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _30724 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _30724 + 68] = mem[idx + _30205 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_30724 + 68] = mem[_30724 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _30724 + -mem[64] + 100
                                _29168 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29168] = 26
                                mem[_29168 + 32] = 'SafeMath: division by zero'
                                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                    revert with 0, 'SafeMath: addition overflow'
                                amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
                                if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                    _32660 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32660] = 26
                                    mem[_32660 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _33115 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _33115 + 68] = mem[idx + _32660 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33115 + 68] = mem[_33115 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _33115 + -mem[64] + 100
                                if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _32895 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32895] = 26
                                mem[_32895 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _33351 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _33351 + 68] = mem[idx + _32895 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_33351 + 68] = mem[_33351 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _33351 + -mem[64] + 100
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            if ext_call.return_data[0] >= ext_call.return_data[0]:
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _26940 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26940] = 26
                                mem[_26940 + 32] = 'SafeMath: division by zero'
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                    if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                        _31008 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31008] = 26
                                        mem[_31008 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _31569 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _31569 + 68] = mem[idx + _31008 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_31569 + 68] = mem[_31569 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _31569 + -mem[64] + 100
                                    if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _31280 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31280] = 26
                                    mem[_31280 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _31867 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _31867 + 68] = mem[idx + _31280 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_31867 + 68] = mem[_31867 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _31867 + -mem[64] + 100
                                _29978 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29978] = 26
                                mem[_29978 + 32] = 'SafeMath: division by zero'
                                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                    revert with 0, 'SafeMath: addition overflow'
                                amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
                                if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                    _33558 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33558] = 26
                                    mem[_33558 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _33974 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _33974 + 68] = mem[idx + _33558 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33974 + 68] = mem[_33974 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _33974 + -mem[64] + 100
                                if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _33776 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33776] = 26
                                mem[_33776 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _34184 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _34184 + 68] = mem[idx + _33776 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_34184 + 68] = mem[_34184 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _34184 + -mem[64] + 100
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            _27448 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27448] = 30
                            mem[_27448 + 32] = 'SafeMath: subtraction overflow'
                            if ext_call.return_data[0] > ext_call.return_data[0]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                idx = 32
                                while idx < 30:
                                    mem[idx + mem[64] + 68] = mem[idx + _27448 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: subtraction overflow'
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0
                            require ext_code.size(sphereTokenAddress)
                            call sphereTokenAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args address(this.address), 0
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            _29979 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29979] = 26
                            mem[_29979 + 32] = 'SafeMath: division by zero'
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                revert with 0, 'SafeMath: addition overflow'
                            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                    _34187 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34187] = 26
                                    mem[_34187 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _34583 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _34583 + 68] = mem[idx + _34187 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_34583 + 68] = mem[_34583 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _34583 + -mem[64] + 100
                                if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _34369 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34369] = 26
                                mem[_34369 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _34800 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _34800 + 68] = mem[idx + _34369 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_34800 + 68] = mem[_34800 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _34800 + -mem[64] + 100
                            _33350 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_33350] = 26
                            mem[_33350 + 32] = 'SafeMath: division by zero'
                            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                revert with 0, 'SafeMath: addition overflow'
                            amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
                            if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                _35871 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35871] = 26
                                mem[_35871 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _36112 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _36112 + 68] = mem[idx + _35871 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_36112 + 68] = mem[_36112 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _36112 + -mem[64] + 100
                            if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _35986 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35986] = 26
                            mem[_35986 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _36235 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _36235 + 68] = mem[idx + _35986 + 32]
                                idx = idx + 32
                                continue 
                            mem[_36235 + 68] = mem[_36235 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _36235 + -mem[64] + 100
                        staticcall sphereTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(sphereTokenAddress)
                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        _23437 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23437] = 30
                        mem[_23437 + 32] = 'SafeMath: subtraction overflow'
                        if ext_call.return_data[0] > ext_call.return_data[0]:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                            idx = 32
                            while idx < 30:
                                mem[idx + mem[64] + 68] = mem[idx + _23437 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: subtraction overflow'
                        mem[mem[64] + 4] = devAddress
                        mem[mem[64] + 36] = 0
                        require ext_code.size(sphereTokenAddress)
                        call sphereTokenAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devAddress, 0
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(sphereTokenAddress)
                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(sphereTokenAddress)
                        staticcall sphereTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                            revert with 0, 'SafeMath: addition overflow'
                        if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint
                            require ext_code.size(sphereTokenAddress)
                            call sphereTokenAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args address(this.address), (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            _29171 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29171] = 26
                            mem[_29171 + 32] = 'SafeMath: division by zero'
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                revert with 0, 'SafeMath: addition overflow'
                            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                    _33356 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33356] = 26
                                    mem[_33356 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _33780 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _33780 + 68] = mem[idx + _33356 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33780 + 68] = mem[_33780 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _33780 + -mem[64] + 100
                                if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _33560 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33560] = 26
                                mem[_33560 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _33984 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _33984 + 68] = mem[idx + _33560 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_33984 + 68] = mem[_33984 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _33984 + -mem[64] + 100
                            _32421 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_32421] = 26
                            mem[_32421 + 32] = 'SafeMath: division by zero'
                            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                revert with 0, 'SafeMath: addition overflow'
                            amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
                            if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                _35351 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35351] = 26
                                mem[_35351 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _35649 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _35649 + 68] = mem[idx + _35351 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35649 + 68] = mem[_35649 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _35649 + -mem[64] + 100
                            if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _35504 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35504] = 26
                            mem[_35504 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _35766 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _35766 + 68] = mem[idx + _35504 + 32]
                                idx = idx + 32
                                continue 
                            mem[_35766 + 68] = mem[_35766 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _35766 + -mem[64] + 100
                        require ext_code.size(sphereTokenAddress)
                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(sphereTokenAddress)
                        staticcall sphereTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(sphereTokenAddress)
                        if ext_call.return_data[0] >= ext_call.return_data[0]:
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            _29981 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29981] = 26
                            mem[_29981 + 32] = 'SafeMath: division by zero'
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                revert with 0, 'SafeMath: addition overflow'
                            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                    _34191 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34191] = 26
                                    mem[_34191 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _34586 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _34586 + 68] = mem[idx + _34191 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_34586 + 68] = mem[_34586 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _34586 + -mem[64] + 100
                                if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _34372 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34372] = 26
                                mem[_34372 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _34805 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _34805 + 68] = mem[idx + _34372 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_34805 + 68] = mem[_34805 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _34805 + -mem[64] + 100
                            _33354 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_33354] = 26
                            mem[_33354 + 32] = 'SafeMath: division by zero'
                            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                revert with 0, 'SafeMath: addition overflow'
                            amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
                            if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                _35872 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35872] = 26
                                mem[_35872 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _36115 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _36115 + 68] = mem[idx + _35872 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_36115 + 68] = mem[_36115 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _36115 + -mem[64] + 100
                            if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _35987 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35987] = 26
                            mem[_35987 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _36238 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _36238 + 68] = mem[idx + _35987 + 32]
                                idx = idx + 32
                                continue 
                            mem[_36238 + 68] = mem[_36238 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _36238 + -mem[64] + 100
                        staticcall sphereTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(sphereTokenAddress)
                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        _30464 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30464] = 30
                        mem[_30464 + 32] = 'SafeMath: subtraction overflow'
                        if ext_call.return_data[0] > ext_call.return_data[0]:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                            idx = 32
                            while idx < 30:
                                mem[idx + mem[64] + 68] = mem[idx + _30464 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: subtraction overflow'
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0
                        require ext_code.size(sphereTokenAddress)
                        call sphereTokenAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), 0
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(sphereTokenAddress)
                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        _33355 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_33355] = 26
                        mem[_33355 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(sphereTokenAddress)
                        staticcall sphereTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                            revert with 0, 'SafeMath: addition overflow'
                        if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                            if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                _36241 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_36241] = 26
                                mem[_36241 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _36427 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _36427 + 68] = mem[idx + _36241 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_36427 + 68] = mem[_36427 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _36427 + -mem[64] + 100
                            if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _36333 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_36333] = 26
                            mem[_36333 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _36514 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _36514 + 68] = mem[idx + _36333 + 32]
                                idx = idx + 32
                                continue 
                            mem[_36514 + 68] = mem[_36514 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _36514 + -mem[64] + 100
                        _35765 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_35765] = 26
                        mem[_35765 + 32] = 'SafeMath: division by zero'
                        if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                            revert with 0, 'SafeMath: addition overflow'
                        amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
                        if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                            _36787 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_36787] = 26
                            mem[_36787 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _36841 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _36841 + 68] = mem[idx + _36787 + 32]
                                idx = idx + 32
                                continue 
                            mem[_36841 + 68] = mem[_36841 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _36841 + -mem[64] + 100
                        if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _36811 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_36811] = 26
                        mem[_36811 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0]:
                            if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _36868 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _36868 + 68] = mem[idx + _36811 + 32]
                            idx = idx + 32
                            continue 
                        mem[_36868 + 68] = mem[_36868 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _36868 + -mem[64] + 100
                    if 100 * bottomPrice >= 100 * topPrice:
                        _19141 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19141] = 26
                        mem[_19141 + 32] = 'SafeMath: division by zero'
                        if not maxEmissionRate / 100:
                            spherePerBlock = 0
                        else:
                            if maxEmissionRate / 100 / maxEmissionRate / 100 != 1:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            spherePerBlock = maxEmissionRate / 100
                    else:
                        if 100 * bottomPrice <= 100 * bottomPrice:
                            _19147 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19147] = 26
                            mem[_19147 + 32] = 'SafeMath: division by zero'
                            if not maxEmissionRate / 100:
                                spherePerBlock = 0
                            else:
                                if 100 * maxEmissionRate / 100 / maxEmissionRate / 100 != 100:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                spherePerBlock = 100 * maxEmissionRate / 100
                        else:
                            if not 100 * bottomPrice:
                                _19156 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19156] = 26
                                mem[_19156 + 32] = 'SafeMath: division by zero'
                                if not 100 * topPrice:
                                    revert with 0, 'SafeMath: division by zero'
                                require ext_code.size(0xd75dcd756844276df0330ff8f5a02c06c26a44e7)
                                delegate 0xd75dcd756844276df0330ff8f5a02c06c26a44e7.reciprocal(int256 rg1) with:
                                     gas gas_remaining wei
                                    args curveRate
                                if not delegate.return_code:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _19265 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19265] = 30
                                mem[_19265 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / 100 * topPrice > 100:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require ext_code.size(0xd75dcd756844276df0330ff8f5a02c06c26a44e7)
                                delegate 0xd75dcd756844276df0330ff8f5a02c06c26a44e7.multiply(int256 rg1, int256 rg2) with:
                                     gas gas_remaining wei
                                    args delegate.return_data[0], -(0 / 100 * topPrice) + 100
                                if not delegate.return_code:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(0xd75dcd756844276df0330ff8f5a02c06c26a44e7)
                                delegate 0xd75dcd756844276df0330ff8f5a02c06c26a44e7.fromFixed(int256 rg1) with:
                                     gas gas_remaining wei
                                    args delegate.return_data[0]
                                if not delegate.return_code:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(0xd75dcd756844276df0330ff8f5a02c06c26a44e7)
                                delegate 0xd75dcd756844276df0330ff8f5a02c06c26a44e7.divide(int256 rg1, int256 rg2) with:
                                     gas gas_remaining wei
                                    args 100, 0 / 100 * topPrice
                                if not delegate.return_code:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(0xd75dcd756844276df0330ff8f5a02c06c26a44e7)
                                delegate 0xd75dcd756844276df0330ff8f5a02c06c26a44e7.fromFixed(int256 rg1) with:
                                     gas gas_remaining wei
                                    args delegate.return_data[0]
                                if not delegate.return_code:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _19825 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19825] = 26
                                mem[_19825 + 32] = 'SafeMath: division by zero'
                            else:
                                if 10000 * bottomPrice / 100 * bottomPrice != 100:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _19159 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19159] = 26
                                mem[_19159 + 32] = 'SafeMath: division by zero'
                                if not 100 * topPrice:
                                    revert with 0, 'SafeMath: division by zero'
                                require ext_code.size(0xd75dcd756844276df0330ff8f5a02c06c26a44e7)
                                delegate 0xd75dcd756844276df0330ff8f5a02c06c26a44e7.reciprocal(int256 rg1) with:
                                     gas gas_remaining wei
                                    args curveRate
                                if not delegate.return_code:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _19279 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19279] = 30
                                mem[_19279 + 32] = 'SafeMath: subtraction overflow'
                                if 10000 * bottomPrice / 100 * topPrice > 100:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require ext_code.size(0xd75dcd756844276df0330ff8f5a02c06c26a44e7)
                                delegate 0xd75dcd756844276df0330ff8f5a02c06c26a44e7.multiply(int256 rg1, int256 rg2) with:
                                     gas gas_remaining wei
                                    args delegate.return_data[0], -(10000 * bottomPrice / 100 * topPrice) + 100
                                if not delegate.return_code:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(0xd75dcd756844276df0330ff8f5a02c06c26a44e7)
                                delegate 0xd75dcd756844276df0330ff8f5a02c06c26a44e7.fromFixed(int256 rg1) with:
                                     gas gas_remaining wei
                                    args delegate.return_data[0]
                                if not delegate.return_code:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(0xd75dcd756844276df0330ff8f5a02c06c26a44e7)
                                delegate 0xd75dcd756844276df0330ff8f5a02c06c26a44e7.divide(int256 rg1, int256 rg2) with:
                                     gas gas_remaining wei
                                    args 100, 10000 * bottomPrice / 100 * topPrice
                                if not delegate.return_code:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(0xd75dcd756844276df0330ff8f5a02c06c26a44e7)
                                delegate 0xd75dcd756844276df0330ff8f5a02c06c26a44e7.fromFixed(int256 rg1) with:
                                     gas gas_remaining wei
                                    args delegate.return_data[0]
                                if not delegate.return_code:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _19858 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19858] = 26
                                mem[_19858 + 32] = 'SafeMath: division by zero'
                            if not maxEmissionRate / 100:
                                spherePerBlock = 0
                            else:
                                if (delegate.return_data[0] * maxEmissionRate / 100) + (delegate.return_data[0] * maxEmissionRate / 100) / maxEmissionRate / 100 != 2 * delegate.return_data[0]:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                spherePerBlock = (delegate.return_data[0] * maxEmissionRate / 100) + (delegate.return_data[0] * maxEmissionRate / 100)
                else:
                    require ext_code.size(usdcAddress)
                    staticcall usdcAddress.0x70a08231 with:
                            gas gas_remaining wei
                           args usdcSphereLPAddress
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if not ext_call.return_data[0]:
                        mem[64] = 160
                        mem[96] = 26
                        mem[128] = 'SafeMath: division by zero'
                        if not ext_call.return_data[0]:
                            revert with 0, 'SafeMath: division by zero'
                        idx = 0
                        while idx < poolInfo.length:
                            mem[0] = 10
                            if block.number <= poolInfo[idx].field_512:
                                idx = idx + 1
                                continue 
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(poolInfo[idx].field_0)
                            staticcall poolInfo[idx].field_0.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not ext_call.return_data[0]:
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            if not poolInfo[idx].field_256:
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0] >= ext_call.return_data[0]:
                                _19521 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19521] = 26
                                mem[_19521 + 32] = 'SafeMath: division by zero'
                                if not totalAllocPoint:
                                    _19579 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _19579 + 68] = mem[idx + _19521 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19579 + 68] = mem[_19579 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _19579 + -mem[64] + 100
                                _19763 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19763] = 26
                                mem[_19763 + 32] = 'SafeMath: division by zero'
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                    mem[mem[64] + 4] = devAddress
                                    mem[mem[64] + 36] = 0 / totalAllocPoint / 20
                                    require ext_code.size(sphereTokenAddress)
                                    call sphereTokenAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devAddress, 0 / totalAllocPoint / 20
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = 0 / totalAllocPoint
                                        require ext_code.size(sphereTokenAddress)
                                        call sphereTokenAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        _24198 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_24198] = 26
                                        mem[_24198 + 32] = 'SafeMath: division by zero'
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                            if not 0 / totalAllocPoint:
                                                _27954 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_27954] = 26
                                                mem[_27954 + 32] = 'SafeMath: division by zero'
                                                if ext_call.return_data[0]:
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                                    idx = idx + 1
                                                    continue 
                                                _28456 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _28456 + 68] = mem[idx + _27954 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_28456 + 68] = mem[_28456 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _28456 + -mem[64] + 100
                                            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _28212 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_28212] = 26
                                            mem[_28212 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _28667 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _28667 + 68] = mem[idx + _28212 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_28667 + 68] = mem[_28667 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _28667 + -mem[64] + 100
                                        _26895 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26895] = 26
                                        mem[_26895 + 32] = 'SafeMath: division by zero'
                                        if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                            revert with 0, 'SafeMath: addition overflow'
                                        amountToBurn += 0 / totalAllocPoint / 20
                                        if not 0 / totalAllocPoint:
                                            _30174 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_30174] = 26
                                            mem[_30174 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _30679 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _30679 + 68] = mem[idx + _30174 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_30679 + 68] = mem[_30679 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _30679 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _30423 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30423] = 26
                                        mem[_30423 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _30967 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _30967 + 68] = mem[idx + _30423 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_30967 + 68] = mem[_30967 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _30967 + -mem[64] + 100
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    if ext_call.return_data[0] >= ext_call.return_data[0]:
                                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        _25103 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25103] = 26
                                        mem[_25103 + 32] = 'SafeMath: division by zero'
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                            if not 0 / totalAllocPoint:
                                                _28868 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_28868] = 26
                                                mem[_28868 + 32] = 'SafeMath: division by zero'
                                                if ext_call.return_data[0]:
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                                    idx = idx + 1
                                                    continue 
                                                _29347 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _29347 + 68] = mem[idx + _28868 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_29347 + 68] = mem[_29347 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _29347 + -mem[64] + 100
                                            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _29113 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_29113] = 26
                                            mem[_29113 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _29542 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _29542 + 68] = mem[idx + _29113 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_29542 + 68] = mem[_29542 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _29542 + -mem[64] + 100
                                        _27952 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_27952] = 26
                                        mem[_27952 + 32] = 'SafeMath: division by zero'
                                        if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                            revert with 0, 'SafeMath: addition overflow'
                                        amountToBurn += 0 / totalAllocPoint / 20
                                        if not 0 / totalAllocPoint:
                                            _31238 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31238] = 26
                                            mem[_31238 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _31823 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _31823 + 68] = mem[idx + _31238 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_31823 + 68] = mem[_31823 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _31823 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _31527 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31527] = 26
                                        mem[_31527 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _32109 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _32109 + 68] = mem[idx + _31527 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_32109 + 68] = mem[_32109 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _32109 + -mem[64] + 100
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _25560 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_25560] = 30
                                    mem[_25560 + 32] = 'SafeMath: subtraction overflow'
                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                        idx = 32
                                        while idx < 30:
                                            mem[idx + mem[64] + 68] = mem[idx + _25560 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = 0
                                    require ext_code.size(sphereTokenAddress)
                                    call sphereTokenAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _27953 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27953] = 26
                                    mem[_27953 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not 0 / totalAllocPoint:
                                            _32112 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32112] = 26
                                            mem[_32112 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _32629 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _32629 + 68] = mem[idx + _32112 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_32629 + 68] = mem[_32629 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _32629 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _32371 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32371] = 26
                                        mem[_32371 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _32870 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _32870 + 68] = mem[idx + _32371 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_32870 + 68] = mem[_32870 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _32870 + -mem[64] + 100
                                    _30966 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30966] = 26
                                    mem[_30966 + 32] = 'SafeMath: division by zero'
                                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                        revert with 0, 'SafeMath: addition overflow'
                                    amountToBurn += 0 / totalAllocPoint / 20
                                    if not 0 / totalAllocPoint:
                                        _34356 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34356] = 26
                                        mem[_34356 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _34774 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _34774 + 68] = mem[idx + _34356 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_34774 + 68] = mem[_34774 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _34774 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _34563 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34563] = 26
                                    mem[_34563 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _34993 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _34993 + 68] = mem[idx + _34563 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_34993 + 68] = mem[_34993 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _34993 + -mem[64] + 100
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                if ext_call.return_data[0] >= ext_call.return_data[0]:
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = 0 / totalAllocPoint
                                        require ext_code.size(sphereTokenAddress)
                                        call sphereTokenAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        _25101 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25101] = 26
                                        mem[_25101 + 32] = 'SafeMath: division by zero'
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                            if not 0 / totalAllocPoint:
                                                _28865 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_28865] = 26
                                                mem[_28865 + 32] = 'SafeMath: division by zero'
                                                if ext_call.return_data[0]:
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                                    idx = idx + 1
                                                    continue 
                                                _29343 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _29343 + 68] = mem[idx + _28865 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_29343 + 68] = mem[_29343 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _29343 + -mem[64] + 100
                                            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _29109 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_29109] = 26
                                            mem[_29109 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _29536 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _29536 + 68] = mem[idx + _29109 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_29536 + 68] = mem[_29536 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _29536 + -mem[64] + 100
                                        _27948 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_27948] = 26
                                        mem[_27948 + 32] = 'SafeMath: division by zero'
                                        if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                            revert with 0, 'SafeMath: addition overflow'
                                        amountToBurn += 0 / totalAllocPoint / 20
                                        if not 0 / totalAllocPoint:
                                            _31235 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31235] = 26
                                            mem[_31235 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _31817 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _31817 + 68] = mem[idx + _31235 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_31817 + 68] = mem[_31817 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _31817 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _31525 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31525] = 26
                                        mem[_31525 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _32103 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _32103 + 68] = mem[idx + _31525 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_32103 + 68] = mem[_32103 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _32103 + -mem[64] + 100
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    if ext_call.return_data[0] >= ext_call.return_data[0]:
                                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        _25969 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25969] = 26
                                        mem[_25969 + 32] = 'SafeMath: division by zero'
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                            if not 0 / totalAllocPoint:
                                                _29718 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_29718] = 26
                                                mem[_29718 + 32] = 'SafeMath: division by zero'
                                                if ext_call.return_data[0]:
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                                    idx = idx + 1
                                                    continue 
                                                _30157 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _30157 + 68] = mem[idx + _29718 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_30157 + 68] = mem[_30157 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _30157 + -mem[64] + 100
                                            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _29933 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_29933] = 26
                                            mem[_29933 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _30408 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _30408 + 68] = mem[idx + _29933 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_30408 + 68] = mem[_30408 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _30408 + -mem[64] + 100
                                        _28863 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28863] = 26
                                        mem[_28863 + 32] = 'SafeMath: division by zero'
                                        if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                            revert with 0, 'SafeMath: addition overflow'
                                        amountToBurn += 0 / totalAllocPoint / 20
                                        if not 0 / totalAllocPoint:
                                            _32367 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32367] = 26
                                            mem[_32367 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _32852 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _32852 + 68] = mem[idx + _32367 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_32852 + 68] = mem[_32852 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _32852 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _32619 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32619] = 26
                                        mem[_32619 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _33075 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _33075 + 68] = mem[idx + _32619 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33075 + 68] = mem[_33075 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _33075 + -mem[64] + 100
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _26364 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26364] = 30
                                    mem[_26364 + 32] = 'SafeMath: subtraction overflow'
                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                        idx = 32
                                        while idx < 30:
                                            mem[idx + mem[64] + 68] = mem[idx + _26364 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = 0
                                    require ext_code.size(sphereTokenAddress)
                                    call sphereTokenAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _28864 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28864] = 26
                                    mem[_28864 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not 0 / totalAllocPoint:
                                            _33078 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33078] = 26
                                            mem[_33078 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _33535 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _33535 + 68] = mem[idx + _33078 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33535 + 68] = mem[_33535 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _33535 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _33311 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33311] = 26
                                        mem[_33311 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _33752 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _33752 + 68] = mem[idx + _33311 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33752 + 68] = mem[_33752 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _33752 + -mem[64] + 100
                                    _32102 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32102] = 26
                                    mem[_32102 + 32] = 'SafeMath: division by zero'
                                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                        revert with 0, 'SafeMath: addition overflow'
                                    amountToBurn += 0 / totalAllocPoint / 20
                                    if not 0 / totalAllocPoint:
                                        _35163 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35163] = 26
                                        mem[_35163 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _35477 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _35477 + 68] = mem[idx + _35163 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35477 + 68] = mem[_35477 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _35477 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _35324 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35324] = 26
                                    mem[_35324 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _35625 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _35625 + 68] = mem[idx + _35324 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35625 + 68] = mem[_35625 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _35625 + -mem[64] + 100
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _22596 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22596] = 30
                                mem[_22596 + 32] = 'SafeMath: subtraction overflow'
                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _22596 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[mem[64] + 4] = devAddress
                                mem[mem[64] + 36] = 0
                                require ext_code.size(sphereTokenAddress)
                                call sphereTokenAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args devAddress, 0
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = 0 / totalAllocPoint
                                    require ext_code.size(sphereTokenAddress)
                                    call sphereTokenAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _27951 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27951] = 26
                                    mem[_27951 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not 0 / totalAllocPoint:
                                            _32108 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32108] = 26
                                            mem[_32108 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _32623 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _32623 + 68] = mem[idx + _32108 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_32623 + 68] = mem[_32623 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _32623 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _32369 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32369] = 26
                                        mem[_32369 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _32862 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _32862 + 68] = mem[idx + _32369 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_32862 + 68] = mem[_32862 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _32862 + -mem[64] + 100
                                    _30963 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30963] = 26
                                    mem[_30963 + 32] = 'SafeMath: division by zero'
                                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                        revert with 0, 'SafeMath: addition overflow'
                                    amountToBurn += 0 / totalAllocPoint / 20
                                    if not 0 / totalAllocPoint:
                                        _34355 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34355] = 26
                                        mem[_34355 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _34771 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _34771 + 68] = mem[idx + _34355 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_34771 + 68] = mem[_34771 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _34771 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _34562 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34562] = 26
                                    mem[_34562 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _34990 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _34990 + 68] = mem[idx + _34562 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_34990 + 68] = mem[_34990 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _34990 + -mem[64] + 100
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                if ext_call.return_data[0] >= ext_call.return_data[0]:
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _28866 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28866] = 26
                                    mem[_28866 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not 0 / totalAllocPoint:
                                            _33082 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33082] = 26
                                            mem[_33082 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _33538 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _33538 + 68] = mem[idx + _33082 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33538 + 68] = mem[_33538 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _33538 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _33314 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33314] = 26
                                        mem[_33314 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _33757 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _33757 + 68] = mem[idx + _33314 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33757 + 68] = mem[_33757 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _33757 + -mem[64] + 100
                                    _32106 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32106] = 26
                                    mem[_32106 + 32] = 'SafeMath: division by zero'
                                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                        revert with 0, 'SafeMath: addition overflow'
                                    amountToBurn += 0 / totalAllocPoint / 20
                                    if not 0 / totalAllocPoint:
                                        _35164 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35164] = 26
                                        mem[_35164 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _35480 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _35480 + 68] = mem[idx + _35164 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35480 + 68] = mem[_35480 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _35480 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _35325 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35325] = 26
                                    mem[_35325 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _35628 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _35628 + 68] = mem[idx + _35325 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35628 + 68] = mem[_35628 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _35628 + -mem[64] + 100
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _29346 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29346] = 30
                                mem[_29346 + 32] = 'SafeMath: subtraction overflow'
                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _29346 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[mem[64] + 4] = this.address
                                mem[mem[64] + 36] = 0
                                require ext_code.size(sphereTokenAddress)
                                call sphereTokenAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _32107 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32107] = 26
                                mem[_32107 + 32] = 'SafeMath: division by zero'
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                    if not 0 / totalAllocPoint:
                                        _35631 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35631] = 26
                                        mem[_35631 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _35866 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _35866 + 68] = mem[idx + _35631 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35866 + 68] = mem[_35866 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _35866 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _35750 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35750] = 26
                                    mem[_35750 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _35981 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _35981 + 68] = mem[idx + _35750 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35981 + 68] = mem[_35981 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _35981 + -mem[64] + 100
                                _34989 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34989] = 26
                                mem[_34989 + 32] = 'SafeMath: division by zero'
                                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                    revert with 0, 'SafeMath: addition overflow'
                                amountToBurn += 0 / totalAllocPoint / 20
                                if not 0 / totalAllocPoint:
                                    _36642 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_36642] = 26
                                    mem[_36642 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _36715 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _36715 + 68] = mem[idx + _36642 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36715 + 68] = mem[_36715 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _36715 + -mem[64] + 100
                                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _36684 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_36684] = 26
                                mem[_36684 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _36745 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _36745 + 68] = mem[idx + _36684 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_36745 + 68] = mem[_36745 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _36745 + -mem[64] + 100
                            _19278 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19278] = 30
                            mem[_19278 + 32] = 'SafeMath: subtraction overflow'
                            if poolInfo[idx].field_512 > block.number:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                idx = 32
                                while idx < 30:
                                    mem[idx + mem[64] + 68] = mem[idx + _19278 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not block.number - poolInfo[idx].field_512:
                                _19673 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19673] = 26
                                mem[_19673 + 32] = 'SafeMath: division by zero'
                                if not totalAllocPoint:
                                    _19760 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _19760 + 68] = mem[idx + _19673 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19760 + 68] = mem[_19760 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _19760 + -mem[64] + 100
                                _19904 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19904] = 26
                                mem[_19904 + 32] = 'SafeMath: division by zero'
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                    mem[mem[64] + 4] = devAddress
                                    mem[mem[64] + 36] = 0 / totalAllocPoint / 20
                                    require ext_code.size(sphereTokenAddress)
                                    call sphereTokenAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devAddress, 0 / totalAllocPoint / 20
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = 0 / totalAllocPoint
                                        require ext_code.size(sphereTokenAddress)
                                        call sphereTokenAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        _25098 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25098] = 26
                                        mem[_25098 + 32] = 'SafeMath: division by zero'
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                            if not 0 / totalAllocPoint:
                                                _28862 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_28862] = 26
                                                mem[_28862 + 32] = 'SafeMath: division by zero'
                                                if ext_call.return_data[0]:
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                                    idx = idx + 1
                                                    continue 
                                                _29340 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _29340 + 68] = mem[idx + _28862 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_29340 + 68] = mem[_29340 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _29340 + -mem[64] + 100
                                            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _29108 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_29108] = 26
                                            mem[_29108 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _29529 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _29529 + 68] = mem[idx + _29108 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_29529 + 68] = mem[_29529 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _29529 + -mem[64] + 100
                                        _27944 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_27944] = 26
                                        mem[_27944 + 32] = 'SafeMath: division by zero'
                                        if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                            revert with 0, 'SafeMath: addition overflow'
                                        amountToBurn += 0 / totalAllocPoint / 20
                                        if not 0 / totalAllocPoint:
                                            _31229 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31229] = 26
                                            mem[_31229 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _31812 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _31812 + 68] = mem[idx + _31229 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_31812 + 68] = mem[_31812 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _31812 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _31521 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31521] = 26
                                        mem[_31521 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _32097 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _32097 + 68] = mem[idx + _31521 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_32097 + 68] = mem[_32097 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _32097 + -mem[64] + 100
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    if ext_call.return_data[0] >= ext_call.return_data[0]:
                                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        _25967 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25967] = 26
                                        mem[_25967 + 32] = 'SafeMath: division by zero'
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                            if not 0 / totalAllocPoint:
                                                _29716 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_29716] = 26
                                                mem[_29716 + 32] = 'SafeMath: division by zero'
                                                if ext_call.return_data[0]:
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                                    idx = idx + 1
                                                    continue 
                                                _30151 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _30151 + 68] = mem[idx + _29716 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_30151 + 68] = mem[_30151 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _30151 + -mem[64] + 100
                                            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _29927 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_29927] = 26
                                            mem[_29927 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _30399 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _30399 + 68] = mem[idx + _29927 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_30399 + 68] = mem[_30399 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _30399 + -mem[64] + 100
                                        _28860 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28860] = 26
                                        mem[_28860 + 32] = 'SafeMath: division by zero'
                                        if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                            revert with 0, 'SafeMath: addition overflow'
                                        amountToBurn += 0 / totalAllocPoint / 20
                                        if not 0 / totalAllocPoint:
                                            _32365 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32365] = 26
                                            mem[_32365 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _32844 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _32844 + 68] = mem[idx + _32365 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_32844 + 68] = mem[_32844 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _32844 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _32615 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32615] = 26
                                        mem[_32615 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _33068 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _33068 + 68] = mem[idx + _32615 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33068 + 68] = mem[_33068 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _33068 + -mem[64] + 100
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _26363 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26363] = 30
                                    mem[_26363 + 32] = 'SafeMath: subtraction overflow'
                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                        idx = 32
                                        while idx < 30:
                                            mem[idx + mem[64] + 68] = mem[idx + _26363 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = 0
                                    require ext_code.size(sphereTokenAddress)
                                    call sphereTokenAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _28861 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28861] = 26
                                    mem[_28861 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not 0 / totalAllocPoint:
                                            _33071 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33071] = 26
                                            mem[_33071 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _33529 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _33529 + 68] = mem[idx + _33071 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33529 + 68] = mem[_33529 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _33529 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _33307 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33307] = 26
                                        mem[_33307 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _33744 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _33744 + 68] = mem[idx + _33307 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33744 + 68] = mem[_33744 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _33744 + -mem[64] + 100
                                    _32096 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32096] = 26
                                    mem[_32096 + 32] = 'SafeMath: division by zero'
                                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                        revert with 0, 'SafeMath: addition overflow'
                                    amountToBurn += 0 / totalAllocPoint / 20
                                    if not 0 / totalAllocPoint:
                                        _35162 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35162] = 26
                                        mem[_35162 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _35474 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _35474 + 68] = mem[idx + _35162 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35474 + 68] = mem[_35474 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _35474 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _35323 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35323] = 26
                                    mem[_35323 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _35622 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _35622 + 68] = mem[idx + _35323 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35622 + 68] = mem[_35622 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _35622 + -mem[64] + 100
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                if ext_call.return_data[0] >= ext_call.return_data[0]:
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = 0 / totalAllocPoint
                                        require ext_code.size(sphereTokenAddress)
                                        call sphereTokenAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        _25965 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25965] = 26
                                        mem[_25965 + 32] = 'SafeMath: division by zero'
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                            if not 0 / totalAllocPoint:
                                                _29713 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_29713] = 26
                                                mem[_29713 + 32] = 'SafeMath: division by zero'
                                                if ext_call.return_data[0]:
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                                    idx = idx + 1
                                                    continue 
                                                _30147 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _30147 + 68] = mem[idx + _29713 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_30147 + 68] = mem[_30147 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _30147 + -mem[64] + 100
                                            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _29923 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_29923] = 26
                                            mem[_29923 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _30393 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _30393 + 68] = mem[idx + _29923 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_30393 + 68] = mem[_30393 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _30393 + -mem[64] + 100
                                        _28856 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28856] = 26
                                        mem[_28856 + 32] = 'SafeMath: division by zero'
                                        if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                            revert with 0, 'SafeMath: addition overflow'
                                        amountToBurn += 0 / totalAllocPoint / 20
                                        if not 0 / totalAllocPoint:
                                            _32362 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32362] = 26
                                            mem[_32362 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _32838 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _32838 + 68] = mem[idx + _32362 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_32838 + 68] = mem[_32838 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _32838 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _32613 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32613] = 26
                                        mem[_32613 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _33062 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _33062 + 68] = mem[idx + _32613 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33062 + 68] = mem[_33062 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _33062 + -mem[64] + 100
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    if ext_call.return_data[0] >= ext_call.return_data[0]:
                                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        _26682 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26682] = 26
                                        mem[_26682 + 32] = 'SafeMath: division by zero'
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                            if not 0 / totalAllocPoint:
                                                _30660 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_30660] = 26
                                                mem[_30660 + 32] = 'SafeMath: division by zero'
                                                if ext_call.return_data[0]:
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                                    idx = idx + 1
                                                    continue 
                                                _31212 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _31212 + 68] = mem[idx + _30660 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_31212 + 68] = mem[_31212 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _31212 + -mem[64] + 100
                                            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _30941 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_30941] = 26
                                            mem[_30941 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _31506 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _31506 + 68] = mem[idx + _30941 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_31506 + 68] = mem[_31506 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _31506 + -mem[64] + 100
                                        _29711 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29711] = 26
                                        mem[_29711 + 32] = 'SafeMath: division by zero'
                                        if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                            revert with 0, 'SafeMath: addition overflow'
                                        amountToBurn += 0 / totalAllocPoint / 20
                                        if not 0 / totalAllocPoint:
                                            _33303 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33303] = 26
                                            mem[_33303 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _33726 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _33726 + 68] = mem[idx + _33303 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33726 + 68] = mem[_33726 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _33726 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _33519 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33519] = 26
                                        mem[_33519 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _33944 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _33944 + 68] = mem[idx + _33519 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33944 + 68] = mem[_33944 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _33944 + -mem[64] + 100
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _27108 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27108] = 30
                                    mem[_27108 + 32] = 'SafeMath: subtraction overflow'
                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                        idx = 32
                                        while idx < 30:
                                            mem[idx + mem[64] + 68] = mem[idx + _27108 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = 0
                                    require ext_code.size(sphereTokenAddress)
                                    call sphereTokenAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _29712 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29712] = 26
                                    mem[_29712 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not 0 / totalAllocPoint:
                                            _33947 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33947] = 26
                                            mem[_33947 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _34335 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _34335 + 68] = mem[idx + _33947 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_34335 + 68] = mem[_34335 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _34335 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _34151 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34151] = 26
                                        mem[_34151 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _34539 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _34539 + 68] = mem[idx + _34151 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_34539 + 68] = mem[_34539 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _34539 + -mem[64] + 100
                                    _33061 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33061] = 26
                                    mem[_33061 + 32] = 'SafeMath: division by zero'
                                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                        revert with 0, 'SafeMath: addition overflow'
                                    amountToBurn += 0 / totalAllocPoint / 20
                                    if not 0 / totalAllocPoint:
                                        _35744 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35744] = 26
                                        mem[_35744 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _35961 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _35961 + 68] = mem[idx + _35744 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35961 + 68] = mem[_35961 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _35961 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _35852 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35852] = 26
                                    mem[_35852 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _36092 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _36092 + 68] = mem[idx + _35852 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36092 + 68] = mem[_36092 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _36092 + -mem[64] + 100
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _23207 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23207] = 30
                                mem[_23207 + 32] = 'SafeMath: subtraction overflow'
                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _23207 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[mem[64] + 4] = devAddress
                                mem[mem[64] + 36] = 0
                                require ext_code.size(sphereTokenAddress)
                                call sphereTokenAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args devAddress, 0
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = 0 / totalAllocPoint
                                    require ext_code.size(sphereTokenAddress)
                                    call sphereTokenAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _28859 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28859] = 26
                                    mem[_28859 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not 0 / totalAllocPoint:
                                            _33067 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33067] = 26
                                            mem[_33067 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _33523 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _33523 + 68] = mem[idx + _33067 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33523 + 68] = mem[_33523 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _33523 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _33305 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33305] = 26
                                        mem[_33305 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _33736 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _33736 + 68] = mem[idx + _33305 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33736 + 68] = mem[_33736 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _33736 + -mem[64] + 100
                                    _32093 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32093] = 26
                                    mem[_32093 + 32] = 'SafeMath: division by zero'
                                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                        revert with 0, 'SafeMath: addition overflow'
                                    amountToBurn += 0 / totalAllocPoint / 20
                                    if not 0 / totalAllocPoint:
                                        _35161 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35161] = 26
                                        mem[_35161 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _35471 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _35471 + 68] = mem[idx + _35161 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35471 + 68] = mem[_35471 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _35471 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _35322 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35322] = 26
                                    mem[_35322 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _35619 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _35619 + 68] = mem[idx + _35322 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35619 + 68] = mem[_35619 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _35619 + -mem[64] + 100
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                if ext_call.return_data[0] >= ext_call.return_data[0]:
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _29714 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29714] = 26
                                    mem[_29714 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not 0 / totalAllocPoint:
                                            _33951 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33951] = 26
                                            mem[_33951 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _34338 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _34338 + 68] = mem[idx + _33951 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_34338 + 68] = mem[_34338 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _34338 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _34154 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34154] = 26
                                        mem[_34154 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _34544 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _34544 + 68] = mem[idx + _34154 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_34544 + 68] = mem[_34544 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _34544 + -mem[64] + 100
                                    _33065 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33065] = 26
                                    mem[_33065 + 32] = 'SafeMath: division by zero'
                                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                        revert with 0, 'SafeMath: addition overflow'
                                    amountToBurn += 0 / totalAllocPoint / 20
                                    if not 0 / totalAllocPoint:
                                        _35745 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35745] = 26
                                        mem[_35745 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _35964 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _35964 + 68] = mem[idx + _35745 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35964 + 68] = mem[_35964 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _35964 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _35853 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35853] = 26
                                    mem[_35853 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _36095 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _36095 + 68] = mem[idx + _35853 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36095 + 68] = mem[_36095 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _36095 + -mem[64] + 100
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _30150 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_30150] = 30
                                mem[_30150 + 32] = 'SafeMath: subtraction overflow'
                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _30150 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[mem[64] + 4] = this.address
                                mem[mem[64] + 36] = 0
                                require ext_code.size(sphereTokenAddress)
                                call sphereTokenAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _33066 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33066] = 26
                                mem[_33066 + 32] = 'SafeMath: division by zero'
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                    if not 0 / totalAllocPoint:
                                        _36098 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_36098] = 26
                                        mem[_36098 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _36325 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _36325 + 68] = mem[idx + _36098 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_36325 + 68] = mem[_36325 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _36325 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _36223 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_36223] = 26
                                    mem[_36223 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _36413 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _36413 + 68] = mem[idx + _36223 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36413 + 68] = mem[_36413 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _36413 + -mem[64] + 100
                                _35618 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35618] = 26
                                mem[_35618 + 32] = 'SafeMath: division by zero'
                                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                    revert with 0, 'SafeMath: addition overflow'
                                amountToBurn += 0 / totalAllocPoint / 20
                                if not 0 / totalAllocPoint:
                                    _36764 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_36764] = 26
                                    mem[_36764 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _36805 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _36805 + 68] = mem[idx + _36764 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36805 + 68] = mem[_36805 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _36805 + -mem[64] + 100
                                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _36783 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_36783] = 26
                                mem[_36783 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _36835 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _36835 + 68] = mem[idx + _36783 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_36835 + 68] = mem[_36835 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _36835 + -mem[64] + 100
                            if (block.number * spherePerBlock) - (poolInfo[idx].field_512 * spherePerBlock) / block.number - poolInfo[idx].field_512 != spherePerBlock:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not (block.number * spherePerBlock) - (poolInfo[idx].field_512 * spherePerBlock):
                                _19717 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19717] = 26
                                mem[_19717 + 32] = 'SafeMath: division by zero'
                                if not totalAllocPoint:
                                    _19792 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _19792 + 68] = mem[idx + _19717 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19792 + 68] = mem[_19792 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _19792 + -mem[64] + 100
                                _19958 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19958] = 26
                                mem[_19958 + 32] = 'SafeMath: division by zero'
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                    mem[mem[64] + 4] = devAddress
                                    mem[mem[64] + 36] = 0 / totalAllocPoint / 20
                                    require ext_code.size(sphereTokenAddress)
                                    call sphereTokenAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devAddress, 0 / totalAllocPoint / 20
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = 0 / totalAllocPoint
                                        require ext_code.size(sphereTokenAddress)
                                        call sphereTokenAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        _25342 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25342] = 26
                                        mem[_25342 + 32] = 'SafeMath: division by zero'
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                            if not 0 / totalAllocPoint:
                                                _29104 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_29104] = 26
                                                mem[_29104 + 32] = 'SafeMath: division by zero'
                                                if ext_call.return_data[0]:
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                                    idx = idx + 1
                                                    continue 
                                                _29520 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _29520 + 68] = mem[idx + _29104 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_29520 + 68] = mem[_29520 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _29520 + -mem[64] + 100
                                            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _29334 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_29334] = 26
                                            mem[_29334 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _29706 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _29706 + 68] = mem[idx + _29334 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_29706 + 68] = mem[_29706 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _29706 + -mem[64] + 100
                                        _28199 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28199] = 26
                                        mem[_28199 + 32] = 'SafeMath: division by zero'
                                        if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                            revert with 0, 'SafeMath: addition overflow'
                                        amountToBurn += 0 / totalAllocPoint / 20
                                        if not 0 / totalAllocPoint:
                                            _31505 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31505] = 26
                                            mem[_31505 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _32082 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _32082 + 68] = mem[idx + _31505 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_32082 + 68] = mem[_32082 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _32082 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _31802 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31802] = 26
                                        mem[_31802 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _32354 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _32354 + 68] = mem[idx + _31802 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_32354 + 68] = mem[_32354 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _32354 + -mem[64] + 100
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    if ext_call.return_data[0] >= ext_call.return_data[0]:
                                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        _26177 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26177] = 26
                                        mem[_26177 + 32] = 'SafeMath: division by zero'
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                            if not 0 / totalAllocPoint:
                                                _29921 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_29921] = 26
                                                mem[_29921 + 32] = 'SafeMath: division by zero'
                                                if ext_call.return_data[0]:
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                                    idx = idx + 1
                                                    continue 
                                                _30385 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _30385 + 68] = mem[idx + _29921 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_30385 + 68] = mem[_30385 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _30385 + -mem[64] + 100
                                            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _30141 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_30141] = 26
                                            mem[_30141 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _30651 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _30651 + 68] = mem[idx + _30141 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_30651 + 68] = mem[_30651 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _30651 + -mem[64] + 100
                                        _29102 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29102] = 26
                                        mem[_29102 + 32] = 'SafeMath: division by zero'
                                        if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                            revert with 0, 'SafeMath: addition overflow'
                                        amountToBurn += 0 / totalAllocPoint / 20
                                        if not 0 / totalAllocPoint:
                                            _32608 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32608] = 26
                                            mem[_32608 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _33051 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _33051 + 68] = mem[idx + _32608 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33051 + 68] = mem[_33051 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _33051 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _32832 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32832] = 26
                                        mem[_32832 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _33296 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _33296 + 68] = mem[idx + _32832 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33296 + 68] = mem[_33296 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _33296 + -mem[64] + 100
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _26511 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26511] = 30
                                    mem[_26511 + 32] = 'SafeMath: subtraction overflow'
                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                        idx = 32
                                        while idx < 30:
                                            mem[idx + mem[64] + 68] = mem[idx + _26511 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = 0
                                    require ext_code.size(sphereTokenAddress)
                                    call sphereTokenAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _29103 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29103] = 26
                                    mem[_29103 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not 0 / totalAllocPoint:
                                            _33299 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33299] = 26
                                            mem[_33299 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _33723 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _33723 + 68] = mem[idx + _33299 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33723 + 68] = mem[_33723 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _33723 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _33516 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33516] = 26
                                        mem[_33516 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _33939 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _33939 + 68] = mem[idx + _33516 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33939 + 68] = mem[_33939 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _33939 + -mem[64] + 100
                                    _32353 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32353] = 26
                                    mem[_32353 + 32] = 'SafeMath: division by zero'
                                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                        revert with 0, 'SafeMath: addition overflow'
                                    amountToBurn += 0 / totalAllocPoint / 20
                                    if not 0 / totalAllocPoint:
                                        _35315 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35315] = 26
                                        mem[_35315 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _35611 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _35611 + 68] = mem[idx + _35315 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35611 + 68] = mem[_35611 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _35611 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _35466 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35466] = 26
                                    mem[_35466 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _35741 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _35741 + 68] = mem[idx + _35466 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35741 + 68] = mem[_35741 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _35741 + -mem[64] + 100
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                if ext_call.return_data[0] >= ext_call.return_data[0]:
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = 0 / totalAllocPoint
                                        require ext_code.size(sphereTokenAddress)
                                        call sphereTokenAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        _26175 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26175] = 26
                                        mem[_26175 + 32] = 'SafeMath: division by zero'
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                            if not 0 / totalAllocPoint:
                                                _29918 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_29918] = 26
                                                mem[_29918 + 32] = 'SafeMath: division by zero'
                                                if ext_call.return_data[0]:
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                                    idx = idx + 1
                                                    continue 
                                                _30381 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _30381 + 68] = mem[idx + _29918 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_30381 + 68] = mem[_30381 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _30381 + -mem[64] + 100
                                            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _30137 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_30137] = 26
                                            mem[_30137 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _30645 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _30645 + 68] = mem[idx + _30137 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_30645 + 68] = mem[_30645 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _30645 + -mem[64] + 100
                                        _29098 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29098] = 26
                                        mem[_29098 + 32] = 'SafeMath: division by zero'
                                        if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                            revert with 0, 'SafeMath: addition overflow'
                                        amountToBurn += 0 / totalAllocPoint / 20
                                        if not 0 / totalAllocPoint:
                                            _32605 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32605] = 26
                                            mem[_32605 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _33045 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _33045 + 68] = mem[idx + _32605 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33045 + 68] = mem[_33045 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _33045 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _32830 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32830] = 26
                                        mem[_32830 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _33290 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _33290 + 68] = mem[idx + _32830 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33290 + 68] = mem[_33290 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _33290 + -mem[64] + 100
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    if ext_call.return_data[0] >= ext_call.return_data[0]:
                                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        _26871 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26871] = 26
                                        mem[_26871 + 32] = 'SafeMath: division by zero'
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                            if not 0 / totalAllocPoint:
                                                _30931 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_30931] = 26
                                                mem[_30931 + 32] = 'SafeMath: division by zero'
                                                if ext_call.return_data[0]:
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                                    idx = idx + 1
                                                    continue 
                                                _31488 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _31488 + 68] = mem[idx + _30931 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_31488 + 68] = mem[_31488 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _31488 + -mem[64] + 100
                                            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _31198 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31198] = 26
                                            mem[_31198 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _31787 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _31787 + 68] = mem[idx + _31198 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_31787 + 68] = mem[_31787 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _31787 + -mem[64] + 100
                                        _29916 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29916] = 26
                                        mem[_29916 + 32] = 'SafeMath: division by zero'
                                        if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                            revert with 0, 'SafeMath: addition overflow'
                                        amountToBurn += 0 / totalAllocPoint / 20
                                        if not 0 / totalAllocPoint:
                                            _33512 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33512] = 26
                                            mem[_33512 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _33921 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _33921 + 68] = mem[idx + _33512 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33921 + 68] = mem[_33921 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _33921 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _33713 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33713] = 26
                                        mem[_33713 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _34137 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _34137 + 68] = mem[idx + _33713 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_34137 + 68] = mem[_34137 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _34137 + -mem[64] + 100
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _27364 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27364] = 30
                                    mem[_27364 + 32] = 'SafeMath: subtraction overflow'
                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                        idx = 32
                                        while idx < 30:
                                            mem[idx + mem[64] + 68] = mem[idx + _27364 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = 0
                                    require ext_code.size(sphereTokenAddress)
                                    call sphereTokenAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _29917 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29917] = 26
                                    mem[_29917 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not 0 / totalAllocPoint:
                                            _34140 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34140] = 26
                                            mem[_34140 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _34524 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _34524 + 68] = mem[idx + _34140 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_34524 + 68] = mem[_34524 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _34524 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _34318 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34318] = 26
                                        mem[_34318 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _34740 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _34740 + 68] = mem[idx + _34318 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_34740 + 68] = mem[_34740 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _34740 + -mem[64] + 100
                                    _33289 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33289] = 26
                                    mem[_33289 + 32] = 'SafeMath: division by zero'
                                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                        revert with 0, 'SafeMath: addition overflow'
                                    amountToBurn += 0 / totalAllocPoint / 20
                                    if not 0 / totalAllocPoint:
                                        _35848 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35848] = 26
                                        mem[_35848 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _36078 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _36078 + 68] = mem[idx + _35848 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_36078 + 68] = mem[_36078 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _36078 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _35953 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35953] = 26
                                    mem[_35953 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _36208 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _36208 + 68] = mem[idx + _35953 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36208 + 68] = mem[_36208 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _36208 + -mem[64] + 100
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _23378 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23378] = 30
                                mem[_23378 + 32] = 'SafeMath: subtraction overflow'
                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _23378 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[mem[64] + 4] = devAddress
                                mem[mem[64] + 36] = 0
                                require ext_code.size(sphereTokenAddress)
                                call sphereTokenAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args devAddress, 0
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = 0 / totalAllocPoint
                                    require ext_code.size(sphereTokenAddress)
                                    call sphereTokenAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _29101 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29101] = 26
                                    mem[_29101 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not 0 / totalAllocPoint:
                                            _33295 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33295] = 26
                                            mem[_33295 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _33717 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _33717 + 68] = mem[idx + _33295 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33717 + 68] = mem[_33717 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _33717 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _33514 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33514] = 26
                                        mem[_33514 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _33931 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _33931 + 68] = mem[idx + _33514 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33931 + 68] = mem[_33931 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _33931 + -mem[64] + 100
                                    _32350 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32350] = 26
                                    mem[_32350 + 32] = 'SafeMath: division by zero'
                                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                        revert with 0, 'SafeMath: addition overflow'
                                    amountToBurn += 0 / totalAllocPoint / 20
                                    if not 0 / totalAllocPoint:
                                        _35314 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35314] = 26
                                        mem[_35314 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _35608 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _35608 + 68] = mem[idx + _35314 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35608 + 68] = mem[_35608 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _35608 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _35465 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35465] = 26
                                    mem[_35465 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _35738 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _35738 + 68] = mem[idx + _35465 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35738 + 68] = mem[_35738 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _35738 + -mem[64] + 100
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                if ext_call.return_data[0] >= ext_call.return_data[0]:
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _29919 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29919] = 26
                                    mem[_29919 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not 0 / totalAllocPoint:
                                            _34144 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34144] = 26
                                            mem[_34144 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _34527 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _34527 + 68] = mem[idx + _34144 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_34527 + 68] = mem[_34527 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _34527 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _34321 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34321] = 26
                                        mem[_34321 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _34745 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _34745 + 68] = mem[idx + _34321 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_34745 + 68] = mem[_34745 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _34745 + -mem[64] + 100
                                    _33293 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33293] = 26
                                    mem[_33293 + 32] = 'SafeMath: division by zero'
                                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                        revert with 0, 'SafeMath: addition overflow'
                                    amountToBurn += 0 / totalAllocPoint / 20
                                    if not 0 / totalAllocPoint:
                                        _35849 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35849] = 26
                                        mem[_35849 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _36081 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _36081 + 68] = mem[idx + _35849 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_36081 + 68] = mem[_36081 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _36081 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _35954 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35954] = 26
                                    mem[_35954 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _36211 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _36211 + 68] = mem[idx + _35954 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36211 + 68] = mem[_36211 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _36211 + -mem[64] + 100
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _30384 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_30384] = 30
                                mem[_30384 + 32] = 'SafeMath: subtraction overflow'
                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _30384 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[mem[64] + 4] = this.address
                                mem[mem[64] + 36] = 0
                                require ext_code.size(sphereTokenAddress)
                                call sphereTokenAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _33294 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33294] = 26
                                mem[_33294 + 32] = 'SafeMath: division by zero'
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                    if not 0 / totalAllocPoint:
                                        _36214 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_36214] = 26
                                        mem[_36214 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _36404 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _36404 + 68] = mem[idx + _36214 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_36404 + 68] = mem[_36404 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _36404 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _36314 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_36314] = 26
                                    mem[_36314 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _36494 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _36494 + 68] = mem[idx + _36314 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36494 + 68] = mem[_36494 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _36494 + -mem[64] + 100
                                _35737 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35737] = 26
                                mem[_35737 + 32] = 'SafeMath: division by zero'
                                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                    revert with 0, 'SafeMath: addition overflow'
                                amountToBurn += 0 / totalAllocPoint / 20
                                if not 0 / totalAllocPoint:
                                    _36782 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_36782] = 26
                                    mem[_36782 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _36832 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _36832 + 68] = mem[idx + _36782 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36832 + 68] = mem[_36832 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _36832 + -mem[64] + 100
                                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _36804 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_36804] = 26
                                mem[_36804 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _36862 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _36862 + 68] = mem[idx + _36804 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_36862 + 68] = mem[_36862 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _36862 + -mem[64] + 100
                            if (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / (block.number * spherePerBlock) - (poolInfo[idx].field_512 * spherePerBlock) != poolInfo[idx].field_256:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _19759 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19759] = 26
                            mem[_19759 + 32] = 'SafeMath: division by zero'
                            if not totalAllocPoint:
                                _19821 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _19821 + 68] = mem[idx + _19759 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19821 + 68] = mem[_19821 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _19821 + -mem[64] + 100
                            _20007 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20007] = 26
                            mem[_20007 + 32] = 'SafeMath: division by zero'
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                revert with 0, 'SafeMath: addition overflow'
                            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                mem[mem[64] + 4] = devAddress
                                mem[mem[64] + 36] = (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
                                require ext_code.size(sphereTokenAddress)
                                call sphereTokenAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args devAddress, (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                    require ext_code.size(sphereTokenAddress)
                                    call sphereTokenAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _25543 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_25543] = 26
                                    mem[_25543 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                            _29330 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_29330] = 26
                                            mem[_29330 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _29697 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _29697 + 68] = mem[idx + _29330 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_29697 + 68] = mem[_29697 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _29697 + -mem[64] + 100
                                        if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _29514 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29514] = 26
                                        mem[_29514 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _29911 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _29911 + 68] = mem[idx + _29514 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_29911 + 68] = mem[_29911 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _29911 + -mem[64] + 100
                                    _28435 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28435] = 26
                                    mem[_28435 + 32] = 'SafeMath: division by zero'
                                    if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                        revert with 0, 'SafeMath: addition overflow'
                                    amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
                                    if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                        _31786 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31786] = 26
                                        mem[_31786 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _32339 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _32339 + 68] = mem[idx + _31786 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_32339 + 68] = mem[_32339 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _32339 + -mem[64] + 100
                                    if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _32072 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32072] = 26
                                    mem[_32072 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _32597 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _32597 + 68] = mem[idx + _32072 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_32597 + 68] = mem[_32597 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _32597 + -mem[64] + 100
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                if ext_call.return_data[0] >= ext_call.return_data[0]:
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _26352 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26352] = 26
                                    mem[_26352 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                            _30135 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_30135] = 26
                                            mem[_30135 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _30637 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _30637 + 68] = mem[idx + _30135 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_30637 + 68] = mem[_30637 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _30637 + -mem[64] + 100
                                        if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _30375 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30375] = 26
                                        mem[_30375 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _30922 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _30922 + 68] = mem[idx + _30375 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_30922 + 68] = mem[_30922 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _30922 + -mem[64] + 100
                                    _29328 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29328] = 26
                                    mem[_29328 + 32] = 'SafeMath: division by zero'
                                    if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                        revert with 0, 'SafeMath: addition overflow'
                                    amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
                                    if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                        _32825 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32825] = 26
                                        mem[_32825 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _33279 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _33279 + 68] = mem[idx + _32825 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33279 + 68] = mem[_33279 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _33279 + -mem[64] + 100
                                    if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _33039 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33039] = 26
                                    mem[_33039 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _33505 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _33505 + 68] = mem[idx + _33039 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33505 + 68] = mem[_33505 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _33505 + -mem[64] + 100
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _26677 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26677] = 30
                                mem[_26677 + 32] = 'SafeMath: subtraction overflow'
                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _26677 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[mem[64] + 4] = this.address
                                mem[mem[64] + 36] = 0
                                require ext_code.size(sphereTokenAddress)
                                call sphereTokenAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _29329 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29329] = 26
                                mem[_29329 + 32] = 'SafeMath: division by zero'
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                    if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                        _33508 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33508] = 26
                                        mem[_33508 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _33918 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _33918 + 68] = mem[idx + _33508 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33918 + 68] = mem[_33918 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _33918 + -mem[64] + 100
                                    if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _33710 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33710] = 26
                                    mem[_33710 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _34132 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _34132 + 68] = mem[idx + _33710 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_34132 + 68] = mem[_34132 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _34132 + -mem[64] + 100
                                _32596 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32596] = 26
                                mem[_32596 + 32] = 'SafeMath: division by zero'
                                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                    revert with 0, 'SafeMath: addition overflow'
                                amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
                                if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                    _35458 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35458] = 26
                                    mem[_35458 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _35730 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _35730 + 68] = mem[idx + _35458 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35730 + 68] = mem[_35730 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _35730 + -mem[64] + 100
                                if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _35603 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35603] = 26
                                mem[_35603 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _35845 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _35845 + 68] = mem[idx + _35603 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35845 + 68] = mem[_35845 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _35845 + -mem[64] + 100
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            if ext_call.return_data[0] >= ext_call.return_data[0]:
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                    require ext_code.size(sphereTokenAddress)
                                    call sphereTokenAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _26350 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26350] = 26
                                    mem[_26350 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                            _30132 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_30132] = 26
                                            mem[_30132 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _30633 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _30633 + 68] = mem[idx + _30132 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_30633 + 68] = mem[_30633 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _30633 + -mem[64] + 100
                                        if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _30371 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30371] = 26
                                        mem[_30371 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _30916 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _30916 + 68] = mem[idx + _30371 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_30916 + 68] = mem[_30916 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _30916 + -mem[64] + 100
                                    _29324 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29324] = 26
                                    mem[_29324 + 32] = 'SafeMath: division by zero'
                                    if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                        revert with 0, 'SafeMath: addition overflow'
                                    amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
                                    if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                        _32822 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32822] = 26
                                        mem[_32822 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _33273 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _33273 + 68] = mem[idx + _32822 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33273 + 68] = mem[_33273 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _33273 + -mem[64] + 100
                                    if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _33037 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33037] = 26
                                    mem[_33037 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _33499 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _33499 + 68] = mem[idx + _33037 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33499 + 68] = mem[_33499 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _33499 + -mem[64] + 100
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                if ext_call.return_data[0] >= ext_call.return_data[0]:
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _27092 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27092] = 26
                                    mem[_27092 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                            _31188 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31188] = 26
                                            mem[_31188 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _31769 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _31769 + 68] = mem[idx + _31188 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_31769 + 68] = mem[_31769 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _31769 + -mem[64] + 100
                                        if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _31474 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31474] = 26
                                        mem[_31474 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _32057 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _32057 + 68] = mem[idx + _31474 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_32057 + 68] = mem[_32057 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _32057 + -mem[64] + 100
                                    _30130 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30130] = 26
                                    mem[_30130 + 32] = 'SafeMath: division by zero'
                                    if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                        revert with 0, 'SafeMath: addition overflow'
                                    amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
                                    if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                        _33706 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33706] = 26
                                        mem[_33706 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _34114 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _34114 + 68] = mem[idx + _33706 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_34114 + 68] = mem[_34114 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _34114 + -mem[64] + 100
                                    if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _33908 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33908] = 26
                                    mem[_33908 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _34304 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _34304 + 68] = mem[idx + _33908 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_34304 + 68] = mem[_34304 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _34304 + -mem[64] + 100
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _27642 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27642] = 30
                                mem[_27642 + 32] = 'SafeMath: subtraction overflow'
                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _27642 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[mem[64] + 4] = this.address
                                mem[mem[64] + 36] = 0
                                require ext_code.size(sphereTokenAddress)
                                call sphereTokenAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _30131 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_30131] = 26
                                mem[_30131 + 32] = 'SafeMath: division by zero'
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                    if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                        _34307 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34307] = 26
                                        mem[_34307 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _34725 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _34725 + 68] = mem[idx + _34307 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_34725 + 68] = mem[_34725 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _34725 + -mem[64] + 100
                                    if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _34507 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34507] = 26
                                    mem[_34507 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _34946 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _34946 + 68] = mem[idx + _34507 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_34946 + 68] = mem[_34946 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _34946 + -mem[64] + 100
                                _33498 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33498] = 26
                                mem[_33498 + 32] = 'SafeMath: division by zero'
                                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                    revert with 0, 'SafeMath: addition overflow'
                                amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
                                if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                    _35949 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35949] = 26
                                    mem[_35949 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _36194 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _36194 + 68] = mem[idx + _35949 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36194 + 68] = mem[_36194 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _36194 + -mem[64] + 100
                                if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _36070 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_36070] = 26
                                mem[_36070 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _36299 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _36299 + 68] = mem[idx + _36070 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_36299 + 68] = mem[_36299 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _36299 + -mem[64] + 100
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            _23551 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23551] = 30
                            mem[_23551 + 32] = 'SafeMath: subtraction overflow'
                            if ext_call.return_data[0] > ext_call.return_data[0]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                idx = 32
                                while idx < 30:
                                    mem[idx + mem[64] + 68] = mem[idx + _23551 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: subtraction overflow'
                            mem[mem[64] + 4] = devAddress
                            mem[mem[64] + 36] = 0
                            require ext_code.size(sphereTokenAddress)
                            call sphereTokenAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devAddress, 0
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                                revert with 0, 'SafeMath: addition overflow'
                            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                mem[mem[64] + 4] = this.address
                                mem[mem[64] + 36] = (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                require ext_code.size(sphereTokenAddress)
                                call sphereTokenAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _29327 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29327] = 26
                                mem[_29327 + 32] = 'SafeMath: division by zero'
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                    if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                        _33504 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33504] = 26
                                        mem[_33504 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _33912 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _33912 + 68] = mem[idx + _33504 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33912 + 68] = mem[_33912 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _33912 + -mem[64] + 100
                                    if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _33708 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33708] = 26
                                    mem[_33708 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _34124 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _34124 + 68] = mem[idx + _33708 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_34124 + 68] = mem[_34124 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _34124 + -mem[64] + 100
                                _32593 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32593] = 26
                                mem[_32593 + 32] = 'SafeMath: division by zero'
                                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                    revert with 0, 'SafeMath: addition overflow'
                                amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
                                if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                    _35457 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35457] = 26
                                    mem[_35457 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _35727 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _35727 + 68] = mem[idx + _35457 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35727 + 68] = mem[_35727 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _35727 + -mem[64] + 100
                                if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _35602 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35602] = 26
                                mem[_35602 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _35842 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _35842 + 68] = mem[idx + _35602 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35842 + 68] = mem[_35842 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _35842 + -mem[64] + 100
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            if ext_call.return_data[0] >= ext_call.return_data[0]:
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _30133 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_30133] = 26
                                mem[_30133 + 32] = 'SafeMath: division by zero'
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                    if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                        _34311 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34311] = 26
                                        mem[_34311 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _34728 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _34728 + 68] = mem[idx + _34311 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_34728 + 68] = mem[_34728 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _34728 + -mem[64] + 100
                                    if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _34510 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34510] = 26
                                    mem[_34510 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _34951 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _34951 + 68] = mem[idx + _34510 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_34951 + 68] = mem[_34951 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _34951 + -mem[64] + 100
                                _33502 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33502] = 26
                                mem[_33502 + 32] = 'SafeMath: division by zero'
                                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                    revert with 0, 'SafeMath: addition overflow'
                                amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
                                if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                    _35950 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35950] = 26
                                    mem[_35950 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _36197 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _36197 + 68] = mem[idx + _35950 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36197 + 68] = mem[_36197 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _36197 + -mem[64] + 100
                                if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _36071 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_36071] = 26
                                mem[_36071 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _36302 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _36302 + 68] = mem[idx + _36071 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_36302 + 68] = mem[_36302 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _36302 + -mem[64] + 100
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            _30636 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_30636] = 30
                            mem[_30636 + 32] = 'SafeMath: subtraction overflow'
                            if ext_call.return_data[0] > ext_call.return_data[0]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                idx = 32
                                while idx < 30:
                                    mem[idx + mem[64] + 68] = mem[idx + _30636 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: subtraction overflow'
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0
                            require ext_code.size(sphereTokenAddress)
                            call sphereTokenAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args address(this.address), 0
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            _33503 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_33503] = 26
                            mem[_33503 + 32] = 'SafeMath: division by zero'
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                revert with 0, 'SafeMath: addition overflow'
                            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                    _36305 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_36305] = 26
                                    mem[_36305 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _36485 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _36485 + 68] = mem[idx + _36305 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36485 + 68] = mem[_36485 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _36485 + -mem[64] + 100
                                if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _36393 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_36393] = 26
                                mem[_36393 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _36568 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _36568 + 68] = mem[idx + _36393 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_36568 + 68] = mem[_36568 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _36568 + -mem[64] + 100
                            _35841 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35841] = 26
                            mem[_35841 + 32] = 'SafeMath: division by zero'
                            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                revert with 0, 'SafeMath: addition overflow'
                            amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
                            if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                _36803 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_36803] = 26
                                mem[_36803 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _36859 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _36859 + 68] = mem[idx + _36803 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_36859 + 68] = mem[_36859 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _36859 + -mem[64] + 100
                            if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _36831 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_36831] = 26
                            mem[_36831 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _36882 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _36882 + 68] = mem[idx + _36831 + 32]
                                idx = idx + 32
                                continue 
                            mem[_36882 + 68] = mem[_36882 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _36882 + -mem[64] + 100
                        if 0 / ext_call.return_data[0] >= 100 * topPrice:
                            _19145 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19145] = 26
                            mem[_19145 + 32] = 'SafeMath: division by zero'
                            if not maxEmissionRate / 100:
                                spherePerBlock = 0
                            else:
                                if maxEmissionRate / 100 / maxEmissionRate / 100 != 1:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                spherePerBlock = maxEmissionRate / 100
                        else:
                            if 0 / ext_call.return_data[0] <= 100 * bottomPrice:
                                _19149 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19149] = 26
                                mem[_19149 + 32] = 'SafeMath: division by zero'
                                if not maxEmissionRate / 100:
                                    spherePerBlock = 0
                                else:
                                    if 100 * maxEmissionRate / 100 / maxEmissionRate / 100 != 100:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    spherePerBlock = 100 * maxEmissionRate / 100
                            else:
                                if not 0 / ext_call.return_data[0]:
                                    _19158 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19158] = 26
                                    mem[_19158 + 32] = 'SafeMath: division by zero'
                                    if not 100 * topPrice:
                                        revert with 0, 'SafeMath: division by zero'
                                    require ext_code.size(0xd75dcd756844276df0330ff8f5a02c06c26a44e7)
                                    delegate 0xd75dcd756844276df0330ff8f5a02c06c26a44e7.reciprocal(int256 rg1) with:
                                         gas gas_remaining wei
                                        args curveRate
                                    if not delegate.return_code:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _19275 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19275] = 30
                                    mem[_19275 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / 100 * topPrice > 100:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(0xd75dcd756844276df0330ff8f5a02c06c26a44e7)
                                    delegate 0xd75dcd756844276df0330ff8f5a02c06c26a44e7.multiply(int256 rg1, int256 rg2) with:
                                         gas gas_remaining wei
                                        args delegate.return_data[0], -(0 / 100 * topPrice) + 100
                                    if not delegate.return_code:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(0xd75dcd756844276df0330ff8f5a02c06c26a44e7)
                                    delegate 0xd75dcd756844276df0330ff8f5a02c06c26a44e7.fromFixed(int256 rg1) with:
                                         gas gas_remaining wei
                                        args delegate.return_data[0]
                                    if not delegate.return_code:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(0xd75dcd756844276df0330ff8f5a02c06c26a44e7)
                                    delegate 0xd75dcd756844276df0330ff8f5a02c06c26a44e7.divide(int256 rg1, int256 rg2) with:
                                         gas gas_remaining wei
                                        args 100, 0 / 100 * topPrice
                                    if not delegate.return_code:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(0xd75dcd756844276df0330ff8f5a02c06c26a44e7)
                                    delegate 0xd75dcd756844276df0330ff8f5a02c06c26a44e7.fromFixed(int256 rg1) with:
                                         gas gas_remaining wei
                                        args delegate.return_data[0]
                                    if not delegate.return_code:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _19847 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19847] = 26
                                    mem[_19847 + 32] = 'SafeMath: division by zero'
                                else:
                                    if 100 * 0 / ext_call.return_data[0] / 0 / ext_call.return_data[0] != 100:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _19165 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19165] = 26
                                    mem[_19165 + 32] = 'SafeMath: division by zero'
                                    if not 100 * topPrice:
                                        revert with 0, 'SafeMath: division by zero'
                                    require ext_code.size(0xd75dcd756844276df0330ff8f5a02c06c26a44e7)
                                    delegate 0xd75dcd756844276df0330ff8f5a02c06c26a44e7.reciprocal(int256 rg1) with:
                                         gas gas_remaining wei
                                        args curveRate
                                    if not delegate.return_code:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _19287 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19287] = 30
                                    mem[_19287 + 32] = 'SafeMath: subtraction overflow'
                                    if 100 * 0 / ext_call.return_data[0] / 100 * topPrice > 100:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(0xd75dcd756844276df0330ff8f5a02c06c26a44e7)
                                    delegate 0xd75dcd756844276df0330ff8f5a02c06c26a44e7.multiply(int256 rg1, int256 rg2) with:
                                         gas gas_remaining wei
                                        args delegate.return_data[0], -(100 * 0 / ext_call.return_data[0] / 100 * topPrice) + 100
                                    if not delegate.return_code:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(0xd75dcd756844276df0330ff8f5a02c06c26a44e7)
                                    delegate 0xd75dcd756844276df0330ff8f5a02c06c26a44e7.fromFixed(int256 rg1) with:
                                         gas gas_remaining wei
                                        args delegate.return_data[0]
                                    if not delegate.return_code:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(0xd75dcd756844276df0330ff8f5a02c06c26a44e7)
                                    delegate 0xd75dcd756844276df0330ff8f5a02c06c26a44e7.divide(int256 rg1, int256 rg2) with:
                                         gas gas_remaining wei
                                        args 100, 100 * 0 / ext_call.return_data[0] / 100 * topPrice
                                    if not delegate.return_code:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(0xd75dcd756844276df0330ff8f5a02c06c26a44e7)
                                    delegate 0xd75dcd756844276df0330ff8f5a02c06c26a44e7.fromFixed(int256 rg1) with:
                                         gas gas_remaining wei
                                        args delegate.return_data[0]
                                    if not delegate.return_code:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _19890 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19890] = 26
                                    mem[_19890 + 32] = 'SafeMath: division by zero'
                                if not maxEmissionRate / 100:
                                    spherePerBlock = 0
                                else:
                                    if (delegate.return_data[0] * maxEmissionRate / 100) + (delegate.return_data[0] * maxEmissionRate / 100) / maxEmissionRate / 100 != 2 * delegate.return_data[0]:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    spherePerBlock = (delegate.return_data[0] * maxEmissionRate / 100) + (delegate.return_data[0] * maxEmissionRate / 100)
                    else:
                        if 10^14 * ext_call.return_data[0] / ext_call.return_data[0] != 10^14:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        mem[64] = 160
                        mem[96] = 26
                        mem[128] = 'SafeMath: division by zero'
                        if not ext_call.return_data[0]:
                            revert with 0, 'SafeMath: division by zero'
                        idx = 0
                        while idx < poolInfo.length:
                            mem[0] = 10
                            if block.number <= poolInfo[idx].field_512:
                                idx = idx + 1
                                continue 
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(poolInfo[idx].field_0)
                            staticcall poolInfo[idx].field_0.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not ext_call.return_data[0]:
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            if not poolInfo[idx].field_256:
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0] >= ext_call.return_data[0]:
                                _19514 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19514] = 26
                                mem[_19514 + 32] = 'SafeMath: division by zero'
                                if not totalAllocPoint:
                                    _19568 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _19568 + 68] = mem[idx + _19514 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19568 + 68] = mem[_19568 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _19568 + -mem[64] + 100
                                _19748 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19748] = 26
                                mem[_19748 + 32] = 'SafeMath: division by zero'
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                    mem[mem[64] + 4] = devAddress
                                    mem[mem[64] + 36] = 0 / totalAllocPoint / 20
                                    require ext_code.size(sphereTokenAddress)
                                    call sphereTokenAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devAddress, 0 / totalAllocPoint / 20
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = 0 / totalAllocPoint
                                        require ext_code.size(sphereTokenAddress)
                                        call sphereTokenAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        _24124 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_24124] = 26
                                        mem[_24124 + 32] = 'SafeMath: division by zero'
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                            if not 0 / totalAllocPoint:
                                                _27860 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_27860] = 26
                                                mem[_27860 + 32] = 'SafeMath: division by zero'
                                                if ext_call.return_data[0]:
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                                    idx = idx + 1
                                                    continue 
                                                _28374 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _28374 + 68] = mem[idx + _27860 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_28374 + 68] = mem[_28374 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _28374 + -mem[64] + 100
                                            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _28126 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_28126] = 26
                                            mem[_28126 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _28596 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _28596 + 68] = mem[idx + _28126 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_28596 + 68] = mem[_28596 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _28596 + -mem[64] + 100
                                        _26829 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26829] = 26
                                        mem[_26829 + 32] = 'SafeMath: division by zero'
                                        if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                            revert with 0, 'SafeMath: addition overflow'
                                        amountToBurn += 0 / totalAllocPoint / 20
                                        if not 0 / totalAllocPoint:
                                            _30098 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_30098] = 26
                                            mem[_30098 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _30593 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _30593 + 68] = mem[idx + _30098 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_30593 + 68] = mem[_30593 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _30593 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _30340 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30340] = 26
                                        mem[_30340 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _30871 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _30871 + 68] = mem[idx + _30340 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_30871 + 68] = mem[_30871 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _30871 + -mem[64] + 100
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    if ext_call.return_data[0] >= ext_call.return_data[0]:
                                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        _25020 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25020] = 26
                                        mem[_25020 + 32] = 'SafeMath: division by zero'
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                            if not 0 / totalAllocPoint:
                                                _28802 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_28802] = 26
                                                mem[_28802 + 32] = 'SafeMath: division by zero'
                                                if ext_call.return_data[0]:
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                                    idx = idx + 1
                                                    continue 
                                                _29269 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _29269 + 68] = mem[idx + _28802 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_29269 + 68] = mem[_29269 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _29269 + -mem[64] + 100
                                            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _29030 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_29030] = 26
                                            mem[_29030 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _29476 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _29476 + 68] = mem[idx + _29030 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_29476 + 68] = mem[_29476 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _29476 + -mem[64] + 100
                                        _27858 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_27858] = 26
                                        mem[_27858 + 32] = 'SafeMath: division by zero'
                                        if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                            revert with 0, 'SafeMath: addition overflow'
                                        amountToBurn += 0 / totalAllocPoint / 20
                                        if not 0 / totalAllocPoint:
                                            _31148 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31148] = 26
                                            mem[_31148 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _31723 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _31723 + 68] = mem[idx + _31148 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_31723 + 68] = mem[_31723 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _31723 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _31430 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31430] = 26
                                        mem[_31430 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _32014 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _32014 + 68] = mem[idx + _31430 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_32014 + 68] = mem[_32014 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _32014 + -mem[64] + 100
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _25490 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_25490] = 30
                                    mem[_25490 + 32] = 'SafeMath: subtraction overflow'
                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                        idx = 32
                                        while idx < 30:
                                            mem[idx + mem[64] + 68] = mem[idx + _25490 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = 0
                                    require ext_code.size(sphereTokenAddress)
                                    call sphereTokenAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _27859 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27859] = 26
                                    mem[_27859 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not 0 / totalAllocPoint:
                                            _32017 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32017] = 26
                                            mem[_32017 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _32543 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _32543 + 68] = mem[idx + _32017 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_32543 + 68] = mem[_32543 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _32543 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _32285 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32285] = 26
                                        mem[_32285 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _32789 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _32789 + 68] = mem[idx + _32285 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_32789 + 68] = mem[_32789 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _32789 + -mem[64] + 100
                                    _30870 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30870] = 26
                                    mem[_30870 + 32] = 'SafeMath: division by zero'
                                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                        revert with 0, 'SafeMath: addition overflow'
                                    amountToBurn += 0 / totalAllocPoint / 20
                                    if not 0 / totalAllocPoint:
                                        _34296 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34296] = 26
                                        mem[_34296 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _34703 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _34703 + 68] = mem[idx + _34296 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_34703 + 68] = mem[_34703 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _34703 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _34494 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34494] = 26
                                    mem[_34494 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _34920 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _34920 + 68] = mem[idx + _34494 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_34920 + 68] = mem[_34920 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _34920 + -mem[64] + 100
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                if ext_call.return_data[0] >= ext_call.return_data[0]:
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = 0 / totalAllocPoint
                                        require ext_code.size(sphereTokenAddress)
                                        call sphereTokenAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        _25018 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25018] = 26
                                        mem[_25018 + 32] = 'SafeMath: division by zero'
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                            if not 0 / totalAllocPoint:
                                                _28799 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_28799] = 26
                                                mem[_28799 + 32] = 'SafeMath: division by zero'
                                                if ext_call.return_data[0]:
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                                    idx = idx + 1
                                                    continue 
                                                _29265 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _29265 + 68] = mem[idx + _28799 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_29265 + 68] = mem[_29265 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _29265 + -mem[64] + 100
                                            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _29026 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_29026] = 26
                                            mem[_29026 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _29470 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _29470 + 68] = mem[idx + _29026 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_29470 + 68] = mem[_29470 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _29470 + -mem[64] + 100
                                        _27854 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_27854] = 26
                                        mem[_27854 + 32] = 'SafeMath: division by zero'
                                        if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                            revert with 0, 'SafeMath: addition overflow'
                                        amountToBurn += 0 / totalAllocPoint / 20
                                        if not 0 / totalAllocPoint:
                                            _31145 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31145] = 26
                                            mem[_31145 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _31717 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _31717 + 68] = mem[idx + _31145 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_31717 + 68] = mem[_31717 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _31717 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _31428 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31428] = 26
                                        mem[_31428 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _32008 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _32008 + 68] = mem[idx + _31428 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_32008 + 68] = mem[_32008 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _32008 + -mem[64] + 100
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    if ext_call.return_data[0] >= ext_call.return_data[0]:
                                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        _25894 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25894] = 26
                                        mem[_25894 + 32] = 'SafeMath: division by zero'
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                            if not 0 / totalAllocPoint:
                                                _29659 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_29659] = 26
                                                mem[_29659 + 32] = 'SafeMath: division by zero'
                                                if ext_call.return_data[0]:
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                                    idx = idx + 1
                                                    continue 
                                                _30081 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _30081 + 68] = mem[idx + _29659 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_30081 + 68] = mem[_30081 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _30081 + -mem[64] + 100
                                            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _29860 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_29860] = 26
                                            mem[_29860 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _30325 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _30325 + 68] = mem[idx + _29860 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_30325 + 68] = mem[_30325 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _30325 + -mem[64] + 100
                                        _28797 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28797] = 26
                                        mem[_28797 + 32] = 'SafeMath: division by zero'
                                        if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                            revert with 0, 'SafeMath: addition overflow'
                                        amountToBurn += 0 / totalAllocPoint / 20
                                        if not 0 / totalAllocPoint:
                                            _32281 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32281] = 26
                                            mem[_32281 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _32771 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _32771 + 68] = mem[idx + _32281 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_32771 + 68] = mem[_32771 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _32771 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _32533 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32533] = 26
                                        mem[_32533 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _33004 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _33004 + 68] = mem[idx + _32533 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33004 + 68] = mem[_33004 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _33004 + -mem[64] + 100
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _26305 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26305] = 30
                                    mem[_26305 + 32] = 'SafeMath: subtraction overflow'
                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                        idx = 32
                                        while idx < 30:
                                            mem[idx + mem[64] + 68] = mem[idx + _26305 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = 0
                                    require ext_code.size(sphereTokenAddress)
                                    call sphereTokenAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _28798 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28798] = 26
                                    mem[_28798 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not 0 / totalAllocPoint:
                                            _33007 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33007] = 26
                                            mem[_33007 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _33461 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _33461 + 68] = mem[idx + _33007 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33461 + 68] = mem[_33461 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _33461 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _33232 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33232] = 26
                                        mem[_33232 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _33678 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _33678 + 68] = mem[idx + _33232 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33678 + 68] = mem[_33678 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _33678 + -mem[64] + 100
                                    _32007 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32007] = 26
                                    mem[_32007 + 32] = 'SafeMath: division by zero'
                                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                        revert with 0, 'SafeMath: addition overflow'
                                    amountToBurn += 0 / totalAllocPoint / 20
                                    if not 0 / totalAllocPoint:
                                        _35106 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35106] = 26
                                        mem[_35106 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _35424 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _35424 + 68] = mem[idx + _35106 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35424 + 68] = mem[_35424 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _35424 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _35269 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35269] = 26
                                    mem[_35269 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _35576 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _35576 + 68] = mem[idx + _35269 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35576 + 68] = mem[_35576 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _35576 + -mem[64] + 100
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _22529 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22529] = 30
                                mem[_22529 + 32] = 'SafeMath: subtraction overflow'
                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _22529 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[mem[64] + 4] = devAddress
                                mem[mem[64] + 36] = 0
                                require ext_code.size(sphereTokenAddress)
                                call sphereTokenAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args devAddress, 0
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = 0 / totalAllocPoint
                                    require ext_code.size(sphereTokenAddress)
                                    call sphereTokenAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _27857 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27857] = 26
                                    mem[_27857 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not 0 / totalAllocPoint:
                                            _32013 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32013] = 26
                                            mem[_32013 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _32537 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _32537 + 68] = mem[idx + _32013 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_32537 + 68] = mem[_32537 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _32537 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _32283 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32283] = 26
                                        mem[_32283 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _32781 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _32781 + 68] = mem[idx + _32283 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_32781 + 68] = mem[_32781 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _32781 + -mem[64] + 100
                                    _30867 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30867] = 26
                                    mem[_30867 + 32] = 'SafeMath: division by zero'
                                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                        revert with 0, 'SafeMath: addition overflow'
                                    amountToBurn += 0 / totalAllocPoint / 20
                                    if not 0 / totalAllocPoint:
                                        _34295 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34295] = 26
                                        mem[_34295 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _34700 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _34700 + 68] = mem[idx + _34295 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_34700 + 68] = mem[_34700 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _34700 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _34493 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34493] = 26
                                    mem[_34493 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _34917 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _34917 + 68] = mem[idx + _34493 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_34917 + 68] = mem[_34917 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _34917 + -mem[64] + 100
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                if ext_call.return_data[0] >= ext_call.return_data[0]:
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _28800 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28800] = 26
                                    mem[_28800 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not 0 / totalAllocPoint:
                                            _33011 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33011] = 26
                                            mem[_33011 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _33464 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _33464 + 68] = mem[idx + _33011 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33464 + 68] = mem[_33464 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _33464 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _33235 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33235] = 26
                                        mem[_33235 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _33683 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _33683 + 68] = mem[idx + _33235 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33683 + 68] = mem[_33683 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _33683 + -mem[64] + 100
                                    _32011 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32011] = 26
                                    mem[_32011 + 32] = 'SafeMath: division by zero'
                                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                        revert with 0, 'SafeMath: addition overflow'
                                    amountToBurn += 0 / totalAllocPoint / 20
                                    if not 0 / totalAllocPoint:
                                        _35107 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35107] = 26
                                        mem[_35107 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _35427 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _35427 + 68] = mem[idx + _35107 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35427 + 68] = mem[_35427 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _35427 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _35270 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35270] = 26
                                    mem[_35270 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _35579 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _35579 + 68] = mem[idx + _35270 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35579 + 68] = mem[_35579 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _35579 + -mem[64] + 100
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _29268 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29268] = 30
                                mem[_29268 + 32] = 'SafeMath: subtraction overflow'
                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _29268 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[mem[64] + 4] = this.address
                                mem[mem[64] + 36] = 0
                                require ext_code.size(sphereTokenAddress)
                                call sphereTokenAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _32012 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32012] = 26
                                mem[_32012 + 32] = 'SafeMath: division by zero'
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                    if not 0 / totalAllocPoint:
                                        _35582 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35582] = 26
                                        mem[_35582 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _35828 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _35828 + 68] = mem[idx + _35582 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35828 + 68] = mem[_35828 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _35828 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _35711 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35711] = 26
                                    mem[_35711 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _35942 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _35942 + 68] = mem[idx + _35711 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35942 + 68] = mem[_35942 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _35942 + -mem[64] + 100
                                _34916 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_34916] = 26
                                mem[_34916 + 32] = 'SafeMath: division by zero'
                                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                    revert with 0, 'SafeMath: addition overflow'
                                amountToBurn += 0 / totalAllocPoint / 20
                                if not 0 / totalAllocPoint:
                                    _36624 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_36624] = 26
                                    mem[_36624 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _36704 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _36704 + 68] = mem[idx + _36624 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36704 + 68] = mem[_36704 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _36704 + -mem[64] + 100
                                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _36670 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_36670] = 26
                                mem[_36670 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _36735 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _36735 + 68] = mem[idx + _36670 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_36735 + 68] = mem[_36735 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _36735 + -mem[64] + 100
                            _19273 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19273] = 30
                            mem[_19273 + 32] = 'SafeMath: subtraction overflow'
                            if poolInfo[idx].field_512 > block.number:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                idx = 32
                                while idx < 30:
                                    mem[idx + mem[64] + 68] = mem[idx + _19273 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not block.number - poolInfo[idx].field_512:
                                _19654 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19654] = 26
                                mem[_19654 + 32] = 'SafeMath: division by zero'
                                if not totalAllocPoint:
                                    _19745 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _19745 + 68] = mem[idx + _19654 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19745 + 68] = mem[_19745 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _19745 + -mem[64] + 100
                                _19888 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19888] = 26
                                mem[_19888 + 32] = 'SafeMath: division by zero'
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                    mem[mem[64] + 4] = devAddress
                                    mem[mem[64] + 36] = 0 / totalAllocPoint / 20
                                    require ext_code.size(sphereTokenAddress)
                                    call sphereTokenAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devAddress, 0 / totalAllocPoint / 20
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = 0 / totalAllocPoint
                                        require ext_code.size(sphereTokenAddress)
                                        call sphereTokenAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        _25015 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25015] = 26
                                        mem[_25015 + 32] = 'SafeMath: division by zero'
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                            if not 0 / totalAllocPoint:
                                                _28796 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_28796] = 26
                                                mem[_28796 + 32] = 'SafeMath: division by zero'
                                                if ext_call.return_data[0]:
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                                    idx = idx + 1
                                                    continue 
                                                _29262 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _29262 + 68] = mem[idx + _28796 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_29262 + 68] = mem[_29262 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _29262 + -mem[64] + 100
                                            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _29025 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_29025] = 26
                                            mem[_29025 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _29463 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _29463 + 68] = mem[idx + _29025 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_29463 + 68] = mem[_29463 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _29463 + -mem[64] + 100
                                        _27850 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_27850] = 26
                                        mem[_27850 + 32] = 'SafeMath: division by zero'
                                        if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                            revert with 0, 'SafeMath: addition overflow'
                                        amountToBurn += 0 / totalAllocPoint / 20
                                        if not 0 / totalAllocPoint:
                                            _31139 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31139] = 26
                                            mem[_31139 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _31712 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _31712 + 68] = mem[idx + _31139 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_31712 + 68] = mem[_31712 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _31712 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _31424 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31424] = 26
                                        mem[_31424 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _32002 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _32002 + 68] = mem[idx + _31424 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_32002 + 68] = mem[_32002 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _32002 + -mem[64] + 100
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    if ext_call.return_data[0] >= ext_call.return_data[0]:
                                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        _25892 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25892] = 26
                                        mem[_25892 + 32] = 'SafeMath: division by zero'
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                            if not 0 / totalAllocPoint:
                                                _29657 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_29657] = 26
                                                mem[_29657 + 32] = 'SafeMath: division by zero'
                                                if ext_call.return_data[0]:
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                                    idx = idx + 1
                                                    continue 
                                                _30075 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _30075 + 68] = mem[idx + _29657 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_30075 + 68] = mem[_30075 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _30075 + -mem[64] + 100
                                            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _29854 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_29854] = 26
                                            mem[_29854 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _30316 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _30316 + 68] = mem[idx + _29854 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_30316 + 68] = mem[_30316 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _30316 + -mem[64] + 100
                                        _28794 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28794] = 26
                                        mem[_28794 + 32] = 'SafeMath: division by zero'
                                        if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                            revert with 0, 'SafeMath: addition overflow'
                                        amountToBurn += 0 / totalAllocPoint / 20
                                        if not 0 / totalAllocPoint:
                                            _32279 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32279] = 26
                                            mem[_32279 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _32763 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _32763 + 68] = mem[idx + _32279 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_32763 + 68] = mem[_32763 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _32763 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _32529 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32529] = 26
                                        mem[_32529 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _32997 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _32997 + 68] = mem[idx + _32529 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_32997 + 68] = mem[_32997 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _32997 + -mem[64] + 100
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _26304 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26304] = 30
                                    mem[_26304 + 32] = 'SafeMath: subtraction overflow'
                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                        idx = 32
                                        while idx < 30:
                                            mem[idx + mem[64] + 68] = mem[idx + _26304 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = 0
                                    require ext_code.size(sphereTokenAddress)
                                    call sphereTokenAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _28795 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28795] = 26
                                    mem[_28795 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not 0 / totalAllocPoint:
                                            _33000 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33000] = 26
                                            mem[_33000 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _33455 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _33455 + 68] = mem[idx + _33000 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33455 + 68] = mem[_33455 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _33455 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _33228 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33228] = 26
                                        mem[_33228 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _33670 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _33670 + 68] = mem[idx + _33228 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33670 + 68] = mem[_33670 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _33670 + -mem[64] + 100
                                    _32001 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32001] = 26
                                    mem[_32001 + 32] = 'SafeMath: division by zero'
                                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                        revert with 0, 'SafeMath: addition overflow'
                                    amountToBurn += 0 / totalAllocPoint / 20
                                    if not 0 / totalAllocPoint:
                                        _35105 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35105] = 26
                                        mem[_35105 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _35421 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _35421 + 68] = mem[idx + _35105 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35421 + 68] = mem[_35421 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _35421 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _35268 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35268] = 26
                                    mem[_35268 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _35573 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _35573 + 68] = mem[idx + _35268 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35573 + 68] = mem[_35573 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _35573 + -mem[64] + 100
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                if ext_call.return_data[0] >= ext_call.return_data[0]:
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = 0 / totalAllocPoint
                                        require ext_code.size(sphereTokenAddress)
                                        call sphereTokenAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        _25890 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25890] = 26
                                        mem[_25890 + 32] = 'SafeMath: division by zero'
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                            if not 0 / totalAllocPoint:
                                                _29654 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_29654] = 26
                                                mem[_29654 + 32] = 'SafeMath: division by zero'
                                                if ext_call.return_data[0]:
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                                    idx = idx + 1
                                                    continue 
                                                _30071 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _30071 + 68] = mem[idx + _29654 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_30071 + 68] = mem[_30071 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _30071 + -mem[64] + 100
                                            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _29850 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_29850] = 26
                                            mem[_29850 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _30310 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _30310 + 68] = mem[idx + _29850 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_30310 + 68] = mem[_30310 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _30310 + -mem[64] + 100
                                        _28790 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28790] = 26
                                        mem[_28790 + 32] = 'SafeMath: division by zero'
                                        if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                            revert with 0, 'SafeMath: addition overflow'
                                        amountToBurn += 0 / totalAllocPoint / 20
                                        if not 0 / totalAllocPoint:
                                            _32276 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32276] = 26
                                            mem[_32276 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _32757 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _32757 + 68] = mem[idx + _32276 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_32757 + 68] = mem[_32757 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _32757 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _32527 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32527] = 26
                                        mem[_32527 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _32991 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _32991 + 68] = mem[idx + _32527 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_32991 + 68] = mem[_32991 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _32991 + -mem[64] + 100
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    if ext_call.return_data[0] >= ext_call.return_data[0]:
                                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        _26623 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26623] = 26
                                        mem[_26623 + 32] = 'SafeMath: division by zero'
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                            if not 0 / totalAllocPoint:
                                                _30574 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_30574] = 26
                                                mem[_30574 + 32] = 'SafeMath: division by zero'
                                                if ext_call.return_data[0]:
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                                    idx = idx + 1
                                                    continue 
                                                _31122 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _31122 + 68] = mem[idx + _30574 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_31122 + 68] = mem[_31122 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _31122 + -mem[64] + 100
                                            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _30845 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_30845] = 26
                                            mem[_30845 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _31409 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _31409 + 68] = mem[idx + _30845 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_31409 + 68] = mem[_31409 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _31409 + -mem[64] + 100
                                        _29652 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29652] = 26
                                        mem[_29652 + 32] = 'SafeMath: division by zero'
                                        if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                            revert with 0, 'SafeMath: addition overflow'
                                        amountToBurn += 0 / totalAllocPoint / 20
                                        if not 0 / totalAllocPoint:
                                            _33224 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33224] = 26
                                            mem[_33224 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _33652 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _33652 + 68] = mem[idx + _33224 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33652 + 68] = mem[_33652 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _33652 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _33445 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33445] = 26
                                        mem[_33445 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _33878 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _33878 + 68] = mem[idx + _33445 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33878 + 68] = mem[_33878 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _33878 + -mem[64] + 100
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _27032 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27032] = 30
                                    mem[_27032 + 32] = 'SafeMath: subtraction overflow'
                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                        idx = 32
                                        while idx < 30:
                                            mem[idx + mem[64] + 68] = mem[idx + _27032 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = 0
                                    require ext_code.size(sphereTokenAddress)
                                    call sphereTokenAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _29653 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29653] = 26
                                    mem[_29653 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not 0 / totalAllocPoint:
                                            _33881 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33881] = 26
                                            mem[_33881 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _34275 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _34275 + 68] = mem[idx + _33881 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_34275 + 68] = mem[_34275 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _34275 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _34081 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34081] = 26
                                        mem[_34081 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _34470 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _34470 + 68] = mem[idx + _34081 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_34470 + 68] = mem[_34470 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _34470 + -mem[64] + 100
                                    _32990 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32990] = 26
                                    mem[_32990 + 32] = 'SafeMath: division by zero'
                                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                        revert with 0, 'SafeMath: addition overflow'
                                    amountToBurn += 0 / totalAllocPoint / 20
                                    if not 0 / totalAllocPoint:
                                        _35705 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35705] = 26
                                        mem[_35705 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _35922 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _35922 + 68] = mem[idx + _35705 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35922 + 68] = mem[_35922 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _35922 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _35814 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35814] = 26
                                    mem[_35814 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _36050 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _36050 + 68] = mem[idx + _35814 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36050 + 68] = mem[_36050 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _36050 + -mem[64] + 100
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _23153 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23153] = 30
                                mem[_23153 + 32] = 'SafeMath: subtraction overflow'
                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _23153 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[mem[64] + 4] = devAddress
                                mem[mem[64] + 36] = 0
                                require ext_code.size(sphereTokenAddress)
                                call sphereTokenAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args devAddress, 0
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = 0 / totalAllocPoint
                                    require ext_code.size(sphereTokenAddress)
                                    call sphereTokenAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _28793 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28793] = 26
                                    mem[_28793 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not 0 / totalAllocPoint:
                                            _32996 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32996] = 26
                                            mem[_32996 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _33449 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _33449 + 68] = mem[idx + _32996 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33449 + 68] = mem[_33449 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _33449 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _33226 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33226] = 26
                                        mem[_33226 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _33662 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _33662 + 68] = mem[idx + _33226 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33662 + 68] = mem[_33662 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _33662 + -mem[64] + 100
                                    _31998 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31998] = 26
                                    mem[_31998 + 32] = 'SafeMath: division by zero'
                                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                        revert with 0, 'SafeMath: addition overflow'
                                    amountToBurn += 0 / totalAllocPoint / 20
                                    if not 0 / totalAllocPoint:
                                        _35104 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35104] = 26
                                        mem[_35104 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _35418 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _35418 + 68] = mem[idx + _35104 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35418 + 68] = mem[_35418 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _35418 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _35267 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35267] = 26
                                    mem[_35267 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _35570 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _35570 + 68] = mem[idx + _35267 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35570 + 68] = mem[_35570 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _35570 + -mem[64] + 100
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                if ext_call.return_data[0] >= ext_call.return_data[0]:
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _29655 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29655] = 26
                                    mem[_29655 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not 0 / totalAllocPoint:
                                            _33885 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33885] = 26
                                            mem[_33885 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _34278 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _34278 + 68] = mem[idx + _33885 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_34278 + 68] = mem[_34278 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _34278 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _34084 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34084] = 26
                                        mem[_34084 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _34475 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _34475 + 68] = mem[idx + _34084 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_34475 + 68] = mem[_34475 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _34475 + -mem[64] + 100
                                    _32994 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32994] = 26
                                    mem[_32994 + 32] = 'SafeMath: division by zero'
                                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                        revert with 0, 'SafeMath: addition overflow'
                                    amountToBurn += 0 / totalAllocPoint / 20
                                    if not 0 / totalAllocPoint:
                                        _35706 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35706] = 26
                                        mem[_35706 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _35925 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _35925 + 68] = mem[idx + _35706 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35925 + 68] = mem[_35925 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _35925 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _35815 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35815] = 26
                                    mem[_35815 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _36053 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _36053 + 68] = mem[idx + _35815 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36053 + 68] = mem[_36053 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _36053 + -mem[64] + 100
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _30074 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_30074] = 30
                                mem[_30074 + 32] = 'SafeMath: subtraction overflow'
                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _30074 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[mem[64] + 4] = this.address
                                mem[mem[64] + 36] = 0
                                require ext_code.size(sphereTokenAddress)
                                call sphereTokenAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _32995 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32995] = 26
                                mem[_32995 + 32] = 'SafeMath: division by zero'
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                    if not 0 / totalAllocPoint:
                                        _36056 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_36056] = 26
                                        mem[_36056 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _36293 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _36293 + 68] = mem[idx + _36056 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_36293 + 68] = mem[_36293 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _36293 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _36182 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_36182] = 26
                                    mem[_36182 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _36383 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _36383 + 68] = mem[idx + _36182 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36383 + 68] = mem[_36383 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _36383 + -mem[64] + 100
                                _35569 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35569] = 26
                                mem[_35569 + 32] = 'SafeMath: division by zero'
                                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                    revert with 0, 'SafeMath: addition overflow'
                                amountToBurn += 0 / totalAllocPoint / 20
                                if not 0 / totalAllocPoint:
                                    _36758 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_36758] = 26
                                    mem[_36758 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _36797 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _36797 + 68] = mem[idx + _36758 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36797 + 68] = mem[_36797 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _36797 + -mem[64] + 100
                                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _36776 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_36776] = 26
                                mem[_36776 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _36825 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _36825 + 68] = mem[idx + _36776 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_36825 + 68] = mem[_36825 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _36825 + -mem[64] + 100
                            if (block.number * spherePerBlock) - (poolInfo[idx].field_512 * spherePerBlock) / block.number - poolInfo[idx].field_512 != spherePerBlock:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not (block.number * spherePerBlock) - (poolInfo[idx].field_512 * spherePerBlock):
                                _19702 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19702] = 26
                                mem[_19702 + 32] = 'SafeMath: division by zero'
                                if not totalAllocPoint:
                                    _19782 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _19782 + 68] = mem[idx + _19702 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19782 + 68] = mem[_19782 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _19782 + -mem[64] + 100
                                _19940 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19940] = 26
                                mem[_19940 + 32] = 'SafeMath: division by zero'
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                    mem[mem[64] + 4] = devAddress
                                    mem[mem[64] + 36] = 0 / totalAllocPoint / 20
                                    require ext_code.size(sphereTokenAddress)
                                    call sphereTokenAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devAddress, 0 / totalAllocPoint / 20
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = 0 / totalAllocPoint
                                        require ext_code.size(sphereTokenAddress)
                                        call sphereTokenAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        _25260 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25260] = 26
                                        mem[_25260 + 32] = 'SafeMath: division by zero'
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                            if not 0 / totalAllocPoint:
                                                _29021 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_29021] = 26
                                                mem[_29021 + 32] = 'SafeMath: division by zero'
                                                if ext_call.return_data[0]:
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                                    idx = idx + 1
                                                    continue 
                                                _29454 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _29454 + 68] = mem[idx + _29021 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_29454 + 68] = mem[_29454 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _29454 + -mem[64] + 100
                                            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _29256 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_29256] = 26
                                            mem[_29256 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _29647 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _29647 + 68] = mem[idx + _29256 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_29647 + 68] = mem[_29647 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _29647 + -mem[64] + 100
                                        _28113 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28113] = 26
                                        mem[_28113 + 32] = 'SafeMath: division by zero'
                                        if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                            revert with 0, 'SafeMath: addition overflow'
                                        amountToBurn += 0 / totalAllocPoint / 20
                                        if not 0 / totalAllocPoint:
                                            _31408 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31408] = 26
                                            mem[_31408 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _31987 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _31987 + 68] = mem[idx + _31408 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_31987 + 68] = mem[_31987 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _31987 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _31702 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31702] = 26
                                        mem[_31702 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _32268 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _32268 + 68] = mem[idx + _31702 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_32268 + 68] = mem[_32268 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _32268 + -mem[64] + 100
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    if ext_call.return_data[0] >= ext_call.return_data[0]:
                                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        _26104 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26104] = 26
                                        mem[_26104 + 32] = 'SafeMath: division by zero'
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                            if not 0 / totalAllocPoint:
                                                _29848 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_29848] = 26
                                                mem[_29848 + 32] = 'SafeMath: division by zero'
                                                if ext_call.return_data[0]:
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                                    idx = idx + 1
                                                    continue 
                                                _30302 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _30302 + 68] = mem[idx + _29848 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_30302 + 68] = mem[_30302 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _30302 + -mem[64] + 100
                                            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _30065 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_30065] = 26
                                            mem[_30065 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _30565 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _30565 + 68] = mem[idx + _30065 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_30565 + 68] = mem[_30565 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _30565 + -mem[64] + 100
                                        _29019 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29019] = 26
                                        mem[_29019 + 32] = 'SafeMath: division by zero'
                                        if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                            revert with 0, 'SafeMath: addition overflow'
                                        amountToBurn += 0 / totalAllocPoint / 20
                                        if not 0 / totalAllocPoint:
                                            _32522 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32522] = 26
                                            mem[_32522 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _32980 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _32980 + 68] = mem[idx + _32522 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_32980 + 68] = mem[_32980 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _32980 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _32751 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32751] = 26
                                        mem[_32751 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _33217 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _33217 + 68] = mem[idx + _32751 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33217 + 68] = mem[_33217 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _33217 + -mem[64] + 100
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _26461 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26461] = 30
                                    mem[_26461 + 32] = 'SafeMath: subtraction overflow'
                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                        idx = 32
                                        while idx < 30:
                                            mem[idx + mem[64] + 68] = mem[idx + _26461 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = 0
                                    require ext_code.size(sphereTokenAddress)
                                    call sphereTokenAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _29020 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29020] = 26
                                    mem[_29020 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not 0 / totalAllocPoint:
                                            _33220 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33220] = 26
                                            mem[_33220 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _33649 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _33649 + 68] = mem[idx + _33220 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33649 + 68] = mem[_33649 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _33649 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _33442 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33442] = 26
                                        mem[_33442 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _33873 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _33873 + 68] = mem[idx + _33442 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33873 + 68] = mem[_33873 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _33873 + -mem[64] + 100
                                    _32267 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32267] = 26
                                    mem[_32267 + 32] = 'SafeMath: division by zero'
                                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                        revert with 0, 'SafeMath: addition overflow'
                                    amountToBurn += 0 / totalAllocPoint / 20
                                    if not 0 / totalAllocPoint:
                                        _35260 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35260] = 26
                                        mem[_35260 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _35562 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _35562 + 68] = mem[idx + _35260 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35562 + 68] = mem[_35562 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _35562 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _35413 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35413] = 26
                                    mem[_35413 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _35702 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _35702 + 68] = mem[idx + _35413 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35702 + 68] = mem[_35702 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _35702 + -mem[64] + 100
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                if ext_call.return_data[0] >= ext_call.return_data[0]:
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = 0 / totalAllocPoint
                                        require ext_code.size(sphereTokenAddress)
                                        call sphereTokenAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        _26102 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26102] = 26
                                        mem[_26102 + 32] = 'SafeMath: division by zero'
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                            if not 0 / totalAllocPoint:
                                                _29845 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_29845] = 26
                                                mem[_29845 + 32] = 'SafeMath: division by zero'
                                                if ext_call.return_data[0]:
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                                    idx = idx + 1
                                                    continue 
                                                _30298 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _30298 + 68] = mem[idx + _29845 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_30298 + 68] = mem[_30298 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _30298 + -mem[64] + 100
                                            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _30061 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_30061] = 26
                                            mem[_30061 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _30559 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _30559 + 68] = mem[idx + _30061 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_30559 + 68] = mem[_30559 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _30559 + -mem[64] + 100
                                        _29015 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29015] = 26
                                        mem[_29015 + 32] = 'SafeMath: division by zero'
                                        if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                            revert with 0, 'SafeMath: addition overflow'
                                        amountToBurn += 0 / totalAllocPoint / 20
                                        if not 0 / totalAllocPoint:
                                            _32519 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32519] = 26
                                            mem[_32519 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _32974 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _32974 + 68] = mem[idx + _32519 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_32974 + 68] = mem[_32974 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _32974 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _32749 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32749] = 26
                                        mem[_32749 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _33211 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _33211 + 68] = mem[idx + _32749 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33211 + 68] = mem[_33211 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _33211 + -mem[64] + 100
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    if ext_call.return_data[0] >= ext_call.return_data[0]:
                                        staticcall sphereTokenAddress.0xd5abeb01 with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        _26805 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26805] = 26
                                        mem[_26805 + 32] = 'SafeMath: division by zero'
                                        require ext_code.size(sphereTokenAddress)
                                        staticcall sphereTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                            if not 0 / totalAllocPoint:
                                                _30835 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_30835] = 26
                                                mem[_30835 + 32] = 'SafeMath: division by zero'
                                                if ext_call.return_data[0]:
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                                    idx = idx + 1
                                                    continue 
                                                _31391 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _31391 + 68] = mem[idx + _30835 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_31391 + 68] = mem[_31391 + 74 len 26]
                                                revert with memory
                                                  from mem[64]
                                                   len _31391 + -mem[64] + 100
                                            if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _31108 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31108] = 26
                                            mem[_31108 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _31687 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _31687 + 68] = mem[idx + _31108 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_31687 + 68] = mem[_31687 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _31687 + -mem[64] + 100
                                        _29843 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29843] = 26
                                        mem[_29843 + 32] = 'SafeMath: division by zero'
                                        if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                            revert with 0, 'SafeMath: addition overflow'
                                        amountToBurn += 0 / totalAllocPoint / 20
                                        if not 0 / totalAllocPoint:
                                            _33438 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33438] = 26
                                            mem[_33438 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _33855 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _33855 + 68] = mem[idx + _33438 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33855 + 68] = mem[_33855 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _33855 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _33639 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33639] = 26
                                        mem[_33639 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _34067 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _34067 + 68] = mem[idx + _33639 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_34067 + 68] = mem[_34067 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _34067 + -mem[64] + 100
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _27278 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27278] = 30
                                    mem[_27278 + 32] = 'SafeMath: subtraction overflow'
                                    if ext_call.return_data[0] > ext_call.return_data[0]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                        idx = 32
                                        while idx < 30:
                                            mem[idx + mem[64] + 68] = mem[idx + _27278 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = 0
                                    require ext_code.size(sphereTokenAddress)
                                    call sphereTokenAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _29844 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29844] = 26
                                    mem[_29844 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not 0 / totalAllocPoint:
                                            _34070 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34070] = 26
                                            mem[_34070 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _34455 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _34455 + 68] = mem[idx + _34070 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_34455 + 68] = mem[_34455 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _34455 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _34258 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34258] = 26
                                        mem[_34258 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _34669 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _34669 + 68] = mem[idx + _34258 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_34669 + 68] = mem[_34669 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _34669 + -mem[64] + 100
                                    _33210 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33210] = 26
                                    mem[_33210 + 32] = 'SafeMath: division by zero'
                                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                        revert with 0, 'SafeMath: addition overflow'
                                    amountToBurn += 0 / totalAllocPoint / 20
                                    if not 0 / totalAllocPoint:
                                        _35810 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35810] = 26
                                        mem[_35810 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _36036 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _36036 + 68] = mem[idx + _35810 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_36036 + 68] = mem[_36036 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _36036 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _35914 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35914] = 26
                                    mem[_35914 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _36167 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _36167 + 68] = mem[idx + _35914 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36167 + 68] = mem[_36167 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _36167 + -mem[64] + 100
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _23319 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23319] = 30
                                mem[_23319 + 32] = 'SafeMath: subtraction overflow'
                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _23319 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[mem[64] + 4] = devAddress
                                mem[mem[64] + 36] = 0
                                require ext_code.size(sphereTokenAddress)
                                call sphereTokenAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args devAddress, 0
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if (0 / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (0 / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = 0 / totalAllocPoint
                                    require ext_code.size(sphereTokenAddress)
                                    call sphereTokenAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _29018 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29018] = 26
                                    mem[_29018 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not 0 / totalAllocPoint:
                                            _33216 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33216] = 26
                                            mem[_33216 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _33643 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _33643 + 68] = mem[idx + _33216 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33643 + 68] = mem[_33643 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _33643 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _33440 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33440] = 26
                                        mem[_33440 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _33865 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _33865 + 68] = mem[idx + _33440 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33865 + 68] = mem[_33865 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _33865 + -mem[64] + 100
                                    _32264 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32264] = 26
                                    mem[_32264 + 32] = 'SafeMath: division by zero'
                                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                        revert with 0, 'SafeMath: addition overflow'
                                    amountToBurn += 0 / totalAllocPoint / 20
                                    if not 0 / totalAllocPoint:
                                        _35259 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35259] = 26
                                        mem[_35259 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _35559 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _35559 + 68] = mem[idx + _35259 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_35559 + 68] = mem[_35559 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _35559 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _35412 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35412] = 26
                                    mem[_35412 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _35699 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _35699 + 68] = mem[idx + _35412 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35699 + 68] = mem[_35699 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _35699 + -mem[64] + 100
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                if ext_call.return_data[0] >= ext_call.return_data[0]:
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _29846 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29846] = 26
                                    mem[_29846 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not 0 / totalAllocPoint:
                                            _34074 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34074] = 26
                                            mem[_34074 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _34458 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _34458 + 68] = mem[idx + _34074 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_34458 + 68] = mem[_34458 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _34458 + -mem[64] + 100
                                        if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _34261 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34261] = 26
                                        mem[_34261 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _34674 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _34674 + 68] = mem[idx + _34261 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_34674 + 68] = mem[_34674 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _34674 + -mem[64] + 100
                                    _33214 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33214] = 26
                                    mem[_33214 + 32] = 'SafeMath: division by zero'
                                    if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                        revert with 0, 'SafeMath: addition overflow'
                                    amountToBurn += 0 / totalAllocPoint / 20
                                    if not 0 / totalAllocPoint:
                                        _35811 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35811] = 26
                                        mem[_35811 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _36039 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _36039 + 68] = mem[idx + _35811 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_36039 + 68] = mem[_36039 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _36039 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _35915 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35915] = 26
                                    mem[_35915 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _36170 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _36170 + 68] = mem[idx + _35915 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36170 + 68] = mem[_36170 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _36170 + -mem[64] + 100
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _30301 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_30301] = 30
                                mem[_30301 + 32] = 'SafeMath: subtraction overflow'
                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _30301 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[mem[64] + 4] = this.address
                                mem[mem[64] + 36] = 0
                                require ext_code.size(sphereTokenAddress)
                                call sphereTokenAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _33215 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33215] = 26
                                mem[_33215 + 32] = 'SafeMath: division by zero'
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (0 / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                    if not 0 / totalAllocPoint:
                                        _36173 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_36173] = 26
                                        mem[_36173 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _36374 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _36374 + 68] = mem[idx + _36173 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_36374 + 68] = mem[_36374 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _36374 + -mem[64] + 100
                                    if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _36282 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_36282] = 26
                                    mem[_36282 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _36465 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _36465 + 68] = mem[idx + _36282 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36465 + 68] = mem[_36465 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _36465 + -mem[64] + 100
                                _35698 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35698] = 26
                                mem[_35698 + 32] = 'SafeMath: division by zero'
                                if (0 / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                    revert with 0, 'SafeMath: addition overflow'
                                amountToBurn += 0 / totalAllocPoint / 20
                                if not 0 / totalAllocPoint:
                                    _36775 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_36775] = 26
                                    mem[_36775 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _36822 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _36822 + 68] = mem[idx + _36775 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36822 + 68] = mem[_36822 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _36822 + -mem[64] + 100
                                if 10^18 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _36796 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_36796] = 26
                                mem[_36796 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (10^18 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 10^18 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _36853 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _36853 + 68] = mem[idx + _36796 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_36853 + 68] = mem[_36853 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _36853 + -mem[64] + 100
                            if (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / (block.number * spherePerBlock) - (poolInfo[idx].field_512 * spherePerBlock) != poolInfo[idx].field_256:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _19744 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19744] = 26
                            mem[_19744 + 32] = 'SafeMath: division by zero'
                            if not totalAllocPoint:
                                _19811 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _19811 + 68] = mem[idx + _19744 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19811 + 68] = mem[_19811 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _19811 + -mem[64] + 100
                            _19990 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19990] = 26
                            mem[_19990 + 32] = 'SafeMath: division by zero'
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                revert with 0, 'SafeMath: addition overflow'
                            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                mem[mem[64] + 4] = devAddress
                                mem[mem[64] + 36] = (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
                                require ext_code.size(sphereTokenAddress)
                                call sphereTokenAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args devAddress, (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                    require ext_code.size(sphereTokenAddress)
                                    call sphereTokenAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _25473 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_25473] = 26
                                    mem[_25473 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                            _29252 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_29252] = 26
                                            mem[_29252 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _29638 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _29638 + 68] = mem[idx + _29252 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_29638 + 68] = mem[_29638 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _29638 + -mem[64] + 100
                                        if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _29448 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29448] = 26
                                        mem[_29448 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _29838 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _29838 + 68] = mem[idx + _29448 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_29838 + 68] = mem[_29838 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _29838 + -mem[64] + 100
                                    _28353 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28353] = 26
                                    mem[_28353 + 32] = 'SafeMath: division by zero'
                                    if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                        revert with 0, 'SafeMath: addition overflow'
                                    amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
                                    if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                        _31686 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31686] = 26
                                        mem[_31686 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _32253 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _32253 + 68] = mem[idx + _31686 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_32253 + 68] = mem[_32253 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _32253 + -mem[64] + 100
                                    if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _31977 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31977] = 26
                                    mem[_31977 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _32511 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _32511 + 68] = mem[idx + _31977 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_32511 + 68] = mem[_32511 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _32511 + -mem[64] + 100
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                if ext_call.return_data[0] >= ext_call.return_data[0]:
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _26293 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26293] = 26
                                    mem[_26293 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                            _30059 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_30059] = 26
                                            mem[_30059 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _30551 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _30551 + 68] = mem[idx + _30059 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_30551 + 68] = mem[_30551 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _30551 + -mem[64] + 100
                                        if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _30292 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30292] = 26
                                        mem[_30292 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _30826 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _30826 + 68] = mem[idx + _30292 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_30826 + 68] = mem[_30826 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _30826 + -mem[64] + 100
                                    _29250 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29250] = 26
                                    mem[_29250 + 32] = 'SafeMath: division by zero'
                                    if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                        revert with 0, 'SafeMath: addition overflow'
                                    amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
                                    if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                        _32744 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32744] = 26
                                        mem[_32744 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _33200 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _33200 + 68] = mem[idx + _32744 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33200 + 68] = mem[_33200 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _33200 + -mem[64] + 100
                                    if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _32968 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32968] = 26
                                    mem[_32968 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _33431 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _33431 + 68] = mem[idx + _32968 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33431 + 68] = mem[_33431 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _33431 + -mem[64] + 100
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _26618 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26618] = 30
                                mem[_26618 + 32] = 'SafeMath: subtraction overflow'
                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _26618 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[mem[64] + 4] = this.address
                                mem[mem[64] + 36] = 0
                                require ext_code.size(sphereTokenAddress)
                                call sphereTokenAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _29251 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29251] = 26
                                mem[_29251 + 32] = 'SafeMath: division by zero'
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                    if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                        _33434 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33434] = 26
                                        mem[_33434 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _33852 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _33852 + 68] = mem[idx + _33434 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33852 + 68] = mem[_33852 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _33852 + -mem[64] + 100
                                    if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _33636 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33636] = 26
                                    mem[_33636 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _34062 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _34062 + 68] = mem[idx + _33636 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_34062 + 68] = mem[_34062 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _34062 + -mem[64] + 100
                                _32510 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32510] = 26
                                mem[_32510 + 32] = 'SafeMath: division by zero'
                                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                    revert with 0, 'SafeMath: addition overflow'
                                amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
                                if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                    _35405 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35405] = 26
                                    mem[_35405 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _35691 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _35691 + 68] = mem[idx + _35405 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35691 + 68] = mem[_35691 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _35691 + -mem[64] + 100
                                if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _35554 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35554] = 26
                                mem[_35554 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _35807 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _35807 + 68] = mem[idx + _35554 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35807 + 68] = mem[_35807 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _35807 + -mem[64] + 100
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            if ext_call.return_data[0] >= ext_call.return_data[0]:
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                    require ext_code.size(sphereTokenAddress)
                                    call sphereTokenAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _26291 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26291] = 26
                                    mem[_26291 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                            _30056 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_30056] = 26
                                            mem[_30056 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _30547 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _30547 + 68] = mem[idx + _30056 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_30547 + 68] = mem[_30547 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _30547 + -mem[64] + 100
                                        if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _30288 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30288] = 26
                                        mem[_30288 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _30820 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _30820 + 68] = mem[idx + _30288 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_30820 + 68] = mem[_30820 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _30820 + -mem[64] + 100
                                    _29246 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29246] = 26
                                    mem[_29246 + 32] = 'SafeMath: division by zero'
                                    if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                        revert with 0, 'SafeMath: addition overflow'
                                    amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
                                    if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                        _32741 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32741] = 26
                                        mem[_32741 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _33194 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _33194 + 68] = mem[idx + _32741 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33194 + 68] = mem[_33194 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _33194 + -mem[64] + 100
                                    if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _32966 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32966] = 26
                                    mem[_32966 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _33425 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _33425 + 68] = mem[idx + _32966 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33425 + 68] = mem[_33425 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _33425 + -mem[64] + 100
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                if ext_call.return_data[0] >= ext_call.return_data[0]:
                                    staticcall sphereTokenAddress.0xd5abeb01 with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _27016 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27016] = 26
                                    mem[_27016 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(sphereTokenAddress)
                                    staticcall sphereTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                        if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                            _31098 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31098] = 26
                                            mem[_31098 + 32] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                            _31669 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _31669 + 68] = mem[idx + _31098 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_31669 + 68] = mem[_31669 + 74 len 26]
                                            revert with memory
                                              from mem[64]
                                               len _31669 + -mem[64] + 100
                                        if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _31377 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31377] = 26
                                        mem[_31377 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _31962 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _31962 + 68] = mem[idx + _31377 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_31962 + 68] = mem[_31962 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _31962 + -mem[64] + 100
                                    _30054 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30054] = 26
                                    mem[_30054 + 32] = 'SafeMath: division by zero'
                                    if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                        revert with 0, 'SafeMath: addition overflow'
                                    amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
                                    if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                        _33632 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33632] = 26
                                        mem[_33632 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _34044 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _34044 + 68] = mem[idx + _33632 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_34044 + 68] = mem[_34044 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _34044 + -mem[64] + 100
                                    if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _33842 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33842] = 26
                                    mem[_33842 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _34244 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _34244 + 68] = mem[idx + _33842 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_34244 + 68] = mem[_34244 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _34244 + -mem[64] + 100
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _27545 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27545] = 30
                                mem[_27545 + 32] = 'SafeMath: subtraction overflow'
                                if ext_call.return_data[0] > ext_call.return_data[0]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                    idx = 32
                                    while idx < 30:
                                        mem[idx + mem[64] + 68] = mem[idx + _27545 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[mem[64] + 4] = this.address
                                mem[mem[64] + 36] = 0
                                require ext_code.size(sphereTokenAddress)
                                call sphereTokenAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _30055 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_30055] = 26
                                mem[_30055 + 32] = 'SafeMath: division by zero'
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                    if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                        _34247 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34247] = 26
                                        mem[_34247 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _34654 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _34654 + 68] = mem[idx + _34247 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_34654 + 68] = mem[_34654 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _34654 + -mem[64] + 100
                                    if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _34438 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34438] = 26
                                    mem[_34438 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _34873 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _34873 + 68] = mem[idx + _34438 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_34873 + 68] = mem[_34873 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _34873 + -mem[64] + 100
                                _33424 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33424] = 26
                                mem[_33424 + 32] = 'SafeMath: division by zero'
                                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                    revert with 0, 'SafeMath: addition overflow'
                                amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
                                if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                    _35910 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35910] = 26
                                    mem[_35910 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _36153 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _36153 + 68] = mem[idx + _35910 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36153 + 68] = mem[_36153 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _36153 + -mem[64] + 100
                                if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _36028 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_36028] = 26
                                mem[_36028 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _36267 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _36267 + 68] = mem[idx + _36028 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_36267 + 68] = mem[_36267 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _36267 + -mem[64] + 100
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            _23494 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23494] = 30
                            mem[_23494 + 32] = 'SafeMath: subtraction overflow'
                            if ext_call.return_data[0] > ext_call.return_data[0]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                idx = 32
                                while idx < 30:
                                    mem[idx + mem[64] + 68] = mem[idx + _23494 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: subtraction overflow'
                            mem[mem[64] + 4] = devAddress
                            mem[mem[64] + 36] = 0
                            require ext_code.size(sphereTokenAddress)
                            call sphereTokenAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devAddress, 0
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint) + ext_call.return_data[0] < ext_call.return_data[0]:
                                revert with 0, 'SafeMath: addition overflow'
                            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint) + ext_call.return_data[0] <= ext_call.return_data[0]:
                                mem[mem[64] + 4] = this.address
                                mem[mem[64] + 36] = (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                require ext_code.size(sphereTokenAddress)
                                call sphereTokenAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _29249 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29249] = 26
                                mem[_29249 + 32] = 'SafeMath: division by zero'
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                    if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                        _33430 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33430] = 26
                                        mem[_33430 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _33846 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _33846 + 68] = mem[idx + _33430 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33846 + 68] = mem[_33846 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _33846 + -mem[64] + 100
                                    if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _33634 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33634] = 26
                                    mem[_33634 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _34054 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _34054 + 68] = mem[idx + _33634 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_34054 + 68] = mem[_34054 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _34054 + -mem[64] + 100
                                _32507 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32507] = 26
                                mem[_32507 + 32] = 'SafeMath: division by zero'
                                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                    revert with 0, 'SafeMath: addition overflow'
                                amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
                                if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                    _35404 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35404] = 26
                                    mem[_35404 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _35688 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _35688 + 68] = mem[idx + _35404 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_35688 + 68] = mem[_35688 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _35688 + -mem[64] + 100
                                if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _35553 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35553] = 26
                                mem[_35553 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _35804 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _35804 + 68] = mem[idx + _35553 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_35804 + 68] = mem[_35804 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _35804 + -mem[64] + 100
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            if ext_call.return_data[0] >= ext_call.return_data[0]:
                                staticcall sphereTokenAddress.0xd5abeb01 with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _30057 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_30057] = 26
                                mem[_30057 + 32] = 'SafeMath: division by zero'
                                require ext_code.size(sphereTokenAddress)
                                staticcall sphereTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                    if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                        _34251 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34251] = 26
                                        mem[_34251 + 32] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                        _34657 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _34657 + 68] = mem[idx + _34251 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_34657 + 68] = mem[_34657 + 74 len 26]
                                        revert with memory
                                          from mem[64]
                                           len _34657 + -mem[64] + 100
                                    if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _34441 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34441] = 26
                                    mem[_34441 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _34878 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _34878 + 68] = mem[idx + _34441 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_34878 + 68] = mem[_34878 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _34878 + -mem[64] + 100
                                _33428 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33428] = 26
                                mem[_33428 + 32] = 'SafeMath: division by zero'
                                if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                    revert with 0, 'SafeMath: addition overflow'
                                amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
                                if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                    _35911 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35911] = 26
                                    mem[_35911 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _36156 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _36156 + 68] = mem[idx + _35911 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36156 + 68] = mem[_36156 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _36156 + -mem[64] + 100
                                if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _36029 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_36029] = 26
                                mem[_36029 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _36270 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _36270 + 68] = mem[idx + _36029 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_36270 + 68] = mem[_36270 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _36270 + -mem[64] + 100
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            _30550 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_30550] = 30
                            mem[_30550 + 32] = 'SafeMath: subtraction overflow'
                            if ext_call.return_data[0] > ext_call.return_data[0]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                mem[mem[64] + 68] = 'SafeMath: subtraction overflow'
                                idx = 32
                                while idx < 30:
                                    mem[idx + mem[64] + 68] = mem[idx + _30550 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: subtraction overflow'
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0
                            require ext_code.size(sphereTokenAddress)
                            call sphereTokenAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args address(this.address), 0
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0xd5abeb01 with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            _33429 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_33429] = 26
                            mem[_33429 + 32] = 'SafeMath: division by zero'
                            require ext_code.size(sphereTokenAddress)
                            staticcall sphereTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] < ext_call.return_data[0]:
                                revert with 0, 'SafeMath: addition overflow'
                            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + ext_call.return_data[0] > ext_call.return_data[0]:
                                if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                    _36273 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_36273] = 26
                                    mem[_36273 + 32] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                    _36456 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _36456 + 68] = mem[idx + _36273 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36456 + 68] = mem[_36456 + 74 len 26]
                                    revert with memory
                                      from mem[64]
                                       len _36456 + -mem[64] + 100
                                if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _36363 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_36363] = 26
                                mem[_36363 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _36541 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _36541 + 68] = mem[idx + _36363 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_36541 + 68] = mem[_36541 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _36541 + -mem[64] + 100
                            _35803 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35803] = 26
                            mem[_35803 + 32] = 'SafeMath: division by zero'
                            if ((block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20) + amountToBurn < amountToBurn:
                                revert with 0, 'SafeMath: addition overflow'
                            amountToBurn += (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / 20
                            if not (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                                _36795 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_36795] = 26
                                mem[_36795 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _36850 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _36850 + 68] = mem[idx + _36795 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_36850 + 68] = mem[_36850 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _36850 + -mem[64] + 100
                            if 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _36821 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_36821] = 26
                            mem[_36821 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0]:
                                if (10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 10^18 * (block.number * spherePerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * spherePerBlock * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _36875 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _36875 + 68] = mem[idx + _36821 + 32]
                                idx = idx + 32
                                continue 
                            mem[_36875 + 68] = mem[_36875 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _36875 + -mem[64] + 100
                        if 10^14 * ext_call.return_data[0] / ext_call.return_data[0] >= 100 * topPrice:
                            _19143 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19143] = 26
                            mem[_19143 + 32] = 'SafeMath: division by zero'
                            if not maxEmissionRate / 100:
                                spherePerBlock = 0
                            else:
                                if maxEmissionRate / 100 / maxEmissionRate / 100 != 1:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                spherePerBlock = maxEmissionRate / 100
                        else:
                            if 10^14 * ext_call.return_data[0] / ext_call.return_data[0] <= 100 * bottomPrice:
                                _19148 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19148] = 26
                                mem[_19148 + 32] = 'SafeMath: division by zero'
                                if not maxEmissionRate / 100:
                                    spherePerBlock = 0
                                else:
                                    if 100 * maxEmissionRate / 100 / maxEmissionRate / 100 != 100:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    spherePerBlock = 100 * maxEmissionRate / 100
                            else:
                                if not 10^14 * ext_call.return_data[0] / ext_call.return_data[0]:
                                    _19157 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19157] = 26
                                    mem[_19157 + 32] = 'SafeMath: division by zero'
                                    if not 100 * topPrice:
                                        revert with 0, 'SafeMath: division by zero'
                                    require ext_code.size(0xd75dcd756844276df0330ff8f5a02c06c26a44e7)
                                    delegate 0xd75dcd756844276df0330ff8f5a02c06c26a44e7.reciprocal(int256 rg1) with:
                                         gas gas_remaining wei
                                        args curveRate
                                    if not delegate.return_code:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _19270 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19270] = 30
                                    mem[_19270 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / 100 * topPrice > 100:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(0xd75dcd756844276df0330ff8f5a02c06c26a44e7)
                                    delegate 0xd75dcd756844276df0330ff8f5a02c06c26a44e7.multiply(int256 rg1, int256 rg2) with:
                                         gas gas_remaining wei
                                        args delegate.return_data[0], -(0 / 100 * topPrice) + 100
                                    if not delegate.return_code:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(0xd75dcd756844276df0330ff8f5a02c06c26a44e7)
                                    delegate 0xd75dcd756844276df0330ff8f5a02c06c26a44e7.fromFixed(int256 rg1) with:
                                         gas gas_remaining wei
                                        args delegate.return_data[0]
                                    if not delegate.return_code:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(0xd75dcd756844276df0330ff8f5a02c06c26a44e7)
                                    delegate 0xd75dcd756844276df0330ff8f5a02c06c26a44e7.divide(int256 rg1, int256 rg2) with:
                                         gas gas_remaining wei
                                        args 100, 0 / 100 * topPrice
                                    if not delegate.return_code:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(0xd75dcd756844276df0330ff8f5a02c06c26a44e7)
                                    delegate 0xd75dcd756844276df0330ff8f5a02c06c26a44e7.fromFixed(int256 rg1) with:
                                         gas gas_remaining wei
                                        args delegate.return_data[0]
                                    if not delegate.return_code:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _19836 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19836] = 26
                                    mem[_19836 + 32] = 'SafeMath: division by zero'
                                else:
                                    if 100 * 10^14 * ext_call.return_data[0] / ext_call.return_data[0] / 10^14 * ext_call.return_data[0] / ext_call.return_data[0] != 100:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _19162 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19162] = 26
                                    mem[_19162 + 32] = 'SafeMath: division by zero'
                                    if not 100 * topPrice:
                                        revert with 0, 'SafeMath: division by zero'
                                    require ext_code.size(0xd75dcd756844276df0330ff8f5a02c06c26a44e7)
                                    delegate 0xd75dcd756844276df0330ff8f5a02c06c26a44e7.reciprocal(int256 rg1) with:
                                         gas gas_remaining wei
                                        args curveRate
                                    if not delegate.return_code:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _19283 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19283] = 30
                                    mem[_19283 + 32] = 'SafeMath: subtraction overflow'
                                    if 100 * 10^14 * ext_call.return_data[0] / ext_call.return_data[0] / 100 * topPrice > 100:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(0xd75dcd756844276df0330ff8f5a02c06c26a44e7)
                                    delegate 0xd75dcd756844276df0330ff8f5a02c06c26a44e7.multiply(int256 rg1, int256 rg2) with:
                                         gas gas_remaining wei
                                        args delegate.return_data[0], -(100 * 10^14 * ext_call.return_data[0] / ext_call.return_data[0] / 100 * topPrice) + 100
                                    if not delegate.return_code:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(0xd75dcd756844276df0330ff8f5a02c06c26a44e7)
                                    delegate 0xd75dcd756844276df0330ff8f5a02c06c26a44e7.fromFixed(int256 rg1) with:
                                         gas gas_remaining wei
                                        args delegate.return_data[0]
                                    if not delegate.return_code:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(0xd75dcd756844276df0330ff8f5a02c06c26a44e7)
                                    delegate 0xd75dcd756844276df0330ff8f5a02c06c26a44e7.divide(int256 rg1, int256 rg2) with:
                                         gas gas_remaining wei
                                        args 100, 100 * 10^14 * ext_call.return_data[0] / ext_call.return_data[0] / 100 * topPrice
                                    if not delegate.return_code:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(0xd75dcd756844276df0330ff8f5a02c06c26a44e7)
                                    delegate 0xd75dcd756844276df0330ff8f5a02c06c26a44e7.fromFixed(int256 rg1) with:
                                         gas gas_remaining wei
                                        args delegate.return_data[0]
                                    if not delegate.return_code:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _19874 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19874] = 26
                                    mem[_19874 + 32] = 'SafeMath: division by zero'
                                if not maxEmissionRate / 100:
                                    spherePerBlock = 0
                                else:
                                    if (delegate.return_data[0] * maxEmissionRate / 100) + (delegate.return_data[0] * maxEmissionRate / 100) / maxEmissionRate / 100 != 2 * delegate.return_data[0]:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    spherePerBlock = (delegate.return_data[0] * maxEmissionRate / 100) + (delegate.return_data[0] * maxEmissionRate / 100)
    if amountToBurn + burnInfo[msg.sender] < burnInfo[msg.sender]:
        revert with 0, 'SafeMath: addition overflow'
    burnInfo[msg.sender] += amountToBurn
    if burnInfo[address(stor8)] < amountToBurn + burnInfo[msg.sender]:
        uint256(stor8) = msg.sender or Mask(96, 160, uint256(stor8))
    require ext_code.size(sphereTokenAddress)
    staticcall sphereTokenAddress.0xd5abeb01 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(sphereTokenAddress)
    staticcall sphereTokenAddress.0x18160ddd with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if (amountToBurn / 200) + ext_call.return_data[0] < ext_call.return_data[0]:
        revert with 0, 'SafeMath: addition overflow'
    require ext_code.size(sphereTokenAddress)
    if (amountToBurn / 200) + ext_call.return_data[0] <= ext_call.return_data[0]:
        call sphereTokenAddress.0x40c10f19 with:
             gas gas_remaining wei
            args msg.sender, amountToBurn / 200
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
    else:
        staticcall sphereTokenAddress.0xd5abeb01 with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(sphereTokenAddress)
        staticcall sphereTokenAddress.0x18160ddd with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] < ext_call.return_data[0]:
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0] > ext_call.return_data[0]:
                revert with 0, 'SafeMath: subtraction overflow'
            require ext_code.size(sphereTokenAddress)
            call sphereTokenAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args msg.sender, 0
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
    require ext_code.size(sphereTokenAddress)
    staticcall sphereTokenAddress.0xd5abeb01 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(sphereTokenAddress)
    staticcall sphereTokenAddress.0x18160ddd with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if amountToBurn + ext_call.return_data[0] < ext_call.return_data[0]:
        revert with 0, 'SafeMath: addition overflow'
    require ext_code.size(sphereTokenAddress)
    if amountToBurn + ext_call.return_data[0] <= ext_call.return_data[0]:
        call sphereTokenAddress.0x40c10f19 with:
             gas gas_remaining wei
            args 57005, amountToBurn
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
    else:
        staticcall sphereTokenAddress.0xd5abeb01 with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(sphereTokenAddress)
        staticcall sphereTokenAddress.0x18160ddd with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] < ext_call.return_data[0]:
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0x18160ddd with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sphereTokenAddress)
            staticcall sphereTokenAddress.0xd5abeb01 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0] > ext_call.return_data[0]:
                revert with 0, 'SafeMath: subtraction overflow'
            require ext_code.size(sphereTokenAddress)
            call sphereTokenAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args 57005, 0
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
    if amountToBurn + totalBurned < totalBurned:
        revert with 0, 'SafeMath: addition overflow'
    totalBurned += amountToBurn
    amountToBurn = 0
    stor1 = 1
}



}

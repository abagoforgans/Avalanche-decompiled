contract main {




// =====================  Runtime code  =====================


#
#  - earned(address arg1)
#  - withdraw(uint256 arg1)
#  - notifyRewardAmount(uint256 arg1)
#  - getReward()
#  - stake(uint256 arg1)
#  - notifyReward2(address arg1, uint256 arg2, uint256 arg3)
#  - getRewardA(address arg1)
#  - exit()
#  - stakeWithPermit(uint256 arg1, uint256 arg2, uint8 arg3, bytes32 arg4, bytes32 arg5)
#  - notifyRewardBegin(uint256 arg1, uint256 arg2, uint256 arg3)
#
bool stor0; offset 256
uint8 stor0; offset 160
uint8 stor0; offset 168
uint128 stor0; offset 168
address rewardsDistributionAddress;
address governorAddress;
mapping of uint256 configI;
uint8 stor53;
address rewardsTokenAddress;
address stakingTokenAddress;
uint256 periodFinish;
uint256 rewardRate;
uint256 rewardsDuration;
uint256 lastUpdateTime;
uint256 rewardPerTokenStored;
mapping of uint256 userRewardPerTokenPaid;
mapping of uint256 rewards;
uint256 totalSupply;
mapping of uint256 balanceOf;
uint256 lep;
uint256 begin;
mapping of uint256 paid;
address stor117;
array of struct stor118;
array of struct stor119;
uint256 stor42D0;
address storB531;
uint256 rewards2Ratio;
address rewards2TokenAddress;
uint256 storE5FC;
uint128 storFE82; offset 160
address storFE82;
uint256 storFE82;

function rewards(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return rewards[arg1]
}

function governor() payable {
    return governorAddress
}

function totalSupply() payable {
    return totalSupply
}

function begin() payable {
    return begin
}

function rewards2Token() payable {
    return rewards2TokenAddress
}

function rewardsDuration() payable {
    return rewardsDuration
}

function rewardsDistribution() payable {
    return rewardsDistributionAddress
}

function getConfigA(bytes32 arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    require arg2 == arg2
    return configI[arg2 xor arg1]
}

function getConfigI(bytes32 arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    return configI[arg2 xor arg1]
}

function getConfig(bytes32 arg1) payable {
    require calldata.size - 4 >= 32
    return configI[arg1]
}

function balanceOf(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return balanceOf[address(arg1)]
}

function stakingToken() payable {
    return stakingTokenAddress
}

function rewardRate() payable {
    return rewardRate
}

function userRewardPerTokenPaid(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return userRewardPerTokenPaid[arg1]
}

function lep() payable {
    return lep
}

function paid(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return paid[arg1]
}

function lastUpdateTime() payable {
    return lastUpdateTime
}

function rewardsToken() payable {
    return rewardsTokenAddress
}

function rewardPerTokenStored() payable {
    return rewardPerTokenStored
}

function periodFinish() payable {
    return periodFinish
}

function rewards2Ratio() payable {
    return rewards2Ratio
}

function _fallback() payable {
    revert
}

function lastTimeRewardApplicable() payable {
    if block.timestamp < periodFinish:
        return block.timestamp
    return periodFinish
}

function renounceGovernorship() payable {
    if governorAddress != msg.sender:
        require msg.sender == storB531
    emit GovernorshipTransferred(governorAddress, 0);
    governorAddress = 0
}

function setConfig(bytes32 arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    if governorAddress != msg.sender:
        require msg.sender == storB531
    if arg2 != configI[arg1]:
        configI[arg1] = arg2
}

function setConfigI(bytes32 arg1, uint256 arg2, uint256 arg3) payable {
    require calldata.size - 4 >= 96
    if governorAddress != msg.sender:
        require msg.sender == storB531
    if arg3 != configI[arg2 xor arg1]:
        configI[arg2 xor arg1] = arg3
}

function setConfigA(bytes32 arg1, address arg2, uint256 arg3) payable {
    require calldata.size - 4 >= 96
    require arg2 == arg2
    if governorAddress != msg.sender:
        require msg.sender == storB531
    if arg3 != configI[arg1 xor arg2]:
        configI[arg1 xor arg2] = arg3
}

function transferGovernorship(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if governorAddress != msg.sender:
        require msg.sender == storB531
    require arg1
    emit GovernorshipTransferred(governorAddress, arg1);
    governorAddress = arg1
}

function getRewardForDuration() payable {
    require ext_code.size(rewardsTokenAddress)
    staticcall rewardsTokenAddress.0xdd62ed3e with:
            gas gas_remaining wei
           args rewardsDistributionAddress, this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] > stor42D0:
        return (ext_call.return_data[0] - stor42D0)
    else:
        return 0
}

function __StakingPool_init_unchained(address arg1, address arg2, address arg3, address arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg2 == arg2
    require arg3 == arg3
    require arg4 == arg4
    if governorAddress != msg.sender:
        require msg.sender == storB531
    rewardsTokenAddress = arg2
    stakingTokenAddress = arg3
    rewardsDistributionAddress = arg1
    address(storFE82.field_0) = arg4
    Mask(96, 0, storFE82.field_160) = 0
    storE5FC = 10^17
}

function lptValueTotal() payable {
    require stor118.length
    require stor118.length
    require address(stor118.field_0) != stakingTokenAddress
    require 0 < stor118.length
    require ext_code.size(address(stor118.field_0))
    staticcall address(stor118.field_0).0x70a08231 with:
            gas gas_remaining wei
           args stakingTokenAddress
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if not ext_call.return_data[0]:
        return 0
    if 2 * ext_call.return_data[0] / ext_call.return_data[0] != 2:
        revert with 0, 'SafeMath: multiplication overflow'
    return (2 * ext_call.return_data[0])
}

function __Governable_init_unchained(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if uint8(stor0.field_168):
        governorAddress = arg1
        emit GovernorshipTransferred(0, arg1);
    else:
        if ext_code.size(this.address):
            if uint8(stor0.field_160):
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Contract instance has already been initialized'
        if uint8(stor0.field_168):
            governorAddress = arg1
            emit GovernorshipTransferred(0, arg1);
        else:
            uint8(stor0.field_160) = 1
            uint8(stor0.field_168) = 1
            Mask(88, 0, stor0.field_168) = 0
            stor0.field_256 % 1 = 0
            governorAddress = arg1
            emit GovernorshipTransferred(0, arg1);
            uint8(stor0.field_168) = 0
}

function __StakingRewards_init_unchained(address arg1, address arg2, address arg3) payable {
    require calldata.size - 4 >= 96
    require arg1 == arg1
    require arg2 == arg2
    require arg3 == arg3
    if uint8(stor0.field_168):
        rewardsTokenAddress = arg2
        stakingTokenAddress = arg3
        rewardsDistributionAddress = arg1
    else:
        if ext_code.size(this.address):
            if uint8(stor0.field_160):
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Contract instance has already been initialized'
        if uint8(stor0.field_168):
            rewardsTokenAddress = arg2
            stakingTokenAddress = arg3
            rewardsDistributionAddress = arg1
        else:
            uint8(stor0.field_160) = 1
            uint8(stor0.field_168) = 1
            Mask(88, 0, stor0.field_168) = 0
            stor0.field_256 % 1 = 0
            rewardsTokenAddress = arg2
            stakingTokenAddress = arg3
            rewardsDistributionAddress = arg1
            uint8(stor0.field_168) = 0
}

function lptValue(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require ext_code.size(stakingTokenAddress)
    staticcall stakingTokenAddress.0x18160ddd with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require stor118.length
    require stor118.length
    require address(stor118.field_0) != stakingTokenAddress
    require 0 < stor118.length
    require ext_code.size(address(stor118.field_0))
    staticcall address(stor118.field_0).0x70a08231 with:
            gas gas_remaining wei
           args stakingTokenAddress
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if not ext_call.return_data[0]:
        if not ext_call.return_data[0]:
            revert with 0, 'SafeMath: division by zero', 0
        return (0 / ext_call.return_data[0])
    if 2 * ext_call.return_data[0] / ext_call.return_data[0] != 2:
        revert with 0, 'SafeMath: multiplication overflow'
    if not 2 * ext_call.return_data[0]:
        if not ext_call.return_data[0]:
            revert with 0, 'SafeMath: division by zero', 0
        return (0 / ext_call.return_data[0])
    if arg1 * 2 * ext_call.return_data[0] / 2 * ext_call.return_data[0] != arg1:
        revert with 0, 'SafeMath: multiplication overflow'
    if not ext_call.return_data[0]:
        revert with 0, 'SafeMath: division by zero', 0
    return (arg1 * 2 * ext_call.return_data[0] / ext_call.return_data[0])
}

function __StakingRewards_init(address arg1, address arg2, address arg3) payable {
    require calldata.size - 4 >= 96
    require arg1 == arg1
    require arg2 == arg2
    require arg3 == arg3
    if uint8(stor0.field_168):
        stor53 = 1
        rewardsTokenAddress = arg2
        stakingTokenAddress = arg3
        rewardsDistributionAddress = arg1
    else:
        if ext_code.size(this.address):
            if uint8(stor0.field_160):
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Contract instance has already been initialized'
        if uint8(stor0.field_168):
            stor53 = 1
            rewardsTokenAddress = arg2
            stakingTokenAddress = arg3
            rewardsDistributionAddress = arg1
        else:
            uint8(stor0.field_160) = 1
            uint8(stor0.field_168) = 1
            Mask(88, 0, stor0.field_168) = 0
            stor0.field_256 % 1 = 0
            if ext_code.size(this.address):
                if uint8(stor0.field_160):
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Contract instance has already been initialized'
            if uint8(stor0.field_168):
                stor53 = 1
                rewardsTokenAddress = arg2
                stakingTokenAddress = arg3
                rewardsDistributionAddress = arg1
            else:
                uint8(stor0.field_160) = 1
                uint8(stor0.field_168) = 1
                Mask(88, 0, stor0.field_168) = 0
                stor0.field_256 % 1 = 0
                stor53 = 1
                uint8(stor0.field_168) = 0
                if ext_code.size(this.address):
                    if uint8(stor0.field_160):
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Contract instance has already been initialized'
                if uint8(stor0.field_168):
                    rewardsTokenAddress = arg2
                    stakingTokenAddress = arg3
                    rewardsDistributionAddress = arg1
                else:
                    uint8(stor0.field_160) = 1
                    uint8(stor0.field_168) = 1
                    Mask(88, 0, stor0.field_168) = 0
                    stor0.field_256 % 1 = 0
                    rewardsTokenAddress = arg2
                    stakingTokenAddress = arg3
                    rewardsDistributionAddress = arg1
                    uint8(stor0.field_168) = 0
                    uint8(stor0.field_168) = 0
}

function __StakingPool_init(address arg1, address arg2, address arg3, address arg4, address arg5) payable {
    require calldata.size - 4 >= 160
    require arg1 == arg1
    require arg2 == arg2
    require arg3 == arg3
    require arg4 == arg4
    require arg5 == arg5
    if uint8(stor0.field_168):
        stor53 = 1
        governorAddress = arg1
        emit GovernorshipTransferred(0, arg1);
    else:
        if ext_code.size(this.address):
            if uint8(stor0.field_160):
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Contract instance has already been initialized'
        if uint8(stor0.field_168):
            stor53 = 1
            governorAddress = arg1
            emit GovernorshipTransferred(0, arg1);
        else:
            uint8(stor0.field_160) = 1
            uint8(stor0.field_168) = 1
            Mask(88, 0, stor0.field_168) = 0
            stor0.field_256 % 1 = 0
            if ext_code.size(this.address):
                if uint8(stor0.field_160):
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Contract instance has already been initialized'
            if uint8(stor0.field_168):
                stor53 = 1
                governorAddress = arg1
                emit GovernorshipTransferred(0, arg1);
            else:
                uint8(stor0.field_160) = 1
                uint8(stor0.field_168) = 1
                Mask(88, 0, stor0.field_168) = 0
                stor0.field_256 % 1 = 0
                stor53 = 1
                uint8(stor0.field_168) = 0
                if ext_code.size(this.address):
                    if uint8(stor0.field_160):
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Contract instance has already been initialized'
                if uint8(stor0.field_168):
                    governorAddress = arg1
                    emit GovernorshipTransferred(0, arg1);
                else:
                    uint8(stor0.field_160) = 1
                    uint8(stor0.field_168) = 1
                    Mask(88, 0, stor0.field_168) = 0
                    stor0.field_256 % 1 = 0
                    governorAddress = arg1
                    emit GovernorshipTransferred(0, arg1);
                    uint8(stor0.field_168) = 0
    if governorAddress != msg.sender:
        require msg.sender == storB531
    rewardsTokenAddress = arg3
    stakingTokenAddress = arg4
    rewardsDistributionAddress = arg2
    address(storFE82.field_0) = arg5
    Mask(96, 0, storFE82.field_160) = 0
    storE5FC = 10^17
    if not uint8(stor0.field_168):
        uint8(stor0.field_168) = 0
}

function swapValue(uint256 arg1, address[] arg2) payable {
    require calldata.size - 4 >= 64
    require arg2 <= test266151307()
    require arg2 + 35 < calldata.size
    require arg2.length <= test266151307()
    require (32 * arg2.length) + 128 <= test266151307() and (32 * arg2.length) + 128 >= 96
    mem[64] = (32 * arg2.length) + 128
    mem[96] = arg2.length
    require calldata.size >= arg2 + (32 * arg2.length) + 36
    s = arg2 + 36
    idx = 0
    t = 128
    while idx < arg2.length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        s = s + 32
        idx = idx + 1
        t = t + 32
        continue 
    idx = 0
    s = arg1
    while idx < arg2.length - 1:
        require idx < mem[96]
        require idx + 1 < mem[96]
        _57 = mem[(32 * idx + 1) + 128]
        mem[mem[64] + 4] = mem[(32 * idx) + 140 len 20]
        mem[mem[64] + 36] = address(_57)
        require ext_code.size(stor117)
        staticcall stor117.getPair(address rg1, address rg2) with:
                gas gas_remaining wei
               args mem[mem[64] + 4], address(_57)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _61 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        require mem[_61] == mem[_61 + 12 len 20]
        require ext_code.size(mem[_61 + 12 len 20])
        staticcall mem[_61 + 12 len 20].getReserves() with:
                gas gas_remaining wei
        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _65 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 96
        require mem[_65] == mem[_65 + 18 len 14]
        require mem[_65 + 32] == mem[_65 + 50 len 14]
        require mem[_65 + 64] == mem[_65 + 92 len 4]
        require idx < mem[96]
        require idx + 1 < mem[96]
        if mem[(32 * idx + 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
            if not s:
                if mem[_65 + 50 len 14]:
                    idx = idx + 1
                    s = 0 / mem[_65 + 50 len 14]
                    continue 
            else:
                if mem[_65 + 18 len 14] * s / s != mem[_65 + 18 len 14]:
                    revert with 0, 'SafeMath: multiplication overflow'
                if mem[_65 + 50 len 14]:
                    idx = idx + 1
                    s = mem[_65 + 18 len 14] * s / mem[_65 + 50 len 14]
                    continue 
            ('iszero', ('mem', ('range', ('add', 50, ('var', '_65')), 14)))
        else:
            if not s:
                if mem[_65 + 18 len 14]:
                    idx = idx + 1
                    s = 0 / mem[_65 + 18 len 14]
                    continue 
            else:
                if mem[_65 + 50 len 14] * s / s != mem[_65 + 50 len 14]:
                    revert with 0, 'SafeMath: multiplication overflow'
                if mem[_65 + 18 len 14]:
                    idx = idx + 1
                    s = mem[_65 + 50 len 14] * s / mem[_65 + 18 len 14]
                    continue 
            ('iszero', ('mem', ('range', ('add', 18, ('var', '_65')), 14)))
        revert
    return s
}

function setPath(address arg1, address[] arg2, address[] arg3) payable {
    require calldata.size - 4 >= 96
    require arg1 == arg1
    require arg2 <= test266151307()
    require arg2 + 35 < calldata.size
    require arg2.length <= test266151307()
    require (32 * arg2.length) + 128 <= test266151307() and (32 * arg2.length) + 128 >= 96
    mem[96] = arg2.length
    require calldata.size >= arg2 + (32 * arg2.length) + 36
    s = arg2 + 36
    idx = 0
    t = 128
    while idx < arg2.length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        s = s + 32
        idx = idx + 1
        t = t + 32
        continue 
    require arg3 <= test266151307()
    require arg3 + 35 < calldata.size
    require arg3.length <= test266151307()
    require (32 * arg2.length) + (32 * arg3.length) + 160 <= test266151307() and (32 * arg3.length) + 160 >= 128
    mem[64] = (32 * arg2.length) + (32 * arg3.length) + 160
    mem[(32 * arg2.length) + 128] = arg3.length
    require calldata.size >= arg3 + (32 * arg3.length) + 36
    s = arg3 + 36
    idx = 0
    t = (32 * arg2.length) + 160
    while idx < arg3.length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        s = s + 32
        idx = idx + 1
        t = t + 32
        continue 
    if msg.sender == governorAddress:
        require arg2.length
        require arg3.length > 0
        require arg3.length - 1 < arg3.length
        require arg2.length - 1 < arg2.length
        require mem[(32 * arg2.length - 1) + 140 len 20] == mem[(32 * arg3.length - 1) + (32 * arg2.length) + 172 len 20]
        idx = 0
        while idx < arg2.length - 1:
            require idx < mem[96]
            require idx + 1 < mem[96]
            _198 = mem[(32 * idx + 1) + 128]
            mem[mem[64] + 4] = mem[(32 * idx) + 140 len 20]
            mem[mem[64] + 36] = address(_198)
            require ext_code.size(arg1)
            staticcall arg1.getPair(address rg1, address rg2) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], address(_198)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _218 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_218] == mem[_218 + 12 len 20]
            require mem[_218 + 12 len 20]
            idx = idx + 1
            continue 
        idx = 0
        while idx < arg3.length - 1:
            require idx < mem[(32 * arg2.length) + 128]
            require idx + 1 < mem[(32 * arg2.length) + 128]
            _250 = mem[(32 * idx + 1) + (32 * arg2.length) + 160]
            mem[mem[64] + 4] = mem[(32 * idx) + (32 * arg2.length) + 172 len 20]
            mem[mem[64] + 36] = address(_250)
            require ext_code.size(arg1)
            staticcall arg1.getPair(address rg1, address rg2) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], address(_250)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _258 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_258] == mem[_258 + 12 len 20]
            require mem[_258 + 12 len 20]
            idx = idx + 1
            continue 
    else:
        require msg.sender == storB531
        require arg2.length
        require arg3.length > 0
        require arg3.length - 1 < arg3.length
        require arg2.length - 1 < arg2.length
        require mem[(32 * arg2.length - 1) + 140 len 20] == mem[(32 * arg3.length - 1) + (32 * arg2.length) + 172 len 20]
        idx = 0
        while idx < arg2.length - 1:
            require idx < mem[96]
            require idx + 1 < mem[96]
            _202 = mem[(32 * idx + 1) + 128]
            mem[mem[64] + 4] = mem[(32 * idx) + 140 len 20]
            mem[mem[64] + 36] = address(_202)
            require ext_code.size(arg1)
            staticcall arg1.getPair(address rg1, address rg2) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], address(_202)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _221 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_221] == mem[_221 + 12 len 20]
            require mem[_221 + 12 len 20]
            idx = idx + 1
            continue 
        idx = 0
        while idx < arg3.length - 1:
            require idx < mem[(32 * arg2.length) + 128]
            require idx + 1 < mem[(32 * arg2.length) + 128]
            _252 = mem[(32 * idx + 1) + (32 * arg2.length) + 160]
            mem[mem[64] + 4] = mem[(32 * idx) + (32 * arg2.length) + 172 len 20]
            mem[mem[64] + 36] = address(_252)
            require ext_code.size(arg1)
            staticcall arg1.getPair(address rg1, address rg2) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], address(_252)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _259 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_259] == mem[_259 + 12 len 20]
            require mem[_259 + 12 len 20]
            idx = idx + 1
            continue 
    stor117 = arg1
    stor118.length = mem[96]
    mem[0] = 118
    if not mem[96]:
        idx = 0
        while stor118.length > idx:
            stor118[idx].field_0 = 0
            idx = idx + 1
            continue 
    else:
        s = 0
        idx = 128
        while (32 * mem[96]) + 128 > idx:
            stor118[s].field_0 = mem[idx + 12 len 20]
            s = s + 1
            idx = idx + 32
            continue 
        idx = Mask(251, 0, (32 * mem[96]) + 31) >> 5
        while stor118.length > idx:
            stor118[idx].field_0 = 0
            idx = idx + 1
            continue 
    stor119.length = mem[(32 * arg2.length) + 128]
    if not mem[(32 * arg2.length) + 128]:
        idx = 0
        while stor119.length > idx:
            stor119[idx].field_0 = 0
            idx = idx + 1
            continue 
    else:
        s = 0
        idx = (32 * arg2.length) + 160
        while (32 * arg2.length) + (32 * mem[(32 * arg2.length) + 128]) + 160 > idx:
            stor119[s].field_0 = mem[idx + 12 len 20]
            s = s + 1
            idx = idx + 32
            continue 
        idx = Mask(251, 0, (32 * mem[(32 * arg2.length) + 128]) + 31) >> 5
        while stor119.length > idx:
            stor119[idx].field_0 = 0
            idx = idx + 1
            continue 
}

function rewardDelta() payable {
    if 0 == begin:
        return 0
    if begin >= block.timestamp:
        return 0
    if lastUpdateTime >= block.timestamp:
        return 0
    require ext_code.size(rewardsTokenAddress)
    staticcall rewardsTokenAddress.0xdd62ed3e with:
            gas gas_remaining wei
           args rewardsDistributionAddress, this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(rewardsTokenAddress)
    staticcall rewardsTokenAddress.0x70a08231 with:
            gas gas_remaining wei
           args rewardsDistributionAddress
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] <= stor42D0:
        if lep != 3:
            if lep != 2:
                if block.timestamp >= periodFinish:
                    if uint256(storFE82.field_0):
                        if storE5FC > 10^18:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        else:
                            return 0
                    else:
                        return 0
                if lastUpdateTime > periodFinish:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if lastUpdateTime > block.timestamp:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if not periodFinish - lastUpdateTime:
                    revert with 0, 'SafeMath: division by zero', 0
                if not uint256(storFE82.field_0):
                    return (0 / periodFinish - lastUpdateTime)
                if storE5FC > 10^18:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if not 0 / periodFinish - lastUpdateTime:
                    return 0
                if (10^18 * 0 / periodFinish - lastUpdateTime) - (storE5FC * 0 / periodFinish - lastUpdateTime) / 0 / periodFinish - lastUpdateTime != -storE5FC + 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                return ((10^18 * 0 / periodFinish - lastUpdateTime) - (storE5FC * 0 / periodFinish - lastUpdateTime) / 10^18)
            if lastUpdateTime > block.timestamp:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if block.timestamp - lastUpdateTime >= rewardsDuration:
                if uint256(storFE82.field_0):
                    if storE5FC > 10^18:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    else:
                        return 0
                else:
                    return 0
            if lastUpdateTime > block.timestamp:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if not rewardsDuration:
                revert with 0, 'SafeMath: division by zero', 0
            if not uint256(storFE82.field_0):
                return (0 / rewardsDuration)
            if storE5FC > 10^18:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if not 0 / rewardsDuration:
                return 0
            if (10^18 * 0 / rewardsDuration) - (storE5FC * 0 / rewardsDuration) / 0 / rewardsDuration != -storE5FC + 10^18:
                revert with 0, 'SafeMath: multiplication overflow'
            return ((10^18 * 0 / rewardsDuration) - (storE5FC * 0 / rewardsDuration) / 10^18)
        if rewardsDuration + block.timestamp < block.timestamp:
            revert with 0, 'SafeMath: addition overflow'
        if begin > rewardsDuration + block.timestamp:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if rewardsDuration + lastUpdateTime < lastUpdateTime:
            revert with 0, 'SafeMath: addition overflow'
        if begin > rewardsDuration + lastUpdateTime:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if not rewardsDuration + block.timestamp - begin:
            revert with 0, 'SafeMath: division by zero', 0
        if 0 / rewardsDuration + block.timestamp - begin > 0:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if not uint256(storFE82.field_0):
            return -(0 / rewardsDuration + block.timestamp - begin)
        if storE5FC > 10^18:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if not -0 / rewardsDuration + block.timestamp - begin:
            return 0
        if (-1 * 10^18 * 0 / rewardsDuration + block.timestamp - begin) + (storE5FC * 0 / rewardsDuration + block.timestamp - begin) / -0 / rewardsDuration + block.timestamp - begin != -storE5FC + 10^18:
            revert with 0, 'SafeMath: multiplication overflow'
        return ((-1 * 10^18 * 0 / rewardsDuration + block.timestamp - begin) + (storE5FC * 0 / rewardsDuration + block.timestamp - begin) / 10^18)
    if lep != 3:
        if lep != 2:
            if block.timestamp >= periodFinish:
                if lastUpdateTime >= periodFinish:
                    if uint256(storFE82.field_0):
                        if storE5FC > 10^18:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        else:
                            return 0
                    else:
                        return 0
                if not uint256(storFE82.field_0):
                    return (ext_call.return_data[0] - stor42D0)
                if storE5FC > 10^18:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if not ext_call.return_data[0] - stor42D0:
                    return 0
                if (10^18 * ext_call.return_data[0]) - (10^18 * stor42D0) - (ext_call.return_data[0] * storE5FC) + (stor42D0 * storE5FC) / ext_call.return_data[0] - stor42D0 != -storE5FC + 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                return ((10^18 * ext_call.return_data[0]) - (10^18 * stor42D0) - (ext_call.return_data[0] * storE5FC) + (stor42D0 * storE5FC) / 10^18)
            if lastUpdateTime > periodFinish:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if lastUpdateTime > block.timestamp:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if not ext_call.return_data[0] - stor42D0:
                if not periodFinish - lastUpdateTime:
                    revert with 0, 'SafeMath: division by zero', 0
                if not uint256(storFE82.field_0):
                    return (0 / periodFinish - lastUpdateTime)
                if storE5FC > 10^18:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if not 0 / periodFinish - lastUpdateTime:
                    return 0
                if (10^18 * 0 / periodFinish - lastUpdateTime) - (storE5FC * 0 / periodFinish - lastUpdateTime) / 0 / periodFinish - lastUpdateTime != -storE5FC + 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                return ((10^18 * 0 / periodFinish - lastUpdateTime) - (storE5FC * 0 / periodFinish - lastUpdateTime) / 10^18)
            if (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / ext_call.return_data[0] - stor42D0 != block.timestamp - lastUpdateTime:
                revert with 0, 'SafeMath: multiplication overflow'
            if not periodFinish - lastUpdateTime:
                revert with 0, 'SafeMath: division by zero', 0
            if not uint256(storFE82.field_0):
                return ((ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / periodFinish - lastUpdateTime)
            if storE5FC > 10^18:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if not (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / periodFinish - lastUpdateTime:
                return 0
            if (10^18 * (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / periodFinish - lastUpdateTime) - (storE5FC * (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / periodFinish - lastUpdateTime) / (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / periodFinish - lastUpdateTime != -storE5FC + 10^18:
                revert with 0, 'SafeMath: multiplication overflow'
            return ((10^18 * (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / periodFinish - lastUpdateTime) - (storE5FC * (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / periodFinish - lastUpdateTime) / 10^18)
        if lastUpdateTime > block.timestamp:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if block.timestamp - lastUpdateTime >= rewardsDuration:
            if not uint256(storFE82.field_0):
                return (ext_call.return_data[0] - stor42D0)
            if storE5FC > 10^18:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if not ext_call.return_data[0] - stor42D0:
                return 0
            if (10^18 * ext_call.return_data[0]) - (10^18 * stor42D0) - (ext_call.return_data[0] * storE5FC) + (stor42D0 * storE5FC) / ext_call.return_data[0] - stor42D0 != -storE5FC + 10^18:
                revert with 0, 'SafeMath: multiplication overflow'
            return ((10^18 * ext_call.return_data[0]) - (10^18 * stor42D0) - (ext_call.return_data[0] * storE5FC) + (stor42D0 * storE5FC) / 10^18)
        if lastUpdateTime > block.timestamp:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if not ext_call.return_data[0] - stor42D0:
            if not rewardsDuration:
                revert with 0, 'SafeMath: division by zero', 0
            if not uint256(storFE82.field_0):
                return (0 / rewardsDuration)
            if storE5FC > 10^18:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if not 0 / rewardsDuration:
                return 0
            if (10^18 * 0 / rewardsDuration) - (storE5FC * 0 / rewardsDuration) / 0 / rewardsDuration != -storE5FC + 10^18:
                revert with 0, 'SafeMath: multiplication overflow'
            return ((10^18 * 0 / rewardsDuration) - (storE5FC * 0 / rewardsDuration) / 10^18)
        if (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / ext_call.return_data[0] - stor42D0 != block.timestamp - lastUpdateTime:
            revert with 0, 'SafeMath: multiplication overflow'
        if not rewardsDuration:
            revert with 0, 'SafeMath: division by zero', 0
        if not uint256(storFE82.field_0):
            return ((ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / rewardsDuration)
        if storE5FC > 10^18:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if not (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / rewardsDuration:
            return 0
        if (10^18 * (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / rewardsDuration) - (storE5FC * (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / rewardsDuration) / (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / rewardsDuration != -storE5FC + 10^18:
            revert with 0, 'SafeMath: multiplication overflow'
        return ((10^18 * (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / rewardsDuration) - (storE5FC * (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / rewardsDuration) / 10^18)
    if rewardsDuration + block.timestamp < block.timestamp:
        revert with 0, 'SafeMath: addition overflow'
    if begin > rewardsDuration + block.timestamp:
        revert with 0, 'SafeMath: subtraction overflow', 0
    if rewardsDuration + lastUpdateTime < lastUpdateTime:
        revert with 0, 'SafeMath: addition overflow'
    if begin > rewardsDuration + lastUpdateTime:
        revert with 0, 'SafeMath: subtraction overflow', 0
    if not ext_call.return_data[0] - stor42D0:
        if not rewardsDuration + block.timestamp - begin:
            revert with 0, 'SafeMath: division by zero', 0
        if 0 / rewardsDuration + block.timestamp - begin > ext_call.return_data[0] - stor42D0:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if not uint256(storFE82.field_0):
            return (ext_call.return_data[0] - stor42D0 - (0 / rewardsDuration + block.timestamp - begin))
        if storE5FC > 10^18:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if not ext_call.return_data[0] - stor42D0 - (0 / rewardsDuration + block.timestamp - begin):
            return 0
        if (10^18 * ext_call.return_data[0]) - (10^18 * stor42D0) - (10^18 * 0 / rewardsDuration + block.timestamp - begin) - (ext_call.return_data[0] * storE5FC) + (stor42D0 * storE5FC) + (0 / rewardsDuration + block.timestamp - begin * storE5FC) / ext_call.return_data[0] - stor42D0 - (0 / rewardsDuration + block.timestamp - begin) != -storE5FC + 10^18:
            revert with 0, 'SafeMath: multiplication overflow'
        return ((10^18 * ext_call.return_data[0]) - (10^18 * stor42D0) - (10^18 * 0 / rewardsDuration + block.timestamp - begin) - (ext_call.return_data[0] * storE5FC) + (stor42D0 * storE5FC) + (0 / rewardsDuration + block.timestamp - begin * storE5FC) / 10^18)
    if (ext_call.return_data[0] * rewardsDuration) - (stor42D0 * rewardsDuration) + (ext_call.return_data[0] * lastUpdateTime) - (stor42D0 * lastUpdateTime) - (ext_call.return_data[0] * begin) + (stor42D0 * begin) / ext_call.return_data[0] - stor42D0 != rewardsDuration + lastUpdateTime - begin:
        revert with 0, 'SafeMath: multiplication overflow'
    if not rewardsDuration + block.timestamp - begin:
        revert with 0, 'SafeMath: division by zero', 0
    if (ext_call.return_data[0] * rewardsDuration) - (stor42D0 * rewardsDuration) + (ext_call.return_data[0] * lastUpdateTime) - (stor42D0 * lastUpdateTime) - (ext_call.return_data[0] * begin) + (stor42D0 * begin) / rewardsDuration + block.timestamp - begin > ext_call.return_data[0] - stor42D0:
        revert with 0, 'SafeMath: subtraction overflow', 0
    if not uint256(storFE82.field_0):
        return (ext_call.return_data[0] - stor42D0 - ((ext_call.return_data[0] * rewardsDuration) - (stor42D0 * rewardsDuration) + (ext_call.return_data[0] * lastUpdateTime) - (stor42D0 * lastUpdateTime) - (ext_call.return_data[0] * begin) + (stor42D0 * begin) / rewardsDuration + block.timestamp - begin))
    if storE5FC > 10^18:
        revert with 0, 'SafeMath: subtraction overflow', 0
    if not ext_call.return_data[0] - stor42D0 - ((ext_call.return_data[0] * rewardsDuration) - (stor42D0 * rewardsDuration) + (ext_call.return_data[0] * lastUpdateTime) - (stor42D0 * lastUpdateTime) - (ext_call.return_data[0] * begin) + (stor42D0 * begin) / rewardsDuration + block.timestamp - begin):
        return 0
    if (10^18 * ext_call.return_data[0]) - (10^18 * stor42D0) - (10^18 * (ext_call.return_data[0] * rewardsDuration) - (stor42D0 * rewardsDuration) + (ext_call.return_data[0] * lastUpdateTime) - (stor42D0 * lastUpdateTime) - (ext_call.return_data[0] * begin) + (stor42D0 * begin) / rewardsDuration + block.timestamp - begin) - (ext_call.return_data[0] * storE5FC) + (stor42D0 * storE5FC) + ((ext_call.return_data[0] * rewardsDuration) - (stor42D0 * rewardsDuration) + (ext_call.return_data[0] * lastUpdateTime) - (stor42D0 * lastUpdateTime) - (ext_call.return_data[0] * begin) + (stor42D0 * begin) / rewardsDuration + block.timestamp - begin * storE5FC) / ext_call.return_data[0] - stor42D0 - ((ext_call.return_data[0] * rewardsDuration) - (stor42D0 * rewardsDuration) + (ext_call.return_data[0] * lastUpdateTime) - (stor42D0 * lastUpdateTime) - (ext_call.return_data[0] * begin) + (stor42D0 * begin) / rewardsDuration + block.timestamp - begin) != -storE5FC + 10^18:
        revert with 0, 'SafeMath: multiplication overflow'
    return ((10^18 * ext_call.return_data[0]) - (10^18 * stor42D0) - (10^18 * (ext_call.return_data[0] * rewardsDuration) - (stor42D0 * rewardsDuration) + (ext_call.return_data[0] * lastUpdateTime) - (stor42D0 * lastUpdateTime) - (ext_call.return_data[0] * begin) + (stor42D0 * begin) / rewardsDuration + block.timestamp - begin) - (ext_call.return_data[0] * storE5FC) + (stor42D0 * storE5FC) + ((ext_call.return_data[0] * rewardsDuration) - (stor42D0 * rewardsDuration) + (ext_call.return_data[0] * lastUpdateTime) - (stor42D0 * lastUpdateTime) - (ext_call.return_data[0] * begin) + (stor42D0 * begin) / rewardsDuration + block.timestamp - begin * storE5FC) / 10^18)
}

function TVL() payable {
    require stor118.length
    mem[0] = 118
    if address(stor118.field_0) == stakingTokenAddress:
        mem[64] = (32 * stor118.length) + 128
        mem[96] = stor118.length
        if not stor118.length:
            idx = 0
            s = totalSupply
            while idx < stor118.length - 1:
                require idx < mem[96]
                require idx + 1 < mem[96]
                _100 = mem[(32 * idx + 1) + 128]
                mem[mem[64] + 4] = mem[(32 * idx) + 140 len 20]
                mem[mem[64] + 36] = address(_100)
                require ext_code.size(stor117)
                staticcall stor117.getPair(address rg1, address rg2) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], address(_100)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _114 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_114] == mem[_114 + 12 len 20]
                require ext_code.size(mem[_114 + 12 len 20])
                staticcall mem[_114 + 12 len 20].getReserves() with:
                        gas gas_remaining wei
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _126 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                require mem[_126] == mem[_126 + 18 len 14]
                require mem[_126 + 32] == mem[_126 + 50 len 14]
                require mem[_126 + 64] == mem[_126 + 92 len 4]
                require idx < mem[96]
                require idx + 1 < mem[96]
                if mem[(32 * idx + 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
                    if not s:
                        if mem[_126 + 50 len 14]:
                            idx = idx + 1
                            s = 0 / mem[_126 + 50 len 14]
                            continue 
                    else:
                        if mem[_126 + 18 len 14] * s / s != mem[_126 + 18 len 14]:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if mem[_126 + 50 len 14]:
                            idx = idx + 1
                            s = mem[_126 + 18 len 14] * s / mem[_126 + 50 len 14]
                            continue 
                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_126')), 14)))
                else:
                    if not s:
                        if mem[_126 + 18 len 14]:
                            idx = idx + 1
                            s = 0 / mem[_126 + 18 len 14]
                            continue 
                    else:
                        if mem[_126 + 50 len 14] * s / s != mem[_126 + 50 len 14]:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if mem[_126 + 18 len 14]:
                            idx = idx + 1
                            s = mem[_126 + 50 len 14] * s / mem[_126 + 18 len 14]
                            continue 
                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_126')), 14)))
                revert
        else:
            mem[0] = 118
            mem[128] = address(stor118.field_0)
            idx = 128
            s = 0
            while (32 * stor118.length) + 96 > idx:
                mem[idx + 32] = stor118[s].field_256
                idx = idx + 32
                s = s + 1
                continue 
            idx = 0
            s = totalSupply
            while idx < stor118.length - 1:
                require idx < mem[96]
                require idx + 1 < mem[96]
                _246 = mem[(32 * idx + 1) + 128]
                mem[mem[64] + 4] = mem[(32 * idx) + 140 len 20]
                mem[mem[64] + 36] = address(_246)
                require ext_code.size(stor117)
                staticcall stor117.getPair(address rg1, address rg2) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], address(_246)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _260 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_260] == mem[_260 + 12 len 20]
                require ext_code.size(mem[_260 + 12 len 20])
                staticcall mem[_260 + 12 len 20].getReserves() with:
                        gas gas_remaining wei
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _272 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                require mem[_272] == mem[_272 + 18 len 14]
                require mem[_272 + 32] == mem[_272 + 50 len 14]
                require mem[_272 + 64] == mem[_272 + 92 len 4]
                require idx < mem[96]
                require idx + 1 < mem[96]
                if mem[(32 * idx + 1) + 140 len 20] < mem[(32 * idx) + 140 len 20]:
                    if not s:
                        if mem[_272 + 50 len 14]:
                            idx = idx + 1
                            s = 0 / mem[_272 + 50 len 14]
                            continue 
                    else:
                        if mem[_272 + 18 len 14] * s / s != mem[_272 + 18 len 14]:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if mem[_272 + 50 len 14]:
                            idx = idx + 1
                            s = mem[_272 + 18 len 14] * s / mem[_272 + 50 len 14]
                            continue 
                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_272')), 14)))
                else:
                    if not s:
                        if mem[_272 + 18 len 14]:
                            idx = idx + 1
                            s = 0 / mem[_272 + 18 len 14]
                            continue 
                    else:
                        if mem[_272 + 50 len 14] * s / s != mem[_272 + 50 len 14]:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if mem[_272 + 18 len 14]:
                            idx = idx + 1
                            s = mem[_272 + 50 len 14] * s / mem[_272 + 18 len 14]
                            continue 
                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_272')), 14)))
                revert
    else:
        require stor118.length
        require stor118.length
        require address(stor118.field_0) != stakingTokenAddress
        require 0 < stor118.length
        mem[0] = 118
        mem[100] = stakingTokenAddress
        require ext_code.size(address(stor118.field_0))
        staticcall address(stor118.field_0).0x70a08231 with:
                gas gas_remaining wei
               args stakingTokenAddress
        mem[96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if not ext_call.return_data[0]:
            mem[64] = ceil32(return_data.size) + (32 * stor118.length) + 128
            mem[ceil32(return_data.size) + 96] = stor118.length
            if not stor118.length:
                idx = 0
                s = 0
                while idx < stor118.length - 1:
                    require idx < mem[ceil32(return_data.size) + 96]
                    require idx + 1 < mem[ceil32(return_data.size) + 96]
                    _106 = mem[(32 * idx + 1) + ceil32(return_data.size) + 128]
                    mem[mem[64] + 4] = mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]
                    mem[mem[64] + 36] = address(_106)
                    require ext_code.size(stor117)
                    staticcall stor117.getPair(address rg1, address rg2) with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4], address(_106)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _116 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_116] == mem[_116 + 12 len 20]
                    require ext_code.size(mem[_116 + 12 len 20])
                    staticcall mem[_116 + 12 len 20].getReserves() with:
                            gas gas_remaining wei
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _128 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    require mem[_128] == mem[_128 + 18 len 14]
                    require mem[_128 + 32] == mem[_128 + 50 len 14]
                    require mem[_128 + 64] == mem[_128 + 92 len 4]
                    require idx < mem[ceil32(return_data.size) + 96]
                    require idx + 1 < mem[ceil32(return_data.size) + 96]
                    if mem[(32 * idx + 1) + ceil32(return_data.size) + 140 len 20] < mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]:
                        if not s:
                            if mem[_128 + 50 len 14]:
                                idx = idx + 1
                                s = 0 / mem[_128 + 50 len 14]
                                continue 
                        else:
                            if mem[_128 + 18 len 14] * s / s != mem[_128 + 18 len 14]:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if mem[_128 + 50 len 14]:
                                idx = idx + 1
                                s = mem[_128 + 18 len 14] * s / mem[_128 + 50 len 14]
                                continue 
                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_128')), 14)))
                    else:
                        if not s:
                            if mem[_128 + 18 len 14]:
                                idx = idx + 1
                                s = 0 / mem[_128 + 18 len 14]
                                continue 
                        else:
                            if mem[_128 + 50 len 14] * s / s != mem[_128 + 50 len 14]:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if mem[_128 + 18 len 14]:
                                idx = idx + 1
                                s = mem[_128 + 50 len 14] * s / mem[_128 + 18 len 14]
                                continue 
                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_128')), 14)))
                    revert
            else:
                mem[0] = 118
                mem[ceil32(return_data.size) + 128] = address(stor118.field_0)
                idx = ceil32(return_data.size) + 128
                s = 0
                while ceil32(return_data.size) + (32 * stor118.length) + 96 > idx:
                    mem[idx + 32] = stor118[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                idx = 0
                s = 0
                while idx < stor118.length - 1:
                    require idx < mem[ceil32(return_data.size) + 96]
                    require idx + 1 < mem[ceil32(return_data.size) + 96]
                    _252 = mem[(32 * idx + 1) + ceil32(return_data.size) + 128]
                    mem[mem[64] + 4] = mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]
                    mem[mem[64] + 36] = address(_252)
                    require ext_code.size(stor117)
                    staticcall stor117.getPair(address rg1, address rg2) with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4], address(_252)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _262 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_262] == mem[_262 + 12 len 20]
                    require ext_code.size(mem[_262 + 12 len 20])
                    staticcall mem[_262 + 12 len 20].getReserves() with:
                            gas gas_remaining wei
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _274 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    require mem[_274] == mem[_274 + 18 len 14]
                    require mem[_274 + 32] == mem[_274 + 50 len 14]
                    require mem[_274 + 64] == mem[_274 + 92 len 4]
                    require idx < mem[ceil32(return_data.size) + 96]
                    require idx + 1 < mem[ceil32(return_data.size) + 96]
                    if mem[(32 * idx + 1) + ceil32(return_data.size) + 140 len 20] < mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]:
                        if not s:
                            if mem[_274 + 50 len 14]:
                                idx = idx + 1
                                s = 0 / mem[_274 + 50 len 14]
                                continue 
                        else:
                            if mem[_274 + 18 len 14] * s / s != mem[_274 + 18 len 14]:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if mem[_274 + 50 len 14]:
                                idx = idx + 1
                                s = mem[_274 + 18 len 14] * s / mem[_274 + 50 len 14]
                                continue 
                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_274')), 14)))
                    else:
                        if not s:
                            if mem[_274 + 18 len 14]:
                                idx = idx + 1
                                s = 0 / mem[_274 + 18 len 14]
                                continue 
                        else:
                            if mem[_274 + 50 len 14] * s / s != mem[_274 + 50 len 14]:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if mem[_274 + 18 len 14]:
                                idx = idx + 1
                                s = mem[_274 + 50 len 14] * s / mem[_274 + 18 len 14]
                                continue 
                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_274')), 14)))
                    revert
        else:
            if 2 * ext_call.return_data[0] / ext_call.return_data[0] != 2:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[64] = ceil32(return_data.size) + (32 * stor118.length) + 128
            mem[ceil32(return_data.size) + 96] = stor118.length
            if not stor118.length:
                idx = 0
                s = 2 * ext_call.return_data[0]
                while idx < stor118.length - 1:
                    require idx < mem[ceil32(return_data.size) + 96]
                    require idx + 1 < mem[ceil32(return_data.size) + 96]
                    _103 = mem[(32 * idx + 1) + ceil32(return_data.size) + 128]
                    mem[mem[64] + 4] = mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]
                    mem[mem[64] + 36] = address(_103)
                    require ext_code.size(stor117)
                    staticcall stor117.getPair(address rg1, address rg2) with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4], address(_103)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _115 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_115] == mem[_115 + 12 len 20]
                    require ext_code.size(mem[_115 + 12 len 20])
                    staticcall mem[_115 + 12 len 20].getReserves() with:
                            gas gas_remaining wei
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _127 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    require mem[_127] == mem[_127 + 18 len 14]
                    require mem[_127 + 32] == mem[_127 + 50 len 14]
                    require mem[_127 + 64] == mem[_127 + 92 len 4]
                    require idx < mem[ceil32(return_data.size) + 96]
                    require idx + 1 < mem[ceil32(return_data.size) + 96]
                    if mem[(32 * idx + 1) + ceil32(return_data.size) + 140 len 20] < mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]:
                        if not s:
                            if mem[_127 + 50 len 14]:
                                idx = idx + 1
                                s = 0 / mem[_127 + 50 len 14]
                                continue 
                        else:
                            if mem[_127 + 18 len 14] * s / s != mem[_127 + 18 len 14]:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if mem[_127 + 50 len 14]:
                                idx = idx + 1
                                s = mem[_127 + 18 len 14] * s / mem[_127 + 50 len 14]
                                continue 
                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_127')), 14)))
                    else:
                        if not s:
                            if mem[_127 + 18 len 14]:
                                idx = idx + 1
                                s = 0 / mem[_127 + 18 len 14]
                                continue 
                        else:
                            if mem[_127 + 50 len 14] * s / s != mem[_127 + 50 len 14]:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if mem[_127 + 18 len 14]:
                                idx = idx + 1
                                s = mem[_127 + 50 len 14] * s / mem[_127 + 18 len 14]
                                continue 
                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_127')), 14)))
                    revert
            else:
                mem[0] = 118
                mem[ceil32(return_data.size) + 128] = address(stor118.field_0)
                idx = ceil32(return_data.size) + 128
                s = 0
                while ceil32(return_data.size) + (32 * stor118.length) + 96 > idx:
                    mem[idx + 32] = stor118[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                idx = 0
                s = 2 * ext_call.return_data[0]
                while idx < stor118.length - 1:
                    require idx < mem[ceil32(return_data.size) + 96]
                    require idx + 1 < mem[ceil32(return_data.size) + 96]
                    _249 = mem[(32 * idx + 1) + ceil32(return_data.size) + 128]
                    mem[mem[64] + 4] = mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]
                    mem[mem[64] + 36] = address(_249)
                    require ext_code.size(stor117)
                    staticcall stor117.getPair(address rg1, address rg2) with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4], address(_249)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _261 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_261] == mem[_261 + 12 len 20]
                    require ext_code.size(mem[_261 + 12 len 20])
                    staticcall mem[_261 + 12 len 20].getReserves() with:
                            gas gas_remaining wei
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _273 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    require mem[_273] == mem[_273 + 18 len 14]
                    require mem[_273 + 32] == mem[_273 + 50 len 14]
                    require mem[_273 + 64] == mem[_273 + 92 len 4]
                    require idx < mem[ceil32(return_data.size) + 96]
                    require idx + 1 < mem[ceil32(return_data.size) + 96]
                    if mem[(32 * idx + 1) + ceil32(return_data.size) + 140 len 20] < mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]:
                        if not s:
                            if mem[_273 + 50 len 14]:
                                idx = idx + 1
                                s = 0 / mem[_273 + 50 len 14]
                                continue 
                        else:
                            if mem[_273 + 18 len 14] * s / s != mem[_273 + 18 len 14]:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if mem[_273 + 50 len 14]:
                                idx = idx + 1
                                s = mem[_273 + 18 len 14] * s / mem[_273 + 50 len 14]
                                continue 
                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_273')), 14)))
                    else:
                        if not s:
                            if mem[_273 + 18 len 14]:
                                idx = idx + 1
                                s = 0 / mem[_273 + 18 len 14]
                                continue 
                        else:
                            if mem[_273 + 50 len 14] * s / s != mem[_273 + 50 len 14]:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if mem[_273 + 18 len 14]:
                                idx = idx + 1
                                s = mem[_273 + 50 len 14] * s / mem[_273 + 18 len 14]
                                continue 
                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_273')), 14)))
                    revert
    return s
}

function rewardPerToken() payable {
    if 0 == totalSupply:
        return rewardPerTokenStored
    if 0 == begin:
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero', 0
        if (0 / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
            revert with 0, 'SafeMath: addition overflow'
        return ((0 / totalSupply) + rewardPerTokenStored)
    if begin >= block.timestamp:
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero', 0
        if (0 / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
            revert with 0, 'SafeMath: addition overflow'
        return ((0 / totalSupply) + rewardPerTokenStored)
    if lastUpdateTime >= block.timestamp:
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero', 0
        if (0 / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
            revert with 0, 'SafeMath: addition overflow'
        return ((0 / totalSupply) + rewardPerTokenStored)
    require ext_code.size(rewardsTokenAddress)
    staticcall rewardsTokenAddress.0xdd62ed3e with:
            gas gas_remaining wei
           args rewardsDistributionAddress, this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(rewardsTokenAddress)
    staticcall rewardsTokenAddress.0x70a08231 with:
            gas gas_remaining wei
           args rewardsDistributionAddress
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] <= stor42D0:
        if lep != 3:
            if lep != 2:
                if block.timestamp >= periodFinish:
                    if uint256(storFE82.field_0):
                        if storE5FC > 10^18:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if (0 / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                        revert with 0, 'SafeMath: addition overflow'
                    return ((0 / totalSupply) + rewardPerTokenStored)
                if lastUpdateTime > periodFinish:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if lastUpdateTime > block.timestamp:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if not periodFinish - lastUpdateTime:
                    revert with 0, 'SafeMath: division by zero', 0
                if not uint256(storFE82.field_0):
                    if not 0 / periodFinish - lastUpdateTime:
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero', 0
                        if (0 / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                            revert with 0, 'SafeMath: addition overflow'
                        return ((0 / totalSupply) + rewardPerTokenStored)
                    if 10^18 * 0 / periodFinish - lastUpdateTime / 0 / periodFinish - lastUpdateTime != 10^18:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if (10^18 * 0 / periodFinish - lastUpdateTime / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                        revert with 0, 'SafeMath: addition overflow'
                    return ((10^18 * 0 / periodFinish - lastUpdateTime / totalSupply) + rewardPerTokenStored)
                if storE5FC > 10^18:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if not 0 / periodFinish - lastUpdateTime:
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if (0 / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                        revert with 0, 'SafeMath: addition overflow'
                    return ((0 / totalSupply) + rewardPerTokenStored)
                if (10^18 * 0 / periodFinish - lastUpdateTime) - (storE5FC * 0 / periodFinish - lastUpdateTime) / 0 / periodFinish - lastUpdateTime != -storE5FC + 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not (10^18 * 0 / periodFinish - lastUpdateTime) - (storE5FC * 0 / periodFinish - lastUpdateTime) / 10^18:
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if (0 / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                        revert with 0, 'SafeMath: addition overflow'
                    return ((0 / totalSupply) + rewardPerTokenStored)
                if 10^18 * (10^18 * 0 / periodFinish - lastUpdateTime) - (storE5FC * 0 / periodFinish - lastUpdateTime) / 10^18 / (10^18 * 0 / periodFinish - lastUpdateTime) - (storE5FC * 0 / periodFinish - lastUpdateTime) / 10^18 != 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if (10^18 * (10^18 * 0 / periodFinish - lastUpdateTime) - (storE5FC * 0 / periodFinish - lastUpdateTime) / 10^18 / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                    revert with 0, 'SafeMath: addition overflow'
                return ((10^18 * (10^18 * 0 / periodFinish - lastUpdateTime) - (storE5FC * 0 / periodFinish - lastUpdateTime) / 10^18 / totalSupply) + rewardPerTokenStored)
            if lastUpdateTime > block.timestamp:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if block.timestamp - lastUpdateTime >= rewardsDuration:
                if uint256(storFE82.field_0):
                    if storE5FC > 10^18:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if (0 / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                    revert with 0, 'SafeMath: addition overflow'
                return ((0 / totalSupply) + rewardPerTokenStored)
            if lastUpdateTime > block.timestamp:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if not rewardsDuration:
                revert with 0, 'SafeMath: division by zero', 0
            if not uint256(storFE82.field_0):
                if not 0 / rewardsDuration:
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if (0 / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                        revert with 0, 'SafeMath: addition overflow'
                    return ((0 / totalSupply) + rewardPerTokenStored)
                if 10^18 * 0 / rewardsDuration / 0 / rewardsDuration != 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if (10^18 * 0 / rewardsDuration / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                    revert with 0, 'SafeMath: addition overflow'
                return ((10^18 * 0 / rewardsDuration / totalSupply) + rewardPerTokenStored)
            if storE5FC > 10^18:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if not 0 / rewardsDuration:
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if (0 / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                    revert with 0, 'SafeMath: addition overflow'
                return ((0 / totalSupply) + rewardPerTokenStored)
            if (10^18 * 0 / rewardsDuration) - (storE5FC * 0 / rewardsDuration) / 0 / rewardsDuration != -storE5FC + 10^18:
                revert with 0, 'SafeMath: multiplication overflow'
            if not (10^18 * 0 / rewardsDuration) - (storE5FC * 0 / rewardsDuration) / 10^18:
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if (0 / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                    revert with 0, 'SafeMath: addition overflow'
                return ((0 / totalSupply) + rewardPerTokenStored)
            if 10^18 * (10^18 * 0 / rewardsDuration) - (storE5FC * 0 / rewardsDuration) / 10^18 / (10^18 * 0 / rewardsDuration) - (storE5FC * 0 / rewardsDuration) / 10^18 != 10^18:
                revert with 0, 'SafeMath: multiplication overflow'
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if (10^18 * (10^18 * 0 / rewardsDuration) - (storE5FC * 0 / rewardsDuration) / 10^18 / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                revert with 0, 'SafeMath: addition overflow'
            return ((10^18 * (10^18 * 0 / rewardsDuration) - (storE5FC * 0 / rewardsDuration) / 10^18 / totalSupply) + rewardPerTokenStored)
        if rewardsDuration + block.timestamp < block.timestamp:
            revert with 0, 'SafeMath: addition overflow'
        if begin > rewardsDuration + block.timestamp:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if rewardsDuration + lastUpdateTime < lastUpdateTime:
            revert with 0, 'SafeMath: addition overflow'
        if begin > rewardsDuration + lastUpdateTime:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if not rewardsDuration + block.timestamp - begin:
            revert with 0, 'SafeMath: division by zero', 0
        if 0 / rewardsDuration + block.timestamp - begin > 0:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if not uint256(storFE82.field_0):
            if not -0 / rewardsDuration + block.timestamp - begin:
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if (0 / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                    revert with 0, 'SafeMath: addition overflow'
                return ((0 / totalSupply) + rewardPerTokenStored)
            if -1 * 10^18 * 0 / rewardsDuration + block.timestamp - begin / -0 / rewardsDuration + block.timestamp - begin != 10^18:
                revert with 0, 'SafeMath: multiplication overflow'
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if (-1 * 10^18 * 0 / rewardsDuration + block.timestamp - begin / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                revert with 0, 'SafeMath: addition overflow'
            return ((-1 * 10^18 * 0 / rewardsDuration + block.timestamp - begin / totalSupply) + rewardPerTokenStored)
        if storE5FC > 10^18:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if not -0 / rewardsDuration + block.timestamp - begin:
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if (0 / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                revert with 0, 'SafeMath: addition overflow'
            return ((0 / totalSupply) + rewardPerTokenStored)
        if (-1 * 10^18 * 0 / rewardsDuration + block.timestamp - begin) + (storE5FC * 0 / rewardsDuration + block.timestamp - begin) / -0 / rewardsDuration + block.timestamp - begin != -storE5FC + 10^18:
            revert with 0, 'SafeMath: multiplication overflow'
        if not (-1 * 10^18 * 0 / rewardsDuration + block.timestamp - begin) + (storE5FC * 0 / rewardsDuration + block.timestamp - begin) / 10^18:
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if (0 / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                revert with 0, 'SafeMath: addition overflow'
            return ((0 / totalSupply) + rewardPerTokenStored)
        if 10^18 * (-1 * 10^18 * 0 / rewardsDuration + block.timestamp - begin) + (storE5FC * 0 / rewardsDuration + block.timestamp - begin) / 10^18 / (-1 * 10^18 * 0 / rewardsDuration + block.timestamp - begin) + (storE5FC * 0 / rewardsDuration + block.timestamp - begin) / 10^18 != 10^18:
            revert with 0, 'SafeMath: multiplication overflow'
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero', 0
        if (10^18 * (-1 * 10^18 * 0 / rewardsDuration + block.timestamp - begin) + (storE5FC * 0 / rewardsDuration + block.timestamp - begin) / 10^18 / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
            revert with 0, 'SafeMath: addition overflow'
        return ((10^18 * (-1 * 10^18 * 0 / rewardsDuration + block.timestamp - begin) + (storE5FC * 0 / rewardsDuration + block.timestamp - begin) / 10^18 / totalSupply) + rewardPerTokenStored)
    if lep != 3:
        if lep != 2:
            if block.timestamp >= periodFinish:
                if lastUpdateTime >= periodFinish:
                    if uint256(storFE82.field_0):
                        if storE5FC > 10^18:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if (0 / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                        revert with 0, 'SafeMath: addition overflow'
                    return ((0 / totalSupply) + rewardPerTokenStored)
                if not uint256(storFE82.field_0):
                    if not ext_call.return_data[0] - stor42D0:
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero', 0
                        if (0 / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                            revert with 0, 'SafeMath: addition overflow'
                        return ((0 / totalSupply) + rewardPerTokenStored)
                    if (10^18 * ext_call.return_data[0]) - (10^18 * stor42D0) / ext_call.return_data[0] - stor42D0 != 10^18:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if ((10^18 * ext_call.return_data[0]) - (10^18 * stor42D0) / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                        revert with 0, 'SafeMath: addition overflow'
                    return (((10^18 * ext_call.return_data[0]) - (10^18 * stor42D0) / totalSupply) + rewardPerTokenStored)
                if storE5FC > 10^18:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if not ext_call.return_data[0] - stor42D0:
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if (0 / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                        revert with 0, 'SafeMath: addition overflow'
                    return ((0 / totalSupply) + rewardPerTokenStored)
                if (10^18 * ext_call.return_data[0]) - (10^18 * stor42D0) - (ext_call.return_data[0] * storE5FC) + (stor42D0 * storE5FC) / ext_call.return_data[0] - stor42D0 != -storE5FC + 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not (10^18 * ext_call.return_data[0]) - (10^18 * stor42D0) - (ext_call.return_data[0] * storE5FC) + (stor42D0 * storE5FC) / 10^18:
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if (0 / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                        revert with 0, 'SafeMath: addition overflow'
                    return ((0 / totalSupply) + rewardPerTokenStored)
                if 10^18 * (10^18 * ext_call.return_data[0]) - (10^18 * stor42D0) - (ext_call.return_data[0] * storE5FC) + (stor42D0 * storE5FC) / 10^18 / (10^18 * ext_call.return_data[0]) - (10^18 * stor42D0) - (ext_call.return_data[0] * storE5FC) + (stor42D0 * storE5FC) / 10^18 != 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if (10^18 * (10^18 * ext_call.return_data[0]) - (10^18 * stor42D0) - (ext_call.return_data[0] * storE5FC) + (stor42D0 * storE5FC) / 10^18 / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                    revert with 0, 'SafeMath: addition overflow'
                return ((10^18 * (10^18 * ext_call.return_data[0]) - (10^18 * stor42D0) - (ext_call.return_data[0] * storE5FC) + (stor42D0 * storE5FC) / 10^18 / totalSupply) + rewardPerTokenStored)
            if lastUpdateTime > periodFinish:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if lastUpdateTime > block.timestamp:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if not ext_call.return_data[0] - stor42D0:
                if not periodFinish - lastUpdateTime:
                    revert with 0, 'SafeMath: division by zero', 0
                if not uint256(storFE82.field_0):
                    if not 0 / periodFinish - lastUpdateTime:
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero', 0
                        if (0 / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                            revert with 0, 'SafeMath: addition overflow'
                        return ((0 / totalSupply) + rewardPerTokenStored)
                    if 10^18 * 0 / periodFinish - lastUpdateTime / 0 / periodFinish - lastUpdateTime != 10^18:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if (10^18 * 0 / periodFinish - lastUpdateTime / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                        revert with 0, 'SafeMath: addition overflow'
                    return ((10^18 * 0 / periodFinish - lastUpdateTime / totalSupply) + rewardPerTokenStored)
                if storE5FC > 10^18:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if not 0 / periodFinish - lastUpdateTime:
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if (0 / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                        revert with 0, 'SafeMath: addition overflow'
                    return ((0 / totalSupply) + rewardPerTokenStored)
                if (10^18 * 0 / periodFinish - lastUpdateTime) - (storE5FC * 0 / periodFinish - lastUpdateTime) / 0 / periodFinish - lastUpdateTime != -storE5FC + 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not (10^18 * 0 / periodFinish - lastUpdateTime) - (storE5FC * 0 / periodFinish - lastUpdateTime) / 10^18:
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if (0 / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                        revert with 0, 'SafeMath: addition overflow'
                    return ((0 / totalSupply) + rewardPerTokenStored)
                if 10^18 * (10^18 * 0 / periodFinish - lastUpdateTime) - (storE5FC * 0 / periodFinish - lastUpdateTime) / 10^18 / (10^18 * 0 / periodFinish - lastUpdateTime) - (storE5FC * 0 / periodFinish - lastUpdateTime) / 10^18 != 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if (10^18 * (10^18 * 0 / periodFinish - lastUpdateTime) - (storE5FC * 0 / periodFinish - lastUpdateTime) / 10^18 / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                    revert with 0, 'SafeMath: addition overflow'
                return ((10^18 * (10^18 * 0 / periodFinish - lastUpdateTime) - (storE5FC * 0 / periodFinish - lastUpdateTime) / 10^18 / totalSupply) + rewardPerTokenStored)
            if (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / ext_call.return_data[0] - stor42D0 != block.timestamp - lastUpdateTime:
                revert with 0, 'SafeMath: multiplication overflow'
            if not periodFinish - lastUpdateTime:
                revert with 0, 'SafeMath: division by zero', 0
            if not uint256(storFE82.field_0):
                if not (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / periodFinish - lastUpdateTime:
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if (0 / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                        revert with 0, 'SafeMath: addition overflow'
                    return ((0 / totalSupply) + rewardPerTokenStored)
                if 10^18 * (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / periodFinish - lastUpdateTime / (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / periodFinish - lastUpdateTime != 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if (10^18 * (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / periodFinish - lastUpdateTime / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                    revert with 0, 'SafeMath: addition overflow'
                return ((10^18 * (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / periodFinish - lastUpdateTime / totalSupply) + rewardPerTokenStored)
            if storE5FC > 10^18:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if not (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / periodFinish - lastUpdateTime:
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if (0 / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                    revert with 0, 'SafeMath: addition overflow'
                return ((0 / totalSupply) + rewardPerTokenStored)
            if (10^18 * (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / periodFinish - lastUpdateTime) - (storE5FC * (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / periodFinish - lastUpdateTime) / (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / periodFinish - lastUpdateTime != -storE5FC + 10^18:
                revert with 0, 'SafeMath: multiplication overflow'
            if not (10^18 * (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / periodFinish - lastUpdateTime) - (storE5FC * (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / periodFinish - lastUpdateTime) / 10^18:
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if (0 / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                    revert with 0, 'SafeMath: addition overflow'
                return ((0 / totalSupply) + rewardPerTokenStored)
            if 10^18 * (10^18 * (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / periodFinish - lastUpdateTime) - (storE5FC * (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / periodFinish - lastUpdateTime) / 10^18 / (10^18 * (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / periodFinish - lastUpdateTime) - (storE5FC * (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / periodFinish - lastUpdateTime) / 10^18 != 10^18:
                revert with 0, 'SafeMath: multiplication overflow'
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if (10^18 * (10^18 * (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / periodFinish - lastUpdateTime) - (storE5FC * (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / periodFinish - lastUpdateTime) / 10^18 / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                revert with 0, 'SafeMath: addition overflow'
            return ((10^18 * (10^18 * (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / periodFinish - lastUpdateTime) - (storE5FC * (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / periodFinish - lastUpdateTime) / 10^18 / totalSupply) + rewardPerTokenStored)
        if lastUpdateTime > block.timestamp:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if block.timestamp - lastUpdateTime >= rewardsDuration:
            if not uint256(storFE82.field_0):
                if not ext_call.return_data[0] - stor42D0:
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if (0 / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                        revert with 0, 'SafeMath: addition overflow'
                    return ((0 / totalSupply) + rewardPerTokenStored)
                if (10^18 * ext_call.return_data[0]) - (10^18 * stor42D0) / ext_call.return_data[0] - stor42D0 != 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if ((10^18 * ext_call.return_data[0]) - (10^18 * stor42D0) / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                    revert with 0, 'SafeMath: addition overflow'
                return (((10^18 * ext_call.return_data[0]) - (10^18 * stor42D0) / totalSupply) + rewardPerTokenStored)
            if storE5FC > 10^18:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if not ext_call.return_data[0] - stor42D0:
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if (0 / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                    revert with 0, 'SafeMath: addition overflow'
                return ((0 / totalSupply) + rewardPerTokenStored)
            if (10^18 * ext_call.return_data[0]) - (10^18 * stor42D0) - (ext_call.return_data[0] * storE5FC) + (stor42D0 * storE5FC) / ext_call.return_data[0] - stor42D0 != -storE5FC + 10^18:
                revert with 0, 'SafeMath: multiplication overflow'
            if not (10^18 * ext_call.return_data[0]) - (10^18 * stor42D0) - (ext_call.return_data[0] * storE5FC) + (stor42D0 * storE5FC) / 10^18:
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if (0 / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                    revert with 0, 'SafeMath: addition overflow'
                return ((0 / totalSupply) + rewardPerTokenStored)
            if 10^18 * (10^18 * ext_call.return_data[0]) - (10^18 * stor42D0) - (ext_call.return_data[0] * storE5FC) + (stor42D0 * storE5FC) / 10^18 / (10^18 * ext_call.return_data[0]) - (10^18 * stor42D0) - (ext_call.return_data[0] * storE5FC) + (stor42D0 * storE5FC) / 10^18 != 10^18:
                revert with 0, 'SafeMath: multiplication overflow'
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if (10^18 * (10^18 * ext_call.return_data[0]) - (10^18 * stor42D0) - (ext_call.return_data[0] * storE5FC) + (stor42D0 * storE5FC) / 10^18 / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                revert with 0, 'SafeMath: addition overflow'
            return ((10^18 * (10^18 * ext_call.return_data[0]) - (10^18 * stor42D0) - (ext_call.return_data[0] * storE5FC) + (stor42D0 * storE5FC) / 10^18 / totalSupply) + rewardPerTokenStored)
        if lastUpdateTime > block.timestamp:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if not ext_call.return_data[0] - stor42D0:
            if not rewardsDuration:
                revert with 0, 'SafeMath: division by zero', 0
            if not uint256(storFE82.field_0):
                if not 0 / rewardsDuration:
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if (0 / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                        revert with 0, 'SafeMath: addition overflow'
                    return ((0 / totalSupply) + rewardPerTokenStored)
                if 10^18 * 0 / rewardsDuration / 0 / rewardsDuration != 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if (10^18 * 0 / rewardsDuration / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                    revert with 0, 'SafeMath: addition overflow'
                return ((10^18 * 0 / rewardsDuration / totalSupply) + rewardPerTokenStored)
            if storE5FC > 10^18:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if not 0 / rewardsDuration:
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if (0 / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                    revert with 0, 'SafeMath: addition overflow'
                return ((0 / totalSupply) + rewardPerTokenStored)
            if (10^18 * 0 / rewardsDuration) - (storE5FC * 0 / rewardsDuration) / 0 / rewardsDuration != -storE5FC + 10^18:
                revert with 0, 'SafeMath: multiplication overflow'
            if not (10^18 * 0 / rewardsDuration) - (storE5FC * 0 / rewardsDuration) / 10^18:
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if (0 / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                    revert with 0, 'SafeMath: addition overflow'
                return ((0 / totalSupply) + rewardPerTokenStored)
            if 10^18 * (10^18 * 0 / rewardsDuration) - (storE5FC * 0 / rewardsDuration) / 10^18 / (10^18 * 0 / rewardsDuration) - (storE5FC * 0 / rewardsDuration) / 10^18 != 10^18:
                revert with 0, 'SafeMath: multiplication overflow'
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if (10^18 * (10^18 * 0 / rewardsDuration) - (storE5FC * 0 / rewardsDuration) / 10^18 / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                revert with 0, 'SafeMath: addition overflow'
            return ((10^18 * (10^18 * 0 / rewardsDuration) - (storE5FC * 0 / rewardsDuration) / 10^18 / totalSupply) + rewardPerTokenStored)
        if (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / ext_call.return_data[0] - stor42D0 != block.timestamp - lastUpdateTime:
            revert with 0, 'SafeMath: multiplication overflow'
        if not rewardsDuration:
            revert with 0, 'SafeMath: division by zero', 0
        if not uint256(storFE82.field_0):
            if not (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / rewardsDuration:
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if (0 / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                    revert with 0, 'SafeMath: addition overflow'
                return ((0 / totalSupply) + rewardPerTokenStored)
            if 10^18 * (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / rewardsDuration / (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / rewardsDuration != 10^18:
                revert with 0, 'SafeMath: multiplication overflow'
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if (10^18 * (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / rewardsDuration / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                revert with 0, 'SafeMath: addition overflow'
            return ((10^18 * (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / rewardsDuration / totalSupply) + rewardPerTokenStored)
        if storE5FC > 10^18:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if not (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / rewardsDuration:
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if (0 / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                revert with 0, 'SafeMath: addition overflow'
            return ((0 / totalSupply) + rewardPerTokenStored)
        if (10^18 * (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / rewardsDuration) - (storE5FC * (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / rewardsDuration) / (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / rewardsDuration != -storE5FC + 10^18:
            revert with 0, 'SafeMath: multiplication overflow'
        if not (10^18 * (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / rewardsDuration) - (storE5FC * (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / rewardsDuration) / 10^18:
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if (0 / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                revert with 0, 'SafeMath: addition overflow'
            return ((0 / totalSupply) + rewardPerTokenStored)
        if 10^18 * (10^18 * (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / rewardsDuration) - (storE5FC * (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / rewardsDuration) / 10^18 / (10^18 * (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / rewardsDuration) - (storE5FC * (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / rewardsDuration) / 10^18 != 10^18:
            revert with 0, 'SafeMath: multiplication overflow'
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero', 0
        if (10^18 * (10^18 * (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / rewardsDuration) - (storE5FC * (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / rewardsDuration) / 10^18 / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
            revert with 0, 'SafeMath: addition overflow'
        return ((10^18 * (10^18 * (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / rewardsDuration) - (storE5FC * (ext_call.return_data[0] * block.timestamp) - (stor42D0 * block.timestamp) - (ext_call.return_data[0] * lastUpdateTime) + (stor42D0 * lastUpdateTime) / rewardsDuration) / 10^18 / totalSupply) + rewardPerTokenStored)
    if rewardsDuration + block.timestamp < block.timestamp:
        revert with 0, 'SafeMath: addition overflow'
    if begin > rewardsDuration + block.timestamp:
        revert with 0, 'SafeMath: subtraction overflow', 0
    if rewardsDuration + lastUpdateTime < lastUpdateTime:
        revert with 0, 'SafeMath: addition overflow'
    if begin > rewardsDuration + lastUpdateTime:
        revert with 0, 'SafeMath: subtraction overflow', 0
    if not ext_call.return_data[0] - stor42D0:
        if not rewardsDuration + block.timestamp - begin:
            revert with 0, 'SafeMath: division by zero', 0
        if 0 / rewardsDuration + block.timestamp - begin > ext_call.return_data[0] - stor42D0:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if not uint256(storFE82.field_0):
            if not ext_call.return_data[0] - stor42D0 - (0 / rewardsDuration + block.timestamp - begin):
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if (0 / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                    revert with 0, 'SafeMath: addition overflow'
                return ((0 / totalSupply) + rewardPerTokenStored)
            if (10^18 * ext_call.return_data[0]) - (10^18 * stor42D0) - (10^18 * 0 / rewardsDuration + block.timestamp - begin) / ext_call.return_data[0] - stor42D0 - (0 / rewardsDuration + block.timestamp - begin) != 10^18:
                revert with 0, 'SafeMath: multiplication overflow'
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if ((10^18 * ext_call.return_data[0]) - (10^18 * stor42D0) - (10^18 * 0 / rewardsDuration + block.timestamp - begin) / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                revert with 0, 'SafeMath: addition overflow'
            return (((10^18 * ext_call.return_data[0]) - (10^18 * stor42D0) - (10^18 * 0 / rewardsDuration + block.timestamp - begin) / totalSupply) + rewardPerTokenStored)
        if storE5FC > 10^18:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if not ext_call.return_data[0] - stor42D0 - (0 / rewardsDuration + block.timestamp - begin):
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if (0 / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                revert with 0, 'SafeMath: addition overflow'
            return ((0 / totalSupply) + rewardPerTokenStored)
        if (10^18 * ext_call.return_data[0]) - (10^18 * stor42D0) - (10^18 * 0 / rewardsDuration + block.timestamp - begin) - (ext_call.return_data[0] * storE5FC) + (stor42D0 * storE5FC) + (0 / rewardsDuration + block.timestamp - begin * storE5FC) / ext_call.return_data[0] - stor42D0 - (0 / rewardsDuration + block.timestamp - begin) != -storE5FC + 10^18:
            revert with 0, 'SafeMath: multiplication overflow'
        if not (10^18 * ext_call.return_data[0]) - (10^18 * stor42D0) - (10^18 * 0 / rewardsDuration + block.timestamp - begin) - (ext_call.return_data[0] * storE5FC) + (stor42D0 * storE5FC) + (0 / rewardsDuration + block.timestamp - begin * storE5FC) / 10^18:
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if (0 / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                revert with 0, 'SafeMath: addition overflow'
            return ((0 / totalSupply) + rewardPerTokenStored)
        if 10^18 * (10^18 * ext_call.return_data[0]) - (10^18 * stor42D0) - (10^18 * 0 / rewardsDuration + block.timestamp - begin) - (ext_call.return_data[0] * storE5FC) + (stor42D0 * storE5FC) + (0 / rewardsDuration + block.timestamp - begin * storE5FC) / 10^18 / (10^18 * ext_call.return_data[0]) - (10^18 * stor42D0) - (10^18 * 0 / rewardsDuration + block.timestamp - begin) - (ext_call.return_data[0] * storE5FC) + (stor42D0 * storE5FC) + (0 / rewardsDuration + block.timestamp - begin * storE5FC) / 10^18 != 10^18:
            revert with 0, 'SafeMath: multiplication overflow'
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero', 0
        if (10^18 * (10^18 * ext_call.return_data[0]) - (10^18 * stor42D0) - (10^18 * 0 / rewardsDuration + block.timestamp - begin) - (ext_call.return_data[0] * storE5FC) + (stor42D0 * storE5FC) + (0 / rewardsDuration + block.timestamp - begin * storE5FC) / 10^18 / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
            revert with 0, 'SafeMath: addition overflow'
        return ((10^18 * (10^18 * ext_call.return_data[0]) - (10^18 * stor42D0) - (10^18 * 0 / rewardsDuration + block.timestamp - begin) - (ext_call.return_data[0] * storE5FC) + (stor42D0 * storE5FC) + (0 / rewardsDuration + block.timestamp - begin * storE5FC) / 10^18 / totalSupply) + rewardPerTokenStored)
    if (ext_call.return_data[0] * rewardsDuration) - (stor42D0 * rewardsDuration) + (ext_call.return_data[0] * lastUpdateTime) - (stor42D0 * lastUpdateTime) - (ext_call.return_data[0] * begin) + (stor42D0 * begin) / ext_call.return_data[0] - stor42D0 != rewardsDuration + lastUpdateTime - begin:
        revert with 0, 'SafeMath: multiplication overflow'
    if not rewardsDuration + block.timestamp - begin:
        revert with 0, 'SafeMath: division by zero', 0
    if (ext_call.return_data[0] * rewardsDuration) - (stor42D0 * rewardsDuration) + (ext_call.return_data[0] * lastUpdateTime) - (stor42D0 * lastUpdateTime) - (ext_call.return_data[0] * begin) + (stor42D0 * begin) / rewardsDuration + block.timestamp - begin > ext_call.return_data[0] - stor42D0:
        revert with 0, 'SafeMath: subtraction overflow', 0
    if not uint256(storFE82.field_0):
        if not ext_call.return_data[0] - stor42D0 - ((ext_call.return_data[0] * rewardsDuration) - (stor42D0 * rewardsDuration) + (ext_call.return_data[0] * lastUpdateTime) - (stor42D0 * lastUpdateTime) - (ext_call.return_data[0] * begin) + (stor42D0 * begin) / rewardsDuration + block.timestamp - begin):
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if (0 / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
                revert with 0, 'SafeMath: addition overflow'
            return ((0 / totalSupply) + rewardPerTokenStored)
        if (10^18 * ext_call.return_data[0]) - (10^18 * stor42D0) - (10^18 * (ext_call.return_data[0] * rewardsDuration) - (stor42D0 * rewardsDuration) + (ext_call.return_data[0] * lastUpdateTime) - (stor42D0 * lastUpdateTime) - (ext_call.return_data[0] * begin) + (stor42D0 * begin) / rewardsDuration + block.timestamp - begin) / ext_call.return_data[0] - stor42D0 - ((ext_call.return_data[0] * rewardsDuration) - (stor42D0 * rewardsDuration) + (ext_call.return_data[0] * lastUpdateTime) - (stor42D0 * lastUpdateTime) - (ext_call.return_data[0] * begin) + (stor42D0 * begin) / rewardsDuration + block.timestamp - begin) != 10^18:
            revert with 0, 'SafeMath: multiplication overflow'
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero', 0
        if ((10^18 * ext_call.return_data[0]) - (10^18 * stor42D0) - (10^18 * (ext_call.return_data[0] * rewardsDuration) - (stor42D0 * rewardsDuration) + (ext_call.return_data[0] * lastUpdateTime) - (stor42D0 * lastUpdateTime) - (ext_call.return_data[0] * begin) + (stor42D0 * begin) / rewardsDuration + block.timestamp - begin) / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
            revert with 0, 'SafeMath: addition overflow'
        return (((10^18 * ext_call.return_data[0]) - (10^18 * stor42D0) - (10^18 * (ext_call.return_data[0] * rewardsDuration) - (stor42D0 * rewardsDuration) + (ext_call.return_data[0] * lastUpdateTime) - (stor42D0 * lastUpdateTime) - (ext_call.return_data[0] * begin) + (stor42D0 * begin) / rewardsDuration + block.timestamp - begin) / totalSupply) + rewardPerTokenStored)
    if storE5FC > 10^18:
        revert with 0, 'SafeMath: subtraction overflow', 0
    if not ext_call.return_data[0] - stor42D0 - ((ext_call.return_data[0] * rewardsDuration) - (stor42D0 * rewardsDuration) + (ext_call.return_data[0] * lastUpdateTime) - (stor42D0 * lastUpdateTime) - (ext_call.return_data[0] * begin) + (stor42D0 * begin) / rewardsDuration + block.timestamp - begin):
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero', 0
        if (0 / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
            revert with 0, 'SafeMath: addition overflow'
        return ((0 / totalSupply) + rewardPerTokenStored)
    if (10^18 * ext_call.return_data[0]) - (10^18 * stor42D0) - (10^18 * (ext_call.return_data[0] * rewardsDuration) - (stor42D0 * rewardsDuration) + (ext_call.return_data[0] * lastUpdateTime) - (stor42D0 * lastUpdateTime) - (ext_call.return_data[0] * begin) + (stor42D0 * begin) / rewardsDuration + block.timestamp - begin) - (ext_call.return_data[0] * storE5FC) + (stor42D0 * storE5FC) + ((ext_call.return_data[0] * rewardsDuration) - (stor42D0 * rewardsDuration) + (ext_call.return_data[0] * lastUpdateTime) - (stor42D0 * lastUpdateTime) - (ext_call.return_data[0] * begin) + (stor42D0 * begin) / rewardsDuration + block.timestamp - begin * storE5FC) / ext_call.return_data[0] - stor42D0 - ((ext_call.return_data[0] * rewardsDuration) - (stor42D0 * rewardsDuration) + (ext_call.return_data[0] * lastUpdateTime) - (stor42D0 * lastUpdateTime) - (ext_call.return_data[0] * begin) + (stor42D0 * begin) / rewardsDuration + block.timestamp - begin) != -storE5FC + 10^18:
        revert with 0, 'SafeMath: multiplication overflow'
    if not (10^18 * ext_call.return_data[0]) - (10^18 * stor42D0) - (10^18 * (ext_call.return_data[0] * rewardsDuration) - (stor42D0 * rewardsDuration) + (ext_call.return_data[0] * lastUpdateTime) - (stor42D0 * lastUpdateTime) - (ext_call.return_data[0] * begin) + (stor42D0 * begin) / rewardsDuration + block.timestamp - begin) - (ext_call.return_data[0] * storE5FC) + (stor42D0 * storE5FC) + ((ext_call.return_data[0] * rewardsDuration) - (stor42D0 * rewardsDuration) + (ext_call.return_data[0] * lastUpdateTime) - (stor42D0 * lastUpdateTime) - (ext_call.return_data[0] * begin) + (stor42D0 * begin) / rewardsDuration + block.timestamp - begin * storE5FC) / 10^18:
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero', 0
        if (0 / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
            revert with 0, 'SafeMath: addition overflow'
        return ((0 / totalSupply) + rewardPerTokenStored)
    if 10^18 * (10^18 * ext_call.return_data[0]) - (10^18 * stor42D0) - (10^18 * (ext_call.return_data[0] * rewardsDuration) - (stor42D0 * rewardsDuration) + (ext_call.return_data[0] * lastUpdateTime) - (stor42D0 * lastUpdateTime) - (ext_call.return_data[0] * begin) + (stor42D0 * begin) / rewardsDuration + block.timestamp - begin) - (ext_call.return_data[0] * storE5FC) + (stor42D0 * storE5FC) + ((ext_call.return_data[0] * rewardsDuration) - (stor42D0 * rewardsDuration) + (ext_call.return_data[0] * lastUpdateTime) - (stor42D0 * lastUpdateTime) - (ext_call.return_data[0] * begin) + (stor42D0 * begin) / rewardsDuration + block.timestamp - begin * storE5FC) / 10^18 / (10^18 * ext_call.return_data[0]) - (10^18 * stor42D0) - (10^18 * (ext_call.return_data[0] * rewardsDuration) - (stor42D0 * rewardsDuration) + (ext_call.return_data[0] * lastUpdateTime) - (stor42D0 * lastUpdateTime) - (ext_call.return_data[0] * begin) + (stor42D0 * begin) / rewardsDuration + block.timestamp - begin) - (ext_call.return_data[0] * storE5FC) + (stor42D0 * storE5FC) + ((ext_call.return_data[0] * rewardsDuration) - (stor42D0 * rewardsDuration) + (ext_call.return_data[0] * lastUpdateTime) - (stor42D0 * lastUpdateTime) - (ext_call.return_data[0] * begin) + (stor42D0 * begin) / rewardsDuration + block.timestamp - begin * storE5FC) / 10^18 != 10^18:
        revert with 0, 'SafeMath: multiplication overflow'
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if (10^18 * (10^18 * ext_call.return_data[0]) - (10^18 * stor42D0) - (10^18 * (ext_call.return_data[0] * rewardsDuration) - (stor42D0 * rewardsDuration) + (ext_call.return_data[0] * lastUpdateTime) - (stor42D0 * lastUpdateTime) - (ext_call.return_data[0] * begin) + (stor42D0 * begin) / rewardsDuration + block.timestamp - begin) - (ext_call.return_data[0] * storE5FC) + (stor42D0 * storE5FC) + ((ext_call.return_data[0] * rewardsDuration) - (stor42D0 * rewardsDuration) + (ext_call.return_data[0] * lastUpdateTime) - (stor42D0 * lastUpdateTime) - (ext_call.return_data[0] * begin) + (stor42D0 * begin) / rewardsDuration + block.timestamp - begin * storE5FC) / 10^18 / totalSupply) + rewardPerTokenStored < rewardPerTokenStored:
        revert with 0, 'SafeMath: addition overflow'
    return ((10^18 * (10^18 * ext_call.return_data[0]) - (10^18 * stor42D0) - (10^18 * (ext_call.return_data[0] * rewardsDuration) - (stor42D0 * rewardsDuration) + (ext_call.return_data[0] * lastUpdateTime) - (stor42D0 * lastUpdateTime) - (ext_call.return_data[0] * begin) + (stor42D0 * begin) / rewardsDuration + block.timestamp - begin) - (ext_call.return_data[0] * storE5FC) + (stor42D0 * storE5FC) + ((ext_call.return_data[0] * rewardsDuration) - (stor42D0 * rewardsDuration) + (ext_call.return_data[0] * lastUpdateTime) - (stor42D0 * lastUpdateTime) - (ext_call.return_data[0] * begin) + (stor42D0 * begin) / rewardsDuration + block.timestamp - begin * storE5FC) / 10^18 / totalSupply) + rewardPerTokenStored)
}

function APY() payable {
    mem[32] = 111
    mem[100] = rewardsDistributionAddress
    mem[132] = this.address
    require ext_code.size(rewardsTokenAddress)
    staticcall rewardsTokenAddress.0xdd62ed3e with:
            gas gas_remaining wei
           args rewardsDistributionAddress, this.address
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] <= stor42D0:
        if lep != 3:
            if 2 == lep:
                mem[ceil32(return_data.size) + 96] = 26
                mem[ceil32(return_data.size) + 128] = 'SafeMath: division by zero'
                if not rewardsDuration:
                    revert with 0, 'SafeMath: division by zero', 0
                require 0 < stor119.length
                mem[0] = 119
                require address(stor119.field_0) == rewardsTokenAddress
                mem[64] = ceil32(return_data.size) + (32 * stor119.length) + 192
                mem[ceil32(return_data.size) + 160] = stor119.length
                if not stor119.length:
                    idx = 0
                    s = 0 / rewardsDuration
                    while idx < stor119.length - 1:
                        require idx < mem[ceil32(return_data.size) + 160]
                        require idx + 1 < mem[ceil32(return_data.size) + 160]
                        _4461 = mem[(32 * idx + 1) + ceil32(return_data.size) + 192]
                        mem[mem[64] + 4] = mem[(32 * idx) + ceil32(return_data.size) + 204 len 20]
                        mem[mem[64] + 36] = address(_4461)
                        require ext_code.size(stor117)
                        staticcall stor117.getPair(address rg1, address rg2) with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4], address(_4461)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4589 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_4589] == mem[_4589 + 12 len 20]
                        require ext_code.size(mem[_4589 + 12 len 20])
                        staticcall mem[_4589 + 12 len 20].getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _5056 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        require mem[_5056] == mem[_5056 + 18 len 14]
                        require mem[_5056 + 32] == mem[_5056 + 50 len 14]
                        require mem[_5056 + 64] == mem[_5056 + 92 len 4]
                        require idx < mem[ceil32(return_data.size) + 160]
                        require idx + 1 < mem[ceil32(return_data.size) + 160]
                        if mem[(32 * idx + 1) + ceil32(return_data.size) + 204 len 20] < mem[(32 * idx) + ceil32(return_data.size) + 204 len 20]:
                            if not s:
                                if mem[_5056 + 50 len 14]:
                                    idx = idx + 1
                                    s = 0 / mem[_5056 + 50 len 14]
                                    continue 
                            else:
                                if mem[_5056 + 18 len 14] * s / s != mem[_5056 + 18 len 14]:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if mem[_5056 + 50 len 14]:
                                    idx = idx + 1
                                    s = mem[_5056 + 18 len 14] * s / mem[_5056 + 50 len 14]
                                    continue 
                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_5056')), 14)))
                        else:
                            if not s:
                                if mem[_5056 + 18 len 14]:
                                    idx = idx + 1
                                    s = 0 / mem[_5056 + 18 len 14]
                                    continue 
                            else:
                                if mem[_5056 + 50 len 14] * s / s != mem[_5056 + 50 len 14]:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if mem[_5056 + 18 len 14]:
                                    idx = idx + 1
                                    s = mem[_5056 + 50 len 14] * s / mem[_5056 + 18 len 14]
                                    continue 
                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_5056')), 14)))
                        revert
                    require stor118.length
                    mem[0] = 118
                    if address(stor118.field_0) == stakingTokenAddress:
                        _4669 = mem[64]
                        mem[64] = mem[64] + (32 * stor118.length) + 32
                        mem[_4669] = stor118.length
                        if not stor118.length:
                            idx = 0
                            t = totalSupply
                            while idx < stor118.length - 1:
                                require idx < mem[_4669]
                                require idx + 1 < mem[_4669]
                                _9131 = mem[(32 * idx + 1) + _4669 + 32]
                                mem[mem[64] + 4] = mem[(32 * idx) + _4669 + 44 len 20]
                                mem[mem[64] + 36] = address(_9131)
                                require ext_code.size(stor117)
                                staticcall stor117.getPair(address rg1, address rg2) with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4], address(_9131)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _9468 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_9468] == mem[_9468 + 12 len 20]
                                require ext_code.size(mem[_9468 + 12 len 20])
                                staticcall mem[_9468 + 12 len 20].getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10879 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10879] == mem[_10879 + 18 len 14]
                                require mem[_10879 + 32] == mem[_10879 + 50 len 14]
                                require mem[_10879 + 64] == mem[_10879 + 92 len 4]
                                require idx < mem[_4669]
                                require idx + 1 < mem[_4669]
                                if mem[(32 * idx + 1) + _4669 + 44 len 20] < mem[(32 * idx) + _4669 + 44 len 20]:
                                    if not t:
                                        if mem[_10879 + 50 len 14]:
                                            idx = idx + 1
                                            t = 0 / mem[_10879 + 50 len 14]
                                            continue 
                                    else:
                                        if mem[_10879 + 18 len 14] * t / t != mem[_10879 + 18 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_10879 + 50 len 14]:
                                            idx = idx + 1
                                            t = mem[_10879 + 18 len 14] * t / mem[_10879 + 50 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_10879')), 14)))
                                else:
                                    if not t:
                                        if mem[_10879 + 18 len 14]:
                                            idx = idx + 1
                                            t = 0 / mem[_10879 + 18 len 14]
                                            continue 
                                    else:
                                        if mem[_10879 + 50 len 14] * t / t != mem[_10879 + 50 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_10879 + 18 len 14]:
                                            idx = idx + 1
                                            t = mem[_10879 + 50 len 14] * t / mem[_10879 + 18 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_10879')), 14)))
                                revert
                        else:
                            mem[0] = 118
                            mem[_4669 + 32] = address(stor118.field_0)
                            idx = _4669 + 32
                            t = 0
                            while _4669 + (32 * stor118.length) > idx:
                                mem[idx + 32] = stor118[t].field_256
                                idx = idx + 32
                                t = t + 1
                                continue 
                            idx = 0
                            t = totalSupply
                            while idx < stor118.length - 1:
                                require idx < mem[_4669]
                                require idx + 1 < mem[_4669]
                                _20701 = mem[(32 * idx + 1) + _4669 + 32]
                                mem[mem[64] + 4] = mem[(32 * idx) + _4669 + 44 len 20]
                                mem[mem[64] + 36] = address(_20701)
                                require ext_code.size(stor117)
                                staticcall stor117.getPair(address rg1, address rg2) with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4], address(_20701)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _21080 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_21080] == mem[_21080 + 12 len 20]
                                require ext_code.size(mem[_21080 + 12 len 20])
                                staticcall mem[_21080 + 12 len 20].getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _22953 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_22953] == mem[_22953 + 18 len 14]
                                require mem[_22953 + 32] == mem[_22953 + 50 len 14]
                                require mem[_22953 + 64] == mem[_22953 + 92 len 4]
                                require idx < mem[_4669]
                                require idx + 1 < mem[_4669]
                                if mem[(32 * idx + 1) + _4669 + 44 len 20] < mem[(32 * idx) + _4669 + 44 len 20]:
                                    if not t:
                                        if mem[_22953 + 50 len 14]:
                                            idx = idx + 1
                                            t = 0 / mem[_22953 + 50 len 14]
                                            continue 
                                    else:
                                        if mem[_22953 + 18 len 14] * t / t != mem[_22953 + 18 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_22953 + 50 len 14]:
                                            idx = idx + 1
                                            t = mem[_22953 + 18 len 14] * t / mem[_22953 + 50 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_22953')), 14)))
                                else:
                                    if not t:
                                        if mem[_22953 + 18 len 14]:
                                            idx = idx + 1
                                            t = 0 / mem[_22953 + 18 len 14]
                                            continue 
                                    else:
                                        if mem[_22953 + 50 len 14] * t / t != mem[_22953 + 50 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_22953 + 18 len 14]:
                                            idx = idx + 1
                                            t = mem[_22953 + 50 len 14] * t / mem[_22953 + 18 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_22953')), 14)))
                                revert
                    else:
                        require stor118.length
                        require stor118.length
                        require address(stor118.field_0) != stakingTokenAddress
                        require 0 < stor118.length
                        mem[0] = 118
                        mem[mem[64] + 4] = stakingTokenAddress
                        require ext_code.size(address(stor118.field_0))
                        staticcall address(stor118.field_0).0x70a08231 with:
                                gas gas_remaining wei
                               args stakingTokenAddress
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _5055 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _5142 = mem[_5055]
                        if not mem[_5055]:
                            _5563 = mem[64]
                            mem[64] = mem[64] + (32 * stor118.length) + 32
                            mem[_5563] = stor118.length
                            if not stor118.length:
                                idx = 0
                                t = 0
                                while idx < stor118.length - 1:
                                    require idx < mem[_5563]
                                    require idx + 1 < mem[_5563]
                                    _9135 = mem[(32 * idx + 1) + _5563 + 32]
                                    mem[mem[64] + 4] = mem[(32 * idx) + _5563 + 44 len 20]
                                    mem[mem[64] + 36] = address(_9135)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_9135)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9472 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_9472] == mem[_9472 + 12 len 20]
                                    require ext_code.size(mem[_9472 + 12 len 20])
                                    staticcall mem[_9472 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10885 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_10885] == mem[_10885 + 18 len 14]
                                    require mem[_10885 + 32] == mem[_10885 + 50 len 14]
                                    require mem[_10885 + 64] == mem[_10885 + 92 len 4]
                                    require idx < mem[_5563]
                                    require idx + 1 < mem[_5563]
                                    if mem[(32 * idx + 1) + _5563 + 44 len 20] < mem[(32 * idx) + _5563 + 44 len 20]:
                                        if not t:
                                            if mem[_10885 + 50 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_10885 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_10885 + 18 len 14] * t / t != mem[_10885 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_10885 + 50 len 14]:
                                                idx = idx + 1
                                                t = mem[_10885 + 18 len 14] * t / mem[_10885 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_10885')), 14)))
                                    else:
                                        if not t:
                                            if mem[_10885 + 18 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_10885 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_10885 + 50 len 14] * t / t != mem[_10885 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_10885 + 18 len 14]:
                                                idx = idx + 1
                                                t = mem[_10885 + 50 len 14] * t / mem[_10885 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_10885')), 14)))
                                    revert
                            else:
                                mem[0] = 118
                                mem[_5563 + 32] = address(stor118.field_0)
                                idx = _5563 + 32
                                t = 0
                                while _5563 + (32 * stor118.length) > idx:
                                    mem[idx + 32] = stor118[t].field_256
                                    idx = idx + 32
                                    t = t + 1
                                    continue 
                                idx = 0
                                t = 0
                                while idx < stor118.length - 1:
                                    require idx < mem[_5563]
                                    require idx + 1 < mem[_5563]
                                    _20705 = mem[(32 * idx + 1) + _5563 + 32]
                                    mem[mem[64] + 4] = mem[(32 * idx) + _5563 + 44 len 20]
                                    mem[mem[64] + 36] = address(_20705)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_20705)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21084 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_21084] == mem[_21084 + 12 len 20]
                                    require ext_code.size(mem[_21084 + 12 len 20])
                                    staticcall mem[_21084 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _22959 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_22959] == mem[_22959 + 18 len 14]
                                    require mem[_22959 + 32] == mem[_22959 + 50 len 14]
                                    require mem[_22959 + 64] == mem[_22959 + 92 len 4]
                                    require idx < mem[_5563]
                                    require idx + 1 < mem[_5563]
                                    if mem[(32 * idx + 1) + _5563 + 44 len 20] < mem[(32 * idx) + _5563 + 44 len 20]:
                                        if not t:
                                            if mem[_22959 + 50 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_22959 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_22959 + 18 len 14] * t / t != mem[_22959 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_22959 + 50 len 14]:
                                                idx = idx + 1
                                                t = mem[_22959 + 18 len 14] * t / mem[_22959 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_22959')), 14)))
                                    else:
                                        if not t:
                                            if mem[_22959 + 18 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_22959 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_22959 + 50 len 14] * t / t != mem[_22959 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_22959 + 18 len 14]:
                                                idx = idx + 1
                                                t = mem[_22959 + 50 len 14] * t / mem[_22959 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_22959')), 14)))
                                    revert
                        else:
                            if 2 * mem[_5055] / mem[_5055] != 2:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _5695 = mem[64]
                            mem[64] = mem[64] + (32 * stor118.length) + 32
                            mem[_5695] = stor118.length
                            if not stor118.length:
                                idx = 0
                                t = 2 * _5142
                                while idx < stor118.length - 1:
                                    require idx < mem[_5695]
                                    require idx + 1 < mem[_5695]
                                    _9133 = mem[(32 * idx + 1) + _5695 + 32]
                                    mem[mem[64] + 4] = mem[(32 * idx) + _5695 + 44 len 20]
                                    mem[mem[64] + 36] = address(_9133)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_9133)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9470 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_9470] == mem[_9470 + 12 len 20]
                                    require ext_code.size(mem[_9470 + 12 len 20])
                                    staticcall mem[_9470 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10882 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_10882] == mem[_10882 + 18 len 14]
                                    require mem[_10882 + 32] == mem[_10882 + 50 len 14]
                                    require mem[_10882 + 64] == mem[_10882 + 92 len 4]
                                    require idx < mem[_5695]
                                    require idx + 1 < mem[_5695]
                                    if mem[(32 * idx + 1) + _5695 + 44 len 20] < mem[(32 * idx) + _5695 + 44 len 20]:
                                        if not t:
                                            if mem[_10882 + 50 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_10882 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_10882 + 18 len 14] * t / t != mem[_10882 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_10882 + 50 len 14]:
                                                idx = idx + 1
                                                t = mem[_10882 + 18 len 14] * t / mem[_10882 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_10882')), 14)))
                                    else:
                                        if not t:
                                            if mem[_10882 + 18 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_10882 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_10882 + 50 len 14] * t / t != mem[_10882 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_10882 + 18 len 14]:
                                                idx = idx + 1
                                                t = mem[_10882 + 50 len 14] * t / mem[_10882 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_10882')), 14)))
                                    revert
                            else:
                                mem[0] = 118
                                mem[_5695 + 32] = address(stor118.field_0)
                                idx = _5695 + 32
                                t = 0
                                while _5695 + (32 * stor118.length) > idx:
                                    mem[idx + 32] = stor118[t].field_256
                                    idx = idx + 32
                                    t = t + 1
                                    continue 
                                idx = 0
                                t = 2 * _5142
                                while idx < stor118.length - 1:
                                    require idx < mem[_5695]
                                    require idx + 1 < mem[_5695]
                                    _20703 = mem[(32 * idx + 1) + _5695 + 32]
                                    mem[mem[64] + 4] = mem[(32 * idx) + _5695 + 44 len 20]
                                    mem[mem[64] + 36] = address(_20703)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_20703)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21082 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_21082] == mem[_21082 + 12 len 20]
                                    require ext_code.size(mem[_21082 + 12 len 20])
                                    staticcall mem[_21082 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _22956 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_22956] == mem[_22956 + 18 len 14]
                                    require mem[_22956 + 32] == mem[_22956 + 50 len 14]
                                    require mem[_22956 + 64] == mem[_22956 + 92 len 4]
                                    require idx < mem[_5695]
                                    require idx + 1 < mem[_5695]
                                    if mem[(32 * idx + 1) + _5695 + 44 len 20] < mem[(32 * idx) + _5695 + 44 len 20]:
                                        if not t:
                                            if mem[_22956 + 50 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_22956 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_22956 + 18 len 14] * t / t != mem[_22956 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_22956 + 50 len 14]:
                                                idx = idx + 1
                                                t = mem[_22956 + 18 len 14] * t / mem[_22956 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_22956')), 14)))
                                    else:
                                        if not t:
                                            if mem[_22956 + 18 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_22956 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_22956 + 50 len 14] * t / t != mem[_22956 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_22956 + 18 len 14]:
                                                idx = idx + 1
                                                t = mem[_22956 + 50 len 14] * t / mem[_22956 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_22956')), 14)))
                                    revert
                else:
                    mem[0] = 119
                    mem[ceil32(return_data.size) + 192] = address(stor119.field_0)
                    if (32 * stor119.length) + 32 <= 64:
                        idx = 0
                        s = 0 / rewardsDuration
                        while idx < stor119.length - 1:
                            require idx < mem[ceil32(return_data.size) + 160]
                            require idx + 1 < mem[ceil32(return_data.size) + 160]
                            _4463 = mem[(32 * idx + 1) + ceil32(return_data.size) + 192]
                            mem[mem[64] + 4] = mem[(32 * idx) + ceil32(return_data.size) + 204 len 20]
                            mem[mem[64] + 36] = address(_4463)
                            require ext_code.size(stor117)
                            staticcall stor117.getPair(address rg1, address rg2) with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4], address(_4463)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4590 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_4590] == mem[_4590 + 12 len 20]
                            require ext_code.size(mem[_4590 + 12 len 20])
                            staticcall mem[_4590 + 12 len 20].getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _5060 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_5060] == mem[_5060 + 18 len 14]
                            require mem[_5060 + 32] == mem[_5060 + 50 len 14]
                            require mem[_5060 + 64] == mem[_5060 + 92 len 4]
                            require idx < mem[ceil32(return_data.size) + 160]
                            require idx + 1 < mem[ceil32(return_data.size) + 160]
                            if mem[(32 * idx + 1) + ceil32(return_data.size) + 204 len 20] < mem[(32 * idx) + ceil32(return_data.size) + 204 len 20]:
                                if not s:
                                    if mem[_5060 + 50 len 14]:
                                        idx = idx + 1
                                        s = 0 / mem[_5060 + 50 len 14]
                                        continue 
                                else:
                                    if mem[_5060 + 18 len 14] * s / s != mem[_5060 + 18 len 14]:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if mem[_5060 + 50 len 14]:
                                        idx = idx + 1
                                        s = mem[_5060 + 18 len 14] * s / mem[_5060 + 50 len 14]
                                        continue 
                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_5060')), 14)))
                            else:
                                if not s:
                                    if mem[_5060 + 18 len 14]:
                                        idx = idx + 1
                                        s = 0 / mem[_5060 + 18 len 14]
                                        continue 
                                else:
                                    if mem[_5060 + 50 len 14] * s / s != mem[_5060 + 50 len 14]:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if mem[_5060 + 18 len 14]:
                                        idx = idx + 1
                                        s = mem[_5060 + 50 len 14] * s / mem[_5060 + 18 len 14]
                                        continue 
                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_5060')), 14)))
                            revert
                        require stor118.length
                        mem[0] = 118
                        if address(stor118.field_0) == stakingTokenAddress:
                            _4671 = mem[64]
                            mem[64] = mem[64] + (32 * stor118.length) + 32
                            mem[_4671] = stor118.length
                            if not stor118.length:
                                idx = 0
                                t = totalSupply
                                while idx < stor118.length - 1:
                                    require idx < mem[_4671]
                                    require idx + 1 < mem[_4671]
                                    _9138 = mem[(32 * idx + 1) + _4671 + 32]
                                    mem[mem[64] + 4] = mem[(32 * idx) + _4671 + 44 len 20]
                                    mem[mem[64] + 36] = address(_9138)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_9138)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9475 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_9475] == mem[_9475 + 12 len 20]
                                    require ext_code.size(mem[_9475 + 12 len 20])
                                    staticcall mem[_9475 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10892 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_10892] == mem[_10892 + 18 len 14]
                                    require mem[_10892 + 32] == mem[_10892 + 50 len 14]
                                    require mem[_10892 + 64] == mem[_10892 + 92 len 4]
                                    require idx < mem[_4671]
                                    require idx + 1 < mem[_4671]
                                    if mem[(32 * idx + 1) + _4671 + 44 len 20] < mem[(32 * idx) + _4671 + 44 len 20]:
                                        if not t:
                                            if mem[_10892 + 50 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_10892 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_10892 + 18 len 14] * t / t != mem[_10892 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_10892 + 50 len 14]:
                                                idx = idx + 1
                                                t = mem[_10892 + 18 len 14] * t / mem[_10892 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_10892')), 14)))
                                    else:
                                        if not t:
                                            if mem[_10892 + 18 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_10892 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_10892 + 50 len 14] * t / t != mem[_10892 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_10892 + 18 len 14]:
                                                idx = idx + 1
                                                t = mem[_10892 + 50 len 14] * t / mem[_10892 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_10892')), 14)))
                                    revert
                            else:
                                mem[0] = 118
                                mem[_4671 + 32] = address(stor118.field_0)
                                idx = _4671 + 32
                                t = 0
                                while _4671 + (32 * stor118.length) > idx:
                                    mem[idx + 32] = stor118[t].field_256
                                    idx = idx + 32
                                    t = t + 1
                                    continue 
                                idx = 0
                                t = totalSupply
                                while idx < stor118.length - 1:
                                    require idx < mem[_4671]
                                    require idx + 1 < mem[_4671]
                                    _20713 = mem[(32 * idx + 1) + _4671 + 32]
                                    mem[mem[64] + 4] = mem[(32 * idx) + _4671 + 44 len 20]
                                    mem[mem[64] + 36] = address(_20713)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_20713)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21092 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_21092] == mem[_21092 + 12 len 20]
                                    require ext_code.size(mem[_21092 + 12 len 20])
                                    staticcall mem[_21092 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _22971 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_22971] == mem[_22971 + 18 len 14]
                                    require mem[_22971 + 32] == mem[_22971 + 50 len 14]
                                    require mem[_22971 + 64] == mem[_22971 + 92 len 4]
                                    require idx < mem[_4671]
                                    require idx + 1 < mem[_4671]
                                    if mem[(32 * idx + 1) + _4671 + 44 len 20] < mem[(32 * idx) + _4671 + 44 len 20]:
                                        if not t:
                                            if mem[_22971 + 50 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_22971 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_22971 + 18 len 14] * t / t != mem[_22971 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_22971 + 50 len 14]:
                                                idx = idx + 1
                                                t = mem[_22971 + 18 len 14] * t / mem[_22971 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_22971')), 14)))
                                    else:
                                        if not t:
                                            if mem[_22971 + 18 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_22971 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_22971 + 50 len 14] * t / t != mem[_22971 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_22971 + 18 len 14]:
                                                idx = idx + 1
                                                t = mem[_22971 + 50 len 14] * t / mem[_22971 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_22971')), 14)))
                                    revert
                        else:
                            require stor118.length
                            require stor118.length
                            require address(stor118.field_0) != stakingTokenAddress
                            require 0 < stor118.length
                            mem[0] = 118
                            mem[mem[64] + 4] = stakingTokenAddress
                            require ext_code.size(address(stor118.field_0))
                            staticcall address(stor118.field_0).0x70a08231 with:
                                    gas gas_remaining wei
                                   args stakingTokenAddress
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _5059 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _5145 = mem[_5059]
                            if not mem[_5059]:
                                _5566 = mem[64]
                                mem[64] = mem[64] + (32 * stor118.length) + 32
                                mem[_5566] = stor118.length
                                if not stor118.length:
                                    idx = 0
                                    t = 0
                                    while idx < stor118.length - 1:
                                        require idx < mem[_5566]
                                        require idx + 1 < mem[_5566]
                                        _9142 = mem[(32 * idx + 1) + _5566 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _5566 + 44 len 20]
                                        mem[mem[64] + 36] = address(_9142)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_9142)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9479 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9479] == mem[_9479 + 12 len 20]
                                        require ext_code.size(mem[_9479 + 12 len 20])
                                        staticcall mem[_9479 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _10898 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_10898] == mem[_10898 + 18 len 14]
                                        require mem[_10898 + 32] == mem[_10898 + 50 len 14]
                                        require mem[_10898 + 64] == mem[_10898 + 92 len 4]
                                        require idx < mem[_5566]
                                        require idx + 1 < mem[_5566]
                                        if mem[(32 * idx + 1) + _5566 + 44 len 20] < mem[(32 * idx) + _5566 + 44 len 20]:
                                            if not t:
                                                if mem[_10898 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_10898 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_10898 + 18 len 14] * t / t != mem[_10898 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_10898 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_10898 + 18 len 14] * t / mem[_10898 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_10898')), 14)))
                                        else:
                                            if not t:
                                                if mem[_10898 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_10898 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_10898 + 50 len 14] * t / t != mem[_10898 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_10898 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_10898 + 50 len 14] * t / mem[_10898 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_10898')), 14)))
                                        revert
                                else:
                                    mem[0] = 118
                                    mem[_5566 + 32] = address(stor118.field_0)
                                    idx = _5566 + 32
                                    t = 0
                                    while _5566 + (32 * stor118.length) > idx:
                                        mem[idx + 32] = stor118[t].field_256
                                        idx = idx + 32
                                        t = t + 1
                                        continue 
                                    idx = 0
                                    t = 0
                                    while idx < stor118.length - 1:
                                        require idx < mem[_5566]
                                        require idx + 1 < mem[_5566]
                                        _20717 = mem[(32 * idx + 1) + _5566 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _5566 + 44 len 20]
                                        mem[mem[64] + 36] = address(_20717)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_20717)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21096 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_21096] == mem[_21096 + 12 len 20]
                                        require ext_code.size(mem[_21096 + 12 len 20])
                                        staticcall mem[_21096 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22977 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_22977] == mem[_22977 + 18 len 14]
                                        require mem[_22977 + 32] == mem[_22977 + 50 len 14]
                                        require mem[_22977 + 64] == mem[_22977 + 92 len 4]
                                        require idx < mem[_5566]
                                        require idx + 1 < mem[_5566]
                                        if mem[(32 * idx + 1) + _5566 + 44 len 20] < mem[(32 * idx) + _5566 + 44 len 20]:
                                            if not t:
                                                if mem[_22977 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22977 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_22977 + 18 len 14] * t / t != mem[_22977 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22977 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22977 + 18 len 14] * t / mem[_22977 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_22977')), 14)))
                                        else:
                                            if not t:
                                                if mem[_22977 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22977 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_22977 + 50 len 14] * t / t != mem[_22977 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22977 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22977 + 50 len 14] * t / mem[_22977 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_22977')), 14)))
                                        revert
                            else:
                                if 2 * mem[_5059] / mem[_5059] != 2:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _5700 = mem[64]
                                mem[64] = mem[64] + (32 * stor118.length) + 32
                                mem[_5700] = stor118.length
                                if not stor118.length:
                                    idx = 0
                                    t = 2 * _5145
                                    while idx < stor118.length - 1:
                                        require idx < mem[_5700]
                                        require idx + 1 < mem[_5700]
                                        _9140 = mem[(32 * idx + 1) + _5700 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _5700 + 44 len 20]
                                        mem[mem[64] + 36] = address(_9140)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_9140)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9477 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9477] == mem[_9477 + 12 len 20]
                                        require ext_code.size(mem[_9477 + 12 len 20])
                                        staticcall mem[_9477 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _10895 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_10895] == mem[_10895 + 18 len 14]
                                        require mem[_10895 + 32] == mem[_10895 + 50 len 14]
                                        require mem[_10895 + 64] == mem[_10895 + 92 len 4]
                                        require idx < mem[_5700]
                                        require idx + 1 < mem[_5700]
                                        if mem[(32 * idx + 1) + _5700 + 44 len 20] < mem[(32 * idx) + _5700 + 44 len 20]:
                                            if not t:
                                                if mem[_10895 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_10895 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_10895 + 18 len 14] * t / t != mem[_10895 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_10895 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_10895 + 18 len 14] * t / mem[_10895 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_10895')), 14)))
                                        else:
                                            if not t:
                                                if mem[_10895 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_10895 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_10895 + 50 len 14] * t / t != mem[_10895 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_10895 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_10895 + 50 len 14] * t / mem[_10895 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_10895')), 14)))
                                        revert
                                else:
                                    mem[0] = 118
                                    mem[_5700 + 32] = address(stor118.field_0)
                                    idx = _5700 + 32
                                    t = 0
                                    while _5700 + (32 * stor118.length) > idx:
                                        mem[idx + 32] = stor118[t].field_256
                                        idx = idx + 32
                                        t = t + 1
                                        continue 
                                    idx = 0
                                    t = 2 * _5145
                                    while idx < stor118.length - 1:
                                        require idx < mem[_5700]
                                        require idx + 1 < mem[_5700]
                                        _20715 = mem[(32 * idx + 1) + _5700 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _5700 + 44 len 20]
                                        mem[mem[64] + 36] = address(_20715)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_20715)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21094 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_21094] == mem[_21094 + 12 len 20]
                                        require ext_code.size(mem[_21094 + 12 len 20])
                                        staticcall mem[_21094 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22974 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_22974] == mem[_22974 + 18 len 14]
                                        require mem[_22974 + 32] == mem[_22974 + 50 len 14]
                                        require mem[_22974 + 64] == mem[_22974 + 92 len 4]
                                        require idx < mem[_5700]
                                        require idx + 1 < mem[_5700]
                                        if mem[(32 * idx + 1) + _5700 + 44 len 20] < mem[(32 * idx) + _5700 + 44 len 20]:
                                            if not t:
                                                if mem[_22974 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22974 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_22974 + 18 len 14] * t / t != mem[_22974 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22974 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22974 + 18 len 14] * t / mem[_22974 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_22974')), 14)))
                                        else:
                                            if not t:
                                                if mem[_22974 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22974 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_22974 + 50 len 14] * t / t != mem[_22974 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22974 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22974 + 50 len 14] * t / mem[_22974 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_22974')), 14)))
                                        revert
                    else:
                        mem[ceil32(return_data.size) + 224] = address(stor119.field_256)
                        idx = ceil32(return_data.size) + 224
                        s = 1
                        while ceil32(return_data.size) + (32 * stor119.length) + 160 > idx:
                            mem[idx + 32] = stor119[s].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                        idx = 0
                        s = 0 / rewardsDuration
                        while idx < stor119.length - 1:
                            require idx < mem[ceil32(return_data.size) + 160]
                            require idx + 1 < mem[ceil32(return_data.size) + 160]
                            _14522 = mem[(32 * idx + 1) + ceil32(return_data.size) + 192]
                            mem[mem[64] + 4] = mem[(32 * idx) + ceil32(return_data.size) + 204 len 20]
                            mem[mem[64] + 36] = address(_14522)
                            require ext_code.size(stor117)
                            staticcall stor117.getPair(address rg1, address rg2) with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4], address(_14522)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _15322 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_15322] == mem[_15322 + 12 len 20]
                            require ext_code.size(mem[_15322 + 12 len 20])
                            staticcall mem[_15322 + 12 len 20].getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _16556 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_16556] == mem[_16556 + 18 len 14]
                            require mem[_16556 + 32] == mem[_16556 + 50 len 14]
                            require mem[_16556 + 64] == mem[_16556 + 92 len 4]
                            require idx < mem[ceil32(return_data.size) + 160]
                            require idx + 1 < mem[ceil32(return_data.size) + 160]
                            if mem[(32 * idx + 1) + ceil32(return_data.size) + 204 len 20] < mem[(32 * idx) + ceil32(return_data.size) + 204 len 20]:
                                if not s:
                                    if mem[_16556 + 50 len 14]:
                                        idx = idx + 1
                                        s = 0 / mem[_16556 + 50 len 14]
                                        continue 
                                else:
                                    if mem[_16556 + 18 len 14] * s / s != mem[_16556 + 18 len 14]:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if mem[_16556 + 50 len 14]:
                                        idx = idx + 1
                                        s = mem[_16556 + 18 len 14] * s / mem[_16556 + 50 len 14]
                                        continue 
                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_16556')), 14)))
                            else:
                                if not s:
                                    if mem[_16556 + 18 len 14]:
                                        idx = idx + 1
                                        s = 0 / mem[_16556 + 18 len 14]
                                        continue 
                                else:
                                    if mem[_16556 + 50 len 14] * s / s != mem[_16556 + 50 len 14]:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if mem[_16556 + 18 len 14]:
                                        idx = idx + 1
                                        s = mem[_16556 + 50 len 14] * s / mem[_16556 + 18 len 14]
                                        continue 
                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_16556')), 14)))
                            revert
                        require stor118.length
                        mem[0] = 118
                        if address(stor118.field_0) == stakingTokenAddress:
                            _15521 = mem[64]
                            mem[64] = mem[64] + (32 * stor118.length) + 32
                            mem[_15521] = stor118.length
                            if not stor118.length:
                                idx = 0
                                t = totalSupply
                                while idx < stor118.length - 1:
                                    require idx < mem[_15521]
                                    require idx + 1 < mem[_15521]
                                    _20707 = mem[(32 * idx + 1) + _15521 + 32]
                                    mem[mem[64] + 4] = mem[(32 * idx) + _15521 + 44 len 20]
                                    mem[mem[64] + 36] = address(_20707)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_20707)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21086 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_21086] == mem[_21086 + 12 len 20]
                                    require ext_code.size(mem[_21086 + 12 len 20])
                                    staticcall mem[_21086 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _22962 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_22962] == mem[_22962 + 18 len 14]
                                    require mem[_22962 + 32] == mem[_22962 + 50 len 14]
                                    require mem[_22962 + 64] == mem[_22962 + 92 len 4]
                                    require idx < mem[_15521]
                                    require idx + 1 < mem[_15521]
                                    if mem[(32 * idx + 1) + _15521 + 44 len 20] < mem[(32 * idx) + _15521 + 44 len 20]:
                                        if not t:
                                            if mem[_22962 + 50 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_22962 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_22962 + 18 len 14] * t / t != mem[_22962 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_22962 + 50 len 14]:
                                                idx = idx + 1
                                                t = mem[_22962 + 18 len 14] * t / mem[_22962 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_22962')), 14)))
                                    else:
                                        if not t:
                                            if mem[_22962 + 18 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_22962 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_22962 + 50 len 14] * t / t != mem[_22962 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_22962 + 18 len 14]:
                                                idx = idx + 1
                                                t = mem[_22962 + 50 len 14] * t / mem[_22962 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_22962')), 14)))
                                    revert
                                if s:
                                    if 10^18 * s / s != 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not t:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    return (10^18 * s / t)
                                if t:
                                    return (0 / t)
                                var64001 = 32
                                revert with 0, 'SafeMath: division by zero', 0
                            mem[0] = 118
                            mem[_15521 + 32] = address(stor118.field_0)
                            idx = _15521 + 32
                            t = 0
                            while _15521 + (32 * stor118.length) > idx:
                                mem[idx + 32] = stor118[t].field_256
                                idx = idx + 32
                                t = t + 1
                                continue 
                            idx = 0
                            t = totalSupply
                            while idx < stor118.length - 1:
                                require idx < mem[_15521]
                                require idx + 1 < mem[_15521]
                                _27753 = mem[(32 * idx + 1) + _15521 + 32]
                                mem[mem[64] + 4] = mem[(32 * idx) + _15521 + 44 len 20]
                                mem[mem[64] + 36] = address(_27753)
                                require ext_code.size(stor117)
                                staticcall stor117.getPair(address rg1, address rg2) with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4], address(_27753)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _27880 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_27880] == mem[_27880 + 12 len 20]
                                require ext_code.size(mem[_27880 + 12 len 20])
                                staticcall mem[_27880 + 12 len 20].getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _28505 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_28505] == mem[_28505 + 18 len 14]
                                require mem[_28505 + 32] == mem[_28505 + 50 len 14]
                                require mem[_28505 + 64] == mem[_28505 + 92 len 4]
                                require idx < mem[_15521]
                                require idx + 1 < mem[_15521]
                                if mem[(32 * idx + 1) + _15521 + 44 len 20] < mem[(32 * idx) + _15521 + 44 len 20]:
                                    if not t:
                                        if mem[_28505 + 50 len 14]:
                                            idx = idx + 1
                                            t = 0 / mem[_28505 + 50 len 14]
                                            continue 
                                    else:
                                        if mem[_28505 + 18 len 14] * t / t != mem[_28505 + 18 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_28505 + 50 len 14]:
                                            idx = idx + 1
                                            t = mem[_28505 + 18 len 14] * t / mem[_28505 + 50 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_28505')), 14)))
                                else:
                                    if not t:
                                        if mem[_28505 + 18 len 14]:
                                            idx = idx + 1
                                            t = 0 / mem[_28505 + 18 len 14]
                                            continue 
                                    else:
                                        if mem[_28505 + 50 len 14] * t / t != mem[_28505 + 50 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_28505 + 18 len 14]:
                                            idx = idx + 1
                                            t = mem[_28505 + 50 len 14] * t / mem[_28505 + 18 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_28505')), 14)))
                                revert
                        else:
                            require stor118.length
                            require stor118.length
                            require address(stor118.field_0) != stakingTokenAddress
                            require 0 < stor118.length
                            mem[0] = 118
                            mem[mem[64] + 4] = stakingTokenAddress
                            require ext_code.size(address(stor118.field_0))
                            staticcall address(stor118.field_0).0x70a08231 with:
                                    gas gas_remaining wei
                                   args stakingTokenAddress
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _16555 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _16956 = mem[_16555]
                            if not mem[_16555]:
                                _17807 = mem[64]
                                mem[64] = mem[64] + (32 * stor118.length) + 32
                                mem[_17807] = stor118.length
                                if not stor118.length:
                                    idx = 0
                                    t = 0
                                    while idx < stor118.length - 1:
                                        require idx < mem[_17807]
                                        require idx + 1 < mem[_17807]
                                        _20711 = mem[(32 * idx + 1) + _17807 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _17807 + 44 len 20]
                                        mem[mem[64] + 36] = address(_20711)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_20711)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21090 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_21090] == mem[_21090 + 12 len 20]
                                        require ext_code.size(mem[_21090 + 12 len 20])
                                        staticcall mem[_21090 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22968 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_22968] == mem[_22968 + 18 len 14]
                                        require mem[_22968 + 32] == mem[_22968 + 50 len 14]
                                        require mem[_22968 + 64] == mem[_22968 + 92 len 4]
                                        require idx < mem[_17807]
                                        require idx + 1 < mem[_17807]
                                        if mem[(32 * idx + 1) + _17807 + 44 len 20] < mem[(32 * idx) + _17807 + 44 len 20]:
                                            if not t:
                                                if mem[_22968 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22968 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_22968 + 18 len 14] * t / t != mem[_22968 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22968 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22968 + 18 len 14] * t / mem[_22968 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_22968')), 14)))
                                        else:
                                            if not t:
                                                if mem[_22968 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22968 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_22968 + 50 len 14] * t / t != mem[_22968 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22968 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22968 + 50 len 14] * t / mem[_22968 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_22968')), 14)))
                                        revert
                                    if not s:
                                        if not t:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        return (0 / t)
                                    if 10^18 * s / s != 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not t:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    return (10^18 * s / t)
                                mem[0] = 118
                                mem[_17807 + 32] = address(stor118.field_0)
                                idx = _17807 + 32
                                t = 0
                                while _17807 + (32 * stor118.length) > idx:
                                    mem[idx + 32] = stor118[t].field_256
                                    idx = idx + 32
                                    t = t + 1
                                    continue 
                                idx = 0
                                t = 0
                                while idx < stor118.length - 1:
                                    require idx < mem[_17807]
                                    require idx + 1 < mem[_17807]
                                    _27757 = mem[(32 * idx + 1) + _17807 + 32]
                                    mem[mem[64] + 4] = mem[(32 * idx) + _17807 + 44 len 20]
                                    mem[mem[64] + 36] = address(_27757)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_27757)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _27884 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_27884] == mem[_27884 + 12 len 20]
                                    require ext_code.size(mem[_27884 + 12 len 20])
                                    staticcall mem[_27884 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _28511 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_28511] == mem[_28511 + 18 len 14]
                                    require mem[_28511 + 32] == mem[_28511 + 50 len 14]
                                    require mem[_28511 + 64] == mem[_28511 + 92 len 4]
                                    require idx < mem[_17807]
                                    require idx + 1 < mem[_17807]
                                    if mem[(32 * idx + 1) + _17807 + 44 len 20] < mem[(32 * idx) + _17807 + 44 len 20]:
                                        if not t:
                                            if mem[_28511 + 50 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_28511 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_28511 + 18 len 14] * t / t != mem[_28511 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_28511 + 50 len 14]:
                                                idx = idx + 1
                                                t = mem[_28511 + 18 len 14] * t / mem[_28511 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_28511')), 14)))
                                    else:
                                        if not t:
                                            if mem[_28511 + 18 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_28511 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_28511 + 50 len 14] * t / t != mem[_28511 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_28511 + 18 len 14]:
                                                idx = idx + 1
                                                t = mem[_28511 + 50 len 14] * t / mem[_28511 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_28511')), 14)))
                                    revert
                                if s:
                                    if 10^18 * s / s != 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not t:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    return (10^18 * s / t)
                                if t:
                                    return (0 / t)
                                var83001 = 32
                                revert with 0, 'SafeMath: division by zero', 0
                            if 2 * mem[_16555] / mem[_16555] != 2:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _17948 = mem[64]
                            mem[64] = mem[64] + (32 * stor118.length) + 32
                            mem[_17948] = stor118.length
                            if not stor118.length:
                                idx = 0
                                t = 2 * _16956
                                while idx < stor118.length - 1:
                                    require idx < mem[_17948]
                                    require idx + 1 < mem[_17948]
                                    _20709 = mem[(32 * idx + 1) + _17948 + 32]
                                    mem[mem[64] + 4] = mem[(32 * idx) + _17948 + 44 len 20]
                                    mem[mem[64] + 36] = address(_20709)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_20709)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21088 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_21088] == mem[_21088 + 12 len 20]
                                    require ext_code.size(mem[_21088 + 12 len 20])
                                    staticcall mem[_21088 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _22965 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_22965] == mem[_22965 + 18 len 14]
                                    require mem[_22965 + 32] == mem[_22965 + 50 len 14]
                                    require mem[_22965 + 64] == mem[_22965 + 92 len 4]
                                    require idx < mem[_17948]
                                    require idx + 1 < mem[_17948]
                                    if mem[(32 * idx + 1) + _17948 + 44 len 20] < mem[(32 * idx) + _17948 + 44 len 20]:
                                        if not t:
                                            if mem[_22965 + 50 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_22965 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_22965 + 18 len 14] * t / t != mem[_22965 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_22965 + 50 len 14]:
                                                idx = idx + 1
                                                t = mem[_22965 + 18 len 14] * t / mem[_22965 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_22965')), 14)))
                                    else:
                                        if not t:
                                            if mem[_22965 + 18 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_22965 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_22965 + 50 len 14] * t / t != mem[_22965 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_22965 + 18 len 14]:
                                                idx = idx + 1
                                                t = mem[_22965 + 50 len 14] * t / mem[_22965 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_22965')), 14)))
                                    revert
                            else:
                                mem[0] = 118
                                mem[_17948 + 32] = address(stor118.field_0)
                                idx = _17948 + 32
                                t = 0
                                while _17948 + (32 * stor118.length) > idx:
                                    mem[idx + 32] = stor118[t].field_256
                                    idx = idx + 32
                                    t = t + 1
                                    continue 
                                idx = 0
                                t = 2 * _16956
                                while idx < stor118.length - 1:
                                    require idx < mem[_17948]
                                    require idx + 1 < mem[_17948]
                                    _27755 = mem[(32 * idx + 1) + _17948 + 32]
                                    mem[mem[64] + 4] = mem[(32 * idx) + _17948 + 44 len 20]
                                    mem[mem[64] + 36] = address(_27755)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_27755)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _27882 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_27882] == mem[_27882 + 12 len 20]
                                    require ext_code.size(mem[_27882 + 12 len 20])
                                    staticcall mem[_27882 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _28508 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_28508] == mem[_28508 + 18 len 14]
                                    require mem[_28508 + 32] == mem[_28508 + 50 len 14]
                                    require mem[_28508 + 64] == mem[_28508 + 92 len 4]
                                    require idx < mem[_17948]
                                    require idx + 1 < mem[_17948]
                                    if mem[(32 * idx + 1) + _17948 + 44 len 20] < mem[(32 * idx) + _17948 + 44 len 20]:
                                        if not t:
                                            if mem[_28508 + 50 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_28508 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_28508 + 18 len 14] * t / t != mem[_28508 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_28508 + 50 len 14]:
                                                idx = idx + 1
                                                t = mem[_28508 + 18 len 14] * t / mem[_28508 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_28508')), 14)))
                                    else:
                                        if not t:
                                            if mem[_28508 + 18 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_28508 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_28508 + 50 len 14] * t / t != mem[_28508 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_28508 + 18 len 14]:
                                                idx = idx + 1
                                                t = mem[_28508 + 50 len 14] * t / mem[_28508 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_28508')), 14)))
                                    revert
            else:
                if block.timestamp >= periodFinish:
                    require 0 < stor119.length
                    mem[0] = 119
                    require address(stor119.field_0) == rewardsTokenAddress
                    mem[64] = ceil32(return_data.size) + (32 * stor119.length) + 128
                    mem[ceil32(return_data.size) + 96] = stor119.length
                    if lastUpdateTime < periodFinish:
                        if not stor119.length:
                            idx = 0
                            s = 0
                            while idx < stor119.length - 1:
                                require idx < mem[ceil32(return_data.size) + 96]
                                require idx + 1 < mem[ceil32(return_data.size) + 96]
                                _4449 = mem[(32 * idx + 1) + ceil32(return_data.size) + 128]
                                mem[mem[64] + 4] = mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]
                                mem[mem[64] + 36] = address(_4449)
                                require ext_code.size(stor117)
                                staticcall stor117.getPair(address rg1, address rg2) with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4], address(_4449)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4583 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_4583] == mem[_4583 + 12 len 20]
                                require ext_code.size(mem[_4583 + 12 len 20])
                                staticcall mem[_4583 + 12 len 20].getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5032 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_5032] == mem[_5032 + 18 len 14]
                                require mem[_5032 + 32] == mem[_5032 + 50 len 14]
                                require mem[_5032 + 64] == mem[_5032 + 92 len 4]
                                require idx < mem[ceil32(return_data.size) + 96]
                                require idx + 1 < mem[ceil32(return_data.size) + 96]
                                if mem[(32 * idx + 1) + ceil32(return_data.size) + 140 len 20] < mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]:
                                    if not s:
                                        if mem[_5032 + 50 len 14]:
                                            idx = idx + 1
                                            s = 0 / mem[_5032 + 50 len 14]
                                            continue 
                                    else:
                                        if mem[_5032 + 18 len 14] * s / s != mem[_5032 + 18 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_5032 + 50 len 14]:
                                            idx = idx + 1
                                            s = mem[_5032 + 18 len 14] * s / mem[_5032 + 50 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_5032')), 14)))
                                else:
                                    if not s:
                                        if mem[_5032 + 18 len 14]:
                                            idx = idx + 1
                                            s = 0 / mem[_5032 + 18 len 14]
                                            continue 
                                    else:
                                        if mem[_5032 + 50 len 14] * s / s != mem[_5032 + 50 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_5032 + 18 len 14]:
                                            idx = idx + 1
                                            s = mem[_5032 + 50 len 14] * s / mem[_5032 + 18 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_5032')), 14)))
                                revert
                            require stor118.length
                            mem[0] = 118
                            if address(stor118.field_0) == stakingTokenAddress:
                                _4657 = mem[64]
                                mem[64] = mem[64] + (32 * stor118.length) + 32
                                mem[_4657] = stor118.length
                                if not stor118.length:
                                    idx = 0
                                    t = totalSupply
                                    while idx < stor118.length - 1:
                                        require idx < mem[_4657]
                                        require idx + 1 < mem[_4657]
                                        _9092 = mem[(32 * idx + 1) + _4657 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _4657 + 44 len 20]
                                        mem[mem[64] + 36] = address(_9092)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_9092)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9429 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9429] == mem[_9429 + 12 len 20]
                                        require ext_code.size(mem[_9429 + 12 len 20])
                                        staticcall mem[_9429 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _10813 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_10813] == mem[_10813 + 18 len 14]
                                        require mem[_10813 + 32] == mem[_10813 + 50 len 14]
                                        require mem[_10813 + 64] == mem[_10813 + 92 len 4]
                                        require idx < mem[_4657]
                                        require idx + 1 < mem[_4657]
                                        if mem[(32 * idx + 1) + _4657 + 44 len 20] < mem[(32 * idx) + _4657 + 44 len 20]:
                                            if not t:
                                                if mem[_10813 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_10813 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_10813 + 18 len 14] * t / t != mem[_10813 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_10813 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_10813 + 18 len 14] * t / mem[_10813 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_10813')), 14)))
                                        else:
                                            if not t:
                                                if mem[_10813 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_10813 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_10813 + 50 len 14] * t / t != mem[_10813 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_10813 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_10813 + 50 len 14] * t / mem[_10813 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_10813')), 14)))
                                        revert
                                else:
                                    mem[0] = 118
                                    mem[_4657 + 32] = address(stor118.field_0)
                                    idx = _4657 + 32
                                    t = 0
                                    while _4657 + (32 * stor118.length) > idx:
                                        mem[idx + 32] = stor118[t].field_256
                                        idx = idx + 32
                                        t = t + 1
                                        continue 
                                    idx = 0
                                    t = totalSupply
                                    while idx < stor118.length - 1:
                                        require idx < mem[_4657]
                                        require idx + 1 < mem[_4657]
                                        _20647 = mem[(32 * idx + 1) + _4657 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _4657 + 44 len 20]
                                        mem[mem[64] + 36] = address(_20647)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_20647)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21026 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_21026] == mem[_21026 + 12 len 20]
                                        require ext_code.size(mem[_21026 + 12 len 20])
                                        staticcall mem[_21026 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22872 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_22872] == mem[_22872 + 18 len 14]
                                        require mem[_22872 + 32] == mem[_22872 + 50 len 14]
                                        require mem[_22872 + 64] == mem[_22872 + 92 len 4]
                                        require idx < mem[_4657]
                                        require idx + 1 < mem[_4657]
                                        if mem[(32 * idx + 1) + _4657 + 44 len 20] < mem[(32 * idx) + _4657 + 44 len 20]:
                                            if not t:
                                                if mem[_22872 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22872 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_22872 + 18 len 14] * t / t != mem[_22872 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22872 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22872 + 18 len 14] * t / mem[_22872 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_22872')), 14)))
                                        else:
                                            if not t:
                                                if mem[_22872 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22872 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_22872 + 50 len 14] * t / t != mem[_22872 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22872 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22872 + 50 len 14] * t / mem[_22872 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_22872')), 14)))
                                        revert
                            else:
                                require stor118.length
                                require stor118.length
                                require address(stor118.field_0) != stakingTokenAddress
                                require 0 < stor118.length
                                mem[0] = 118
                                mem[mem[64] + 4] = stakingTokenAddress
                                require ext_code.size(address(stor118.field_0))
                                staticcall address(stor118.field_0).0x70a08231 with:
                                        gas gas_remaining wei
                                       args stakingTokenAddress
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5031 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _5124 = mem[_5031]
                                if not mem[_5031]:
                                    _5545 = mem[64]
                                    mem[64] = mem[64] + (32 * stor118.length) + 32
                                    mem[_5545] = stor118.length
                                    if not stor118.length:
                                        idx = 0
                                        t = 0
                                        while idx < stor118.length - 1:
                                            require idx < mem[_5545]
                                            require idx + 1 < mem[_5545]
                                            _9096 = mem[(32 * idx + 1) + _5545 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _5545 + 44 len 20]
                                            mem[mem[64] + 36] = address(_9096)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_9096)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9433 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9433] == mem[_9433 + 12 len 20]
                                            require ext_code.size(mem[_9433 + 12 len 20])
                                            staticcall mem[_9433 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _10819 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_10819] == mem[_10819 + 18 len 14]
                                            require mem[_10819 + 32] == mem[_10819 + 50 len 14]
                                            require mem[_10819 + 64] == mem[_10819 + 92 len 4]
                                            require idx < mem[_5545]
                                            require idx + 1 < mem[_5545]
                                            if mem[(32 * idx + 1) + _5545 + 44 len 20] < mem[(32 * idx) + _5545 + 44 len 20]:
                                                if not t:
                                                    if mem[_10819 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10819 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10819 + 18 len 14] * t / t != mem[_10819 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10819 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10819 + 18 len 14] * t / mem[_10819 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_10819')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_10819 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10819 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10819 + 50 len 14] * t / t != mem[_10819 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10819 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10819 + 50 len 14] * t / mem[_10819 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_10819')), 14)))
                                            revert
                                    else:
                                        mem[0] = 118
                                        mem[_5545 + 32] = address(stor118.field_0)
                                        idx = _5545 + 32
                                        t = 0
                                        while _5545 + (32 * stor118.length) > idx:
                                            mem[idx + 32] = stor118[t].field_256
                                            idx = idx + 32
                                            t = t + 1
                                            continue 
                                        idx = 0
                                        t = 0
                                        while idx < stor118.length - 1:
                                            require idx < mem[_5545]
                                            require idx + 1 < mem[_5545]
                                            _20651 = mem[(32 * idx + 1) + _5545 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _5545 + 44 len 20]
                                            mem[mem[64] + 36] = address(_20651)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_20651)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _21030 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_21030] == mem[_21030 + 12 len 20]
                                            require ext_code.size(mem[_21030 + 12 len 20])
                                            staticcall mem[_21030 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22878 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_22878] == mem[_22878 + 18 len 14]
                                            require mem[_22878 + 32] == mem[_22878 + 50 len 14]
                                            require mem[_22878 + 64] == mem[_22878 + 92 len 4]
                                            require idx < mem[_5545]
                                            require idx + 1 < mem[_5545]
                                            if mem[(32 * idx + 1) + _5545 + 44 len 20] < mem[(32 * idx) + _5545 + 44 len 20]:
                                                if not t:
                                                    if mem[_22878 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22878 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22878 + 18 len 14] * t / t != mem[_22878 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22878 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22878 + 18 len 14] * t / mem[_22878 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_22878')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_22878 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22878 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22878 + 50 len 14] * t / t != mem[_22878 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22878 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22878 + 50 len 14] * t / mem[_22878 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_22878')), 14)))
                                            revert
                                else:
                                    if 2 * mem[_5031] / mem[_5031] != 2:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _5665 = mem[64]
                                    mem[64] = mem[64] + (32 * stor118.length) + 32
                                    mem[_5665] = stor118.length
                                    if not stor118.length:
                                        idx = 0
                                        t = 2 * _5124
                                        while idx < stor118.length - 1:
                                            require idx < mem[_5665]
                                            require idx + 1 < mem[_5665]
                                            _9094 = mem[(32 * idx + 1) + _5665 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _5665 + 44 len 20]
                                            mem[mem[64] + 36] = address(_9094)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_9094)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9431 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9431] == mem[_9431 + 12 len 20]
                                            require ext_code.size(mem[_9431 + 12 len 20])
                                            staticcall mem[_9431 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _10816 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_10816] == mem[_10816 + 18 len 14]
                                            require mem[_10816 + 32] == mem[_10816 + 50 len 14]
                                            require mem[_10816 + 64] == mem[_10816 + 92 len 4]
                                            require idx < mem[_5665]
                                            require idx + 1 < mem[_5665]
                                            if mem[(32 * idx + 1) + _5665 + 44 len 20] < mem[(32 * idx) + _5665 + 44 len 20]:
                                                if not t:
                                                    if mem[_10816 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10816 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10816 + 18 len 14] * t / t != mem[_10816 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10816 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10816 + 18 len 14] * t / mem[_10816 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_10816')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_10816 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10816 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10816 + 50 len 14] * t / t != mem[_10816 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10816 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10816 + 50 len 14] * t / mem[_10816 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_10816')), 14)))
                                            revert
                                    else:
                                        mem[0] = 118
                                        mem[_5665 + 32] = address(stor118.field_0)
                                        idx = _5665 + 32
                                        t = 0
                                        while _5665 + (32 * stor118.length) > idx:
                                            mem[idx + 32] = stor118[t].field_256
                                            idx = idx + 32
                                            t = t + 1
                                            continue 
                                        idx = 0
                                        t = 2 * _5124
                                        while idx < stor118.length - 1:
                                            require idx < mem[_5665]
                                            require idx + 1 < mem[_5665]
                                            _20649 = mem[(32 * idx + 1) + _5665 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _5665 + 44 len 20]
                                            mem[mem[64] + 36] = address(_20649)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_20649)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _21028 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_21028] == mem[_21028 + 12 len 20]
                                            require ext_code.size(mem[_21028 + 12 len 20])
                                            staticcall mem[_21028 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22875 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_22875] == mem[_22875 + 18 len 14]
                                            require mem[_22875 + 32] == mem[_22875 + 50 len 14]
                                            require mem[_22875 + 64] == mem[_22875 + 92 len 4]
                                            require idx < mem[_5665]
                                            require idx + 1 < mem[_5665]
                                            if mem[(32 * idx + 1) + _5665 + 44 len 20] < mem[(32 * idx) + _5665 + 44 len 20]:
                                                if not t:
                                                    if mem[_22875 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22875 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22875 + 18 len 14] * t / t != mem[_22875 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22875 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22875 + 18 len 14] * t / mem[_22875 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_22875')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_22875 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22875 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22875 + 50 len 14] * t / t != mem[_22875 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22875 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22875 + 50 len 14] * t / mem[_22875 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_22875')), 14)))
                                            revert
                        else:
                            mem[0] = 119
                            mem[ceil32(return_data.size) + 128] = address(stor119.field_0)
                            if (32 * stor119.length) + 32 <= 64:
                                idx = 0
                                s = 0
                                while idx < stor119.length - 1:
                                    require idx < mem[ceil32(return_data.size) + 96]
                                    require idx + 1 < mem[ceil32(return_data.size) + 96]
                                    _4451 = mem[(32 * idx + 1) + ceil32(return_data.size) + 128]
                                    mem[mem[64] + 4] = mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]
                                    mem[mem[64] + 36] = address(_4451)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_4451)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4584 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_4584] == mem[_4584 + 12 len 20]
                                    require ext_code.size(mem[_4584 + 12 len 20])
                                    staticcall mem[_4584 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5036 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_5036] == mem[_5036 + 18 len 14]
                                    require mem[_5036 + 32] == mem[_5036 + 50 len 14]
                                    require mem[_5036 + 64] == mem[_5036 + 92 len 4]
                                    require idx < mem[ceil32(return_data.size) + 96]
                                    require idx + 1 < mem[ceil32(return_data.size) + 96]
                                    if mem[(32 * idx + 1) + ceil32(return_data.size) + 140 len 20] < mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]:
                                        if not s:
                                            if mem[_5036 + 50 len 14]:
                                                idx = idx + 1
                                                s = 0 / mem[_5036 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_5036 + 18 len 14] * s / s != mem[_5036 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_5036 + 50 len 14]:
                                                idx = idx + 1
                                                s = mem[_5036 + 18 len 14] * s / mem[_5036 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_5036')), 14)))
                                    else:
                                        if not s:
                                            if mem[_5036 + 18 len 14]:
                                                idx = idx + 1
                                                s = 0 / mem[_5036 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_5036 + 50 len 14] * s / s != mem[_5036 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_5036 + 18 len 14]:
                                                idx = idx + 1
                                                s = mem[_5036 + 50 len 14] * s / mem[_5036 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_5036')), 14)))
                                    revert
                                require stor118.length
                                mem[0] = 118
                                if address(stor118.field_0) == stakingTokenAddress:
                                    _4659 = mem[64]
                                    mem[64] = mem[64] + (32 * stor118.length) + 32
                                    mem[_4659] = stor118.length
                                    if not stor118.length:
                                        idx = 0
                                        t = totalSupply
                                        while idx < stor118.length - 1:
                                            require idx < mem[_4659]
                                            require idx + 1 < mem[_4659]
                                            _9099 = mem[(32 * idx + 1) + _4659 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _4659 + 44 len 20]
                                            mem[mem[64] + 36] = address(_9099)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_9099)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9436 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9436] == mem[_9436 + 12 len 20]
                                            require ext_code.size(mem[_9436 + 12 len 20])
                                            staticcall mem[_9436 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _10826 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_10826] == mem[_10826 + 18 len 14]
                                            require mem[_10826 + 32] == mem[_10826 + 50 len 14]
                                            require mem[_10826 + 64] == mem[_10826 + 92 len 4]
                                            require idx < mem[_4659]
                                            require idx + 1 < mem[_4659]
                                            if mem[(32 * idx + 1) + _4659 + 44 len 20] < mem[(32 * idx) + _4659 + 44 len 20]:
                                                if not t:
                                                    if mem[_10826 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10826 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10826 + 18 len 14] * t / t != mem[_10826 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10826 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10826 + 18 len 14] * t / mem[_10826 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_10826')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_10826 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10826 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10826 + 50 len 14] * t / t != mem[_10826 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10826 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10826 + 50 len 14] * t / mem[_10826 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_10826')), 14)))
                                            revert
                                    else:
                                        mem[0] = 118
                                        mem[_4659 + 32] = address(stor118.field_0)
                                        idx = _4659 + 32
                                        t = 0
                                        while _4659 + (32 * stor118.length) > idx:
                                            mem[idx + 32] = stor118[t].field_256
                                            idx = idx + 32
                                            t = t + 1
                                            continue 
                                        idx = 0
                                        t = totalSupply
                                        while idx < stor118.length - 1:
                                            require idx < mem[_4659]
                                            require idx + 1 < mem[_4659]
                                            _20659 = mem[(32 * idx + 1) + _4659 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _4659 + 44 len 20]
                                            mem[mem[64] + 36] = address(_20659)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_20659)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _21038 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_21038] == mem[_21038 + 12 len 20]
                                            require ext_code.size(mem[_21038 + 12 len 20])
                                            staticcall mem[_21038 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22890 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_22890] == mem[_22890 + 18 len 14]
                                            require mem[_22890 + 32] == mem[_22890 + 50 len 14]
                                            require mem[_22890 + 64] == mem[_22890 + 92 len 4]
                                            require idx < mem[_4659]
                                            require idx + 1 < mem[_4659]
                                            if mem[(32 * idx + 1) + _4659 + 44 len 20] < mem[(32 * idx) + _4659 + 44 len 20]:
                                                if not t:
                                                    if mem[_22890 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22890 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22890 + 18 len 14] * t / t != mem[_22890 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22890 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22890 + 18 len 14] * t / mem[_22890 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_22890')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_22890 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22890 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22890 + 50 len 14] * t / t != mem[_22890 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22890 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22890 + 50 len 14] * t / mem[_22890 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_22890')), 14)))
                                            revert
                                else:
                                    require stor118.length
                                    require stor118.length
                                    require address(stor118.field_0) != stakingTokenAddress
                                    require 0 < stor118.length
                                    mem[0] = 118
                                    mem[mem[64] + 4] = stakingTokenAddress
                                    require ext_code.size(address(stor118.field_0))
                                    staticcall address(stor118.field_0).0x70a08231 with:
                                            gas gas_remaining wei
                                           args stakingTokenAddress
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5035 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _5127 = mem[_5035]
                                    if not mem[_5035]:
                                        _5548 = mem[64]
                                        mem[64] = mem[64] + (32 * stor118.length) + 32
                                        mem[_5548] = stor118.length
                                        if not stor118.length:
                                            idx = 0
                                            t = 0
                                            while idx < stor118.length - 1:
                                                require idx < mem[_5548]
                                                require idx + 1 < mem[_5548]
                                                _9103 = mem[(32 * idx + 1) + _5548 + 32]
                                                mem[mem[64] + 4] = mem[(32 * idx) + _5548 + 44 len 20]
                                                mem[mem[64] + 36] = address(_9103)
                                                require ext_code.size(stor117)
                                                staticcall stor117.getPair(address rg1, address rg2) with:
                                                        gas gas_remaining wei
                                                       args mem[mem[64] + 4], address(_9103)
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _9440 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_9440] == mem[_9440 + 12 len 20]
                                                require ext_code.size(mem[_9440 + 12 len 20])
                                                staticcall mem[_9440 + 12 len 20].getReserves() with:
                                                        gas gas_remaining wei
                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _10832 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 96
                                                require mem[_10832] == mem[_10832 + 18 len 14]
                                                require mem[_10832 + 32] == mem[_10832 + 50 len 14]
                                                require mem[_10832 + 64] == mem[_10832 + 92 len 4]
                                                require idx < mem[_5548]
                                                require idx + 1 < mem[_5548]
                                                if mem[(32 * idx + 1) + _5548 + 44 len 20] < mem[(32 * idx) + _5548 + 44 len 20]:
                                                    if not t:
                                                        if mem[_10832 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_10832 + 50 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_10832 + 18 len 14] * t / t != mem[_10832 + 18 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_10832 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_10832 + 18 len 14] * t / mem[_10832 + 50 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_10832')), 14)))
                                                else:
                                                    if not t:
                                                        if mem[_10832 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_10832 + 18 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_10832 + 50 len 14] * t / t != mem[_10832 + 50 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_10832 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_10832 + 50 len 14] * t / mem[_10832 + 18 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_10832')), 14)))
                                                revert
                                        else:
                                            mem[0] = 118
                                            mem[_5548 + 32] = address(stor118.field_0)
                                            idx = _5548 + 32
                                            t = 0
                                            while _5548 + (32 * stor118.length) > idx:
                                                mem[idx + 32] = stor118[t].field_256
                                                idx = idx + 32
                                                t = t + 1
                                                continue 
                                            idx = 0
                                            t = 0
                                            while idx < stor118.length - 1:
                                                require idx < mem[_5548]
                                                require idx + 1 < mem[_5548]
                                                _20663 = mem[(32 * idx + 1) + _5548 + 32]
                                                mem[mem[64] + 4] = mem[(32 * idx) + _5548 + 44 len 20]
                                                mem[mem[64] + 36] = address(_20663)
                                                require ext_code.size(stor117)
                                                staticcall stor117.getPair(address rg1, address rg2) with:
                                                        gas gas_remaining wei
                                                       args mem[mem[64] + 4], address(_20663)
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _21042 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_21042] == mem[_21042 + 12 len 20]
                                                require ext_code.size(mem[_21042 + 12 len 20])
                                                staticcall mem[_21042 + 12 len 20].getReserves() with:
                                                        gas gas_remaining wei
                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _22896 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 96
                                                require mem[_22896] == mem[_22896 + 18 len 14]
                                                require mem[_22896 + 32] == mem[_22896 + 50 len 14]
                                                require mem[_22896 + 64] == mem[_22896 + 92 len 4]
                                                require idx < mem[_5548]
                                                require idx + 1 < mem[_5548]
                                                if mem[(32 * idx + 1) + _5548 + 44 len 20] < mem[(32 * idx) + _5548 + 44 len 20]:
                                                    if not t:
                                                        if mem[_22896 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_22896 + 50 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_22896 + 18 len 14] * t / t != mem[_22896 + 18 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_22896 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_22896 + 18 len 14] * t / mem[_22896 + 50 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_22896')), 14)))
                                                else:
                                                    if not t:
                                                        if mem[_22896 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_22896 + 18 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_22896 + 50 len 14] * t / t != mem[_22896 + 50 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_22896 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_22896 + 50 len 14] * t / mem[_22896 + 18 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_22896')), 14)))
                                                revert
                                    else:
                                        if 2 * mem[_5035] / mem[_5035] != 2:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _5670 = mem[64]
                                        mem[64] = mem[64] + (32 * stor118.length) + 32
                                        mem[_5670] = stor118.length
                                        if not stor118.length:
                                            idx = 0
                                            t = 2 * _5127
                                            while idx < stor118.length - 1:
                                                require idx < mem[_5670]
                                                require idx + 1 < mem[_5670]
                                                _9101 = mem[(32 * idx + 1) + _5670 + 32]
                                                mem[mem[64] + 4] = mem[(32 * idx) + _5670 + 44 len 20]
                                                mem[mem[64] + 36] = address(_9101)
                                                require ext_code.size(stor117)
                                                staticcall stor117.getPair(address rg1, address rg2) with:
                                                        gas gas_remaining wei
                                                       args mem[mem[64] + 4], address(_9101)
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _9438 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_9438] == mem[_9438 + 12 len 20]
                                                require ext_code.size(mem[_9438 + 12 len 20])
                                                staticcall mem[_9438 + 12 len 20].getReserves() with:
                                                        gas gas_remaining wei
                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _10829 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 96
                                                require mem[_10829] == mem[_10829 + 18 len 14]
                                                require mem[_10829 + 32] == mem[_10829 + 50 len 14]
                                                require mem[_10829 + 64] == mem[_10829 + 92 len 4]
                                                require idx < mem[_5670]
                                                require idx + 1 < mem[_5670]
                                                if mem[(32 * idx + 1) + _5670 + 44 len 20] < mem[(32 * idx) + _5670 + 44 len 20]:
                                                    if not t:
                                                        if mem[_10829 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_10829 + 50 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_10829 + 18 len 14] * t / t != mem[_10829 + 18 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_10829 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_10829 + 18 len 14] * t / mem[_10829 + 50 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_10829')), 14)))
                                                else:
                                                    if not t:
                                                        if mem[_10829 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_10829 + 18 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_10829 + 50 len 14] * t / t != mem[_10829 + 50 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_10829 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_10829 + 50 len 14] * t / mem[_10829 + 18 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_10829')), 14)))
                                                revert
                                        else:
                                            mem[0] = 118
                                            mem[_5670 + 32] = address(stor118.field_0)
                                            idx = _5670 + 32
                                            t = 0
                                            while _5670 + (32 * stor118.length) > idx:
                                                mem[idx + 32] = stor118[t].field_256
                                                idx = idx + 32
                                                t = t + 1
                                                continue 
                                            idx = 0
                                            t = 2 * _5127
                                            while idx < stor118.length - 1:
                                                require idx < mem[_5670]
                                                require idx + 1 < mem[_5670]
                                                _20661 = mem[(32 * idx + 1) + _5670 + 32]
                                                mem[mem[64] + 4] = mem[(32 * idx) + _5670 + 44 len 20]
                                                mem[mem[64] + 36] = address(_20661)
                                                require ext_code.size(stor117)
                                                staticcall stor117.getPair(address rg1, address rg2) with:
                                                        gas gas_remaining wei
                                                       args mem[mem[64] + 4], address(_20661)
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _21040 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_21040] == mem[_21040 + 12 len 20]
                                                require ext_code.size(mem[_21040 + 12 len 20])
                                                staticcall mem[_21040 + 12 len 20].getReserves() with:
                                                        gas gas_remaining wei
                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _22893 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 96
                                                require mem[_22893] == mem[_22893 + 18 len 14]
                                                require mem[_22893 + 32] == mem[_22893 + 50 len 14]
                                                require mem[_22893 + 64] == mem[_22893 + 92 len 4]
                                                require idx < mem[_5670]
                                                require idx + 1 < mem[_5670]
                                                if mem[(32 * idx + 1) + _5670 + 44 len 20] < mem[(32 * idx) + _5670 + 44 len 20]:
                                                    if not t:
                                                        if mem[_22893 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_22893 + 50 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_22893 + 18 len 14] * t / t != mem[_22893 + 18 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_22893 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_22893 + 18 len 14] * t / mem[_22893 + 50 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_22893')), 14)))
                                                else:
                                                    if not t:
                                                        if mem[_22893 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_22893 + 18 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_22893 + 50 len 14] * t / t != mem[_22893 + 50 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_22893 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_22893 + 50 len 14] * t / mem[_22893 + 18 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_22893')), 14)))
                                                revert
                            else:
                                mem[ceil32(return_data.size) + 160] = address(stor119.field_256)
                                idx = ceil32(return_data.size) + 160
                                s = 1
                                while ceil32(return_data.size) + (32 * stor119.length) + 96 > idx:
                                    mem[idx + 32] = stor119[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                idx = 0
                                s = 0
                                while idx < stor119.length - 1:
                                    require idx < mem[ceil32(return_data.size) + 96]
                                    require idx + 1 < mem[ceil32(return_data.size) + 96]
                                    _14498 = mem[(32 * idx + 1) + ceil32(return_data.size) + 128]
                                    mem[mem[64] + 4] = mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]
                                    mem[mem[64] + 36] = address(_14498)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_14498)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _15301 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_15301] == mem[_15301 + 12 len 20]
                                    require ext_code.size(mem[_15301 + 12 len 20])
                                    staticcall mem[_15301 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _16508 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_16508] == mem[_16508 + 18 len 14]
                                    require mem[_16508 + 32] == mem[_16508 + 50 len 14]
                                    require mem[_16508 + 64] == mem[_16508 + 92 len 4]
                                    require idx < mem[ceil32(return_data.size) + 96]
                                    require idx + 1 < mem[ceil32(return_data.size) + 96]
                                    if mem[(32 * idx + 1) + ceil32(return_data.size) + 140 len 20] < mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]:
                                        if not s:
                                            if mem[_16508 + 50 len 14]:
                                                idx = idx + 1
                                                s = 0 / mem[_16508 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_16508 + 18 len 14] * s / s != mem[_16508 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_16508 + 50 len 14]:
                                                idx = idx + 1
                                                s = mem[_16508 + 18 len 14] * s / mem[_16508 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_16508')), 14)))
                                    else:
                                        if not s:
                                            if mem[_16508 + 18 len 14]:
                                                idx = idx + 1
                                                s = 0 / mem[_16508 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_16508 + 50 len 14] * s / s != mem[_16508 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_16508 + 18 len 14]:
                                                idx = idx + 1
                                                s = mem[_16508 + 50 len 14] * s / mem[_16508 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_16508')), 14)))
                                    revert
                                require stor118.length
                                mem[0] = 118
                                if address(stor118.field_0) == stakingTokenAddress:
                                    _15479 = mem[64]
                                    mem[64] = mem[64] + (32 * stor118.length) + 32
                                    mem[_15479] = stor118.length
                                    if not stor118.length:
                                        idx = 0
                                        t = totalSupply
                                        while idx < stor118.length - 1:
                                            require idx < mem[_15479]
                                            require idx + 1 < mem[_15479]
                                            _20653 = mem[(32 * idx + 1) + _15479 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _15479 + 44 len 20]
                                            mem[mem[64] + 36] = address(_20653)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_20653)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _21032 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_21032] == mem[_21032 + 12 len 20]
                                            require ext_code.size(mem[_21032 + 12 len 20])
                                            staticcall mem[_21032 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22881 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_22881] == mem[_22881 + 18 len 14]
                                            require mem[_22881 + 32] == mem[_22881 + 50 len 14]
                                            require mem[_22881 + 64] == mem[_22881 + 92 len 4]
                                            require idx < mem[_15479]
                                            require idx + 1 < mem[_15479]
                                            if mem[(32 * idx + 1) + _15479 + 44 len 20] < mem[(32 * idx) + _15479 + 44 len 20]:
                                                if not t:
                                                    if mem[_22881 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22881 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22881 + 18 len 14] * t / t != mem[_22881 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22881 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22881 + 18 len 14] * t / mem[_22881 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_22881')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_22881 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22881 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22881 + 50 len 14] * t / t != mem[_22881 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22881 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22881 + 50 len 14] * t / mem[_22881 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_22881')), 14)))
                                            revert
                                        if s:
                                            if 10^18 * s / s != 10^18:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not t:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            return (10^18 * s / t)
                                        if t:
                                            return (0 / t)
                                        var55001 = 32
                                        revert with 0, 'SafeMath: division by zero', 0
                                    mem[0] = 118
                                    mem[_15479 + 32] = address(stor118.field_0)
                                    idx = _15479 + 32
                                    t = 0
                                    while _15479 + (32 * stor118.length) > idx:
                                        mem[idx + 32] = stor118[t].field_256
                                        idx = idx + 32
                                        t = t + 1
                                        continue 
                                    idx = 0
                                    t = totalSupply
                                    while idx < stor118.length - 1:
                                        require idx < mem[_15479]
                                        require idx + 1 < mem[_15479]
                                        _27735 = mem[(32 * idx + 1) + _15479 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _15479 + 44 len 20]
                                        mem[mem[64] + 36] = address(_27735)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_27735)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27862 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_27862] == mem[_27862 + 12 len 20]
                                        require ext_code.size(mem[_27862 + 12 len 20])
                                        staticcall mem[_27862 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _28478 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_28478] == mem[_28478 + 18 len 14]
                                        require mem[_28478 + 32] == mem[_28478 + 50 len 14]
                                        require mem[_28478 + 64] == mem[_28478 + 92 len 4]
                                        require idx < mem[_15479]
                                        require idx + 1 < mem[_15479]
                                        if mem[(32 * idx + 1) + _15479 + 44 len 20] < mem[(32 * idx) + _15479 + 44 len 20]:
                                            if not t:
                                                if mem[_28478 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_28478 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_28478 + 18 len 14] * t / t != mem[_28478 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_28478 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_28478 + 18 len 14] * t / mem[_28478 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_28478')), 14)))
                                        else:
                                            if not t:
                                                if mem[_28478 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_28478 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_28478 + 50 len 14] * t / t != mem[_28478 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_28478 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_28478 + 50 len 14] * t / mem[_28478 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_28478')), 14)))
                                        revert
                                else:
                                    require stor118.length
                                    require stor118.length
                                    require address(stor118.field_0) != stakingTokenAddress
                                    require 0 < stor118.length
                                    mem[0] = 118
                                    mem[mem[64] + 4] = stakingTokenAddress
                                    require ext_code.size(address(stor118.field_0))
                                    staticcall address(stor118.field_0).0x70a08231 with:
                                            gas gas_remaining wei
                                           args stakingTokenAddress
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _16507 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _16899 = mem[_16507]
                                    if not mem[_16507]:
                                        _17798 = mem[64]
                                        mem[64] = mem[64] + (32 * stor118.length) + 32
                                        mem[_17798] = stor118.length
                                        if not stor118.length:
                                            idx = 0
                                            t = 0
                                            while idx < stor118.length - 1:
                                                require idx < mem[_17798]
                                                require idx + 1 < mem[_17798]
                                                _20657 = mem[(32 * idx + 1) + _17798 + 32]
                                                mem[mem[64] + 4] = mem[(32 * idx) + _17798 + 44 len 20]
                                                mem[mem[64] + 36] = address(_20657)
                                                require ext_code.size(stor117)
                                                staticcall stor117.getPair(address rg1, address rg2) with:
                                                        gas gas_remaining wei
                                                       args mem[mem[64] + 4], address(_20657)
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _21036 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_21036] == mem[_21036 + 12 len 20]
                                                require ext_code.size(mem[_21036 + 12 len 20])
                                                staticcall mem[_21036 + 12 len 20].getReserves() with:
                                                        gas gas_remaining wei
                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _22887 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 96
                                                require mem[_22887] == mem[_22887 + 18 len 14]
                                                require mem[_22887 + 32] == mem[_22887 + 50 len 14]
                                                require mem[_22887 + 64] == mem[_22887 + 92 len 4]
                                                require idx < mem[_17798]
                                                require idx + 1 < mem[_17798]
                                                if mem[(32 * idx + 1) + _17798 + 44 len 20] < mem[(32 * idx) + _17798 + 44 len 20]:
                                                    if not t:
                                                        if mem[_22887 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_22887 + 50 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_22887 + 18 len 14] * t / t != mem[_22887 + 18 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_22887 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_22887 + 18 len 14] * t / mem[_22887 + 50 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_22887')), 14)))
                                                else:
                                                    if not t:
                                                        if mem[_22887 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_22887 + 18 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_22887 + 50 len 14] * t / t != mem[_22887 + 50 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_22887 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_22887 + 50 len 14] * t / mem[_22887 + 18 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_22887')), 14)))
                                                revert
                                            if not s:
                                                if not t:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                return (0 / t)
                                            if 10^18 * s / s != 10^18:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not t:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            return (10^18 * s / t)
                                        mem[0] = 118
                                        mem[_17798 + 32] = address(stor118.field_0)
                                        idx = _17798 + 32
                                        t = 0
                                        while _17798 + (32 * stor118.length) > idx:
                                            mem[idx + 32] = stor118[t].field_256
                                            idx = idx + 32
                                            t = t + 1
                                            continue 
                                        idx = 0
                                        t = 0
                                        while idx < stor118.length - 1:
                                            require idx < mem[_17798]
                                            require idx + 1 < mem[_17798]
                                            _27739 = mem[(32 * idx + 1) + _17798 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _17798 + 44 len 20]
                                            mem[mem[64] + 36] = address(_27739)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_27739)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27866 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_27866] == mem[_27866 + 12 len 20]
                                            require ext_code.size(mem[_27866 + 12 len 20])
                                            staticcall mem[_27866 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _28484 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_28484] == mem[_28484 + 18 len 14]
                                            require mem[_28484 + 32] == mem[_28484 + 50 len 14]
                                            require mem[_28484 + 64] == mem[_28484 + 92 len 4]
                                            require idx < mem[_17798]
                                            require idx + 1 < mem[_17798]
                                            if mem[(32 * idx + 1) + _17798 + 44 len 20] < mem[(32 * idx) + _17798 + 44 len 20]:
                                                if not t:
                                                    if mem[_28484 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_28484 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_28484 + 18 len 14] * t / t != mem[_28484 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_28484 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_28484 + 18 len 14] * t / mem[_28484 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_28484')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_28484 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_28484 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_28484 + 50 len 14] * t / t != mem[_28484 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_28484 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_28484 + 50 len 14] * t / mem[_28484 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_28484')), 14)))
                                            revert
                                        if s:
                                            if 10^18 * s / s != 10^18:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not t:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            return (10^18 * s / t)
                                        if t:
                                            return (0 / t)
                                        var74001 = 32
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if 2 * mem[_16507] / mem[_16507] != 2:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _17915 = mem[64]
                                    mem[64] = mem[64] + (32 * stor118.length) + 32
                                    mem[_17915] = stor118.length
                                    if not stor118.length:
                                        idx = 0
                                        t = 2 * _16899
                                        while idx < stor118.length - 1:
                                            require idx < mem[_17915]
                                            require idx + 1 < mem[_17915]
                                            _20655 = mem[(32 * idx + 1) + _17915 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _17915 + 44 len 20]
                                            mem[mem[64] + 36] = address(_20655)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_20655)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _21034 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_21034] == mem[_21034 + 12 len 20]
                                            require ext_code.size(mem[_21034 + 12 len 20])
                                            staticcall mem[_21034 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22884 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_22884] == mem[_22884 + 18 len 14]
                                            require mem[_22884 + 32] == mem[_22884 + 50 len 14]
                                            require mem[_22884 + 64] == mem[_22884 + 92 len 4]
                                            require idx < mem[_17915]
                                            require idx + 1 < mem[_17915]
                                            if mem[(32 * idx + 1) + _17915 + 44 len 20] < mem[(32 * idx) + _17915 + 44 len 20]:
                                                if not t:
                                                    if mem[_22884 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22884 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22884 + 18 len 14] * t / t != mem[_22884 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22884 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22884 + 18 len 14] * t / mem[_22884 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_22884')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_22884 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22884 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22884 + 50 len 14] * t / t != mem[_22884 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22884 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22884 + 50 len 14] * t / mem[_22884 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_22884')), 14)))
                                            revert
                                    else:
                                        mem[0] = 118
                                        mem[_17915 + 32] = address(stor118.field_0)
                                        idx = _17915 + 32
                                        t = 0
                                        while _17915 + (32 * stor118.length) > idx:
                                            mem[idx + 32] = stor118[t].field_256
                                            idx = idx + 32
                                            t = t + 1
                                            continue 
                                        idx = 0
                                        t = 2 * _16899
                                        while idx < stor118.length - 1:
                                            require idx < mem[_17915]
                                            require idx + 1 < mem[_17915]
                                            _27737 = mem[(32 * idx + 1) + _17915 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _17915 + 44 len 20]
                                            mem[mem[64] + 36] = address(_27737)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_27737)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27864 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_27864] == mem[_27864 + 12 len 20]
                                            require ext_code.size(mem[_27864 + 12 len 20])
                                            staticcall mem[_27864 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _28481 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_28481] == mem[_28481 + 18 len 14]
                                            require mem[_28481 + 32] == mem[_28481 + 50 len 14]
                                            require mem[_28481 + 64] == mem[_28481 + 92 len 4]
                                            require idx < mem[_17915]
                                            require idx + 1 < mem[_17915]
                                            if mem[(32 * idx + 1) + _17915 + 44 len 20] < mem[(32 * idx) + _17915 + 44 len 20]:
                                                if not t:
                                                    if mem[_28481 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_28481 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_28481 + 18 len 14] * t / t != mem[_28481 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_28481 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_28481 + 18 len 14] * t / mem[_28481 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_28481')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_28481 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_28481 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_28481 + 50 len 14] * t / t != mem[_28481 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_28481 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_28481 + 50 len 14] * t / mem[_28481 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_28481')), 14)))
                                            revert
                    else:
                        if not stor119.length:
                            idx = 0
                            s = 0
                            while idx < stor119.length - 1:
                                require idx < mem[ceil32(return_data.size) + 96]
                                require idx + 1 < mem[ceil32(return_data.size) + 96]
                                _4453 = mem[(32 * idx + 1) + ceil32(return_data.size) + 128]
                                mem[mem[64] + 4] = mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]
                                mem[mem[64] + 36] = address(_4453)
                                require ext_code.size(stor117)
                                staticcall stor117.getPair(address rg1, address rg2) with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4], address(_4453)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4585 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_4585] == mem[_4585 + 12 len 20]
                                require ext_code.size(mem[_4585 + 12 len 20])
                                staticcall mem[_4585 + 12 len 20].getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5040 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_5040] == mem[_5040 + 18 len 14]
                                require mem[_5040 + 32] == mem[_5040 + 50 len 14]
                                require mem[_5040 + 64] == mem[_5040 + 92 len 4]
                                require idx < mem[ceil32(return_data.size) + 96]
                                require idx + 1 < mem[ceil32(return_data.size) + 96]
                                if mem[(32 * idx + 1) + ceil32(return_data.size) + 140 len 20] < mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]:
                                    if not s:
                                        if mem[_5040 + 50 len 14]:
                                            idx = idx + 1
                                            s = 0 / mem[_5040 + 50 len 14]
                                            continue 
                                    else:
                                        if mem[_5040 + 18 len 14] * s / s != mem[_5040 + 18 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_5040 + 50 len 14]:
                                            idx = idx + 1
                                            s = mem[_5040 + 18 len 14] * s / mem[_5040 + 50 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_5040')), 14)))
                                else:
                                    if not s:
                                        if mem[_5040 + 18 len 14]:
                                            idx = idx + 1
                                            s = 0 / mem[_5040 + 18 len 14]
                                            continue 
                                    else:
                                        if mem[_5040 + 50 len 14] * s / s != mem[_5040 + 50 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_5040 + 18 len 14]:
                                            idx = idx + 1
                                            s = mem[_5040 + 50 len 14] * s / mem[_5040 + 18 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_5040')), 14)))
                                revert
                            require stor118.length
                            mem[0] = 118
                            if address(stor118.field_0) == stakingTokenAddress:
                                _4661 = mem[64]
                                mem[64] = mem[64] + (32 * stor118.length) + 32
                                mem[_4661] = stor118.length
                                if not stor118.length:
                                    idx = 0
                                    t = totalSupply
                                    while idx < stor118.length - 1:
                                        require idx < mem[_4661]
                                        require idx + 1 < mem[_4661]
                                        _9105 = mem[(32 * idx + 1) + _4661 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _4661 + 44 len 20]
                                        mem[mem[64] + 36] = address(_9105)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_9105)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9442 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9442] == mem[_9442 + 12 len 20]
                                        require ext_code.size(mem[_9442 + 12 len 20])
                                        staticcall mem[_9442 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _10835 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_10835] == mem[_10835 + 18 len 14]
                                        require mem[_10835 + 32] == mem[_10835 + 50 len 14]
                                        require mem[_10835 + 64] == mem[_10835 + 92 len 4]
                                        require idx < mem[_4661]
                                        require idx + 1 < mem[_4661]
                                        if mem[(32 * idx + 1) + _4661 + 44 len 20] < mem[(32 * idx) + _4661 + 44 len 20]:
                                            if not t:
                                                if mem[_10835 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_10835 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_10835 + 18 len 14] * t / t != mem[_10835 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_10835 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_10835 + 18 len 14] * t / mem[_10835 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_10835')), 14)))
                                        else:
                                            if not t:
                                                if mem[_10835 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_10835 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_10835 + 50 len 14] * t / t != mem[_10835 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_10835 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_10835 + 50 len 14] * t / mem[_10835 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_10835')), 14)))
                                        revert
                                else:
                                    mem[0] = 118
                                    mem[_4661 + 32] = address(stor118.field_0)
                                    idx = _4661 + 32
                                    t = 0
                                    while _4661 + (32 * stor118.length) > idx:
                                        mem[idx + 32] = stor118[t].field_256
                                        idx = idx + 32
                                        t = t + 1
                                        continue 
                                    idx = 0
                                    t = totalSupply
                                    while idx < stor118.length - 1:
                                        require idx < mem[_4661]
                                        require idx + 1 < mem[_4661]
                                        _20665 = mem[(32 * idx + 1) + _4661 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _4661 + 44 len 20]
                                        mem[mem[64] + 36] = address(_20665)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_20665)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21044 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_21044] == mem[_21044 + 12 len 20]
                                        require ext_code.size(mem[_21044 + 12 len 20])
                                        staticcall mem[_21044 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22899 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_22899] == mem[_22899 + 18 len 14]
                                        require mem[_22899 + 32] == mem[_22899 + 50 len 14]
                                        require mem[_22899 + 64] == mem[_22899 + 92 len 4]
                                        require idx < mem[_4661]
                                        require idx + 1 < mem[_4661]
                                        if mem[(32 * idx + 1) + _4661 + 44 len 20] < mem[(32 * idx) + _4661 + 44 len 20]:
                                            if not t:
                                                if mem[_22899 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22899 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_22899 + 18 len 14] * t / t != mem[_22899 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22899 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22899 + 18 len 14] * t / mem[_22899 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_22899')), 14)))
                                        else:
                                            if not t:
                                                if mem[_22899 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22899 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_22899 + 50 len 14] * t / t != mem[_22899 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22899 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22899 + 50 len 14] * t / mem[_22899 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_22899')), 14)))
                                        revert
                            else:
                                require stor118.length
                                require stor118.length
                                require address(stor118.field_0) != stakingTokenAddress
                                require 0 < stor118.length
                                mem[0] = 118
                                mem[mem[64] + 4] = stakingTokenAddress
                                require ext_code.size(address(stor118.field_0))
                                staticcall address(stor118.field_0).0x70a08231 with:
                                        gas gas_remaining wei
                                       args stakingTokenAddress
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5039 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _5130 = mem[_5039]
                                if not mem[_5039]:
                                    _5551 = mem[64]
                                    mem[64] = mem[64] + (32 * stor118.length) + 32
                                    mem[_5551] = stor118.length
                                    if not stor118.length:
                                        idx = 0
                                        t = 0
                                        while idx < stor118.length - 1:
                                            require idx < mem[_5551]
                                            require idx + 1 < mem[_5551]
                                            _9109 = mem[(32 * idx + 1) + _5551 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _5551 + 44 len 20]
                                            mem[mem[64] + 36] = address(_9109)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_9109)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9446 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9446] == mem[_9446 + 12 len 20]
                                            require ext_code.size(mem[_9446 + 12 len 20])
                                            staticcall mem[_9446 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _10841 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_10841] == mem[_10841 + 18 len 14]
                                            require mem[_10841 + 32] == mem[_10841 + 50 len 14]
                                            require mem[_10841 + 64] == mem[_10841 + 92 len 4]
                                            require idx < mem[_5551]
                                            require idx + 1 < mem[_5551]
                                            if mem[(32 * idx + 1) + _5551 + 44 len 20] < mem[(32 * idx) + _5551 + 44 len 20]:
                                                if not t:
                                                    if mem[_10841 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10841 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10841 + 18 len 14] * t / t != mem[_10841 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10841 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10841 + 18 len 14] * t / mem[_10841 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_10841')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_10841 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10841 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10841 + 50 len 14] * t / t != mem[_10841 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10841 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10841 + 50 len 14] * t / mem[_10841 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_10841')), 14)))
                                            revert
                                    else:
                                        mem[0] = 118
                                        mem[_5551 + 32] = address(stor118.field_0)
                                        idx = _5551 + 32
                                        t = 0
                                        while _5551 + (32 * stor118.length) > idx:
                                            mem[idx + 32] = stor118[t].field_256
                                            idx = idx + 32
                                            t = t + 1
                                            continue 
                                        idx = 0
                                        t = 0
                                        while idx < stor118.length - 1:
                                            require idx < mem[_5551]
                                            require idx + 1 < mem[_5551]
                                            _20669 = mem[(32 * idx + 1) + _5551 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _5551 + 44 len 20]
                                            mem[mem[64] + 36] = address(_20669)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_20669)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _21048 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_21048] == mem[_21048 + 12 len 20]
                                            require ext_code.size(mem[_21048 + 12 len 20])
                                            staticcall mem[_21048 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22905 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_22905] == mem[_22905 + 18 len 14]
                                            require mem[_22905 + 32] == mem[_22905 + 50 len 14]
                                            require mem[_22905 + 64] == mem[_22905 + 92 len 4]
                                            require idx < mem[_5551]
                                            require idx + 1 < mem[_5551]
                                            if mem[(32 * idx + 1) + _5551 + 44 len 20] < mem[(32 * idx) + _5551 + 44 len 20]:
                                                if not t:
                                                    if mem[_22905 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22905 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22905 + 18 len 14] * t / t != mem[_22905 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22905 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22905 + 18 len 14] * t / mem[_22905 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_22905')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_22905 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22905 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22905 + 50 len 14] * t / t != mem[_22905 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22905 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22905 + 50 len 14] * t / mem[_22905 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_22905')), 14)))
                                            revert
                                else:
                                    if 2 * mem[_5039] / mem[_5039] != 2:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _5675 = mem[64]
                                    mem[64] = mem[64] + (32 * stor118.length) + 32
                                    mem[_5675] = stor118.length
                                    if not stor118.length:
                                        idx = 0
                                        t = 2 * _5130
                                        while idx < stor118.length - 1:
                                            require idx < mem[_5675]
                                            require idx + 1 < mem[_5675]
                                            _9107 = mem[(32 * idx + 1) + _5675 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _5675 + 44 len 20]
                                            mem[mem[64] + 36] = address(_9107)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_9107)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9444 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9444] == mem[_9444 + 12 len 20]
                                            require ext_code.size(mem[_9444 + 12 len 20])
                                            staticcall mem[_9444 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _10838 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_10838] == mem[_10838 + 18 len 14]
                                            require mem[_10838 + 32] == mem[_10838 + 50 len 14]
                                            require mem[_10838 + 64] == mem[_10838 + 92 len 4]
                                            require idx < mem[_5675]
                                            require idx + 1 < mem[_5675]
                                            if mem[(32 * idx + 1) + _5675 + 44 len 20] < mem[(32 * idx) + _5675 + 44 len 20]:
                                                if not t:
                                                    if mem[_10838 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10838 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10838 + 18 len 14] * t / t != mem[_10838 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10838 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10838 + 18 len 14] * t / mem[_10838 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_10838')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_10838 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10838 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10838 + 50 len 14] * t / t != mem[_10838 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10838 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10838 + 50 len 14] * t / mem[_10838 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_10838')), 14)))
                                            revert
                                    else:
                                        mem[0] = 118
                                        mem[_5675 + 32] = address(stor118.field_0)
                                        idx = _5675 + 32
                                        t = 0
                                        while _5675 + (32 * stor118.length) > idx:
                                            mem[idx + 32] = stor118[t].field_256
                                            idx = idx + 32
                                            t = t + 1
                                            continue 
                                        idx = 0
                                        t = 2 * _5130
                                        while idx < stor118.length - 1:
                                            require idx < mem[_5675]
                                            require idx + 1 < mem[_5675]
                                            _20667 = mem[(32 * idx + 1) + _5675 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _5675 + 44 len 20]
                                            mem[mem[64] + 36] = address(_20667)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_20667)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _21046 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_21046] == mem[_21046 + 12 len 20]
                                            require ext_code.size(mem[_21046 + 12 len 20])
                                            staticcall mem[_21046 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22902 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_22902] == mem[_22902 + 18 len 14]
                                            require mem[_22902 + 32] == mem[_22902 + 50 len 14]
                                            require mem[_22902 + 64] == mem[_22902 + 92 len 4]
                                            require idx < mem[_5675]
                                            require idx + 1 < mem[_5675]
                                            if mem[(32 * idx + 1) + _5675 + 44 len 20] < mem[(32 * idx) + _5675 + 44 len 20]:
                                                if not t:
                                                    if mem[_22902 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22902 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22902 + 18 len 14] * t / t != mem[_22902 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22902 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22902 + 18 len 14] * t / mem[_22902 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_22902')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_22902 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22902 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22902 + 50 len 14] * t / t != mem[_22902 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22902 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22902 + 50 len 14] * t / mem[_22902 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_22902')), 14)))
                                            revert
                        else:
                            mem[0] = 119
                            mem[ceil32(return_data.size) + 128] = address(stor119.field_0)
                            if (32 * stor119.length) + 32 <= 64:
                                idx = 0
                                s = 0
                                while idx < stor119.length - 1:
                                    require idx < mem[ceil32(return_data.size) + 96]
                                    require idx + 1 < mem[ceil32(return_data.size) + 96]
                                    _4455 = mem[(32 * idx + 1) + ceil32(return_data.size) + 128]
                                    mem[mem[64] + 4] = mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]
                                    mem[mem[64] + 36] = address(_4455)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_4455)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4586 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_4586] == mem[_4586 + 12 len 20]
                                    require ext_code.size(mem[_4586 + 12 len 20])
                                    staticcall mem[_4586 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5044 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_5044] == mem[_5044 + 18 len 14]
                                    require mem[_5044 + 32] == mem[_5044 + 50 len 14]
                                    require mem[_5044 + 64] == mem[_5044 + 92 len 4]
                                    require idx < mem[ceil32(return_data.size) + 96]
                                    require idx + 1 < mem[ceil32(return_data.size) + 96]
                                    if mem[(32 * idx + 1) + ceil32(return_data.size) + 140 len 20] < mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]:
                                        if not s:
                                            if mem[_5044 + 50 len 14]:
                                                idx = idx + 1
                                                s = 0 / mem[_5044 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_5044 + 18 len 14] * s / s != mem[_5044 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_5044 + 50 len 14]:
                                                idx = idx + 1
                                                s = mem[_5044 + 18 len 14] * s / mem[_5044 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_5044')), 14)))
                                    else:
                                        if not s:
                                            if mem[_5044 + 18 len 14]:
                                                idx = idx + 1
                                                s = 0 / mem[_5044 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_5044 + 50 len 14] * s / s != mem[_5044 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_5044 + 18 len 14]:
                                                idx = idx + 1
                                                s = mem[_5044 + 50 len 14] * s / mem[_5044 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_5044')), 14)))
                                    revert
                                require stor118.length
                                mem[0] = 118
                                if address(stor118.field_0) == stakingTokenAddress:
                                    _4663 = mem[64]
                                    mem[64] = mem[64] + (32 * stor118.length) + 32
                                    mem[_4663] = stor118.length
                                    if not stor118.length:
                                        idx = 0
                                        t = totalSupply
                                        while idx < stor118.length - 1:
                                            require idx < mem[_4663]
                                            require idx + 1 < mem[_4663]
                                            _9112 = mem[(32 * idx + 1) + _4663 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _4663 + 44 len 20]
                                            mem[mem[64] + 36] = address(_9112)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_9112)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9449 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9449] == mem[_9449 + 12 len 20]
                                            require ext_code.size(mem[_9449 + 12 len 20])
                                            staticcall mem[_9449 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _10848 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_10848] == mem[_10848 + 18 len 14]
                                            require mem[_10848 + 32] == mem[_10848 + 50 len 14]
                                            require mem[_10848 + 64] == mem[_10848 + 92 len 4]
                                            require idx < mem[_4663]
                                            require idx + 1 < mem[_4663]
                                            if mem[(32 * idx + 1) + _4663 + 44 len 20] < mem[(32 * idx) + _4663 + 44 len 20]:
                                                if not t:
                                                    if mem[_10848 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10848 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10848 + 18 len 14] * t / t != mem[_10848 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10848 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10848 + 18 len 14] * t / mem[_10848 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_10848')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_10848 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10848 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10848 + 50 len 14] * t / t != mem[_10848 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10848 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10848 + 50 len 14] * t / mem[_10848 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_10848')), 14)))
                                            revert
                                    else:
                                        mem[0] = 118
                                        mem[_4663 + 32] = address(stor118.field_0)
                                        idx = _4663 + 32
                                        t = 0
                                        while _4663 + (32 * stor118.length) > idx:
                                            mem[idx + 32] = stor118[t].field_256
                                            idx = idx + 32
                                            t = t + 1
                                            continue 
                                        idx = 0
                                        t = totalSupply
                                        while idx < stor118.length - 1:
                                            require idx < mem[_4663]
                                            require idx + 1 < mem[_4663]
                                            _20677 = mem[(32 * idx + 1) + _4663 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _4663 + 44 len 20]
                                            mem[mem[64] + 36] = address(_20677)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_20677)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _21056 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_21056] == mem[_21056 + 12 len 20]
                                            require ext_code.size(mem[_21056 + 12 len 20])
                                            staticcall mem[_21056 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22917 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_22917] == mem[_22917 + 18 len 14]
                                            require mem[_22917 + 32] == mem[_22917 + 50 len 14]
                                            require mem[_22917 + 64] == mem[_22917 + 92 len 4]
                                            require idx < mem[_4663]
                                            require idx + 1 < mem[_4663]
                                            if mem[(32 * idx + 1) + _4663 + 44 len 20] < mem[(32 * idx) + _4663 + 44 len 20]:
                                                if not t:
                                                    if mem[_22917 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22917 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22917 + 18 len 14] * t / t != mem[_22917 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22917 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22917 + 18 len 14] * t / mem[_22917 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_22917')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_22917 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22917 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22917 + 50 len 14] * t / t != mem[_22917 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22917 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22917 + 50 len 14] * t / mem[_22917 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_22917')), 14)))
                                            revert
                                else:
                                    require stor118.length
                                    require stor118.length
                                    require address(stor118.field_0) != stakingTokenAddress
                                    require 0 < stor118.length
                                    mem[0] = 118
                                    mem[mem[64] + 4] = stakingTokenAddress
                                    require ext_code.size(address(stor118.field_0))
                                    staticcall address(stor118.field_0).0x70a08231 with:
                                            gas gas_remaining wei
                                           args stakingTokenAddress
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5043 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _5133 = mem[_5043]
                                    if not mem[_5043]:
                                        _5554 = mem[64]
                                        mem[64] = mem[64] + (32 * stor118.length) + 32
                                        mem[_5554] = stor118.length
                                        if not stor118.length:
                                            idx = 0
                                            t = 0
                                            while idx < stor118.length - 1:
                                                require idx < mem[_5554]
                                                require idx + 1 < mem[_5554]
                                                _9116 = mem[(32 * idx + 1) + _5554 + 32]
                                                mem[mem[64] + 4] = mem[(32 * idx) + _5554 + 44 len 20]
                                                mem[mem[64] + 36] = address(_9116)
                                                require ext_code.size(stor117)
                                                staticcall stor117.getPair(address rg1, address rg2) with:
                                                        gas gas_remaining wei
                                                       args mem[mem[64] + 4], address(_9116)
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _9453 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_9453] == mem[_9453 + 12 len 20]
                                                require ext_code.size(mem[_9453 + 12 len 20])
                                                staticcall mem[_9453 + 12 len 20].getReserves() with:
                                                        gas gas_remaining wei
                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _10854 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 96
                                                require mem[_10854] == mem[_10854 + 18 len 14]
                                                require mem[_10854 + 32] == mem[_10854 + 50 len 14]
                                                require mem[_10854 + 64] == mem[_10854 + 92 len 4]
                                                require idx < mem[_5554]
                                                require idx + 1 < mem[_5554]
                                                if mem[(32 * idx + 1) + _5554 + 44 len 20] < mem[(32 * idx) + _5554 + 44 len 20]:
                                                    if not t:
                                                        if mem[_10854 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_10854 + 50 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_10854 + 18 len 14] * t / t != mem[_10854 + 18 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_10854 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_10854 + 18 len 14] * t / mem[_10854 + 50 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_10854')), 14)))
                                                else:
                                                    if not t:
                                                        if mem[_10854 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_10854 + 18 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_10854 + 50 len 14] * t / t != mem[_10854 + 50 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_10854 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_10854 + 50 len 14] * t / mem[_10854 + 18 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_10854')), 14)))
                                                revert
                                        else:
                                            mem[0] = 118
                                            mem[_5554 + 32] = address(stor118.field_0)
                                            idx = _5554 + 32
                                            t = 0
                                            while _5554 + (32 * stor118.length) > idx:
                                                mem[idx + 32] = stor118[t].field_256
                                                idx = idx + 32
                                                t = t + 1
                                                continue 
                                            idx = 0
                                            t = 0
                                            while idx < stor118.length - 1:
                                                require idx < mem[_5554]
                                                require idx + 1 < mem[_5554]
                                                _20681 = mem[(32 * idx + 1) + _5554 + 32]
                                                mem[mem[64] + 4] = mem[(32 * idx) + _5554 + 44 len 20]
                                                mem[mem[64] + 36] = address(_20681)
                                                require ext_code.size(stor117)
                                                staticcall stor117.getPair(address rg1, address rg2) with:
                                                        gas gas_remaining wei
                                                       args mem[mem[64] + 4], address(_20681)
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _21060 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_21060] == mem[_21060 + 12 len 20]
                                                require ext_code.size(mem[_21060 + 12 len 20])
                                                staticcall mem[_21060 + 12 len 20].getReserves() with:
                                                        gas gas_remaining wei
                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _22923 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 96
                                                require mem[_22923] == mem[_22923 + 18 len 14]
                                                require mem[_22923 + 32] == mem[_22923 + 50 len 14]
                                                require mem[_22923 + 64] == mem[_22923 + 92 len 4]
                                                require idx < mem[_5554]
                                                require idx + 1 < mem[_5554]
                                                if mem[(32 * idx + 1) + _5554 + 44 len 20] < mem[(32 * idx) + _5554 + 44 len 20]:
                                                    if not t:
                                                        if mem[_22923 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_22923 + 50 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_22923 + 18 len 14] * t / t != mem[_22923 + 18 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_22923 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_22923 + 18 len 14] * t / mem[_22923 + 50 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_22923')), 14)))
                                                else:
                                                    if not t:
                                                        if mem[_22923 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_22923 + 18 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_22923 + 50 len 14] * t / t != mem[_22923 + 50 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_22923 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_22923 + 50 len 14] * t / mem[_22923 + 18 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_22923')), 14)))
                                                revert
                                    else:
                                        if 2 * mem[_5043] / mem[_5043] != 2:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _5680 = mem[64]
                                        mem[64] = mem[64] + (32 * stor118.length) + 32
                                        mem[_5680] = stor118.length
                                        if not stor118.length:
                                            idx = 0
                                            t = 2 * _5133
                                            while idx < stor118.length - 1:
                                                require idx < mem[_5680]
                                                require idx + 1 < mem[_5680]
                                                _9114 = mem[(32 * idx + 1) + _5680 + 32]
                                                mem[mem[64] + 4] = mem[(32 * idx) + _5680 + 44 len 20]
                                                mem[mem[64] + 36] = address(_9114)
                                                require ext_code.size(stor117)
                                                staticcall stor117.getPair(address rg1, address rg2) with:
                                                        gas gas_remaining wei
                                                       args mem[mem[64] + 4], address(_9114)
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _9451 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_9451] == mem[_9451 + 12 len 20]
                                                require ext_code.size(mem[_9451 + 12 len 20])
                                                staticcall mem[_9451 + 12 len 20].getReserves() with:
                                                        gas gas_remaining wei
                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _10851 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 96
                                                require mem[_10851] == mem[_10851 + 18 len 14]
                                                require mem[_10851 + 32] == mem[_10851 + 50 len 14]
                                                require mem[_10851 + 64] == mem[_10851 + 92 len 4]
                                                require idx < mem[_5680]
                                                require idx + 1 < mem[_5680]
                                                if mem[(32 * idx + 1) + _5680 + 44 len 20] < mem[(32 * idx) + _5680 + 44 len 20]:
                                                    if not t:
                                                        if mem[_10851 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_10851 + 50 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_10851 + 18 len 14] * t / t != mem[_10851 + 18 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_10851 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_10851 + 18 len 14] * t / mem[_10851 + 50 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_10851')), 14)))
                                                else:
                                                    if not t:
                                                        if mem[_10851 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_10851 + 18 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_10851 + 50 len 14] * t / t != mem[_10851 + 50 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_10851 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_10851 + 50 len 14] * t / mem[_10851 + 18 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_10851')), 14)))
                                                revert
                                        else:
                                            mem[0] = 118
                                            mem[_5680 + 32] = address(stor118.field_0)
                                            idx = _5680 + 32
                                            t = 0
                                            while _5680 + (32 * stor118.length) > idx:
                                                mem[idx + 32] = stor118[t].field_256
                                                idx = idx + 32
                                                t = t + 1
                                                continue 
                                            idx = 0
                                            t = 2 * _5133
                                            while idx < stor118.length - 1:
                                                require idx < mem[_5680]
                                                require idx + 1 < mem[_5680]
                                                _20679 = mem[(32 * idx + 1) + _5680 + 32]
                                                mem[mem[64] + 4] = mem[(32 * idx) + _5680 + 44 len 20]
                                                mem[mem[64] + 36] = address(_20679)
                                                require ext_code.size(stor117)
                                                staticcall stor117.getPair(address rg1, address rg2) with:
                                                        gas gas_remaining wei
                                                       args mem[mem[64] + 4], address(_20679)
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _21058 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_21058] == mem[_21058 + 12 len 20]
                                                require ext_code.size(mem[_21058 + 12 len 20])
                                                staticcall mem[_21058 + 12 len 20].getReserves() with:
                                                        gas gas_remaining wei
                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _22920 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 96
                                                require mem[_22920] == mem[_22920 + 18 len 14]
                                                require mem[_22920 + 32] == mem[_22920 + 50 len 14]
                                                require mem[_22920 + 64] == mem[_22920 + 92 len 4]
                                                require idx < mem[_5680]
                                                require idx + 1 < mem[_5680]
                                                if mem[(32 * idx + 1) + _5680 + 44 len 20] < mem[(32 * idx) + _5680 + 44 len 20]:
                                                    if not t:
                                                        if mem[_22920 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_22920 + 50 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_22920 + 18 len 14] * t / t != mem[_22920 + 18 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_22920 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_22920 + 18 len 14] * t / mem[_22920 + 50 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_22920')), 14)))
                                                else:
                                                    if not t:
                                                        if mem[_22920 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_22920 + 18 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_22920 + 50 len 14] * t / t != mem[_22920 + 50 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_22920 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_22920 + 50 len 14] * t / mem[_22920 + 18 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_22920')), 14)))
                                                revert
                            else:
                                mem[ceil32(return_data.size) + 160] = address(stor119.field_256)
                                idx = ceil32(return_data.size) + 160
                                s = 1
                                while ceil32(return_data.size) + (32 * stor119.length) + 96 > idx:
                                    mem[idx + 32] = stor119[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                idx = 0
                                s = 0
                                while idx < stor119.length - 1:
                                    require idx < mem[ceil32(return_data.size) + 96]
                                    require idx + 1 < mem[ceil32(return_data.size) + 96]
                                    _14506 = mem[(32 * idx + 1) + ceil32(return_data.size) + 128]
                                    mem[mem[64] + 4] = mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]
                                    mem[mem[64] + 36] = address(_14506)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_14506)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _15308 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_15308] == mem[_15308 + 12 len 20]
                                    require ext_code.size(mem[_15308 + 12 len 20])
                                    staticcall mem[_15308 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _16524 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_16524] == mem[_16524 + 18 len 14]
                                    require mem[_16524 + 32] == mem[_16524 + 50 len 14]
                                    require mem[_16524 + 64] == mem[_16524 + 92 len 4]
                                    require idx < mem[ceil32(return_data.size) + 96]
                                    require idx + 1 < mem[ceil32(return_data.size) + 96]
                                    if mem[(32 * idx + 1) + ceil32(return_data.size) + 140 len 20] < mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]:
                                        if not s:
                                            if mem[_16524 + 50 len 14]:
                                                idx = idx + 1
                                                s = 0 / mem[_16524 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_16524 + 18 len 14] * s / s != mem[_16524 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_16524 + 50 len 14]:
                                                idx = idx + 1
                                                s = mem[_16524 + 18 len 14] * s / mem[_16524 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_16524')), 14)))
                                    else:
                                        if not s:
                                            if mem[_16524 + 18 len 14]:
                                                idx = idx + 1
                                                s = 0 / mem[_16524 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_16524 + 50 len 14] * s / s != mem[_16524 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_16524 + 18 len 14]:
                                                idx = idx + 1
                                                s = mem[_16524 + 50 len 14] * s / mem[_16524 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_16524')), 14)))
                                    revert
                                require stor118.length
                                mem[0] = 118
                                if address(stor118.field_0) == stakingTokenAddress:
                                    _15493 = mem[64]
                                    mem[64] = mem[64] + (32 * stor118.length) + 32
                                    mem[_15493] = stor118.length
                                    if not stor118.length:
                                        idx = 0
                                        t = totalSupply
                                        while idx < stor118.length - 1:
                                            require idx < mem[_15493]
                                            require idx + 1 < mem[_15493]
                                            _20671 = mem[(32 * idx + 1) + _15493 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _15493 + 44 len 20]
                                            mem[mem[64] + 36] = address(_20671)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_20671)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _21050 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_21050] == mem[_21050 + 12 len 20]
                                            require ext_code.size(mem[_21050 + 12 len 20])
                                            staticcall mem[_21050 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22908 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_22908] == mem[_22908 + 18 len 14]
                                            require mem[_22908 + 32] == mem[_22908 + 50 len 14]
                                            require mem[_22908 + 64] == mem[_22908 + 92 len 4]
                                            require idx < mem[_15493]
                                            require idx + 1 < mem[_15493]
                                            if mem[(32 * idx + 1) + _15493 + 44 len 20] < mem[(32 * idx) + _15493 + 44 len 20]:
                                                if not t:
                                                    if mem[_22908 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22908 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22908 + 18 len 14] * t / t != mem[_22908 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22908 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22908 + 18 len 14] * t / mem[_22908 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_22908')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_22908 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22908 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22908 + 50 len 14] * t / t != mem[_22908 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22908 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22908 + 50 len 14] * t / mem[_22908 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_22908')), 14)))
                                            revert
                                        if s:
                                            if 10^18 * s / s != 10^18:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not t:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            return (10^18 * s / t)
                                        if t:
                                            return (0 / t)
                                        var56001 = 32
                                        revert with 0, 'SafeMath: division by zero', 0
                                    mem[0] = 118
                                    mem[_15493 + 32] = address(stor118.field_0)
                                    idx = _15493 + 32
                                    t = 0
                                    while _15493 + (32 * stor118.length) > idx:
                                        mem[idx + 32] = stor118[t].field_256
                                        idx = idx + 32
                                        t = t + 1
                                        continue 
                                    idx = 0
                                    t = totalSupply
                                    while idx < stor118.length - 1:
                                        require idx < mem[_15493]
                                        require idx + 1 < mem[_15493]
                                        _27741 = mem[(32 * idx + 1) + _15493 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _15493 + 44 len 20]
                                        mem[mem[64] + 36] = address(_27741)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_27741)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27868 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_27868] == mem[_27868 + 12 len 20]
                                        require ext_code.size(mem[_27868 + 12 len 20])
                                        staticcall mem[_27868 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _28487 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_28487] == mem[_28487 + 18 len 14]
                                        require mem[_28487 + 32] == mem[_28487 + 50 len 14]
                                        require mem[_28487 + 64] == mem[_28487 + 92 len 4]
                                        require idx < mem[_15493]
                                        require idx + 1 < mem[_15493]
                                        if mem[(32 * idx + 1) + _15493 + 44 len 20] < mem[(32 * idx) + _15493 + 44 len 20]:
                                            if not t:
                                                if mem[_28487 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_28487 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_28487 + 18 len 14] * t / t != mem[_28487 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_28487 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_28487 + 18 len 14] * t / mem[_28487 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_28487')), 14)))
                                        else:
                                            if not t:
                                                if mem[_28487 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_28487 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_28487 + 50 len 14] * t / t != mem[_28487 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_28487 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_28487 + 50 len 14] * t / mem[_28487 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_28487')), 14)))
                                        revert
                                else:
                                    require stor118.length
                                    require stor118.length
                                    require address(stor118.field_0) != stakingTokenAddress
                                    require 0 < stor118.length
                                    mem[0] = 118
                                    mem[mem[64] + 4] = stakingTokenAddress
                                    require ext_code.size(address(stor118.field_0))
                                    staticcall address(stor118.field_0).0x70a08231 with:
                                            gas gas_remaining wei
                                           args stakingTokenAddress
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _16523 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _16918 = mem[_16523]
                                    if not mem[_16523]:
                                        _17801 = mem[64]
                                        mem[64] = mem[64] + (32 * stor118.length) + 32
                                        mem[_17801] = stor118.length
                                        if not stor118.length:
                                            idx = 0
                                            t = 0
                                            while idx < stor118.length - 1:
                                                require idx < mem[_17801]
                                                require idx + 1 < mem[_17801]
                                                _20675 = mem[(32 * idx + 1) + _17801 + 32]
                                                mem[mem[64] + 4] = mem[(32 * idx) + _17801 + 44 len 20]
                                                mem[mem[64] + 36] = address(_20675)
                                                require ext_code.size(stor117)
                                                staticcall stor117.getPair(address rg1, address rg2) with:
                                                        gas gas_remaining wei
                                                       args mem[mem[64] + 4], address(_20675)
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _21054 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_21054] == mem[_21054 + 12 len 20]
                                                require ext_code.size(mem[_21054 + 12 len 20])
                                                staticcall mem[_21054 + 12 len 20].getReserves() with:
                                                        gas gas_remaining wei
                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _22914 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 96
                                                require mem[_22914] == mem[_22914 + 18 len 14]
                                                require mem[_22914 + 32] == mem[_22914 + 50 len 14]
                                                require mem[_22914 + 64] == mem[_22914 + 92 len 4]
                                                require idx < mem[_17801]
                                                require idx + 1 < mem[_17801]
                                                if mem[(32 * idx + 1) + _17801 + 44 len 20] < mem[(32 * idx) + _17801 + 44 len 20]:
                                                    if not t:
                                                        if mem[_22914 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_22914 + 50 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_22914 + 18 len 14] * t / t != mem[_22914 + 18 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_22914 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_22914 + 18 len 14] * t / mem[_22914 + 50 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_22914')), 14)))
                                                else:
                                                    if not t:
                                                        if mem[_22914 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_22914 + 18 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_22914 + 50 len 14] * t / t != mem[_22914 + 50 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_22914 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_22914 + 50 len 14] * t / mem[_22914 + 18 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_22914')), 14)))
                                                revert
                                            if not s:
                                                if not t:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                return (0 / t)
                                            if 10^18 * s / s != 10^18:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not t:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            return (10^18 * s / t)
                                        mem[0] = 118
                                        mem[_17801 + 32] = address(stor118.field_0)
                                        idx = _17801 + 32
                                        t = 0
                                        while _17801 + (32 * stor118.length) > idx:
                                            mem[idx + 32] = stor118[t].field_256
                                            idx = idx + 32
                                            t = t + 1
                                            continue 
                                        idx = 0
                                        t = 0
                                        while idx < stor118.length - 1:
                                            require idx < mem[_17801]
                                            require idx + 1 < mem[_17801]
                                            _27745 = mem[(32 * idx + 1) + _17801 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _17801 + 44 len 20]
                                            mem[mem[64] + 36] = address(_27745)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_27745)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27872 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_27872] == mem[_27872 + 12 len 20]
                                            require ext_code.size(mem[_27872 + 12 len 20])
                                            staticcall mem[_27872 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _28493 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_28493] == mem[_28493 + 18 len 14]
                                            require mem[_28493 + 32] == mem[_28493 + 50 len 14]
                                            require mem[_28493 + 64] == mem[_28493 + 92 len 4]
                                            require idx < mem[_17801]
                                            require idx + 1 < mem[_17801]
                                            if mem[(32 * idx + 1) + _17801 + 44 len 20] < mem[(32 * idx) + _17801 + 44 len 20]:
                                                if not t:
                                                    if mem[_28493 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_28493 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_28493 + 18 len 14] * t / t != mem[_28493 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_28493 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_28493 + 18 len 14] * t / mem[_28493 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_28493')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_28493 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_28493 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_28493 + 50 len 14] * t / t != mem[_28493 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_28493 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_28493 + 50 len 14] * t / mem[_28493 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_28493')), 14)))
                                            revert
                                        if s:
                                            if 10^18 * s / s != 10^18:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not t:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            return (10^18 * s / t)
                                        if t:
                                            return (0 / t)
                                        var75001 = 32
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if 2 * mem[_16523] / mem[_16523] != 2:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _17926 = mem[64]
                                    mem[64] = mem[64] + (32 * stor118.length) + 32
                                    mem[_17926] = stor118.length
                                    if not stor118.length:
                                        idx = 0
                                        t = 2 * _16918
                                        while idx < stor118.length - 1:
                                            require idx < mem[_17926]
                                            require idx + 1 < mem[_17926]
                                            _20673 = mem[(32 * idx + 1) + _17926 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _17926 + 44 len 20]
                                            mem[mem[64] + 36] = address(_20673)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_20673)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _21052 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_21052] == mem[_21052 + 12 len 20]
                                            require ext_code.size(mem[_21052 + 12 len 20])
                                            staticcall mem[_21052 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22911 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_22911] == mem[_22911 + 18 len 14]
                                            require mem[_22911 + 32] == mem[_22911 + 50 len 14]
                                            require mem[_22911 + 64] == mem[_22911 + 92 len 4]
                                            require idx < mem[_17926]
                                            require idx + 1 < mem[_17926]
                                            if mem[(32 * idx + 1) + _17926 + 44 len 20] < mem[(32 * idx) + _17926 + 44 len 20]:
                                                if not t:
                                                    if mem[_22911 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22911 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22911 + 18 len 14] * t / t != mem[_22911 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22911 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22911 + 18 len 14] * t / mem[_22911 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_22911')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_22911 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22911 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22911 + 50 len 14] * t / t != mem[_22911 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22911 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22911 + 50 len 14] * t / mem[_22911 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_22911')), 14)))
                                            revert
                                    else:
                                        mem[0] = 118
                                        mem[_17926 + 32] = address(stor118.field_0)
                                        idx = _17926 + 32
                                        t = 0
                                        while _17926 + (32 * stor118.length) > idx:
                                            mem[idx + 32] = stor118[t].field_256
                                            idx = idx + 32
                                            t = t + 1
                                            continue 
                                        idx = 0
                                        t = 2 * _16918
                                        while idx < stor118.length - 1:
                                            require idx < mem[_17926]
                                            require idx + 1 < mem[_17926]
                                            _27743 = mem[(32 * idx + 1) + _17926 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _17926 + 44 len 20]
                                            mem[mem[64] + 36] = address(_27743)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_27743)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27870 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_27870] == mem[_27870 + 12 len 20]
                                            require ext_code.size(mem[_27870 + 12 len 20])
                                            staticcall mem[_27870 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _28490 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_28490] == mem[_28490 + 18 len 14]
                                            require mem[_28490 + 32] == mem[_28490 + 50 len 14]
                                            require mem[_28490 + 64] == mem[_28490 + 92 len 4]
                                            require idx < mem[_17926]
                                            require idx + 1 < mem[_17926]
                                            if mem[(32 * idx + 1) + _17926 + 44 len 20] < mem[(32 * idx) + _17926 + 44 len 20]:
                                                if not t:
                                                    if mem[_28490 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_28490 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_28490 + 18 len 14] * t / t != mem[_28490 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_28490 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_28490 + 18 len 14] * t / mem[_28490 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_28490')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_28490 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_28490 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_28490 + 50 len 14] * t / t != mem[_28490 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_28490 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_28490 + 50 len 14] * t / mem[_28490 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_28490')), 14)))
                                            revert
                else:
                    mem[ceil32(return_data.size) + 96] = 30
                    mem[ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                    if lastUpdateTime > periodFinish:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    mem[ceil32(return_data.size) + 160] = 26
                    mem[ceil32(return_data.size) + 192] = 'SafeMath: division by zero'
                    if not periodFinish - lastUpdateTime:
                        revert with 0, 'SafeMath: division by zero', 0
                    require 0 < stor119.length
                    mem[0] = 119
                    require address(stor119.field_0) == rewardsTokenAddress
                    mem[64] = ceil32(return_data.size) + (32 * stor119.length) + 256
                    mem[ceil32(return_data.size) + 224] = stor119.length
                    if not stor119.length:
                        idx = 0
                        s = 0 / periodFinish - lastUpdateTime
                        while idx < stor119.length - 1:
                            require idx < mem[ceil32(return_data.size) + 224]
                            require idx + 1 < mem[ceil32(return_data.size) + 224]
                            _4457 = mem[(32 * idx + 1) + ceil32(return_data.size) + 256]
                            mem[mem[64] + 4] = mem[(32 * idx) + ceil32(return_data.size) + 268 len 20]
                            mem[mem[64] + 36] = address(_4457)
                            require ext_code.size(stor117)
                            staticcall stor117.getPair(address rg1, address rg2) with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4], address(_4457)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4587 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_4587] == mem[_4587 + 12 len 20]
                            require ext_code.size(mem[_4587 + 12 len 20])
                            staticcall mem[_4587 + 12 len 20].getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _5048 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_5048] == mem[_5048 + 18 len 14]
                            require mem[_5048 + 32] == mem[_5048 + 50 len 14]
                            require mem[_5048 + 64] == mem[_5048 + 92 len 4]
                            require idx < mem[ceil32(return_data.size) + 224]
                            require idx + 1 < mem[ceil32(return_data.size) + 224]
                            if mem[(32 * idx + 1) + ceil32(return_data.size) + 268 len 20] < mem[(32 * idx) + ceil32(return_data.size) + 268 len 20]:
                                if not s:
                                    if mem[_5048 + 50 len 14]:
                                        idx = idx + 1
                                        s = 0 / mem[_5048 + 50 len 14]
                                        continue 
                                else:
                                    if mem[_5048 + 18 len 14] * s / s != mem[_5048 + 18 len 14]:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if mem[_5048 + 50 len 14]:
                                        idx = idx + 1
                                        s = mem[_5048 + 18 len 14] * s / mem[_5048 + 50 len 14]
                                        continue 
                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_5048')), 14)))
                            else:
                                if not s:
                                    if mem[_5048 + 18 len 14]:
                                        idx = idx + 1
                                        s = 0 / mem[_5048 + 18 len 14]
                                        continue 
                                else:
                                    if mem[_5048 + 50 len 14] * s / s != mem[_5048 + 50 len 14]:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if mem[_5048 + 18 len 14]:
                                        idx = idx + 1
                                        s = mem[_5048 + 50 len 14] * s / mem[_5048 + 18 len 14]
                                        continue 
                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_5048')), 14)))
                            revert
                        require stor118.length
                        mem[0] = 118
                        if address(stor118.field_0) == stakingTokenAddress:
                            _4665 = mem[64]
                            mem[64] = mem[64] + (32 * stor118.length) + 32
                            mem[_4665] = stor118.length
                            if not stor118.length:
                                idx = 0
                                t = totalSupply
                                while idx < stor118.length - 1:
                                    require idx < mem[_4665]
                                    require idx + 1 < mem[_4665]
                                    _9118 = mem[(32 * idx + 1) + _4665 + 32]
                                    mem[mem[64] + 4] = mem[(32 * idx) + _4665 + 44 len 20]
                                    mem[mem[64] + 36] = address(_9118)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_9118)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9455 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_9455] == mem[_9455 + 12 len 20]
                                    require ext_code.size(mem[_9455 + 12 len 20])
                                    staticcall mem[_9455 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10857 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_10857] == mem[_10857 + 18 len 14]
                                    require mem[_10857 + 32] == mem[_10857 + 50 len 14]
                                    require mem[_10857 + 64] == mem[_10857 + 92 len 4]
                                    require idx < mem[_4665]
                                    require idx + 1 < mem[_4665]
                                    if mem[(32 * idx + 1) + _4665 + 44 len 20] < mem[(32 * idx) + _4665 + 44 len 20]:
                                        if not t:
                                            if mem[_10857 + 50 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_10857 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_10857 + 18 len 14] * t / t != mem[_10857 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_10857 + 50 len 14]:
                                                idx = idx + 1
                                                t = mem[_10857 + 18 len 14] * t / mem[_10857 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_10857')), 14)))
                                    else:
                                        if not t:
                                            if mem[_10857 + 18 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_10857 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_10857 + 50 len 14] * t / t != mem[_10857 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_10857 + 18 len 14]:
                                                idx = idx + 1
                                                t = mem[_10857 + 50 len 14] * t / mem[_10857 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_10857')), 14)))
                                    revert
                            else:
                                mem[0] = 118
                                mem[_4665 + 32] = address(stor118.field_0)
                                idx = _4665 + 32
                                t = 0
                                while _4665 + (32 * stor118.length) > idx:
                                    mem[idx + 32] = stor118[t].field_256
                                    idx = idx + 32
                                    t = t + 1
                                    continue 
                                idx = 0
                                t = totalSupply
                                while idx < stor118.length - 1:
                                    require idx < mem[_4665]
                                    require idx + 1 < mem[_4665]
                                    _20683 = mem[(32 * idx + 1) + _4665 + 32]
                                    mem[mem[64] + 4] = mem[(32 * idx) + _4665 + 44 len 20]
                                    mem[mem[64] + 36] = address(_20683)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_20683)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21062 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_21062] == mem[_21062 + 12 len 20]
                                    require ext_code.size(mem[_21062 + 12 len 20])
                                    staticcall mem[_21062 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _22926 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_22926] == mem[_22926 + 18 len 14]
                                    require mem[_22926 + 32] == mem[_22926 + 50 len 14]
                                    require mem[_22926 + 64] == mem[_22926 + 92 len 4]
                                    require idx < mem[_4665]
                                    require idx + 1 < mem[_4665]
                                    if mem[(32 * idx + 1) + _4665 + 44 len 20] < mem[(32 * idx) + _4665 + 44 len 20]:
                                        if not t:
                                            if mem[_22926 + 50 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_22926 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_22926 + 18 len 14] * t / t != mem[_22926 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_22926 + 50 len 14]:
                                                idx = idx + 1
                                                t = mem[_22926 + 18 len 14] * t / mem[_22926 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_22926')), 14)))
                                    else:
                                        if not t:
                                            if mem[_22926 + 18 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_22926 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_22926 + 50 len 14] * t / t != mem[_22926 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_22926 + 18 len 14]:
                                                idx = idx + 1
                                                t = mem[_22926 + 50 len 14] * t / mem[_22926 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_22926')), 14)))
                                    revert
                        else:
                            require stor118.length
                            require stor118.length
                            require address(stor118.field_0) != stakingTokenAddress
                            require 0 < stor118.length
                            mem[0] = 118
                            mem[mem[64] + 4] = stakingTokenAddress
                            require ext_code.size(address(stor118.field_0))
                            staticcall address(stor118.field_0).0x70a08231 with:
                                    gas gas_remaining wei
                                   args stakingTokenAddress
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _5047 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _5136 = mem[_5047]
                            if not mem[_5047]:
                                _5557 = mem[64]
                                mem[64] = mem[64] + (32 * stor118.length) + 32
                                mem[_5557] = stor118.length
                                if not stor118.length:
                                    idx = 0
                                    t = 0
                                    while idx < stor118.length - 1:
                                        require idx < mem[_5557]
                                        require idx + 1 < mem[_5557]
                                        _9122 = mem[(32 * idx + 1) + _5557 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _5557 + 44 len 20]
                                        mem[mem[64] + 36] = address(_9122)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_9122)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9459 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9459] == mem[_9459 + 12 len 20]
                                        require ext_code.size(mem[_9459 + 12 len 20])
                                        staticcall mem[_9459 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _10863 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_10863] == mem[_10863 + 18 len 14]
                                        require mem[_10863 + 32] == mem[_10863 + 50 len 14]
                                        require mem[_10863 + 64] == mem[_10863 + 92 len 4]
                                        require idx < mem[_5557]
                                        require idx + 1 < mem[_5557]
                                        if mem[(32 * idx + 1) + _5557 + 44 len 20] < mem[(32 * idx) + _5557 + 44 len 20]:
                                            if not t:
                                                if mem[_10863 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_10863 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_10863 + 18 len 14] * t / t != mem[_10863 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_10863 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_10863 + 18 len 14] * t / mem[_10863 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_10863')), 14)))
                                        else:
                                            if not t:
                                                if mem[_10863 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_10863 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_10863 + 50 len 14] * t / t != mem[_10863 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_10863 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_10863 + 50 len 14] * t / mem[_10863 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_10863')), 14)))
                                        revert
                                else:
                                    mem[0] = 118
                                    mem[_5557 + 32] = address(stor118.field_0)
                                    idx = _5557 + 32
                                    t = 0
                                    while _5557 + (32 * stor118.length) > idx:
                                        mem[idx + 32] = stor118[t].field_256
                                        idx = idx + 32
                                        t = t + 1
                                        continue 
                                    idx = 0
                                    t = 0
                                    while idx < stor118.length - 1:
                                        require idx < mem[_5557]
                                        require idx + 1 < mem[_5557]
                                        _20687 = mem[(32 * idx + 1) + _5557 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _5557 + 44 len 20]
                                        mem[mem[64] + 36] = address(_20687)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_20687)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21066 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_21066] == mem[_21066 + 12 len 20]
                                        require ext_code.size(mem[_21066 + 12 len 20])
                                        staticcall mem[_21066 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22932 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_22932] == mem[_22932 + 18 len 14]
                                        require mem[_22932 + 32] == mem[_22932 + 50 len 14]
                                        require mem[_22932 + 64] == mem[_22932 + 92 len 4]
                                        require idx < mem[_5557]
                                        require idx + 1 < mem[_5557]
                                        if mem[(32 * idx + 1) + _5557 + 44 len 20] < mem[(32 * idx) + _5557 + 44 len 20]:
                                            if not t:
                                                if mem[_22932 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22932 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_22932 + 18 len 14] * t / t != mem[_22932 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22932 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22932 + 18 len 14] * t / mem[_22932 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_22932')), 14)))
                                        else:
                                            if not t:
                                                if mem[_22932 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22932 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_22932 + 50 len 14] * t / t != mem[_22932 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22932 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22932 + 50 len 14] * t / mem[_22932 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_22932')), 14)))
                                        revert
                            else:
                                if 2 * mem[_5047] / mem[_5047] != 2:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _5685 = mem[64]
                                mem[64] = mem[64] + (32 * stor118.length) + 32
                                mem[_5685] = stor118.length
                                if not stor118.length:
                                    idx = 0
                                    t = 2 * _5136
                                    while idx < stor118.length - 1:
                                        require idx < mem[_5685]
                                        require idx + 1 < mem[_5685]
                                        _9120 = mem[(32 * idx + 1) + _5685 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _5685 + 44 len 20]
                                        mem[mem[64] + 36] = address(_9120)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_9120)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9457 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9457] == mem[_9457 + 12 len 20]
                                        require ext_code.size(mem[_9457 + 12 len 20])
                                        staticcall mem[_9457 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _10860 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_10860] == mem[_10860 + 18 len 14]
                                        require mem[_10860 + 32] == mem[_10860 + 50 len 14]
                                        require mem[_10860 + 64] == mem[_10860 + 92 len 4]
                                        require idx < mem[_5685]
                                        require idx + 1 < mem[_5685]
                                        if mem[(32 * idx + 1) + _5685 + 44 len 20] < mem[(32 * idx) + _5685 + 44 len 20]:
                                            if not t:
                                                if mem[_10860 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_10860 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_10860 + 18 len 14] * t / t != mem[_10860 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_10860 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_10860 + 18 len 14] * t / mem[_10860 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_10860')), 14)))
                                        else:
                                            if not t:
                                                if mem[_10860 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_10860 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_10860 + 50 len 14] * t / t != mem[_10860 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_10860 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_10860 + 50 len 14] * t / mem[_10860 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_10860')), 14)))
                                        revert
                                else:
                                    mem[0] = 118
                                    mem[_5685 + 32] = address(stor118.field_0)
                                    idx = _5685 + 32
                                    t = 0
                                    while _5685 + (32 * stor118.length) > idx:
                                        mem[idx + 32] = stor118[t].field_256
                                        idx = idx + 32
                                        t = t + 1
                                        continue 
                                    idx = 0
                                    t = 2 * _5136
                                    while idx < stor118.length - 1:
                                        require idx < mem[_5685]
                                        require idx + 1 < mem[_5685]
                                        _20685 = mem[(32 * idx + 1) + _5685 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _5685 + 44 len 20]
                                        mem[mem[64] + 36] = address(_20685)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_20685)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21064 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_21064] == mem[_21064 + 12 len 20]
                                        require ext_code.size(mem[_21064 + 12 len 20])
                                        staticcall mem[_21064 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22929 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_22929] == mem[_22929 + 18 len 14]
                                        require mem[_22929 + 32] == mem[_22929 + 50 len 14]
                                        require mem[_22929 + 64] == mem[_22929 + 92 len 4]
                                        require idx < mem[_5685]
                                        require idx + 1 < mem[_5685]
                                        if mem[(32 * idx + 1) + _5685 + 44 len 20] < mem[(32 * idx) + _5685 + 44 len 20]:
                                            if not t:
                                                if mem[_22929 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22929 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_22929 + 18 len 14] * t / t != mem[_22929 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22929 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22929 + 18 len 14] * t / mem[_22929 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_22929')), 14)))
                                        else:
                                            if not t:
                                                if mem[_22929 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22929 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_22929 + 50 len 14] * t / t != mem[_22929 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22929 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22929 + 50 len 14] * t / mem[_22929 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_22929')), 14)))
                                        revert
                    else:
                        mem[0] = 119
                        mem[ceil32(return_data.size) + 256] = address(stor119.field_0)
                        if (32 * stor119.length) + 32 <= 64:
                            idx = 0
                            s = 0 / periodFinish - lastUpdateTime
                            while idx < stor119.length - 1:
                                require idx < mem[ceil32(return_data.size) + 224]
                                require idx + 1 < mem[ceil32(return_data.size) + 224]
                                _4459 = mem[(32 * idx + 1) + ceil32(return_data.size) + 256]
                                mem[mem[64] + 4] = mem[(32 * idx) + ceil32(return_data.size) + 268 len 20]
                                mem[mem[64] + 36] = address(_4459)
                                require ext_code.size(stor117)
                                staticcall stor117.getPair(address rg1, address rg2) with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4], address(_4459)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4588 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_4588] == mem[_4588 + 12 len 20]
                                require ext_code.size(mem[_4588 + 12 len 20])
                                staticcall mem[_4588 + 12 len 20].getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5052 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_5052] == mem[_5052 + 18 len 14]
                                require mem[_5052 + 32] == mem[_5052 + 50 len 14]
                                require mem[_5052 + 64] == mem[_5052 + 92 len 4]
                                require idx < mem[ceil32(return_data.size) + 224]
                                require idx + 1 < mem[ceil32(return_data.size) + 224]
                                if mem[(32 * idx + 1) + ceil32(return_data.size) + 268 len 20] < mem[(32 * idx) + ceil32(return_data.size) + 268 len 20]:
                                    if not s:
                                        if mem[_5052 + 50 len 14]:
                                            idx = idx + 1
                                            s = 0 / mem[_5052 + 50 len 14]
                                            continue 
                                    else:
                                        if mem[_5052 + 18 len 14] * s / s != mem[_5052 + 18 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_5052 + 50 len 14]:
                                            idx = idx + 1
                                            s = mem[_5052 + 18 len 14] * s / mem[_5052 + 50 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_5052')), 14)))
                                else:
                                    if not s:
                                        if mem[_5052 + 18 len 14]:
                                            idx = idx + 1
                                            s = 0 / mem[_5052 + 18 len 14]
                                            continue 
                                    else:
                                        if mem[_5052 + 50 len 14] * s / s != mem[_5052 + 50 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_5052 + 18 len 14]:
                                            idx = idx + 1
                                            s = mem[_5052 + 50 len 14] * s / mem[_5052 + 18 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_5052')), 14)))
                                revert
                            require stor118.length
                            mem[0] = 118
                            if address(stor118.field_0) == stakingTokenAddress:
                                _4667 = mem[64]
                                mem[64] = mem[64] + (32 * stor118.length) + 32
                                mem[_4667] = stor118.length
                                if not stor118.length:
                                    idx = 0
                                    t = totalSupply
                                    while idx < stor118.length - 1:
                                        require idx < mem[_4667]
                                        require idx + 1 < mem[_4667]
                                        _9125 = mem[(32 * idx + 1) + _4667 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _4667 + 44 len 20]
                                        mem[mem[64] + 36] = address(_9125)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_9125)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9462 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9462] == mem[_9462 + 12 len 20]
                                        require ext_code.size(mem[_9462 + 12 len 20])
                                        staticcall mem[_9462 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _10870 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_10870] == mem[_10870 + 18 len 14]
                                        require mem[_10870 + 32] == mem[_10870 + 50 len 14]
                                        require mem[_10870 + 64] == mem[_10870 + 92 len 4]
                                        require idx < mem[_4667]
                                        require idx + 1 < mem[_4667]
                                        if mem[(32 * idx + 1) + _4667 + 44 len 20] < mem[(32 * idx) + _4667 + 44 len 20]:
                                            if not t:
                                                if mem[_10870 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_10870 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_10870 + 18 len 14] * t / t != mem[_10870 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_10870 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_10870 + 18 len 14] * t / mem[_10870 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_10870')), 14)))
                                        else:
                                            if not t:
                                                if mem[_10870 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_10870 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_10870 + 50 len 14] * t / t != mem[_10870 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_10870 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_10870 + 50 len 14] * t / mem[_10870 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_10870')), 14)))
                                        revert
                                else:
                                    mem[0] = 118
                                    mem[_4667 + 32] = address(stor118.field_0)
                                    idx = _4667 + 32
                                    t = 0
                                    while _4667 + (32 * stor118.length) > idx:
                                        mem[idx + 32] = stor118[t].field_256
                                        idx = idx + 32
                                        t = t + 1
                                        continue 
                                    idx = 0
                                    t = totalSupply
                                    while idx < stor118.length - 1:
                                        require idx < mem[_4667]
                                        require idx + 1 < mem[_4667]
                                        _20695 = mem[(32 * idx + 1) + _4667 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _4667 + 44 len 20]
                                        mem[mem[64] + 36] = address(_20695)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_20695)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21074 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_21074] == mem[_21074 + 12 len 20]
                                        require ext_code.size(mem[_21074 + 12 len 20])
                                        staticcall mem[_21074 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22944 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_22944] == mem[_22944 + 18 len 14]
                                        require mem[_22944 + 32] == mem[_22944 + 50 len 14]
                                        require mem[_22944 + 64] == mem[_22944 + 92 len 4]
                                        require idx < mem[_4667]
                                        require idx + 1 < mem[_4667]
                                        if mem[(32 * idx + 1) + _4667 + 44 len 20] < mem[(32 * idx) + _4667 + 44 len 20]:
                                            if not t:
                                                if mem[_22944 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22944 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_22944 + 18 len 14] * t / t != mem[_22944 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22944 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22944 + 18 len 14] * t / mem[_22944 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_22944')), 14)))
                                        else:
                                            if not t:
                                                if mem[_22944 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22944 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_22944 + 50 len 14] * t / t != mem[_22944 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22944 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22944 + 50 len 14] * t / mem[_22944 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_22944')), 14)))
                                        revert
                            else:
                                require stor118.length
                                require stor118.length
                                require address(stor118.field_0) != stakingTokenAddress
                                require 0 < stor118.length
                                mem[0] = 118
                                mem[mem[64] + 4] = stakingTokenAddress
                                require ext_code.size(address(stor118.field_0))
                                staticcall address(stor118.field_0).0x70a08231 with:
                                        gas gas_remaining wei
                                       args stakingTokenAddress
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5051 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _5139 = mem[_5051]
                                if not mem[_5051]:
                                    _5560 = mem[64]
                                    mem[64] = mem[64] + (32 * stor118.length) + 32
                                    mem[_5560] = stor118.length
                                    if not stor118.length:
                                        idx = 0
                                        t = 0
                                        while idx < stor118.length - 1:
                                            require idx < mem[_5560]
                                            require idx + 1 < mem[_5560]
                                            _9129 = mem[(32 * idx + 1) + _5560 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _5560 + 44 len 20]
                                            mem[mem[64] + 36] = address(_9129)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_9129)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9466 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9466] == mem[_9466 + 12 len 20]
                                            require ext_code.size(mem[_9466 + 12 len 20])
                                            staticcall mem[_9466 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _10876 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_10876] == mem[_10876 + 18 len 14]
                                            require mem[_10876 + 32] == mem[_10876 + 50 len 14]
                                            require mem[_10876 + 64] == mem[_10876 + 92 len 4]
                                            require idx < mem[_5560]
                                            require idx + 1 < mem[_5560]
                                            if mem[(32 * idx + 1) + _5560 + 44 len 20] < mem[(32 * idx) + _5560 + 44 len 20]:
                                                if not t:
                                                    if mem[_10876 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10876 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10876 + 18 len 14] * t / t != mem[_10876 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10876 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10876 + 18 len 14] * t / mem[_10876 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_10876')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_10876 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10876 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10876 + 50 len 14] * t / t != mem[_10876 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10876 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10876 + 50 len 14] * t / mem[_10876 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_10876')), 14)))
                                            revert
                                    else:
                                        mem[0] = 118
                                        mem[_5560 + 32] = address(stor118.field_0)
                                        idx = _5560 + 32
                                        t = 0
                                        while _5560 + (32 * stor118.length) > idx:
                                            mem[idx + 32] = stor118[t].field_256
                                            idx = idx + 32
                                            t = t + 1
                                            continue 
                                        idx = 0
                                        t = 0
                                        while idx < stor118.length - 1:
                                            require idx < mem[_5560]
                                            require idx + 1 < mem[_5560]
                                            _20699 = mem[(32 * idx + 1) + _5560 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _5560 + 44 len 20]
                                            mem[mem[64] + 36] = address(_20699)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_20699)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _21078 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_21078] == mem[_21078 + 12 len 20]
                                            require ext_code.size(mem[_21078 + 12 len 20])
                                            staticcall mem[_21078 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22950 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_22950] == mem[_22950 + 18 len 14]
                                            require mem[_22950 + 32] == mem[_22950 + 50 len 14]
                                            require mem[_22950 + 64] == mem[_22950 + 92 len 4]
                                            require idx < mem[_5560]
                                            require idx + 1 < mem[_5560]
                                            if mem[(32 * idx + 1) + _5560 + 44 len 20] < mem[(32 * idx) + _5560 + 44 len 20]:
                                                if not t:
                                                    if mem[_22950 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22950 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22950 + 18 len 14] * t / t != mem[_22950 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22950 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22950 + 18 len 14] * t / mem[_22950 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_22950')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_22950 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22950 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22950 + 50 len 14] * t / t != mem[_22950 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22950 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22950 + 50 len 14] * t / mem[_22950 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_22950')), 14)))
                                            revert
                                else:
                                    if 2 * mem[_5051] / mem[_5051] != 2:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _5690 = mem[64]
                                    mem[64] = mem[64] + (32 * stor118.length) + 32
                                    mem[_5690] = stor118.length
                                    if not stor118.length:
                                        idx = 0
                                        t = 2 * _5139
                                        while idx < stor118.length - 1:
                                            require idx < mem[_5690]
                                            require idx + 1 < mem[_5690]
                                            _9127 = mem[(32 * idx + 1) + _5690 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _5690 + 44 len 20]
                                            mem[mem[64] + 36] = address(_9127)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_9127)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9464 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9464] == mem[_9464 + 12 len 20]
                                            require ext_code.size(mem[_9464 + 12 len 20])
                                            staticcall mem[_9464 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _10873 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_10873] == mem[_10873 + 18 len 14]
                                            require mem[_10873 + 32] == mem[_10873 + 50 len 14]
                                            require mem[_10873 + 64] == mem[_10873 + 92 len 4]
                                            require idx < mem[_5690]
                                            require idx + 1 < mem[_5690]
                                            if mem[(32 * idx + 1) + _5690 + 44 len 20] < mem[(32 * idx) + _5690 + 44 len 20]:
                                                if not t:
                                                    if mem[_10873 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10873 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10873 + 18 len 14] * t / t != mem[_10873 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10873 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10873 + 18 len 14] * t / mem[_10873 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_10873')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_10873 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10873 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10873 + 50 len 14] * t / t != mem[_10873 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10873 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10873 + 50 len 14] * t / mem[_10873 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_10873')), 14)))
                                            revert
                                    else:
                                        mem[0] = 118
                                        mem[_5690 + 32] = address(stor118.field_0)
                                        idx = _5690 + 32
                                        t = 0
                                        while _5690 + (32 * stor118.length) > idx:
                                            mem[idx + 32] = stor118[t].field_256
                                            idx = idx + 32
                                            t = t + 1
                                            continue 
                                        idx = 0
                                        t = 2 * _5139
                                        while idx < stor118.length - 1:
                                            require idx < mem[_5690]
                                            require idx + 1 < mem[_5690]
                                            _20697 = mem[(32 * idx + 1) + _5690 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _5690 + 44 len 20]
                                            mem[mem[64] + 36] = address(_20697)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_20697)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _21076 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_21076] == mem[_21076 + 12 len 20]
                                            require ext_code.size(mem[_21076 + 12 len 20])
                                            staticcall mem[_21076 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22947 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_22947] == mem[_22947 + 18 len 14]
                                            require mem[_22947 + 32] == mem[_22947 + 50 len 14]
                                            require mem[_22947 + 64] == mem[_22947 + 92 len 4]
                                            require idx < mem[_5690]
                                            require idx + 1 < mem[_5690]
                                            if mem[(32 * idx + 1) + _5690 + 44 len 20] < mem[(32 * idx) + _5690 + 44 len 20]:
                                                if not t:
                                                    if mem[_22947 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22947 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22947 + 18 len 14] * t / t != mem[_22947 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22947 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22947 + 18 len 14] * t / mem[_22947 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_22947')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_22947 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22947 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22947 + 50 len 14] * t / t != mem[_22947 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22947 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22947 + 50 len 14] * t / mem[_22947 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_22947')), 14)))
                                            revert
                        else:
                            mem[ceil32(return_data.size) + 288] = address(stor119.field_256)
                            idx = ceil32(return_data.size) + 288
                            s = 1
                            while ceil32(return_data.size) + (32 * stor119.length) + 224 > idx:
                                mem[idx + 32] = stor119[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            idx = 0
                            s = 0 / periodFinish - lastUpdateTime
                            while idx < stor119.length - 1:
                                require idx < mem[ceil32(return_data.size) + 224]
                                require idx + 1 < mem[ceil32(return_data.size) + 224]
                                _14514 = mem[(32 * idx + 1) + ceil32(return_data.size) + 256]
                                mem[mem[64] + 4] = mem[(32 * idx) + ceil32(return_data.size) + 268 len 20]
                                mem[mem[64] + 36] = address(_14514)
                                require ext_code.size(stor117)
                                staticcall stor117.getPair(address rg1, address rg2) with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4], address(_14514)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _15315 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_15315] == mem[_15315 + 12 len 20]
                                require ext_code.size(mem[_15315 + 12 len 20])
                                staticcall mem[_15315 + 12 len 20].getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _16540 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_16540] == mem[_16540 + 18 len 14]
                                require mem[_16540 + 32] == mem[_16540 + 50 len 14]
                                require mem[_16540 + 64] == mem[_16540 + 92 len 4]
                                require idx < mem[ceil32(return_data.size) + 224]
                                require idx + 1 < mem[ceil32(return_data.size) + 224]
                                if mem[(32 * idx + 1) + ceil32(return_data.size) + 268 len 20] < mem[(32 * idx) + ceil32(return_data.size) + 268 len 20]:
                                    if not s:
                                        if mem[_16540 + 50 len 14]:
                                            idx = idx + 1
                                            s = 0 / mem[_16540 + 50 len 14]
                                            continue 
                                    else:
                                        if mem[_16540 + 18 len 14] * s / s != mem[_16540 + 18 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_16540 + 50 len 14]:
                                            idx = idx + 1
                                            s = mem[_16540 + 18 len 14] * s / mem[_16540 + 50 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_16540')), 14)))
                                else:
                                    if not s:
                                        if mem[_16540 + 18 len 14]:
                                            idx = idx + 1
                                            s = 0 / mem[_16540 + 18 len 14]
                                            continue 
                                    else:
                                        if mem[_16540 + 50 len 14] * s / s != mem[_16540 + 50 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_16540 + 18 len 14]:
                                            idx = idx + 1
                                            s = mem[_16540 + 50 len 14] * s / mem[_16540 + 18 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_16540')), 14)))
                                revert
                            require stor118.length
                            mem[0] = 118
                            if address(stor118.field_0) == stakingTokenAddress:
                                _15507 = mem[64]
                                mem[64] = mem[64] + (32 * stor118.length) + 32
                                mem[_15507] = stor118.length
                                if not stor118.length:
                                    idx = 0
                                    t = totalSupply
                                    while idx < stor118.length - 1:
                                        require idx < mem[_15507]
                                        require idx + 1 < mem[_15507]
                                        _20689 = mem[(32 * idx + 1) + _15507 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _15507 + 44 len 20]
                                        mem[mem[64] + 36] = address(_20689)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_20689)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21068 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_21068] == mem[_21068 + 12 len 20]
                                        require ext_code.size(mem[_21068 + 12 len 20])
                                        staticcall mem[_21068 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22935 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_22935] == mem[_22935 + 18 len 14]
                                        require mem[_22935 + 32] == mem[_22935 + 50 len 14]
                                        require mem[_22935 + 64] == mem[_22935 + 92 len 4]
                                        require idx < mem[_15507]
                                        require idx + 1 < mem[_15507]
                                        if mem[(32 * idx + 1) + _15507 + 44 len 20] < mem[(32 * idx) + _15507 + 44 len 20]:
                                            if not t:
                                                if mem[_22935 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22935 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_22935 + 18 len 14] * t / t != mem[_22935 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22935 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22935 + 18 len 14] * t / mem[_22935 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_22935')), 14)))
                                        else:
                                            if not t:
                                                if mem[_22935 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22935 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_22935 + 50 len 14] * t / t != mem[_22935 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22935 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22935 + 50 len 14] * t / mem[_22935 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_22935')), 14)))
                                        revert
                                    if s:
                                        if 10^18 * s / s != 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not t:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        return (10^18 * s / t)
                                    if t:
                                        return (0 / t)
                                    var70001 = 32
                                    revert with 0, 'SafeMath: division by zero', 0
                                mem[0] = 118
                                mem[_15507 + 32] = address(stor118.field_0)
                                idx = _15507 + 32
                                t = 0
                                while _15507 + (32 * stor118.length) > idx:
                                    mem[idx + 32] = stor118[t].field_256
                                    idx = idx + 32
                                    t = t + 1
                                    continue 
                                idx = 0
                                t = totalSupply
                                while idx < stor118.length - 1:
                                    require idx < mem[_15507]
                                    require idx + 1 < mem[_15507]
                                    _27747 = mem[(32 * idx + 1) + _15507 + 32]
                                    mem[mem[64] + 4] = mem[(32 * idx) + _15507 + 44 len 20]
                                    mem[mem[64] + 36] = address(_27747)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_27747)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _27874 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_27874] == mem[_27874 + 12 len 20]
                                    require ext_code.size(mem[_27874 + 12 len 20])
                                    staticcall mem[_27874 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _28496 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_28496] == mem[_28496 + 18 len 14]
                                    require mem[_28496 + 32] == mem[_28496 + 50 len 14]
                                    require mem[_28496 + 64] == mem[_28496 + 92 len 4]
                                    require idx < mem[_15507]
                                    require idx + 1 < mem[_15507]
                                    if mem[(32 * idx + 1) + _15507 + 44 len 20] < mem[(32 * idx) + _15507 + 44 len 20]:
                                        if not t:
                                            if mem[_28496 + 50 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_28496 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_28496 + 18 len 14] * t / t != mem[_28496 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_28496 + 50 len 14]:
                                                idx = idx + 1
                                                t = mem[_28496 + 18 len 14] * t / mem[_28496 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_28496')), 14)))
                                    else:
                                        if not t:
                                            if mem[_28496 + 18 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_28496 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_28496 + 50 len 14] * t / t != mem[_28496 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_28496 + 18 len 14]:
                                                idx = idx + 1
                                                t = mem[_28496 + 50 len 14] * t / mem[_28496 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_28496')), 14)))
                                    revert
                            else:
                                require stor118.length
                                require stor118.length
                                require address(stor118.field_0) != stakingTokenAddress
                                require 0 < stor118.length
                                mem[0] = 118
                                mem[mem[64] + 4] = stakingTokenAddress
                                require ext_code.size(address(stor118.field_0))
                                staticcall address(stor118.field_0).0x70a08231 with:
                                        gas gas_remaining wei
                                       args stakingTokenAddress
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _16539 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _16937 = mem[_16539]
                                if not mem[_16539]:
                                    _17804 = mem[64]
                                    mem[64] = mem[64] + (32 * stor118.length) + 32
                                    mem[_17804] = stor118.length
                                    if not stor118.length:
                                        idx = 0
                                        t = 0
                                        while idx < stor118.length - 1:
                                            require idx < mem[_17804]
                                            require idx + 1 < mem[_17804]
                                            _20693 = mem[(32 * idx + 1) + _17804 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _17804 + 44 len 20]
                                            mem[mem[64] + 36] = address(_20693)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_20693)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _21072 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_21072] == mem[_21072 + 12 len 20]
                                            require ext_code.size(mem[_21072 + 12 len 20])
                                            staticcall mem[_21072 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22941 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_22941] == mem[_22941 + 18 len 14]
                                            require mem[_22941 + 32] == mem[_22941 + 50 len 14]
                                            require mem[_22941 + 64] == mem[_22941 + 92 len 4]
                                            require idx < mem[_17804]
                                            require idx + 1 < mem[_17804]
                                            if mem[(32 * idx + 1) + _17804 + 44 len 20] < mem[(32 * idx) + _17804 + 44 len 20]:
                                                if not t:
                                                    if mem[_22941 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22941 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22941 + 18 len 14] * t / t != mem[_22941 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22941 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22941 + 18 len 14] * t / mem[_22941 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_22941')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_22941 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22941 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22941 + 50 len 14] * t / t != mem[_22941 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22941 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22941 + 50 len 14] * t / mem[_22941 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_22941')), 14)))
                                            revert
                                        if not s:
                                            if not t:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            return (0 / t)
                                        if 10^18 * s / s != 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not t:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        return (10^18 * s / t)
                                    mem[0] = 118
                                    mem[_17804 + 32] = address(stor118.field_0)
                                    idx = _17804 + 32
                                    t = 0
                                    while _17804 + (32 * stor118.length) > idx:
                                        mem[idx + 32] = stor118[t].field_256
                                        idx = idx + 32
                                        t = t + 1
                                        continue 
                                    idx = 0
                                    t = 0
                                    while idx < stor118.length - 1:
                                        require idx < mem[_17804]
                                        require idx + 1 < mem[_17804]
                                        _27751 = mem[(32 * idx + 1) + _17804 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _17804 + 44 len 20]
                                        mem[mem[64] + 36] = address(_27751)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_27751)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27878 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_27878] == mem[_27878 + 12 len 20]
                                        require ext_code.size(mem[_27878 + 12 len 20])
                                        staticcall mem[_27878 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _28502 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_28502] == mem[_28502 + 18 len 14]
                                        require mem[_28502 + 32] == mem[_28502 + 50 len 14]
                                        require mem[_28502 + 64] == mem[_28502 + 92 len 4]
                                        require idx < mem[_17804]
                                        require idx + 1 < mem[_17804]
                                        if mem[(32 * idx + 1) + _17804 + 44 len 20] < mem[(32 * idx) + _17804 + 44 len 20]:
                                            if not t:
                                                if mem[_28502 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_28502 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_28502 + 18 len 14] * t / t != mem[_28502 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_28502 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_28502 + 18 len 14] * t / mem[_28502 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_28502')), 14)))
                                        else:
                                            if not t:
                                                if mem[_28502 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_28502 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_28502 + 50 len 14] * t / t != mem[_28502 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_28502 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_28502 + 50 len 14] * t / mem[_28502 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_28502')), 14)))
                                        revert
                                    if s:
                                        if 10^18 * s / s != 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not t:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        return (10^18 * s / t)
                                    if t:
                                        return (0 / t)
                                    var89001 = 32
                                    revert with 0, 'SafeMath: division by zero', 0
                                if 2 * mem[_16539] / mem[_16539] != 2:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _17937 = mem[64]
                                mem[64] = mem[64] + (32 * stor118.length) + 32
                                mem[_17937] = stor118.length
                                if not stor118.length:
                                    idx = 0
                                    t = 2 * _16937
                                    while idx < stor118.length - 1:
                                        require idx < mem[_17937]
                                        require idx + 1 < mem[_17937]
                                        _20691 = mem[(32 * idx + 1) + _17937 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _17937 + 44 len 20]
                                        mem[mem[64] + 36] = address(_20691)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_20691)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21070 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_21070] == mem[_21070 + 12 len 20]
                                        require ext_code.size(mem[_21070 + 12 len 20])
                                        staticcall mem[_21070 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22938 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_22938] == mem[_22938 + 18 len 14]
                                        require mem[_22938 + 32] == mem[_22938 + 50 len 14]
                                        require mem[_22938 + 64] == mem[_22938 + 92 len 4]
                                        require idx < mem[_17937]
                                        require idx + 1 < mem[_17937]
                                        if mem[(32 * idx + 1) + _17937 + 44 len 20] < mem[(32 * idx) + _17937 + 44 len 20]:
                                            if not t:
                                                if mem[_22938 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22938 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_22938 + 18 len 14] * t / t != mem[_22938 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22938 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22938 + 18 len 14] * t / mem[_22938 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_22938')), 14)))
                                        else:
                                            if not t:
                                                if mem[_22938 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22938 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_22938 + 50 len 14] * t / t != mem[_22938 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22938 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22938 + 50 len 14] * t / mem[_22938 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_22938')), 14)))
                                        revert
                                else:
                                    mem[0] = 118
                                    mem[_17937 + 32] = address(stor118.field_0)
                                    idx = _17937 + 32
                                    t = 0
                                    while _17937 + (32 * stor118.length) > idx:
                                        mem[idx + 32] = stor118[t].field_256
                                        idx = idx + 32
                                        t = t + 1
                                        continue 
                                    idx = 0
                                    t = 2 * _16937
                                    while idx < stor118.length - 1:
                                        require idx < mem[_17937]
                                        require idx + 1 < mem[_17937]
                                        _27749 = mem[(32 * idx + 1) + _17937 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _17937 + 44 len 20]
                                        mem[mem[64] + 36] = address(_27749)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_27749)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27876 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_27876] == mem[_27876 + 12 len 20]
                                        require ext_code.size(mem[_27876 + 12 len 20])
                                        staticcall mem[_27876 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _28499 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_28499] == mem[_28499 + 18 len 14]
                                        require mem[_28499 + 32] == mem[_28499 + 50 len 14]
                                        require mem[_28499 + 64] == mem[_28499 + 92 len 4]
                                        require idx < mem[_17937]
                                        require idx + 1 < mem[_17937]
                                        if mem[(32 * idx + 1) + _17937 + 44 len 20] < mem[(32 * idx) + _17937 + 44 len 20]:
                                            if not t:
                                                if mem[_28499 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_28499 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_28499 + 18 len 14] * t / t != mem[_28499 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_28499 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_28499 + 18 len 14] * t / mem[_28499 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_28499')), 14)))
                                        else:
                                            if not t:
                                                if mem[_28499 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_28499 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_28499 + 50 len 14] * t / t != mem[_28499 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_28499 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_28499 + 50 len 14] * t / mem[_28499 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_28499')), 14)))
                                        revert
        else:
            if block.timestamp + 1 < block.timestamp:
                revert with 0, 'SafeMath: addition overflow'
            if rewardsDuration < 0:
                revert with 0, 'SafeMath: addition overflow'
            mem[ceil32(return_data.size) + 96] = 30
            mem[ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
            if begin > rewardsDuration + block.timestamp + 1:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if rewardsDuration + block.timestamp < block.timestamp:
                revert with 0, 'SafeMath: addition overflow'
            mem[ceil32(return_data.size) + 160] = 30
            mem[ceil32(return_data.size) + 192] = 'SafeMath: subtraction overflow'
            if begin > rewardsDuration + block.timestamp:
                revert with 0, 'SafeMath: subtraction overflow', 0
            mem[ceil32(return_data.size) + 224] = 26
            mem[ceil32(return_data.size) + 256] = 'SafeMath: division by zero'
            if not rewardsDuration + block.timestamp + -begin + 1:
                revert with 0, 'SafeMath: division by zero', 0
            mem[ceil32(return_data.size) + 288] = 30
            mem[ceil32(return_data.size) + 320] = 'SafeMath: subtraction overflow'
            if 0 / rewardsDuration + block.timestamp + -begin + 1 > 0:
                revert with 0, 'SafeMath: subtraction overflow', 0
            require 0 < stor119.length
            mem[0] = 119
            require address(stor119.field_0) == rewardsTokenAddress
            mem[64] = ceil32(return_data.size) + (32 * stor119.length) + 384
            mem[ceil32(return_data.size) + 352] = stor119.length
            if not stor119.length:
                idx = 0
                s = -0 / rewardsDuration + block.timestamp + -begin + 1
                while idx < stor119.length - 1:
                    require idx < mem[ceil32(return_data.size) + 352]
                    require idx + 1 < mem[ceil32(return_data.size) + 352]
                    _4465 = mem[(32 * idx + 1) + ceil32(return_data.size) + 384]
                    mem[mem[64] + 4] = mem[(32 * idx) + ceil32(return_data.size) + 396 len 20]
                    mem[mem[64] + 36] = address(_4465)
                    require ext_code.size(stor117)
                    staticcall stor117.getPair(address rg1, address rg2) with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4], address(_4465)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _4591 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_4591] == mem[_4591 + 12 len 20]
                    require ext_code.size(mem[_4591 + 12 len 20])
                    staticcall mem[_4591 + 12 len 20].getReserves() with:
                            gas gas_remaining wei
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _5064 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    require mem[_5064] == mem[_5064 + 18 len 14]
                    require mem[_5064 + 32] == mem[_5064 + 50 len 14]
                    require mem[_5064 + 64] == mem[_5064 + 92 len 4]
                    require idx < mem[ceil32(return_data.size) + 352]
                    require idx + 1 < mem[ceil32(return_data.size) + 352]
                    if mem[(32 * idx + 1) + ceil32(return_data.size) + 396 len 20] < mem[(32 * idx) + ceil32(return_data.size) + 396 len 20]:
                        if not s:
                            if mem[_5064 + 50 len 14]:
                                idx = idx + 1
                                s = 0 / mem[_5064 + 50 len 14]
                                continue 
                        else:
                            if mem[_5064 + 18 len 14] * s / s != mem[_5064 + 18 len 14]:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if mem[_5064 + 50 len 14]:
                                idx = idx + 1
                                s = mem[_5064 + 18 len 14] * s / mem[_5064 + 50 len 14]
                                continue 
                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_5064')), 14)))
                    else:
                        if not s:
                            if mem[_5064 + 18 len 14]:
                                idx = idx + 1
                                s = 0 / mem[_5064 + 18 len 14]
                                continue 
                        else:
                            if mem[_5064 + 50 len 14] * s / s != mem[_5064 + 50 len 14]:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if mem[_5064 + 18 len 14]:
                                idx = idx + 1
                                s = mem[_5064 + 50 len 14] * s / mem[_5064 + 18 len 14]
                                continue 
                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_5064')), 14)))
                    revert
                require stor118.length
                mem[0] = 118
                if address(stor118.field_0) == stakingTokenAddress:
                    _4673 = mem[64]
                    mem[64] = mem[64] + (32 * stor118.length) + 32
                    mem[_4673] = stor118.length
                    if not stor118.length:
                        idx = 0
                        t = totalSupply
                        while idx < stor118.length - 1:
                            require idx < mem[_4673]
                            require idx + 1 < mem[_4673]
                            _9144 = mem[(32 * idx + 1) + _4673 + 32]
                            mem[mem[64] + 4] = mem[(32 * idx) + _4673 + 44 len 20]
                            mem[mem[64] + 36] = address(_9144)
                            require ext_code.size(stor117)
                            staticcall stor117.getPair(address rg1, address rg2) with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4], address(_9144)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9481 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_9481] == mem[_9481 + 12 len 20]
                            require ext_code.size(mem[_9481 + 12 len 20])
                            staticcall mem[_9481 + 12 len 20].getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _10901 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_10901] == mem[_10901 + 18 len 14]
                            require mem[_10901 + 32] == mem[_10901 + 50 len 14]
                            require mem[_10901 + 64] == mem[_10901 + 92 len 4]
                            require idx < mem[_4673]
                            require idx + 1 < mem[_4673]
                            if mem[(32 * idx + 1) + _4673 + 44 len 20] < mem[(32 * idx) + _4673 + 44 len 20]:
                                if not t:
                                    if mem[_10901 + 50 len 14]:
                                        idx = idx + 1
                                        t = 0 / mem[_10901 + 50 len 14]
                                        continue 
                                else:
                                    if mem[_10901 + 18 len 14] * t / t != mem[_10901 + 18 len 14]:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if mem[_10901 + 50 len 14]:
                                        idx = idx + 1
                                        t = mem[_10901 + 18 len 14] * t / mem[_10901 + 50 len 14]
                                        continue 
                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_10901')), 14)))
                            else:
                                if not t:
                                    if mem[_10901 + 18 len 14]:
                                        idx = idx + 1
                                        t = 0 / mem[_10901 + 18 len 14]
                                        continue 
                                else:
                                    if mem[_10901 + 50 len 14] * t / t != mem[_10901 + 50 len 14]:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if mem[_10901 + 18 len 14]:
                                        idx = idx + 1
                                        t = mem[_10901 + 50 len 14] * t / mem[_10901 + 18 len 14]
                                        continue 
                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_10901')), 14)))
                            revert
                    else:
                        mem[0] = 118
                        mem[_4673 + 32] = address(stor118.field_0)
                        idx = _4673 + 32
                        t = 0
                        while _4673 + (32 * stor118.length) > idx:
                            mem[idx + 32] = stor118[t].field_256
                            idx = idx + 32
                            t = t + 1
                            continue 
                        idx = 0
                        t = totalSupply
                        while idx < stor118.length - 1:
                            require idx < mem[_4673]
                            require idx + 1 < mem[_4673]
                            _20719 = mem[(32 * idx + 1) + _4673 + 32]
                            mem[mem[64] + 4] = mem[(32 * idx) + _4673 + 44 len 20]
                            mem[mem[64] + 36] = address(_20719)
                            require ext_code.size(stor117)
                            staticcall stor117.getPair(address rg1, address rg2) with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4], address(_20719)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _21098 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_21098] == mem[_21098 + 12 len 20]
                            require ext_code.size(mem[_21098 + 12 len 20])
                            staticcall mem[_21098 + 12 len 20].getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _22980 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_22980] == mem[_22980 + 18 len 14]
                            require mem[_22980 + 32] == mem[_22980 + 50 len 14]
                            require mem[_22980 + 64] == mem[_22980 + 92 len 4]
                            require idx < mem[_4673]
                            require idx + 1 < mem[_4673]
                            if mem[(32 * idx + 1) + _4673 + 44 len 20] < mem[(32 * idx) + _4673 + 44 len 20]:
                                if not t:
                                    if mem[_22980 + 50 len 14]:
                                        idx = idx + 1
                                        t = 0 / mem[_22980 + 50 len 14]
                                        continue 
                                else:
                                    if mem[_22980 + 18 len 14] * t / t != mem[_22980 + 18 len 14]:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if mem[_22980 + 50 len 14]:
                                        idx = idx + 1
                                        t = mem[_22980 + 18 len 14] * t / mem[_22980 + 50 len 14]
                                        continue 
                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_22980')), 14)))
                            else:
                                if not t:
                                    if mem[_22980 + 18 len 14]:
                                        idx = idx + 1
                                        t = 0 / mem[_22980 + 18 len 14]
                                        continue 
                                else:
                                    if mem[_22980 + 50 len 14] * t / t != mem[_22980 + 50 len 14]:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if mem[_22980 + 18 len 14]:
                                        idx = idx + 1
                                        t = mem[_22980 + 50 len 14] * t / mem[_22980 + 18 len 14]
                                        continue 
                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_22980')), 14)))
                            revert
                else:
                    require stor118.length
                    require stor118.length
                    require address(stor118.field_0) != stakingTokenAddress
                    require 0 < stor118.length
                    mem[0] = 118
                    mem[mem[64] + 4] = stakingTokenAddress
                    require ext_code.size(address(stor118.field_0))
                    staticcall address(stor118.field_0).0x70a08231 with:
                            gas gas_remaining wei
                           args stakingTokenAddress
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _5063 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _5148 = mem[_5063]
                    if not mem[_5063]:
                        _5569 = mem[64]
                        mem[64] = mem[64] + (32 * stor118.length) + 32
                        mem[_5569] = stor118.length
                        if not stor118.length:
                            idx = 0
                            t = 0
                            while idx < stor118.length - 1:
                                require idx < mem[_5569]
                                require idx + 1 < mem[_5569]
                                _9148 = mem[(32 * idx + 1) + _5569 + 32]
                                mem[mem[64] + 4] = mem[(32 * idx) + _5569 + 44 len 20]
                                mem[mem[64] + 36] = address(_9148)
                                require ext_code.size(stor117)
                                staticcall stor117.getPair(address rg1, address rg2) with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4], address(_9148)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _9485 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_9485] == mem[_9485 + 12 len 20]
                                require ext_code.size(mem[_9485 + 12 len 20])
                                staticcall mem[_9485 + 12 len 20].getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10907 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10907] == mem[_10907 + 18 len 14]
                                require mem[_10907 + 32] == mem[_10907 + 50 len 14]
                                require mem[_10907 + 64] == mem[_10907 + 92 len 4]
                                require idx < mem[_5569]
                                require idx + 1 < mem[_5569]
                                if mem[(32 * idx + 1) + _5569 + 44 len 20] < mem[(32 * idx) + _5569 + 44 len 20]:
                                    if not t:
                                        if mem[_10907 + 50 len 14]:
                                            idx = idx + 1
                                            t = 0 / mem[_10907 + 50 len 14]
                                            continue 
                                    else:
                                        if mem[_10907 + 18 len 14] * t / t != mem[_10907 + 18 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_10907 + 50 len 14]:
                                            idx = idx + 1
                                            t = mem[_10907 + 18 len 14] * t / mem[_10907 + 50 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_10907')), 14)))
                                else:
                                    if not t:
                                        if mem[_10907 + 18 len 14]:
                                            idx = idx + 1
                                            t = 0 / mem[_10907 + 18 len 14]
                                            continue 
                                    else:
                                        if mem[_10907 + 50 len 14] * t / t != mem[_10907 + 50 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_10907 + 18 len 14]:
                                            idx = idx + 1
                                            t = mem[_10907 + 50 len 14] * t / mem[_10907 + 18 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_10907')), 14)))
                                revert
                        else:
                            mem[0] = 118
                            mem[_5569 + 32] = address(stor118.field_0)
                            idx = _5569 + 32
                            t = 0
                            while _5569 + (32 * stor118.length) > idx:
                                mem[idx + 32] = stor118[t].field_256
                                idx = idx + 32
                                t = t + 1
                                continue 
                            idx = 0
                            t = 0
                            while idx < stor118.length - 1:
                                require idx < mem[_5569]
                                require idx + 1 < mem[_5569]
                                _20723 = mem[(32 * idx + 1) + _5569 + 32]
                                mem[mem[64] + 4] = mem[(32 * idx) + _5569 + 44 len 20]
                                mem[mem[64] + 36] = address(_20723)
                                require ext_code.size(stor117)
                                staticcall stor117.getPair(address rg1, address rg2) with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4], address(_20723)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _21102 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_21102] == mem[_21102 + 12 len 20]
                                require ext_code.size(mem[_21102 + 12 len 20])
                                staticcall mem[_21102 + 12 len 20].getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _22986 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_22986] == mem[_22986 + 18 len 14]
                                require mem[_22986 + 32] == mem[_22986 + 50 len 14]
                                require mem[_22986 + 64] == mem[_22986 + 92 len 4]
                                require idx < mem[_5569]
                                require idx + 1 < mem[_5569]
                                if mem[(32 * idx + 1) + _5569 + 44 len 20] < mem[(32 * idx) + _5569 + 44 len 20]:
                                    if not t:
                                        if mem[_22986 + 50 len 14]:
                                            idx = idx + 1
                                            t = 0 / mem[_22986 + 50 len 14]
                                            continue 
                                    else:
                                        if mem[_22986 + 18 len 14] * t / t != mem[_22986 + 18 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_22986 + 50 len 14]:
                                            idx = idx + 1
                                            t = mem[_22986 + 18 len 14] * t / mem[_22986 + 50 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_22986')), 14)))
                                else:
                                    if not t:
                                        if mem[_22986 + 18 len 14]:
                                            idx = idx + 1
                                            t = 0 / mem[_22986 + 18 len 14]
                                            continue 
                                    else:
                                        if mem[_22986 + 50 len 14] * t / t != mem[_22986 + 50 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_22986 + 18 len 14]:
                                            idx = idx + 1
                                            t = mem[_22986 + 50 len 14] * t / mem[_22986 + 18 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_22986')), 14)))
                                revert
                    else:
                        if 2 * mem[_5063] / mem[_5063] != 2:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _5705 = mem[64]
                        mem[64] = mem[64] + (32 * stor118.length) + 32
                        mem[_5705] = stor118.length
                        if not stor118.length:
                            idx = 0
                            t = 2 * _5148
                            while idx < stor118.length - 1:
                                require idx < mem[_5705]
                                require idx + 1 < mem[_5705]
                                _9146 = mem[(32 * idx + 1) + _5705 + 32]
                                mem[mem[64] + 4] = mem[(32 * idx) + _5705 + 44 len 20]
                                mem[mem[64] + 36] = address(_9146)
                                require ext_code.size(stor117)
                                staticcall stor117.getPair(address rg1, address rg2) with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4], address(_9146)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _9483 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_9483] == mem[_9483 + 12 len 20]
                                require ext_code.size(mem[_9483 + 12 len 20])
                                staticcall mem[_9483 + 12 len 20].getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10904 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10904] == mem[_10904 + 18 len 14]
                                require mem[_10904 + 32] == mem[_10904 + 50 len 14]
                                require mem[_10904 + 64] == mem[_10904 + 92 len 4]
                                require idx < mem[_5705]
                                require idx + 1 < mem[_5705]
                                if mem[(32 * idx + 1) + _5705 + 44 len 20] < mem[(32 * idx) + _5705 + 44 len 20]:
                                    if not t:
                                        if mem[_10904 + 50 len 14]:
                                            idx = idx + 1
                                            t = 0 / mem[_10904 + 50 len 14]
                                            continue 
                                    else:
                                        if mem[_10904 + 18 len 14] * t / t != mem[_10904 + 18 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_10904 + 50 len 14]:
                                            idx = idx + 1
                                            t = mem[_10904 + 18 len 14] * t / mem[_10904 + 50 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_10904')), 14)))
                                else:
                                    if not t:
                                        if mem[_10904 + 18 len 14]:
                                            idx = idx + 1
                                            t = 0 / mem[_10904 + 18 len 14]
                                            continue 
                                    else:
                                        if mem[_10904 + 50 len 14] * t / t != mem[_10904 + 50 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_10904 + 18 len 14]:
                                            idx = idx + 1
                                            t = mem[_10904 + 50 len 14] * t / mem[_10904 + 18 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_10904')), 14)))
                                revert
                        else:
                            mem[0] = 118
                            mem[_5705 + 32] = address(stor118.field_0)
                            idx = _5705 + 32
                            t = 0
                            while _5705 + (32 * stor118.length) > idx:
                                mem[idx + 32] = stor118[t].field_256
                                idx = idx + 32
                                t = t + 1
                                continue 
                            idx = 0
                            t = 2 * _5148
                            while idx < stor118.length - 1:
                                require idx < mem[_5705]
                                require idx + 1 < mem[_5705]
                                _20721 = mem[(32 * idx + 1) + _5705 + 32]
                                mem[mem[64] + 4] = mem[(32 * idx) + _5705 + 44 len 20]
                                mem[mem[64] + 36] = address(_20721)
                                require ext_code.size(stor117)
                                staticcall stor117.getPair(address rg1, address rg2) with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4], address(_20721)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _21100 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_21100] == mem[_21100 + 12 len 20]
                                require ext_code.size(mem[_21100 + 12 len 20])
                                staticcall mem[_21100 + 12 len 20].getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _22983 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_22983] == mem[_22983 + 18 len 14]
                                require mem[_22983 + 32] == mem[_22983 + 50 len 14]
                                require mem[_22983 + 64] == mem[_22983 + 92 len 4]
                                require idx < mem[_5705]
                                require idx + 1 < mem[_5705]
                                if mem[(32 * idx + 1) + _5705 + 44 len 20] < mem[(32 * idx) + _5705 + 44 len 20]:
                                    if not t:
                                        if mem[_22983 + 50 len 14]:
                                            idx = idx + 1
                                            t = 0 / mem[_22983 + 50 len 14]
                                            continue 
                                    else:
                                        if mem[_22983 + 18 len 14] * t / t != mem[_22983 + 18 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_22983 + 50 len 14]:
                                            idx = idx + 1
                                            t = mem[_22983 + 18 len 14] * t / mem[_22983 + 50 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_22983')), 14)))
                                else:
                                    if not t:
                                        if mem[_22983 + 18 len 14]:
                                            idx = idx + 1
                                            t = 0 / mem[_22983 + 18 len 14]
                                            continue 
                                    else:
                                        if mem[_22983 + 50 len 14] * t / t != mem[_22983 + 50 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_22983 + 18 len 14]:
                                            idx = idx + 1
                                            t = mem[_22983 + 50 len 14] * t / mem[_22983 + 18 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_22983')), 14)))
                                revert
            else:
                mem[0] = 119
                mem[ceil32(return_data.size) + 384] = address(stor119.field_0)
                if (32 * stor119.length) + 32 <= 64:
                    idx = 0
                    s = -0 / rewardsDuration + block.timestamp + -begin + 1
                    while idx < stor119.length - 1:
                        require idx < mem[ceil32(return_data.size) + 352]
                        require idx + 1 < mem[ceil32(return_data.size) + 352]
                        _4467 = mem[(32 * idx + 1) + ceil32(return_data.size) + 384]
                        mem[mem[64] + 4] = mem[(32 * idx) + ceil32(return_data.size) + 396 len 20]
                        mem[mem[64] + 36] = address(_4467)
                        require ext_code.size(stor117)
                        staticcall stor117.getPair(address rg1, address rg2) with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4], address(_4467)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4592 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_4592] == mem[_4592 + 12 len 20]
                        require ext_code.size(mem[_4592 + 12 len 20])
                        staticcall mem[_4592 + 12 len 20].getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _5068 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        require mem[_5068] == mem[_5068 + 18 len 14]
                        require mem[_5068 + 32] == mem[_5068 + 50 len 14]
                        require mem[_5068 + 64] == mem[_5068 + 92 len 4]
                        require idx < mem[ceil32(return_data.size) + 352]
                        require idx + 1 < mem[ceil32(return_data.size) + 352]
                        if mem[(32 * idx + 1) + ceil32(return_data.size) + 396 len 20] < mem[(32 * idx) + ceil32(return_data.size) + 396 len 20]:
                            if not s:
                                if mem[_5068 + 50 len 14]:
                                    idx = idx + 1
                                    s = 0 / mem[_5068 + 50 len 14]
                                    continue 
                            else:
                                if mem[_5068 + 18 len 14] * s / s != mem[_5068 + 18 len 14]:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if mem[_5068 + 50 len 14]:
                                    idx = idx + 1
                                    s = mem[_5068 + 18 len 14] * s / mem[_5068 + 50 len 14]
                                    continue 
                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_5068')), 14)))
                        else:
                            if not s:
                                if mem[_5068 + 18 len 14]:
                                    idx = idx + 1
                                    s = 0 / mem[_5068 + 18 len 14]
                                    continue 
                            else:
                                if mem[_5068 + 50 len 14] * s / s != mem[_5068 + 50 len 14]:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if mem[_5068 + 18 len 14]:
                                    idx = idx + 1
                                    s = mem[_5068 + 50 len 14] * s / mem[_5068 + 18 len 14]
                                    continue 
                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_5068')), 14)))
                        revert
                    require stor118.length
                    mem[0] = 118
                    if address(stor118.field_0) == stakingTokenAddress:
                        _4675 = mem[64]
                        mem[64] = mem[64] + (32 * stor118.length) + 32
                        mem[_4675] = stor118.length
                        if not stor118.length:
                            idx = 0
                            t = totalSupply
                            while idx < stor118.length - 1:
                                require idx < mem[_4675]
                                require idx + 1 < mem[_4675]
                                _9151 = mem[(32 * idx + 1) + _4675 + 32]
                                mem[mem[64] + 4] = mem[(32 * idx) + _4675 + 44 len 20]
                                mem[mem[64] + 36] = address(_9151)
                                require ext_code.size(stor117)
                                staticcall stor117.getPair(address rg1, address rg2) with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4], address(_9151)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _9488 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_9488] == mem[_9488 + 12 len 20]
                                require ext_code.size(mem[_9488 + 12 len 20])
                                staticcall mem[_9488 + 12 len 20].getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10914 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10914] == mem[_10914 + 18 len 14]
                                require mem[_10914 + 32] == mem[_10914 + 50 len 14]
                                require mem[_10914 + 64] == mem[_10914 + 92 len 4]
                                require idx < mem[_4675]
                                require idx + 1 < mem[_4675]
                                if mem[(32 * idx + 1) + _4675 + 44 len 20] < mem[(32 * idx) + _4675 + 44 len 20]:
                                    if not t:
                                        if mem[_10914 + 50 len 14]:
                                            idx = idx + 1
                                            t = 0 / mem[_10914 + 50 len 14]
                                            continue 
                                    else:
                                        if mem[_10914 + 18 len 14] * t / t != mem[_10914 + 18 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_10914 + 50 len 14]:
                                            idx = idx + 1
                                            t = mem[_10914 + 18 len 14] * t / mem[_10914 + 50 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_10914')), 14)))
                                else:
                                    if not t:
                                        if mem[_10914 + 18 len 14]:
                                            idx = idx + 1
                                            t = 0 / mem[_10914 + 18 len 14]
                                            continue 
                                    else:
                                        if mem[_10914 + 50 len 14] * t / t != mem[_10914 + 50 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_10914 + 18 len 14]:
                                            idx = idx + 1
                                            t = mem[_10914 + 50 len 14] * t / mem[_10914 + 18 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_10914')), 14)))
                                revert
                        else:
                            mem[0] = 118
                            mem[_4675 + 32] = address(stor118.field_0)
                            idx = _4675 + 32
                            t = 0
                            while _4675 + (32 * stor118.length) > idx:
                                mem[idx + 32] = stor118[t].field_256
                                idx = idx + 32
                                t = t + 1
                                continue 
                            idx = 0
                            t = totalSupply
                            while idx < stor118.length - 1:
                                require idx < mem[_4675]
                                require idx + 1 < mem[_4675]
                                _20731 = mem[(32 * idx + 1) + _4675 + 32]
                                mem[mem[64] + 4] = mem[(32 * idx) + _4675 + 44 len 20]
                                mem[mem[64] + 36] = address(_20731)
                                require ext_code.size(stor117)
                                staticcall stor117.getPair(address rg1, address rg2) with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4], address(_20731)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _21110 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_21110] == mem[_21110 + 12 len 20]
                                require ext_code.size(mem[_21110 + 12 len 20])
                                staticcall mem[_21110 + 12 len 20].getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _22998 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_22998] == mem[_22998 + 18 len 14]
                                require mem[_22998 + 32] == mem[_22998 + 50 len 14]
                                require mem[_22998 + 64] == mem[_22998 + 92 len 4]
                                require idx < mem[_4675]
                                require idx + 1 < mem[_4675]
                                if mem[(32 * idx + 1) + _4675 + 44 len 20] < mem[(32 * idx) + _4675 + 44 len 20]:
                                    if not t:
                                        if mem[_22998 + 50 len 14]:
                                            idx = idx + 1
                                            t = 0 / mem[_22998 + 50 len 14]
                                            continue 
                                    else:
                                        if mem[_22998 + 18 len 14] * t / t != mem[_22998 + 18 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_22998 + 50 len 14]:
                                            idx = idx + 1
                                            t = mem[_22998 + 18 len 14] * t / mem[_22998 + 50 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_22998')), 14)))
                                else:
                                    if not t:
                                        if mem[_22998 + 18 len 14]:
                                            idx = idx + 1
                                            t = 0 / mem[_22998 + 18 len 14]
                                            continue 
                                    else:
                                        if mem[_22998 + 50 len 14] * t / t != mem[_22998 + 50 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_22998 + 18 len 14]:
                                            idx = idx + 1
                                            t = mem[_22998 + 50 len 14] * t / mem[_22998 + 18 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_22998')), 14)))
                                revert
                    else:
                        require stor118.length
                        require stor118.length
                        require address(stor118.field_0) != stakingTokenAddress
                        require 0 < stor118.length
                        mem[0] = 118
                        mem[mem[64] + 4] = stakingTokenAddress
                        require ext_code.size(address(stor118.field_0))
                        staticcall address(stor118.field_0).0x70a08231 with:
                                gas gas_remaining wei
                               args stakingTokenAddress
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _5067 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _5151 = mem[_5067]
                        if not mem[_5067]:
                            _5572 = mem[64]
                            mem[64] = mem[64] + (32 * stor118.length) + 32
                            mem[_5572] = stor118.length
                            if not stor118.length:
                                idx = 0
                                t = 0
                                while idx < stor118.length - 1:
                                    require idx < mem[_5572]
                                    require idx + 1 < mem[_5572]
                                    _9155 = mem[(32 * idx + 1) + _5572 + 32]
                                    mem[mem[64] + 4] = mem[(32 * idx) + _5572 + 44 len 20]
                                    mem[mem[64] + 36] = address(_9155)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_9155)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9492 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_9492] == mem[_9492 + 12 len 20]
                                    require ext_code.size(mem[_9492 + 12 len 20])
                                    staticcall mem[_9492 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10920 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_10920] == mem[_10920 + 18 len 14]
                                    require mem[_10920 + 32] == mem[_10920 + 50 len 14]
                                    require mem[_10920 + 64] == mem[_10920 + 92 len 4]
                                    require idx < mem[_5572]
                                    require idx + 1 < mem[_5572]
                                    if mem[(32 * idx + 1) + _5572 + 44 len 20] < mem[(32 * idx) + _5572 + 44 len 20]:
                                        if not t:
                                            if mem[_10920 + 50 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_10920 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_10920 + 18 len 14] * t / t != mem[_10920 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_10920 + 50 len 14]:
                                                idx = idx + 1
                                                t = mem[_10920 + 18 len 14] * t / mem[_10920 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_10920')), 14)))
                                    else:
                                        if not t:
                                            if mem[_10920 + 18 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_10920 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_10920 + 50 len 14] * t / t != mem[_10920 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_10920 + 18 len 14]:
                                                idx = idx + 1
                                                t = mem[_10920 + 50 len 14] * t / mem[_10920 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_10920')), 14)))
                                    revert
                            else:
                                mem[0] = 118
                                mem[_5572 + 32] = address(stor118.field_0)
                                idx = _5572 + 32
                                t = 0
                                while _5572 + (32 * stor118.length) > idx:
                                    mem[idx + 32] = stor118[t].field_256
                                    idx = idx + 32
                                    t = t + 1
                                    continue 
                                idx = 0
                                t = 0
                                while idx < stor118.length - 1:
                                    require idx < mem[_5572]
                                    require idx + 1 < mem[_5572]
                                    _20735 = mem[(32 * idx + 1) + _5572 + 32]
                                    mem[mem[64] + 4] = mem[(32 * idx) + _5572 + 44 len 20]
                                    mem[mem[64] + 36] = address(_20735)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_20735)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21114 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_21114] == mem[_21114 + 12 len 20]
                                    require ext_code.size(mem[_21114 + 12 len 20])
                                    staticcall mem[_21114 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _23004 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_23004] == mem[_23004 + 18 len 14]
                                    require mem[_23004 + 32] == mem[_23004 + 50 len 14]
                                    require mem[_23004 + 64] == mem[_23004 + 92 len 4]
                                    require idx < mem[_5572]
                                    require idx + 1 < mem[_5572]
                                    if mem[(32 * idx + 1) + _5572 + 44 len 20] < mem[(32 * idx) + _5572 + 44 len 20]:
                                        if not t:
                                            if mem[_23004 + 50 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_23004 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_23004 + 18 len 14] * t / t != mem[_23004 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_23004 + 50 len 14]:
                                                idx = idx + 1
                                                t = mem[_23004 + 18 len 14] * t / mem[_23004 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_23004')), 14)))
                                    else:
                                        if not t:
                                            if mem[_23004 + 18 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_23004 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_23004 + 50 len 14] * t / t != mem[_23004 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_23004 + 18 len 14]:
                                                idx = idx + 1
                                                t = mem[_23004 + 50 len 14] * t / mem[_23004 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_23004')), 14)))
                                    revert
                        else:
                            if 2 * mem[_5067] / mem[_5067] != 2:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _5710 = mem[64]
                            mem[64] = mem[64] + (32 * stor118.length) + 32
                            mem[_5710] = stor118.length
                            if not stor118.length:
                                idx = 0
                                t = 2 * _5151
                                while idx < stor118.length - 1:
                                    require idx < mem[_5710]
                                    require idx + 1 < mem[_5710]
                                    _9153 = mem[(32 * idx + 1) + _5710 + 32]
                                    mem[mem[64] + 4] = mem[(32 * idx) + _5710 + 44 len 20]
                                    mem[mem[64] + 36] = address(_9153)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_9153)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9490 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_9490] == mem[_9490 + 12 len 20]
                                    require ext_code.size(mem[_9490 + 12 len 20])
                                    staticcall mem[_9490 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10917 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_10917] == mem[_10917 + 18 len 14]
                                    require mem[_10917 + 32] == mem[_10917 + 50 len 14]
                                    require mem[_10917 + 64] == mem[_10917 + 92 len 4]
                                    require idx < mem[_5710]
                                    require idx + 1 < mem[_5710]
                                    if mem[(32 * idx + 1) + _5710 + 44 len 20] < mem[(32 * idx) + _5710 + 44 len 20]:
                                        if not t:
                                            if mem[_10917 + 50 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_10917 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_10917 + 18 len 14] * t / t != mem[_10917 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_10917 + 50 len 14]:
                                                idx = idx + 1
                                                t = mem[_10917 + 18 len 14] * t / mem[_10917 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_10917')), 14)))
                                    else:
                                        if not t:
                                            if mem[_10917 + 18 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_10917 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_10917 + 50 len 14] * t / t != mem[_10917 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_10917 + 18 len 14]:
                                                idx = idx + 1
                                                t = mem[_10917 + 50 len 14] * t / mem[_10917 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_10917')), 14)))
                                    revert
                            else:
                                mem[0] = 118
                                mem[_5710 + 32] = address(stor118.field_0)
                                idx = _5710 + 32
                                t = 0
                                while _5710 + (32 * stor118.length) > idx:
                                    mem[idx + 32] = stor118[t].field_256
                                    idx = idx + 32
                                    t = t + 1
                                    continue 
                                idx = 0
                                t = 2 * _5151
                                while idx < stor118.length - 1:
                                    require idx < mem[_5710]
                                    require idx + 1 < mem[_5710]
                                    _20733 = mem[(32 * idx + 1) + _5710 + 32]
                                    mem[mem[64] + 4] = mem[(32 * idx) + _5710 + 44 len 20]
                                    mem[mem[64] + 36] = address(_20733)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_20733)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21112 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_21112] == mem[_21112 + 12 len 20]
                                    require ext_code.size(mem[_21112 + 12 len 20])
                                    staticcall mem[_21112 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _23001 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_23001] == mem[_23001 + 18 len 14]
                                    require mem[_23001 + 32] == mem[_23001 + 50 len 14]
                                    require mem[_23001 + 64] == mem[_23001 + 92 len 4]
                                    require idx < mem[_5710]
                                    require idx + 1 < mem[_5710]
                                    if mem[(32 * idx + 1) + _5710 + 44 len 20] < mem[(32 * idx) + _5710 + 44 len 20]:
                                        if not t:
                                            if mem[_23001 + 50 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_23001 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_23001 + 18 len 14] * t / t != mem[_23001 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_23001 + 50 len 14]:
                                                idx = idx + 1
                                                t = mem[_23001 + 18 len 14] * t / mem[_23001 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_23001')), 14)))
                                    else:
                                        if not t:
                                            if mem[_23001 + 18 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_23001 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_23001 + 50 len 14] * t / t != mem[_23001 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_23001 + 18 len 14]:
                                                idx = idx + 1
                                                t = mem[_23001 + 50 len 14] * t / mem[_23001 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_23001')), 14)))
                                    revert
                else:
                    mem[ceil32(return_data.size) + 416] = address(stor119.field_256)
                    idx = ceil32(return_data.size) + 416
                    s = 1
                    while ceil32(return_data.size) + (32 * stor119.length) + 352 > idx:
                        mem[idx + 32] = stor119[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    idx = 0
                    s = -0 / rewardsDuration + block.timestamp + -begin + 1
                    while idx < stor119.length - 1:
                        require idx < mem[ceil32(return_data.size) + 352]
                        require idx + 1 < mem[ceil32(return_data.size) + 352]
                        _14530 = mem[(32 * idx + 1) + ceil32(return_data.size) + 384]
                        mem[mem[64] + 4] = mem[(32 * idx) + ceil32(return_data.size) + 396 len 20]
                        mem[mem[64] + 36] = address(_14530)
                        require ext_code.size(stor117)
                        staticcall stor117.getPair(address rg1, address rg2) with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4], address(_14530)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _15329 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_15329] == mem[_15329 + 12 len 20]
                        require ext_code.size(mem[_15329 + 12 len 20])
                        staticcall mem[_15329 + 12 len 20].getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _16572 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        require mem[_16572] == mem[_16572 + 18 len 14]
                        require mem[_16572 + 32] == mem[_16572 + 50 len 14]
                        require mem[_16572 + 64] == mem[_16572 + 92 len 4]
                        require idx < mem[ceil32(return_data.size) + 352]
                        require idx + 1 < mem[ceil32(return_data.size) + 352]
                        if mem[(32 * idx + 1) + ceil32(return_data.size) + 396 len 20] < mem[(32 * idx) + ceil32(return_data.size) + 396 len 20]:
                            if not s:
                                if mem[_16572 + 50 len 14]:
                                    idx = idx + 1
                                    s = 0 / mem[_16572 + 50 len 14]
                                    continue 
                            else:
                                if mem[_16572 + 18 len 14] * s / s != mem[_16572 + 18 len 14]:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if mem[_16572 + 50 len 14]:
                                    idx = idx + 1
                                    s = mem[_16572 + 18 len 14] * s / mem[_16572 + 50 len 14]
                                    continue 
                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_16572')), 14)))
                        else:
                            if not s:
                                if mem[_16572 + 18 len 14]:
                                    idx = idx + 1
                                    s = 0 / mem[_16572 + 18 len 14]
                                    continue 
                            else:
                                if mem[_16572 + 50 len 14] * s / s != mem[_16572 + 50 len 14]:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if mem[_16572 + 18 len 14]:
                                    idx = idx + 1
                                    s = mem[_16572 + 50 len 14] * s / mem[_16572 + 18 len 14]
                                    continue 
                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_16572')), 14)))
                        revert
                    require stor118.length
                    mem[0] = 118
                    if address(stor118.field_0) == stakingTokenAddress:
                        _15535 = mem[64]
                        mem[64] = mem[64] + (32 * stor118.length) + 32
                        mem[_15535] = stor118.length
                        if not stor118.length:
                            idx = 0
                            t = totalSupply
                            while idx < stor118.length - 1:
                                require idx < mem[_15535]
                                require idx + 1 < mem[_15535]
                                _20725 = mem[(32 * idx + 1) + _15535 + 32]
                                mem[mem[64] + 4] = mem[(32 * idx) + _15535 + 44 len 20]
                                mem[mem[64] + 36] = address(_20725)
                                require ext_code.size(stor117)
                                staticcall stor117.getPair(address rg1, address rg2) with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4], address(_20725)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _21104 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_21104] == mem[_21104 + 12 len 20]
                                require ext_code.size(mem[_21104 + 12 len 20])
                                staticcall mem[_21104 + 12 len 20].getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _22989 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_22989] == mem[_22989 + 18 len 14]
                                require mem[_22989 + 32] == mem[_22989 + 50 len 14]
                                require mem[_22989 + 64] == mem[_22989 + 92 len 4]
                                require idx < mem[_15535]
                                require idx + 1 < mem[_15535]
                                if mem[(32 * idx + 1) + _15535 + 44 len 20] < mem[(32 * idx) + _15535 + 44 len 20]:
                                    if not t:
                                        if mem[_22989 + 50 len 14]:
                                            idx = idx + 1
                                            t = 0 / mem[_22989 + 50 len 14]
                                            continue 
                                    else:
                                        if mem[_22989 + 18 len 14] * t / t != mem[_22989 + 18 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_22989 + 50 len 14]:
                                            idx = idx + 1
                                            t = mem[_22989 + 18 len 14] * t / mem[_22989 + 50 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_22989')), 14)))
                                else:
                                    if not t:
                                        if mem[_22989 + 18 len 14]:
                                            idx = idx + 1
                                            t = 0 / mem[_22989 + 18 len 14]
                                            continue 
                                    else:
                                        if mem[_22989 + 50 len 14] * t / t != mem[_22989 + 50 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_22989 + 18 len 14]:
                                            idx = idx + 1
                                            t = mem[_22989 + 50 len 14] * t / mem[_22989 + 18 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_22989')), 14)))
                                revert
                            if s:
                                if 10^18 * s / s != 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not t:
                                    revert with 0, 'SafeMath: division by zero', 0
                                return (10^18 * s / t)
                            if t:
                                return (0 / t)
                            var91001 = 32
                            revert with 0, 'SafeMath: division by zero', 0
                        mem[0] = 118
                        mem[_15535 + 32] = address(stor118.field_0)
                        idx = _15535 + 32
                        t = 0
                        while _15535 + (32 * stor118.length) > idx:
                            mem[idx + 32] = stor118[t].field_256
                            idx = idx + 32
                            t = t + 1
                            continue 
                        idx = 0
                        t = totalSupply
                        while idx < stor118.length - 1:
                            require idx < mem[_15535]
                            require idx + 1 < mem[_15535]
                            _27759 = mem[(32 * idx + 1) + _15535 + 32]
                            mem[mem[64] + 4] = mem[(32 * idx) + _15535 + 44 len 20]
                            mem[mem[64] + 36] = address(_27759)
                            require ext_code.size(stor117)
                            staticcall stor117.getPair(address rg1, address rg2) with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4], address(_27759)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _27886 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_27886] == mem[_27886 + 12 len 20]
                            require ext_code.size(mem[_27886 + 12 len 20])
                            staticcall mem[_27886 + 12 len 20].getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _28514 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_28514] == mem[_28514 + 18 len 14]
                            require mem[_28514 + 32] == mem[_28514 + 50 len 14]
                            require mem[_28514 + 64] == mem[_28514 + 92 len 4]
                            require idx < mem[_15535]
                            require idx + 1 < mem[_15535]
                            if mem[(32 * idx + 1) + _15535 + 44 len 20] < mem[(32 * idx) + _15535 + 44 len 20]:
                                if not t:
                                    if mem[_28514 + 50 len 14]:
                                        idx = idx + 1
                                        t = 0 / mem[_28514 + 50 len 14]
                                        continue 
                                else:
                                    if mem[_28514 + 18 len 14] * t / t != mem[_28514 + 18 len 14]:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if mem[_28514 + 50 len 14]:
                                        idx = idx + 1
                                        t = mem[_28514 + 18 len 14] * t / mem[_28514 + 50 len 14]
                                        continue 
                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_28514')), 14)))
                            else:
                                if not t:
                                    if mem[_28514 + 18 len 14]:
                                        idx = idx + 1
                                        t = 0 / mem[_28514 + 18 len 14]
                                        continue 
                                else:
                                    if mem[_28514 + 50 len 14] * t / t != mem[_28514 + 50 len 14]:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if mem[_28514 + 18 len 14]:
                                        idx = idx + 1
                                        t = mem[_28514 + 50 len 14] * t / mem[_28514 + 18 len 14]
                                        continue 
                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_28514')), 14)))
                            revert
                    else:
                        require stor118.length
                        require stor118.length
                        require address(stor118.field_0) != stakingTokenAddress
                        require 0 < stor118.length
                        mem[0] = 118
                        mem[mem[64] + 4] = stakingTokenAddress
                        require ext_code.size(address(stor118.field_0))
                        staticcall address(stor118.field_0).0x70a08231 with:
                                gas gas_remaining wei
                               args stakingTokenAddress
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _16571 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _16975 = mem[_16571]
                        if not mem[_16571]:
                            _17810 = mem[64]
                            mem[64] = mem[64] + (32 * stor118.length) + 32
                            mem[_17810] = stor118.length
                            if not stor118.length:
                                idx = 0
                                t = 0
                                while idx < stor118.length - 1:
                                    require idx < mem[_17810]
                                    require idx + 1 < mem[_17810]
                                    _20729 = mem[(32 * idx + 1) + _17810 + 32]
                                    mem[mem[64] + 4] = mem[(32 * idx) + _17810 + 44 len 20]
                                    mem[mem[64] + 36] = address(_20729)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_20729)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21108 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_21108] == mem[_21108 + 12 len 20]
                                    require ext_code.size(mem[_21108 + 12 len 20])
                                    staticcall mem[_21108 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _22995 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_22995] == mem[_22995 + 18 len 14]
                                    require mem[_22995 + 32] == mem[_22995 + 50 len 14]
                                    require mem[_22995 + 64] == mem[_22995 + 92 len 4]
                                    require idx < mem[_17810]
                                    require idx + 1 < mem[_17810]
                                    if mem[(32 * idx + 1) + _17810 + 44 len 20] < mem[(32 * idx) + _17810 + 44 len 20]:
                                        if not t:
                                            if mem[_22995 + 50 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_22995 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_22995 + 18 len 14] * t / t != mem[_22995 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_22995 + 50 len 14]:
                                                idx = idx + 1
                                                t = mem[_22995 + 18 len 14] * t / mem[_22995 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_22995')), 14)))
                                    else:
                                        if not t:
                                            if mem[_22995 + 18 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_22995 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_22995 + 50 len 14] * t / t != mem[_22995 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_22995 + 18 len 14]:
                                                idx = idx + 1
                                                t = mem[_22995 + 50 len 14] * t / mem[_22995 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_22995')), 14)))
                                    revert
                                if not s:
                                    if not t:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    return (0 / t)
                                if 10^18 * s / s != 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not t:
                                    revert with 0, 'SafeMath: division by zero', 0
                                return (10^18 * s / t)
                            mem[0] = 118
                            mem[_17810 + 32] = address(stor118.field_0)
                            idx = _17810 + 32
                            t = 0
                            while _17810 + (32 * stor118.length) > idx:
                                mem[idx + 32] = stor118[t].field_256
                                idx = idx + 32
                                t = t + 1
                                continue 
                            idx = 0
                            t = 0
                            while idx < stor118.length - 1:
                                require idx < mem[_17810]
                                require idx + 1 < mem[_17810]
                                _27763 = mem[(32 * idx + 1) + _17810 + 32]
                                mem[mem[64] + 4] = mem[(32 * idx) + _17810 + 44 len 20]
                                mem[mem[64] + 36] = address(_27763)
                                require ext_code.size(stor117)
                                staticcall stor117.getPair(address rg1, address rg2) with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4], address(_27763)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _27890 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_27890] == mem[_27890 + 12 len 20]
                                require ext_code.size(mem[_27890 + 12 len 20])
                                staticcall mem[_27890 + 12 len 20].getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _28520 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_28520] == mem[_28520 + 18 len 14]
                                require mem[_28520 + 32] == mem[_28520 + 50 len 14]
                                require mem[_28520 + 64] == mem[_28520 + 92 len 4]
                                require idx < mem[_17810]
                                require idx + 1 < mem[_17810]
                                if mem[(32 * idx + 1) + _17810 + 44 len 20] < mem[(32 * idx) + _17810 + 44 len 20]:
                                    if not t:
                                        if mem[_28520 + 50 len 14]:
                                            idx = idx + 1
                                            t = 0 / mem[_28520 + 50 len 14]
                                            continue 
                                    else:
                                        if mem[_28520 + 18 len 14] * t / t != mem[_28520 + 18 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_28520 + 50 len 14]:
                                            idx = idx + 1
                                            t = mem[_28520 + 18 len 14] * t / mem[_28520 + 50 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_28520')), 14)))
                                else:
                                    if not t:
                                        if mem[_28520 + 18 len 14]:
                                            idx = idx + 1
                                            t = 0 / mem[_28520 + 18 len 14]
                                            continue 
                                    else:
                                        if mem[_28520 + 50 len 14] * t / t != mem[_28520 + 50 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_28520 + 18 len 14]:
                                            idx = idx + 1
                                            t = mem[_28520 + 50 len 14] * t / mem[_28520 + 18 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_28520')), 14)))
                                revert
                            if s:
                                if 10^18 * s / s != 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not t:
                                    revert with 0, 'SafeMath: division by zero', 0
                                return (10^18 * s / t)
                            if t:
                                return (0 / t)
                            var110001 = 32
                            revert with 0, 'SafeMath: division by zero', 0
                        if 2 * mem[_16571] / mem[_16571] != 2:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _17959 = mem[64]
                        mem[64] = mem[64] + (32 * stor118.length) + 32
                        mem[_17959] = stor118.length
                        if not stor118.length:
                            idx = 0
                            t = 2 * _16975
                            while idx < stor118.length - 1:
                                require idx < mem[_17959]
                                require idx + 1 < mem[_17959]
                                _20727 = mem[(32 * idx + 1) + _17959 + 32]
                                mem[mem[64] + 4] = mem[(32 * idx) + _17959 + 44 len 20]
                                mem[mem[64] + 36] = address(_20727)
                                require ext_code.size(stor117)
                                staticcall stor117.getPair(address rg1, address rg2) with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4], address(_20727)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _21106 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_21106] == mem[_21106 + 12 len 20]
                                require ext_code.size(mem[_21106 + 12 len 20])
                                staticcall mem[_21106 + 12 len 20].getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _22992 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_22992] == mem[_22992 + 18 len 14]
                                require mem[_22992 + 32] == mem[_22992 + 50 len 14]
                                require mem[_22992 + 64] == mem[_22992 + 92 len 4]
                                require idx < mem[_17959]
                                require idx + 1 < mem[_17959]
                                if mem[(32 * idx + 1) + _17959 + 44 len 20] < mem[(32 * idx) + _17959 + 44 len 20]:
                                    if not t:
                                        if mem[_22992 + 50 len 14]:
                                            idx = idx + 1
                                            t = 0 / mem[_22992 + 50 len 14]
                                            continue 
                                    else:
                                        if mem[_22992 + 18 len 14] * t / t != mem[_22992 + 18 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_22992 + 50 len 14]:
                                            idx = idx + 1
                                            t = mem[_22992 + 18 len 14] * t / mem[_22992 + 50 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_22992')), 14)))
                                else:
                                    if not t:
                                        if mem[_22992 + 18 len 14]:
                                            idx = idx + 1
                                            t = 0 / mem[_22992 + 18 len 14]
                                            continue 
                                    else:
                                        if mem[_22992 + 50 len 14] * t / t != mem[_22992 + 50 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_22992 + 18 len 14]:
                                            idx = idx + 1
                                            t = mem[_22992 + 50 len 14] * t / mem[_22992 + 18 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_22992')), 14)))
                                revert
                        else:
                            mem[0] = 118
                            mem[_17959 + 32] = address(stor118.field_0)
                            idx = _17959 + 32
                            t = 0
                            while _17959 + (32 * stor118.length) > idx:
                                mem[idx + 32] = stor118[t].field_256
                                idx = idx + 32
                                t = t + 1
                                continue 
                            idx = 0
                            t = 2 * _16975
                            while idx < stor118.length - 1:
                                require idx < mem[_17959]
                                require idx + 1 < mem[_17959]
                                _27761 = mem[(32 * idx + 1) + _17959 + 32]
                                mem[mem[64] + 4] = mem[(32 * idx) + _17959 + 44 len 20]
                                mem[mem[64] + 36] = address(_27761)
                                require ext_code.size(stor117)
                                staticcall stor117.getPair(address rg1, address rg2) with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4], address(_27761)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _27888 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_27888] == mem[_27888 + 12 len 20]
                                require ext_code.size(mem[_27888 + 12 len 20])
                                staticcall mem[_27888 + 12 len 20].getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _28517 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_28517] == mem[_28517 + 18 len 14]
                                require mem[_28517 + 32] == mem[_28517 + 50 len 14]
                                require mem[_28517 + 64] == mem[_28517 + 92 len 4]
                                require idx < mem[_17959]
                                require idx + 1 < mem[_17959]
                                if mem[(32 * idx + 1) + _17959 + 44 len 20] < mem[(32 * idx) + _17959 + 44 len 20]:
                                    if not t:
                                        if mem[_28517 + 50 len 14]:
                                            idx = idx + 1
                                            t = 0 / mem[_28517 + 50 len 14]
                                            continue 
                                    else:
                                        if mem[_28517 + 18 len 14] * t / t != mem[_28517 + 18 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_28517 + 50 len 14]:
                                            idx = idx + 1
                                            t = mem[_28517 + 18 len 14] * t / mem[_28517 + 50 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_28517')), 14)))
                                else:
                                    if not t:
                                        if mem[_28517 + 18 len 14]:
                                            idx = idx + 1
                                            t = 0 / mem[_28517 + 18 len 14]
                                            continue 
                                    else:
                                        if mem[_28517 + 50 len 14] * t / t != mem[_28517 + 50 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_28517 + 18 len 14]:
                                            idx = idx + 1
                                            t = mem[_28517 + 50 len 14] * t / mem[_28517 + 18 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_28517')), 14)))
                                revert
    else:
        if lep != 3:
            if 2 == lep:
                if not ext_call.return_data[0] - stor42D0:
                    mem[ceil32(return_data.size) + 96] = 26
                    mem[ceil32(return_data.size) + 128] = 'SafeMath: division by zero'
                    if not rewardsDuration:
                        revert with 0, 'SafeMath: division by zero', 0
                    require 0 < stor119.length
                    mem[0] = 119
                    require address(stor119.field_0) == rewardsTokenAddress
                    mem[64] = ceil32(return_data.size) + (32 * stor119.length) + 192
                    mem[ceil32(return_data.size) + 160] = stor119.length
                    if not stor119.length:
                        idx = 0
                        s = 0 / rewardsDuration
                        while idx < stor119.length - 1:
                            require idx < mem[ceil32(return_data.size) + 160]
                            require idx + 1 < mem[ceil32(return_data.size) + 160]
                            _4433 = mem[(32 * idx + 1) + ceil32(return_data.size) + 192]
                            mem[mem[64] + 4] = mem[(32 * idx) + ceil32(return_data.size) + 204 len 20]
                            mem[mem[64] + 36] = address(_4433)
                            require ext_code.size(stor117)
                            staticcall stor117.getPair(address rg1, address rg2) with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4], address(_4433)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4575 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_4575] == mem[_4575 + 12 len 20]
                            require ext_code.size(mem[_4575 + 12 len 20])
                            staticcall mem[_4575 + 12 len 20].getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _5000 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_5000] == mem[_5000 + 18 len 14]
                            require mem[_5000 + 32] == mem[_5000 + 50 len 14]
                            require mem[_5000 + 64] == mem[_5000 + 92 len 4]
                            require idx < mem[ceil32(return_data.size) + 160]
                            require idx + 1 < mem[ceil32(return_data.size) + 160]
                            if mem[(32 * idx + 1) + ceil32(return_data.size) + 204 len 20] < mem[(32 * idx) + ceil32(return_data.size) + 204 len 20]:
                                if not s:
                                    if mem[_5000 + 50 len 14]:
                                        idx = idx + 1
                                        s = 0 / mem[_5000 + 50 len 14]
                                        continue 
                                else:
                                    if mem[_5000 + 18 len 14] * s / s != mem[_5000 + 18 len 14]:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if mem[_5000 + 50 len 14]:
                                        idx = idx + 1
                                        s = mem[_5000 + 18 len 14] * s / mem[_5000 + 50 len 14]
                                        continue 
                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_5000')), 14)))
                            else:
                                if not s:
                                    if mem[_5000 + 18 len 14]:
                                        idx = idx + 1
                                        s = 0 / mem[_5000 + 18 len 14]
                                        continue 
                                else:
                                    if mem[_5000 + 50 len 14] * s / s != mem[_5000 + 50 len 14]:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if mem[_5000 + 18 len 14]:
                                        idx = idx + 1
                                        s = mem[_5000 + 50 len 14] * s / mem[_5000 + 18 len 14]
                                        continue 
                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_5000')), 14)))
                            revert
                        require stor118.length
                        mem[0] = 118
                        if address(stor118.field_0) == stakingTokenAddress:
                            _4641 = mem[64]
                            mem[64] = mem[64] + (32 * stor118.length) + 32
                            mem[_4641] = stor118.length
                            if not stor118.length:
                                idx = 0
                                t = totalSupply
                                while idx < stor118.length - 1:
                                    require idx < mem[_4641]
                                    require idx + 1 < mem[_4641]
                                    _9040 = mem[(32 * idx + 1) + _4641 + 32]
                                    mem[mem[64] + 4] = mem[(32 * idx) + _4641 + 44 len 20]
                                    mem[mem[64] + 36] = address(_9040)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_9040)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9377 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_9377] == mem[_9377 + 12 len 20]
                                    require ext_code.size(mem[_9377 + 12 len 20])
                                    staticcall mem[_9377 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10725 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_10725] == mem[_10725 + 18 len 14]
                                    require mem[_10725 + 32] == mem[_10725 + 50 len 14]
                                    require mem[_10725 + 64] == mem[_10725 + 92 len 4]
                                    require idx < mem[_4641]
                                    require idx + 1 < mem[_4641]
                                    if mem[(32 * idx + 1) + _4641 + 44 len 20] < mem[(32 * idx) + _4641 + 44 len 20]:
                                        if not t:
                                            if mem[_10725 + 50 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_10725 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_10725 + 18 len 14] * t / t != mem[_10725 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_10725 + 50 len 14]:
                                                idx = idx + 1
                                                t = mem[_10725 + 18 len 14] * t / mem[_10725 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_10725')), 14)))
                                    else:
                                        if not t:
                                            if mem[_10725 + 18 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_10725 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_10725 + 50 len 14] * t / t != mem[_10725 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_10725 + 18 len 14]:
                                                idx = idx + 1
                                                t = mem[_10725 + 50 len 14] * t / mem[_10725 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_10725')), 14)))
                                    revert
                            else:
                                mem[0] = 118
                                mem[_4641 + 32] = address(stor118.field_0)
                                idx = _4641 + 32
                                t = 0
                                while _4641 + (32 * stor118.length) > idx:
                                    mem[idx + 32] = stor118[t].field_256
                                    idx = idx + 32
                                    t = t + 1
                                    continue 
                                idx = 0
                                t = totalSupply
                                while idx < stor118.length - 1:
                                    require idx < mem[_4641]
                                    require idx + 1 < mem[_4641]
                                    _20575 = mem[(32 * idx + 1) + _4641 + 32]
                                    mem[mem[64] + 4] = mem[(32 * idx) + _4641 + 44 len 20]
                                    mem[mem[64] + 36] = address(_20575)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_20575)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _20954 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_20954] == mem[_20954 + 12 len 20]
                                    require ext_code.size(mem[_20954 + 12 len 20])
                                    staticcall mem[_20954 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _22764 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_22764] == mem[_22764 + 18 len 14]
                                    require mem[_22764 + 32] == mem[_22764 + 50 len 14]
                                    require mem[_22764 + 64] == mem[_22764 + 92 len 4]
                                    require idx < mem[_4641]
                                    require idx + 1 < mem[_4641]
                                    if mem[(32 * idx + 1) + _4641 + 44 len 20] < mem[(32 * idx) + _4641 + 44 len 20]:
                                        if not t:
                                            if mem[_22764 + 50 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_22764 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_22764 + 18 len 14] * t / t != mem[_22764 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_22764 + 50 len 14]:
                                                idx = idx + 1
                                                t = mem[_22764 + 18 len 14] * t / mem[_22764 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_22764')), 14)))
                                    else:
                                        if not t:
                                            if mem[_22764 + 18 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_22764 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_22764 + 50 len 14] * t / t != mem[_22764 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_22764 + 18 len 14]:
                                                idx = idx + 1
                                                t = mem[_22764 + 50 len 14] * t / mem[_22764 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_22764')), 14)))
                                    revert
                        else:
                            require stor118.length
                            require stor118.length
                            require address(stor118.field_0) != stakingTokenAddress
                            require 0 < stor118.length
                            mem[0] = 118
                            mem[mem[64] + 4] = stakingTokenAddress
                            require ext_code.size(address(stor118.field_0))
                            staticcall address(stor118.field_0).0x70a08231 with:
                                    gas gas_remaining wei
                                   args stakingTokenAddress
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4999 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _5100 = mem[_4999]
                            if not mem[_4999]:
                                _5521 = mem[64]
                                mem[64] = mem[64] + (32 * stor118.length) + 32
                                mem[_5521] = stor118.length
                                if not stor118.length:
                                    idx = 0
                                    t = 0
                                    while idx < stor118.length - 1:
                                        require idx < mem[_5521]
                                        require idx + 1 < mem[_5521]
                                        _9044 = mem[(32 * idx + 1) + _5521 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _5521 + 44 len 20]
                                        mem[mem[64] + 36] = address(_9044)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_9044)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9381 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9381] == mem[_9381 + 12 len 20]
                                        require ext_code.size(mem[_9381 + 12 len 20])
                                        staticcall mem[_9381 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _10731 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_10731] == mem[_10731 + 18 len 14]
                                        require mem[_10731 + 32] == mem[_10731 + 50 len 14]
                                        require mem[_10731 + 64] == mem[_10731 + 92 len 4]
                                        require idx < mem[_5521]
                                        require idx + 1 < mem[_5521]
                                        if mem[(32 * idx + 1) + _5521 + 44 len 20] < mem[(32 * idx) + _5521 + 44 len 20]:
                                            if not t:
                                                if mem[_10731 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_10731 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_10731 + 18 len 14] * t / t != mem[_10731 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_10731 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_10731 + 18 len 14] * t / mem[_10731 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_10731')), 14)))
                                        else:
                                            if not t:
                                                if mem[_10731 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_10731 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_10731 + 50 len 14] * t / t != mem[_10731 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_10731 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_10731 + 50 len 14] * t / mem[_10731 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_10731')), 14)))
                                        revert
                                else:
                                    mem[0] = 118
                                    mem[_5521 + 32] = address(stor118.field_0)
                                    idx = _5521 + 32
                                    t = 0
                                    while _5521 + (32 * stor118.length) > idx:
                                        mem[idx + 32] = stor118[t].field_256
                                        idx = idx + 32
                                        t = t + 1
                                        continue 
                                    idx = 0
                                    t = 0
                                    while idx < stor118.length - 1:
                                        require idx < mem[_5521]
                                        require idx + 1 < mem[_5521]
                                        _20579 = mem[(32 * idx + 1) + _5521 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _5521 + 44 len 20]
                                        mem[mem[64] + 36] = address(_20579)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_20579)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20958 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20958] == mem[_20958 + 12 len 20]
                                        require ext_code.size(mem[_20958 + 12 len 20])
                                        staticcall mem[_20958 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22770 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_22770] == mem[_22770 + 18 len 14]
                                        require mem[_22770 + 32] == mem[_22770 + 50 len 14]
                                        require mem[_22770 + 64] == mem[_22770 + 92 len 4]
                                        require idx < mem[_5521]
                                        require idx + 1 < mem[_5521]
                                        if mem[(32 * idx + 1) + _5521 + 44 len 20] < mem[(32 * idx) + _5521 + 44 len 20]:
                                            if not t:
                                                if mem[_22770 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22770 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_22770 + 18 len 14] * t / t != mem[_22770 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22770 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22770 + 18 len 14] * t / mem[_22770 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_22770')), 14)))
                                        else:
                                            if not t:
                                                if mem[_22770 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22770 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_22770 + 50 len 14] * t / t != mem[_22770 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22770 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22770 + 50 len 14] * t / mem[_22770 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_22770')), 14)))
                                        revert
                            else:
                                if 2 * mem[_4999] / mem[_4999] != 2:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _5625 = mem[64]
                                mem[64] = mem[64] + (32 * stor118.length) + 32
                                mem[_5625] = stor118.length
                                if not stor118.length:
                                    idx = 0
                                    t = 2 * _5100
                                    while idx < stor118.length - 1:
                                        require idx < mem[_5625]
                                        require idx + 1 < mem[_5625]
                                        _9042 = mem[(32 * idx + 1) + _5625 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _5625 + 44 len 20]
                                        mem[mem[64] + 36] = address(_9042)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_9042)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9379 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9379] == mem[_9379 + 12 len 20]
                                        require ext_code.size(mem[_9379 + 12 len 20])
                                        staticcall mem[_9379 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _10728 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_10728] == mem[_10728 + 18 len 14]
                                        require mem[_10728 + 32] == mem[_10728 + 50 len 14]
                                        require mem[_10728 + 64] == mem[_10728 + 92 len 4]
                                        require idx < mem[_5625]
                                        require idx + 1 < mem[_5625]
                                        if mem[(32 * idx + 1) + _5625 + 44 len 20] < mem[(32 * idx) + _5625 + 44 len 20]:
                                            if not t:
                                                if mem[_10728 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_10728 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_10728 + 18 len 14] * t / t != mem[_10728 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_10728 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_10728 + 18 len 14] * t / mem[_10728 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_10728')), 14)))
                                        else:
                                            if not t:
                                                if mem[_10728 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_10728 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_10728 + 50 len 14] * t / t != mem[_10728 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_10728 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_10728 + 50 len 14] * t / mem[_10728 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_10728')), 14)))
                                        revert
                                else:
                                    mem[0] = 118
                                    mem[_5625 + 32] = address(stor118.field_0)
                                    idx = _5625 + 32
                                    t = 0
                                    while _5625 + (32 * stor118.length) > idx:
                                        mem[idx + 32] = stor118[t].field_256
                                        idx = idx + 32
                                        t = t + 1
                                        continue 
                                    idx = 0
                                    t = 2 * _5100
                                    while idx < stor118.length - 1:
                                        require idx < mem[_5625]
                                        require idx + 1 < mem[_5625]
                                        _20577 = mem[(32 * idx + 1) + _5625 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _5625 + 44 len 20]
                                        mem[mem[64] + 36] = address(_20577)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_20577)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20956 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20956] == mem[_20956 + 12 len 20]
                                        require ext_code.size(mem[_20956 + 12 len 20])
                                        staticcall mem[_20956 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22767 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_22767] == mem[_22767 + 18 len 14]
                                        require mem[_22767 + 32] == mem[_22767 + 50 len 14]
                                        require mem[_22767 + 64] == mem[_22767 + 92 len 4]
                                        require idx < mem[_5625]
                                        require idx + 1 < mem[_5625]
                                        if mem[(32 * idx + 1) + _5625 + 44 len 20] < mem[(32 * idx) + _5625 + 44 len 20]:
                                            if not t:
                                                if mem[_22767 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22767 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_22767 + 18 len 14] * t / t != mem[_22767 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22767 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22767 + 18 len 14] * t / mem[_22767 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_22767')), 14)))
                                        else:
                                            if not t:
                                                if mem[_22767 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22767 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_22767 + 50 len 14] * t / t != mem[_22767 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22767 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22767 + 50 len 14] * t / mem[_22767 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_22767')), 14)))
                                        revert
                    else:
                        mem[0] = 119
                        mem[ceil32(return_data.size) + 192] = address(stor119.field_0)
                        if (32 * stor119.length) + 32 <= 64:
                            idx = 0
                            s = 0 / rewardsDuration
                            while idx < stor119.length - 1:
                                require idx < mem[ceil32(return_data.size) + 160]
                                require idx + 1 < mem[ceil32(return_data.size) + 160]
                                _4435 = mem[(32 * idx + 1) + ceil32(return_data.size) + 192]
                                mem[mem[64] + 4] = mem[(32 * idx) + ceil32(return_data.size) + 204 len 20]
                                mem[mem[64] + 36] = address(_4435)
                                require ext_code.size(stor117)
                                staticcall stor117.getPair(address rg1, address rg2) with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4], address(_4435)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4576 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_4576] == mem[_4576 + 12 len 20]
                                require ext_code.size(mem[_4576 + 12 len 20])
                                staticcall mem[_4576 + 12 len 20].getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5004 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_5004] == mem[_5004 + 18 len 14]
                                require mem[_5004 + 32] == mem[_5004 + 50 len 14]
                                require mem[_5004 + 64] == mem[_5004 + 92 len 4]
                                require idx < mem[ceil32(return_data.size) + 160]
                                require idx + 1 < mem[ceil32(return_data.size) + 160]
                                if mem[(32 * idx + 1) + ceil32(return_data.size) + 204 len 20] < mem[(32 * idx) + ceil32(return_data.size) + 204 len 20]:
                                    if not s:
                                        if mem[_5004 + 50 len 14]:
                                            idx = idx + 1
                                            s = 0 / mem[_5004 + 50 len 14]
                                            continue 
                                    else:
                                        if mem[_5004 + 18 len 14] * s / s != mem[_5004 + 18 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_5004 + 50 len 14]:
                                            idx = idx + 1
                                            s = mem[_5004 + 18 len 14] * s / mem[_5004 + 50 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_5004')), 14)))
                                else:
                                    if not s:
                                        if mem[_5004 + 18 len 14]:
                                            idx = idx + 1
                                            s = 0 / mem[_5004 + 18 len 14]
                                            continue 
                                    else:
                                        if mem[_5004 + 50 len 14] * s / s != mem[_5004 + 50 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_5004 + 18 len 14]:
                                            idx = idx + 1
                                            s = mem[_5004 + 50 len 14] * s / mem[_5004 + 18 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_5004')), 14)))
                                revert
                            require stor118.length
                            mem[0] = 118
                            if address(stor118.field_0) == stakingTokenAddress:
                                _4643 = mem[64]
                                mem[64] = mem[64] + (32 * stor118.length) + 32
                                mem[_4643] = stor118.length
                                if not stor118.length:
                                    idx = 0
                                    t = totalSupply
                                    while idx < stor118.length - 1:
                                        require idx < mem[_4643]
                                        require idx + 1 < mem[_4643]
                                        _9047 = mem[(32 * idx + 1) + _4643 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _4643 + 44 len 20]
                                        mem[mem[64] + 36] = address(_9047)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_9047)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9384 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9384] == mem[_9384 + 12 len 20]
                                        require ext_code.size(mem[_9384 + 12 len 20])
                                        staticcall mem[_9384 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _10738 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_10738] == mem[_10738 + 18 len 14]
                                        require mem[_10738 + 32] == mem[_10738 + 50 len 14]
                                        require mem[_10738 + 64] == mem[_10738 + 92 len 4]
                                        require idx < mem[_4643]
                                        require idx + 1 < mem[_4643]
                                        if mem[(32 * idx + 1) + _4643 + 44 len 20] < mem[(32 * idx) + _4643 + 44 len 20]:
                                            if not t:
                                                if mem[_10738 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_10738 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_10738 + 18 len 14] * t / t != mem[_10738 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_10738 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_10738 + 18 len 14] * t / mem[_10738 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_10738')), 14)))
                                        else:
                                            if not t:
                                                if mem[_10738 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_10738 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_10738 + 50 len 14] * t / t != mem[_10738 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_10738 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_10738 + 50 len 14] * t / mem[_10738 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_10738')), 14)))
                                        revert
                                else:
                                    mem[0] = 118
                                    mem[_4643 + 32] = address(stor118.field_0)
                                    idx = _4643 + 32
                                    t = 0
                                    while _4643 + (32 * stor118.length) > idx:
                                        mem[idx + 32] = stor118[t].field_256
                                        idx = idx + 32
                                        t = t + 1
                                        continue 
                                    idx = 0
                                    t = totalSupply
                                    while idx < stor118.length - 1:
                                        require idx < mem[_4643]
                                        require idx + 1 < mem[_4643]
                                        _20587 = mem[(32 * idx + 1) + _4643 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _4643 + 44 len 20]
                                        mem[mem[64] + 36] = address(_20587)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_20587)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20966 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20966] == mem[_20966 + 12 len 20]
                                        require ext_code.size(mem[_20966 + 12 len 20])
                                        staticcall mem[_20966 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22782 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_22782] == mem[_22782 + 18 len 14]
                                        require mem[_22782 + 32] == mem[_22782 + 50 len 14]
                                        require mem[_22782 + 64] == mem[_22782 + 92 len 4]
                                        require idx < mem[_4643]
                                        require idx + 1 < mem[_4643]
                                        if mem[(32 * idx + 1) + _4643 + 44 len 20] < mem[(32 * idx) + _4643 + 44 len 20]:
                                            if not t:
                                                if mem[_22782 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22782 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_22782 + 18 len 14] * t / t != mem[_22782 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22782 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22782 + 18 len 14] * t / mem[_22782 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_22782')), 14)))
                                        else:
                                            if not t:
                                                if mem[_22782 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22782 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_22782 + 50 len 14] * t / t != mem[_22782 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22782 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22782 + 50 len 14] * t / mem[_22782 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_22782')), 14)))
                                        revert
                            else:
                                require stor118.length
                                require stor118.length
                                require address(stor118.field_0) != stakingTokenAddress
                                require 0 < stor118.length
                                mem[0] = 118
                                mem[mem[64] + 4] = stakingTokenAddress
                                require ext_code.size(address(stor118.field_0))
                                staticcall address(stor118.field_0).0x70a08231 with:
                                        gas gas_remaining wei
                                       args stakingTokenAddress
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5003 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _5103 = mem[_5003]
                                if not mem[_5003]:
                                    _5524 = mem[64]
                                    mem[64] = mem[64] + (32 * stor118.length) + 32
                                    mem[_5524] = stor118.length
                                    if not stor118.length:
                                        idx = 0
                                        t = 0
                                        while idx < stor118.length - 1:
                                            require idx < mem[_5524]
                                            require idx + 1 < mem[_5524]
                                            _9051 = mem[(32 * idx + 1) + _5524 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _5524 + 44 len 20]
                                            mem[mem[64] + 36] = address(_9051)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_9051)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9388 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9388] == mem[_9388 + 12 len 20]
                                            require ext_code.size(mem[_9388 + 12 len 20])
                                            staticcall mem[_9388 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _10744 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_10744] == mem[_10744 + 18 len 14]
                                            require mem[_10744 + 32] == mem[_10744 + 50 len 14]
                                            require mem[_10744 + 64] == mem[_10744 + 92 len 4]
                                            require idx < mem[_5524]
                                            require idx + 1 < mem[_5524]
                                            if mem[(32 * idx + 1) + _5524 + 44 len 20] < mem[(32 * idx) + _5524 + 44 len 20]:
                                                if not t:
                                                    if mem[_10744 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10744 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10744 + 18 len 14] * t / t != mem[_10744 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10744 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10744 + 18 len 14] * t / mem[_10744 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_10744')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_10744 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10744 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10744 + 50 len 14] * t / t != mem[_10744 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10744 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10744 + 50 len 14] * t / mem[_10744 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_10744')), 14)))
                                            revert
                                    else:
                                        mem[0] = 118
                                        mem[_5524 + 32] = address(stor118.field_0)
                                        idx = _5524 + 32
                                        t = 0
                                        while _5524 + (32 * stor118.length) > idx:
                                            mem[idx + 32] = stor118[t].field_256
                                            idx = idx + 32
                                            t = t + 1
                                            continue 
                                        idx = 0
                                        t = 0
                                        while idx < stor118.length - 1:
                                            require idx < mem[_5524]
                                            require idx + 1 < mem[_5524]
                                            _20591 = mem[(32 * idx + 1) + _5524 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _5524 + 44 len 20]
                                            mem[mem[64] + 36] = address(_20591)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_20591)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _20970 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_20970] == mem[_20970 + 12 len 20]
                                            require ext_code.size(mem[_20970 + 12 len 20])
                                            staticcall mem[_20970 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22788 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_22788] == mem[_22788 + 18 len 14]
                                            require mem[_22788 + 32] == mem[_22788 + 50 len 14]
                                            require mem[_22788 + 64] == mem[_22788 + 92 len 4]
                                            require idx < mem[_5524]
                                            require idx + 1 < mem[_5524]
                                            if mem[(32 * idx + 1) + _5524 + 44 len 20] < mem[(32 * idx) + _5524 + 44 len 20]:
                                                if not t:
                                                    if mem[_22788 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22788 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22788 + 18 len 14] * t / t != mem[_22788 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22788 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22788 + 18 len 14] * t / mem[_22788 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_22788')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_22788 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22788 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22788 + 50 len 14] * t / t != mem[_22788 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22788 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22788 + 50 len 14] * t / mem[_22788 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_22788')), 14)))
                                            revert
                                else:
                                    if 2 * mem[_5003] / mem[_5003] != 2:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _5630 = mem[64]
                                    mem[64] = mem[64] + (32 * stor118.length) + 32
                                    mem[_5630] = stor118.length
                                    if not stor118.length:
                                        idx = 0
                                        t = 2 * _5103
                                        while idx < stor118.length - 1:
                                            require idx < mem[_5630]
                                            require idx + 1 < mem[_5630]
                                            _9049 = mem[(32 * idx + 1) + _5630 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _5630 + 44 len 20]
                                            mem[mem[64] + 36] = address(_9049)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_9049)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9386 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9386] == mem[_9386 + 12 len 20]
                                            require ext_code.size(mem[_9386 + 12 len 20])
                                            staticcall mem[_9386 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _10741 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_10741] == mem[_10741 + 18 len 14]
                                            require mem[_10741 + 32] == mem[_10741 + 50 len 14]
                                            require mem[_10741 + 64] == mem[_10741 + 92 len 4]
                                            require idx < mem[_5630]
                                            require idx + 1 < mem[_5630]
                                            if mem[(32 * idx + 1) + _5630 + 44 len 20] < mem[(32 * idx) + _5630 + 44 len 20]:
                                                if not t:
                                                    if mem[_10741 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10741 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10741 + 18 len 14] * t / t != mem[_10741 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10741 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10741 + 18 len 14] * t / mem[_10741 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_10741')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_10741 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10741 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10741 + 50 len 14] * t / t != mem[_10741 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10741 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10741 + 50 len 14] * t / mem[_10741 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_10741')), 14)))
                                            revert
                                    else:
                                        mem[0] = 118
                                        mem[_5630 + 32] = address(stor118.field_0)
                                        idx = _5630 + 32
                                        t = 0
                                        while _5630 + (32 * stor118.length) > idx:
                                            mem[idx + 32] = stor118[t].field_256
                                            idx = idx + 32
                                            t = t + 1
                                            continue 
                                        idx = 0
                                        t = 2 * _5103
                                        while idx < stor118.length - 1:
                                            require idx < mem[_5630]
                                            require idx + 1 < mem[_5630]
                                            _20589 = mem[(32 * idx + 1) + _5630 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _5630 + 44 len 20]
                                            mem[mem[64] + 36] = address(_20589)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_20589)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _20968 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_20968] == mem[_20968 + 12 len 20]
                                            require ext_code.size(mem[_20968 + 12 len 20])
                                            staticcall mem[_20968 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22785 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_22785] == mem[_22785 + 18 len 14]
                                            require mem[_22785 + 32] == mem[_22785 + 50 len 14]
                                            require mem[_22785 + 64] == mem[_22785 + 92 len 4]
                                            require idx < mem[_5630]
                                            require idx + 1 < mem[_5630]
                                            if mem[(32 * idx + 1) + _5630 + 44 len 20] < mem[(32 * idx) + _5630 + 44 len 20]:
                                                if not t:
                                                    if mem[_22785 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22785 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22785 + 18 len 14] * t / t != mem[_22785 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22785 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22785 + 18 len 14] * t / mem[_22785 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_22785')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_22785 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22785 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22785 + 50 len 14] * t / t != mem[_22785 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22785 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22785 + 50 len 14] * t / mem[_22785 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_22785')), 14)))
                                            revert
                        else:
                            mem[ceil32(return_data.size) + 224] = address(stor119.field_256)
                            idx = ceil32(return_data.size) + 224
                            s = 1
                            while ceil32(return_data.size) + (32 * stor119.length) + 160 > idx:
                                mem[idx + 32] = stor119[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            idx = 0
                            s = 0 / rewardsDuration
                            while idx < stor119.length - 1:
                                require idx < mem[ceil32(return_data.size) + 160]
                                require idx + 1 < mem[ceil32(return_data.size) + 160]
                                _14466 = mem[(32 * idx + 1) + ceil32(return_data.size) + 192]
                                mem[mem[64] + 4] = mem[(32 * idx) + ceil32(return_data.size) + 204 len 20]
                                mem[mem[64] + 36] = address(_14466)
                                require ext_code.size(stor117)
                                staticcall stor117.getPair(address rg1, address rg2) with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4], address(_14466)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _15273 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_15273] == mem[_15273 + 12 len 20]
                                require ext_code.size(mem[_15273 + 12 len 20])
                                staticcall mem[_15273 + 12 len 20].getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _16444 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_16444] == mem[_16444 + 18 len 14]
                                require mem[_16444 + 32] == mem[_16444 + 50 len 14]
                                require mem[_16444 + 64] == mem[_16444 + 92 len 4]
                                require idx < mem[ceil32(return_data.size) + 160]
                                require idx + 1 < mem[ceil32(return_data.size) + 160]
                                if mem[(32 * idx + 1) + ceil32(return_data.size) + 204 len 20] < mem[(32 * idx) + ceil32(return_data.size) + 204 len 20]:
                                    if not s:
                                        if mem[_16444 + 50 len 14]:
                                            idx = idx + 1
                                            s = 0 / mem[_16444 + 50 len 14]
                                            continue 
                                    else:
                                        if mem[_16444 + 18 len 14] * s / s != mem[_16444 + 18 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_16444 + 50 len 14]:
                                            idx = idx + 1
                                            s = mem[_16444 + 18 len 14] * s / mem[_16444 + 50 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_16444')), 14)))
                                else:
                                    if not s:
                                        if mem[_16444 + 18 len 14]:
                                            idx = idx + 1
                                            s = 0 / mem[_16444 + 18 len 14]
                                            continue 
                                    else:
                                        if mem[_16444 + 50 len 14] * s / s != mem[_16444 + 50 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_16444 + 18 len 14]:
                                            idx = idx + 1
                                            s = mem[_16444 + 50 len 14] * s / mem[_16444 + 18 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_16444')), 14)))
                                revert
                            require stor118.length
                            mem[0] = 118
                            if address(stor118.field_0) == stakingTokenAddress:
                                _15423 = mem[64]
                                mem[64] = mem[64] + (32 * stor118.length) + 32
                                mem[_15423] = stor118.length
                                if not stor118.length:
                                    idx = 0
                                    t = totalSupply
                                    while idx < stor118.length - 1:
                                        require idx < mem[_15423]
                                        require idx + 1 < mem[_15423]
                                        _20581 = mem[(32 * idx + 1) + _15423 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _15423 + 44 len 20]
                                        mem[mem[64] + 36] = address(_20581)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_20581)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20960 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20960] == mem[_20960 + 12 len 20]
                                        require ext_code.size(mem[_20960 + 12 len 20])
                                        staticcall mem[_20960 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22773 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_22773] == mem[_22773 + 18 len 14]
                                        require mem[_22773 + 32] == mem[_22773 + 50 len 14]
                                        require mem[_22773 + 64] == mem[_22773 + 92 len 4]
                                        require idx < mem[_15423]
                                        require idx + 1 < mem[_15423]
                                        if mem[(32 * idx + 1) + _15423 + 44 len 20] < mem[(32 * idx) + _15423 + 44 len 20]:
                                            if not t:
                                                if mem[_22773 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22773 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_22773 + 18 len 14] * t / t != mem[_22773 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22773 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22773 + 18 len 14] * t / mem[_22773 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_22773')), 14)))
                                        else:
                                            if not t:
                                                if mem[_22773 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22773 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_22773 + 50 len 14] * t / t != mem[_22773 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22773 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22773 + 50 len 14] * t / mem[_22773 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_22773')), 14)))
                                        revert
                                    if s:
                                        if 10^18 * s / s != 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not t:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        return (10^18 * s / t)
                                    if t:
                                        return (0 / t)
                                    var63001 = 32
                                    revert with 0, 'SafeMath: division by zero', 0
                                mem[0] = 118
                                mem[_15423 + 32] = address(stor118.field_0)
                                idx = _15423 + 32
                                t = 0
                                while _15423 + (32 * stor118.length) > idx:
                                    mem[idx + 32] = stor118[t].field_256
                                    idx = idx + 32
                                    t = t + 1
                                    continue 
                                idx = 0
                                t = totalSupply
                                while idx < stor118.length - 1:
                                    require idx < mem[_15423]
                                    require idx + 1 < mem[_15423]
                                    _27711 = mem[(32 * idx + 1) + _15423 + 32]
                                    mem[mem[64] + 4] = mem[(32 * idx) + _15423 + 44 len 20]
                                    mem[mem[64] + 36] = address(_27711)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_27711)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _27838 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_27838] == mem[_27838 + 12 len 20]
                                    require ext_code.size(mem[_27838 + 12 len 20])
                                    staticcall mem[_27838 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _28442 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_28442] == mem[_28442 + 18 len 14]
                                    require mem[_28442 + 32] == mem[_28442 + 50 len 14]
                                    require mem[_28442 + 64] == mem[_28442 + 92 len 4]
                                    require idx < mem[_15423]
                                    require idx + 1 < mem[_15423]
                                    if mem[(32 * idx + 1) + _15423 + 44 len 20] < mem[(32 * idx) + _15423 + 44 len 20]:
                                        if not t:
                                            if mem[_28442 + 50 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_28442 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_28442 + 18 len 14] * t / t != mem[_28442 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_28442 + 50 len 14]:
                                                idx = idx + 1
                                                t = mem[_28442 + 18 len 14] * t / mem[_28442 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_28442')), 14)))
                                    else:
                                        if not t:
                                            if mem[_28442 + 18 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_28442 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_28442 + 50 len 14] * t / t != mem[_28442 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_28442 + 18 len 14]:
                                                idx = idx + 1
                                                t = mem[_28442 + 50 len 14] * t / mem[_28442 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_28442')), 14)))
                                    revert
                            else:
                                require stor118.length
                                require stor118.length
                                require address(stor118.field_0) != stakingTokenAddress
                                require 0 < stor118.length
                                mem[0] = 118
                                mem[mem[64] + 4] = stakingTokenAddress
                                require ext_code.size(address(stor118.field_0))
                                staticcall address(stor118.field_0).0x70a08231 with:
                                        gas gas_remaining wei
                                       args stakingTokenAddress
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _16443 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _16823 = mem[_16443]
                                if not mem[_16443]:
                                    _17786 = mem[64]
                                    mem[64] = mem[64] + (32 * stor118.length) + 32
                                    mem[_17786] = stor118.length
                                    if not stor118.length:
                                        idx = 0
                                        t = 0
                                        while idx < stor118.length - 1:
                                            require idx < mem[_17786]
                                            require idx + 1 < mem[_17786]
                                            _20585 = mem[(32 * idx + 1) + _17786 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _17786 + 44 len 20]
                                            mem[mem[64] + 36] = address(_20585)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_20585)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _20964 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_20964] == mem[_20964 + 12 len 20]
                                            require ext_code.size(mem[_20964 + 12 len 20])
                                            staticcall mem[_20964 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22779 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_22779] == mem[_22779 + 18 len 14]
                                            require mem[_22779 + 32] == mem[_22779 + 50 len 14]
                                            require mem[_22779 + 64] == mem[_22779 + 92 len 4]
                                            require idx < mem[_17786]
                                            require idx + 1 < mem[_17786]
                                            if mem[(32 * idx + 1) + _17786 + 44 len 20] < mem[(32 * idx) + _17786 + 44 len 20]:
                                                if not t:
                                                    if mem[_22779 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22779 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22779 + 18 len 14] * t / t != mem[_22779 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22779 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22779 + 18 len 14] * t / mem[_22779 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_22779')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_22779 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22779 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22779 + 50 len 14] * t / t != mem[_22779 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22779 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22779 + 50 len 14] * t / mem[_22779 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_22779')), 14)))
                                            revert
                                        if not s:
                                            if not t:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            return (0 / t)
                                        if 10^18 * s / s != 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not t:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        return (10^18 * s / t)
                                    mem[0] = 118
                                    mem[_17786 + 32] = address(stor118.field_0)
                                    idx = _17786 + 32
                                    t = 0
                                    while _17786 + (32 * stor118.length) > idx:
                                        mem[idx + 32] = stor118[t].field_256
                                        idx = idx + 32
                                        t = t + 1
                                        continue 
                                    idx = 0
                                    t = 0
                                    while idx < stor118.length - 1:
                                        require idx < mem[_17786]
                                        require idx + 1 < mem[_17786]
                                        _27715 = mem[(32 * idx + 1) + _17786 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _17786 + 44 len 20]
                                        mem[mem[64] + 36] = address(_27715)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_27715)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27842 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_27842] == mem[_27842 + 12 len 20]
                                        require ext_code.size(mem[_27842 + 12 len 20])
                                        staticcall mem[_27842 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _28448 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_28448] == mem[_28448 + 18 len 14]
                                        require mem[_28448 + 32] == mem[_28448 + 50 len 14]
                                        require mem[_28448 + 64] == mem[_28448 + 92 len 4]
                                        require idx < mem[_17786]
                                        require idx + 1 < mem[_17786]
                                        if mem[(32 * idx + 1) + _17786 + 44 len 20] < mem[(32 * idx) + _17786 + 44 len 20]:
                                            if not t:
                                                if mem[_28448 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_28448 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_28448 + 18 len 14] * t / t != mem[_28448 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_28448 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_28448 + 18 len 14] * t / mem[_28448 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_28448')), 14)))
                                        else:
                                            if not t:
                                                if mem[_28448 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_28448 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_28448 + 50 len 14] * t / t != mem[_28448 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_28448 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_28448 + 50 len 14] * t / mem[_28448 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_28448')), 14)))
                                        revert
                                    if s:
                                        if 10^18 * s / s != 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not t:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        return (10^18 * s / t)
                                    if t:
                                        return (0 / t)
                                    var82001 = 32
                                    revert with 0, 'SafeMath: division by zero', 0
                                if 2 * mem[_16443] / mem[_16443] != 2:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _17871 = mem[64]
                                mem[64] = mem[64] + (32 * stor118.length) + 32
                                mem[_17871] = stor118.length
                                if not stor118.length:
                                    idx = 0
                                    t = 2 * _16823
                                    while idx < stor118.length - 1:
                                        require idx < mem[_17871]
                                        require idx + 1 < mem[_17871]
                                        _20583 = mem[(32 * idx + 1) + _17871 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _17871 + 44 len 20]
                                        mem[mem[64] + 36] = address(_20583)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_20583)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20962 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20962] == mem[_20962 + 12 len 20]
                                        require ext_code.size(mem[_20962 + 12 len 20])
                                        staticcall mem[_20962 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22776 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_22776] == mem[_22776 + 18 len 14]
                                        require mem[_22776 + 32] == mem[_22776 + 50 len 14]
                                        require mem[_22776 + 64] == mem[_22776 + 92 len 4]
                                        require idx < mem[_17871]
                                        require idx + 1 < mem[_17871]
                                        if mem[(32 * idx + 1) + _17871 + 44 len 20] < mem[(32 * idx) + _17871 + 44 len 20]:
                                            if not t:
                                                if mem[_22776 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22776 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_22776 + 18 len 14] * t / t != mem[_22776 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22776 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22776 + 18 len 14] * t / mem[_22776 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_22776')), 14)))
                                        else:
                                            if not t:
                                                if mem[_22776 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22776 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_22776 + 50 len 14] * t / t != mem[_22776 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22776 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22776 + 50 len 14] * t / mem[_22776 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_22776')), 14)))
                                        revert
                                else:
                                    mem[0] = 118
                                    mem[_17871 + 32] = address(stor118.field_0)
                                    idx = _17871 + 32
                                    t = 0
                                    while _17871 + (32 * stor118.length) > idx:
                                        mem[idx + 32] = stor118[t].field_256
                                        idx = idx + 32
                                        t = t + 1
                                        continue 
                                    idx = 0
                                    t = 2 * _16823
                                    while idx < stor118.length - 1:
                                        require idx < mem[_17871]
                                        require idx + 1 < mem[_17871]
                                        _27713 = mem[(32 * idx + 1) + _17871 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _17871 + 44 len 20]
                                        mem[mem[64] + 36] = address(_27713)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_27713)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27840 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_27840] == mem[_27840 + 12 len 20]
                                        require ext_code.size(mem[_27840 + 12 len 20])
                                        staticcall mem[_27840 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _28445 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_28445] == mem[_28445 + 18 len 14]
                                        require mem[_28445 + 32] == mem[_28445 + 50 len 14]
                                        require mem[_28445 + 64] == mem[_28445 + 92 len 4]
                                        require idx < mem[_17871]
                                        require idx + 1 < mem[_17871]
                                        if mem[(32 * idx + 1) + _17871 + 44 len 20] < mem[(32 * idx) + _17871 + 44 len 20]:
                                            if not t:
                                                if mem[_28445 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_28445 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_28445 + 18 len 14] * t / t != mem[_28445 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_28445 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_28445 + 18 len 14] * t / mem[_28445 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_28445')), 14)))
                                        else:
                                            if not t:
                                                if mem[_28445 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_28445 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_28445 + 50 len 14] * t / t != mem[_28445 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_28445 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_28445 + 50 len 14] * t / mem[_28445 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_28445')), 14)))
                                        revert
                else:
                    if (8760 * 24 * 3600 * ext_call.return_data[0]) - (8760 * 24 * 3600 * stor42D0) / ext_call.return_data[0] - stor42D0 != 8760 * 24 * 3600:
                        revert with 0, 'SafeMath: multiplication overflow'
                    mem[ceil32(return_data.size) + 96] = 26
                    mem[ceil32(return_data.size) + 128] = 'SafeMath: division by zero'
                    if not rewardsDuration:
                        revert with 0, 'SafeMath: division by zero', 0
                    require 0 < stor119.length
                    mem[0] = 119
                    require address(stor119.field_0) == rewardsTokenAddress
                    mem[64] = ceil32(return_data.size) + (32 * stor119.length) + 192
                    mem[ceil32(return_data.size) + 160] = stor119.length
                    if not stor119.length:
                        idx = 0
                        s = (8760 * 24 * 3600 * ext_call.return_data[0]) - (8760 * 24 * 3600 * stor42D0) / rewardsDuration
                        while idx < stor119.length - 1:
                            require idx < mem[ceil32(return_data.size) + 160]
                            require idx + 1 < mem[ceil32(return_data.size) + 160]
                            _4429 = mem[(32 * idx + 1) + ceil32(return_data.size) + 192]
                            mem[mem[64] + 4] = mem[(32 * idx) + ceil32(return_data.size) + 204 len 20]
                            mem[mem[64] + 36] = address(_4429)
                            require ext_code.size(stor117)
                            staticcall stor117.getPair(address rg1, address rg2) with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4], address(_4429)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4573 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_4573] == mem[_4573 + 12 len 20]
                            require ext_code.size(mem[_4573 + 12 len 20])
                            staticcall mem[_4573 + 12 len 20].getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4992 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_4992] == mem[_4992 + 18 len 14]
                            require mem[_4992 + 32] == mem[_4992 + 50 len 14]
                            require mem[_4992 + 64] == mem[_4992 + 92 len 4]
                            require idx < mem[ceil32(return_data.size) + 160]
                            require idx + 1 < mem[ceil32(return_data.size) + 160]
                            if mem[(32 * idx + 1) + ceil32(return_data.size) + 204 len 20] < mem[(32 * idx) + ceil32(return_data.size) + 204 len 20]:
                                if not s:
                                    if mem[_4992 + 50 len 14]:
                                        idx = idx + 1
                                        s = 0 / mem[_4992 + 50 len 14]
                                        continue 
                                else:
                                    if mem[_4992 + 18 len 14] * s / s != mem[_4992 + 18 len 14]:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if mem[_4992 + 50 len 14]:
                                        idx = idx + 1
                                        s = mem[_4992 + 18 len 14] * s / mem[_4992 + 50 len 14]
                                        continue 
                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_4992')), 14)))
                            else:
                                if not s:
                                    if mem[_4992 + 18 len 14]:
                                        idx = idx + 1
                                        s = 0 / mem[_4992 + 18 len 14]
                                        continue 
                                else:
                                    if mem[_4992 + 50 len 14] * s / s != mem[_4992 + 50 len 14]:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if mem[_4992 + 18 len 14]:
                                        idx = idx + 1
                                        s = mem[_4992 + 50 len 14] * s / mem[_4992 + 18 len 14]
                                        continue 
                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_4992')), 14)))
                            revert
                        require stor118.length
                        mem[0] = 118
                        if address(stor118.field_0) == stakingTokenAddress:
                            _4637 = mem[64]
                            mem[64] = mem[64] + (32 * stor118.length) + 32
                            mem[_4637] = stor118.length
                            if not stor118.length:
                                idx = 0
                                t = totalSupply
                                while idx < stor118.length - 1:
                                    require idx < mem[_4637]
                                    require idx + 1 < mem[_4637]
                                    _9027 = mem[(32 * idx + 1) + _4637 + 32]
                                    mem[mem[64] + 4] = mem[(32 * idx) + _4637 + 44 len 20]
                                    mem[mem[64] + 36] = address(_9027)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_9027)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9364 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_9364] == mem[_9364 + 12 len 20]
                                    require ext_code.size(mem[_9364 + 12 len 20])
                                    staticcall mem[_9364 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10703 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_10703] == mem[_10703 + 18 len 14]
                                    require mem[_10703 + 32] == mem[_10703 + 50 len 14]
                                    require mem[_10703 + 64] == mem[_10703 + 92 len 4]
                                    require idx < mem[_4637]
                                    require idx + 1 < mem[_4637]
                                    if mem[(32 * idx + 1) + _4637 + 44 len 20] < mem[(32 * idx) + _4637 + 44 len 20]:
                                        if not t:
                                            if mem[_10703 + 50 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_10703 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_10703 + 18 len 14] * t / t != mem[_10703 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_10703 + 50 len 14]:
                                                idx = idx + 1
                                                t = mem[_10703 + 18 len 14] * t / mem[_10703 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_10703')), 14)))
                                    else:
                                        if not t:
                                            if mem[_10703 + 18 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_10703 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_10703 + 50 len 14] * t / t != mem[_10703 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_10703 + 18 len 14]:
                                                idx = idx + 1
                                                t = mem[_10703 + 50 len 14] * t / mem[_10703 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_10703')), 14)))
                                    revert
                            else:
                                mem[0] = 118
                                mem[_4637 + 32] = address(stor118.field_0)
                                idx = _4637 + 32
                                t = 0
                                while _4637 + (32 * stor118.length) > idx:
                                    mem[idx + 32] = stor118[t].field_256
                                    idx = idx + 32
                                    t = t + 1
                                    continue 
                                idx = 0
                                t = totalSupply
                                while idx < stor118.length - 1:
                                    require idx < mem[_4637]
                                    require idx + 1 < mem[_4637]
                                    _20557 = mem[(32 * idx + 1) + _4637 + 32]
                                    mem[mem[64] + 4] = mem[(32 * idx) + _4637 + 44 len 20]
                                    mem[mem[64] + 36] = address(_20557)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_20557)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _20936 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_20936] == mem[_20936 + 12 len 20]
                                    require ext_code.size(mem[_20936 + 12 len 20])
                                    staticcall mem[_20936 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _22737 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_22737] == mem[_22737 + 18 len 14]
                                    require mem[_22737 + 32] == mem[_22737 + 50 len 14]
                                    require mem[_22737 + 64] == mem[_22737 + 92 len 4]
                                    require idx < mem[_4637]
                                    require idx + 1 < mem[_4637]
                                    if mem[(32 * idx + 1) + _4637 + 44 len 20] < mem[(32 * idx) + _4637 + 44 len 20]:
                                        if not t:
                                            if mem[_22737 + 50 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_22737 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_22737 + 18 len 14] * t / t != mem[_22737 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_22737 + 50 len 14]:
                                                idx = idx + 1
                                                t = mem[_22737 + 18 len 14] * t / mem[_22737 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_22737')), 14)))
                                    else:
                                        if not t:
                                            if mem[_22737 + 18 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_22737 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_22737 + 50 len 14] * t / t != mem[_22737 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_22737 + 18 len 14]:
                                                idx = idx + 1
                                                t = mem[_22737 + 50 len 14] * t / mem[_22737 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_22737')), 14)))
                                    revert
                        else:
                            require stor118.length
                            require stor118.length
                            require address(stor118.field_0) != stakingTokenAddress
                            require 0 < stor118.length
                            mem[0] = 118
                            mem[mem[64] + 4] = stakingTokenAddress
                            require ext_code.size(address(stor118.field_0))
                            staticcall address(stor118.field_0).0x70a08231 with:
                                    gas gas_remaining wei
                                   args stakingTokenAddress
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4991 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _5094 = mem[_4991]
                            if not mem[_4991]:
                                _5515 = mem[64]
                                mem[64] = mem[64] + (32 * stor118.length) + 32
                                mem[_5515] = stor118.length
                                if not stor118.length:
                                    idx = 0
                                    t = 0
                                    while idx < stor118.length - 1:
                                        require idx < mem[_5515]
                                        require idx + 1 < mem[_5515]
                                        _9031 = mem[(32 * idx + 1) + _5515 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _5515 + 44 len 20]
                                        mem[mem[64] + 36] = address(_9031)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_9031)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9368 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9368] == mem[_9368 + 12 len 20]
                                        require ext_code.size(mem[_9368 + 12 len 20])
                                        staticcall mem[_9368 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _10709 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_10709] == mem[_10709 + 18 len 14]
                                        require mem[_10709 + 32] == mem[_10709 + 50 len 14]
                                        require mem[_10709 + 64] == mem[_10709 + 92 len 4]
                                        require idx < mem[_5515]
                                        require idx + 1 < mem[_5515]
                                        if mem[(32 * idx + 1) + _5515 + 44 len 20] < mem[(32 * idx) + _5515 + 44 len 20]:
                                            if not t:
                                                if mem[_10709 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_10709 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_10709 + 18 len 14] * t / t != mem[_10709 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_10709 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_10709 + 18 len 14] * t / mem[_10709 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_10709')), 14)))
                                        else:
                                            if not t:
                                                if mem[_10709 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_10709 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_10709 + 50 len 14] * t / t != mem[_10709 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_10709 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_10709 + 50 len 14] * t / mem[_10709 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_10709')), 14)))
                                        revert
                                else:
                                    mem[0] = 118
                                    mem[_5515 + 32] = address(stor118.field_0)
                                    idx = _5515 + 32
                                    t = 0
                                    while _5515 + (32 * stor118.length) > idx:
                                        mem[idx + 32] = stor118[t].field_256
                                        idx = idx + 32
                                        t = t + 1
                                        continue 
                                    idx = 0
                                    t = 0
                                    while idx < stor118.length - 1:
                                        require idx < mem[_5515]
                                        require idx + 1 < mem[_5515]
                                        _20561 = mem[(32 * idx + 1) + _5515 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _5515 + 44 len 20]
                                        mem[mem[64] + 36] = address(_20561)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_20561)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20940 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20940] == mem[_20940 + 12 len 20]
                                        require ext_code.size(mem[_20940 + 12 len 20])
                                        staticcall mem[_20940 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22743 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_22743] == mem[_22743 + 18 len 14]
                                        require mem[_22743 + 32] == mem[_22743 + 50 len 14]
                                        require mem[_22743 + 64] == mem[_22743 + 92 len 4]
                                        require idx < mem[_5515]
                                        require idx + 1 < mem[_5515]
                                        if mem[(32 * idx + 1) + _5515 + 44 len 20] < mem[(32 * idx) + _5515 + 44 len 20]:
                                            if not t:
                                                if mem[_22743 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22743 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_22743 + 18 len 14] * t / t != mem[_22743 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22743 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22743 + 18 len 14] * t / mem[_22743 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_22743')), 14)))
                                        else:
                                            if not t:
                                                if mem[_22743 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22743 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_22743 + 50 len 14] * t / t != mem[_22743 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22743 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22743 + 50 len 14] * t / mem[_22743 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_22743')), 14)))
                                        revert
                            else:
                                if 2 * mem[_4991] / mem[_4991] != 2:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _5615 = mem[64]
                                mem[64] = mem[64] + (32 * stor118.length) + 32
                                mem[_5615] = stor118.length
                                if not stor118.length:
                                    idx = 0
                                    t = 2 * _5094
                                    while idx < stor118.length - 1:
                                        require idx < mem[_5615]
                                        require idx + 1 < mem[_5615]
                                        _9029 = mem[(32 * idx + 1) + _5615 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _5615 + 44 len 20]
                                        mem[mem[64] + 36] = address(_9029)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_9029)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9366 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9366] == mem[_9366 + 12 len 20]
                                        require ext_code.size(mem[_9366 + 12 len 20])
                                        staticcall mem[_9366 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _10706 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_10706] == mem[_10706 + 18 len 14]
                                        require mem[_10706 + 32] == mem[_10706 + 50 len 14]
                                        require mem[_10706 + 64] == mem[_10706 + 92 len 4]
                                        require idx < mem[_5615]
                                        require idx + 1 < mem[_5615]
                                        if mem[(32 * idx + 1) + _5615 + 44 len 20] < mem[(32 * idx) + _5615 + 44 len 20]:
                                            if not t:
                                                if mem[_10706 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_10706 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_10706 + 18 len 14] * t / t != mem[_10706 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_10706 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_10706 + 18 len 14] * t / mem[_10706 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_10706')), 14)))
                                        else:
                                            if not t:
                                                if mem[_10706 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_10706 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_10706 + 50 len 14] * t / t != mem[_10706 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_10706 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_10706 + 50 len 14] * t / mem[_10706 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_10706')), 14)))
                                        revert
                                else:
                                    mem[0] = 118
                                    mem[_5615 + 32] = address(stor118.field_0)
                                    idx = _5615 + 32
                                    t = 0
                                    while _5615 + (32 * stor118.length) > idx:
                                        mem[idx + 32] = stor118[t].field_256
                                        idx = idx + 32
                                        t = t + 1
                                        continue 
                                    idx = 0
                                    t = 2 * _5094
                                    while idx < stor118.length - 1:
                                        require idx < mem[_5615]
                                        require idx + 1 < mem[_5615]
                                        _20559 = mem[(32 * idx + 1) + _5615 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _5615 + 44 len 20]
                                        mem[mem[64] + 36] = address(_20559)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_20559)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20938 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20938] == mem[_20938 + 12 len 20]
                                        require ext_code.size(mem[_20938 + 12 len 20])
                                        staticcall mem[_20938 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22740 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_22740] == mem[_22740 + 18 len 14]
                                        require mem[_22740 + 32] == mem[_22740 + 50 len 14]
                                        require mem[_22740 + 64] == mem[_22740 + 92 len 4]
                                        require idx < mem[_5615]
                                        require idx + 1 < mem[_5615]
                                        if mem[(32 * idx + 1) + _5615 + 44 len 20] < mem[(32 * idx) + _5615 + 44 len 20]:
                                            if not t:
                                                if mem[_22740 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22740 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_22740 + 18 len 14] * t / t != mem[_22740 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22740 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22740 + 18 len 14] * t / mem[_22740 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_22740')), 14)))
                                        else:
                                            if not t:
                                                if mem[_22740 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22740 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_22740 + 50 len 14] * t / t != mem[_22740 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22740 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22740 + 50 len 14] * t / mem[_22740 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_22740')), 14)))
                                        revert
                    else:
                        mem[0] = 119
                        mem[ceil32(return_data.size) + 192] = address(stor119.field_0)
                        if (32 * stor119.length) + 32 <= 64:
                            idx = 0
                            s = (8760 * 24 * 3600 * ext_call.return_data[0]) - (8760 * 24 * 3600 * stor42D0) / rewardsDuration
                            while idx < stor119.length - 1:
                                require idx < mem[ceil32(return_data.size) + 160]
                                require idx + 1 < mem[ceil32(return_data.size) + 160]
                                _4431 = mem[(32 * idx + 1) + ceil32(return_data.size) + 192]
                                mem[mem[64] + 4] = mem[(32 * idx) + ceil32(return_data.size) + 204 len 20]
                                mem[mem[64] + 36] = address(_4431)
                                require ext_code.size(stor117)
                                staticcall stor117.getPair(address rg1, address rg2) with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4], address(_4431)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4574 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_4574] == mem[_4574 + 12 len 20]
                                require ext_code.size(mem[_4574 + 12 len 20])
                                staticcall mem[_4574 + 12 len 20].getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4996 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_4996] == mem[_4996 + 18 len 14]
                                require mem[_4996 + 32] == mem[_4996 + 50 len 14]
                                require mem[_4996 + 64] == mem[_4996 + 92 len 4]
                                require idx < mem[ceil32(return_data.size) + 160]
                                require idx + 1 < mem[ceil32(return_data.size) + 160]
                                if mem[(32 * idx + 1) + ceil32(return_data.size) + 204 len 20] < mem[(32 * idx) + ceil32(return_data.size) + 204 len 20]:
                                    if not s:
                                        if mem[_4996 + 50 len 14]:
                                            idx = idx + 1
                                            s = 0 / mem[_4996 + 50 len 14]
                                            continue 
                                    else:
                                        if mem[_4996 + 18 len 14] * s / s != mem[_4996 + 18 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_4996 + 50 len 14]:
                                            idx = idx + 1
                                            s = mem[_4996 + 18 len 14] * s / mem[_4996 + 50 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_4996')), 14)))
                                else:
                                    if not s:
                                        if mem[_4996 + 18 len 14]:
                                            idx = idx + 1
                                            s = 0 / mem[_4996 + 18 len 14]
                                            continue 
                                    else:
                                        if mem[_4996 + 50 len 14] * s / s != mem[_4996 + 50 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_4996 + 18 len 14]:
                                            idx = idx + 1
                                            s = mem[_4996 + 50 len 14] * s / mem[_4996 + 18 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_4996')), 14)))
                                revert
                            require stor118.length
                            mem[0] = 118
                            if address(stor118.field_0) == stakingTokenAddress:
                                _4639 = mem[64]
                                mem[64] = mem[64] + (32 * stor118.length) + 32
                                mem[_4639] = stor118.length
                                if not stor118.length:
                                    idx = 0
                                    t = totalSupply
                                    while idx < stor118.length - 1:
                                        require idx < mem[_4639]
                                        require idx + 1 < mem[_4639]
                                        _9034 = mem[(32 * idx + 1) + _4639 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _4639 + 44 len 20]
                                        mem[mem[64] + 36] = address(_9034)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_9034)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9371 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9371] == mem[_9371 + 12 len 20]
                                        require ext_code.size(mem[_9371 + 12 len 20])
                                        staticcall mem[_9371 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _10716 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_10716] == mem[_10716 + 18 len 14]
                                        require mem[_10716 + 32] == mem[_10716 + 50 len 14]
                                        require mem[_10716 + 64] == mem[_10716 + 92 len 4]
                                        require idx < mem[_4639]
                                        require idx + 1 < mem[_4639]
                                        if mem[(32 * idx + 1) + _4639 + 44 len 20] < mem[(32 * idx) + _4639 + 44 len 20]:
                                            if not t:
                                                if mem[_10716 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_10716 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_10716 + 18 len 14] * t / t != mem[_10716 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_10716 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_10716 + 18 len 14] * t / mem[_10716 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_10716')), 14)))
                                        else:
                                            if not t:
                                                if mem[_10716 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_10716 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_10716 + 50 len 14] * t / t != mem[_10716 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_10716 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_10716 + 50 len 14] * t / mem[_10716 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_10716')), 14)))
                                        revert
                                else:
                                    mem[0] = 118
                                    mem[_4639 + 32] = address(stor118.field_0)
                                    idx = _4639 + 32
                                    t = 0
                                    while _4639 + (32 * stor118.length) > idx:
                                        mem[idx + 32] = stor118[t].field_256
                                        idx = idx + 32
                                        t = t + 1
                                        continue 
                                    idx = 0
                                    t = totalSupply
                                    while idx < stor118.length - 1:
                                        require idx < mem[_4639]
                                        require idx + 1 < mem[_4639]
                                        _20569 = mem[(32 * idx + 1) + _4639 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _4639 + 44 len 20]
                                        mem[mem[64] + 36] = address(_20569)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_20569)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20948 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20948] == mem[_20948 + 12 len 20]
                                        require ext_code.size(mem[_20948 + 12 len 20])
                                        staticcall mem[_20948 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22755 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_22755] == mem[_22755 + 18 len 14]
                                        require mem[_22755 + 32] == mem[_22755 + 50 len 14]
                                        require mem[_22755 + 64] == mem[_22755 + 92 len 4]
                                        require idx < mem[_4639]
                                        require idx + 1 < mem[_4639]
                                        if mem[(32 * idx + 1) + _4639 + 44 len 20] < mem[(32 * idx) + _4639 + 44 len 20]:
                                            if not t:
                                                if mem[_22755 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22755 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_22755 + 18 len 14] * t / t != mem[_22755 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22755 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22755 + 18 len 14] * t / mem[_22755 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_22755')), 14)))
                                        else:
                                            if not t:
                                                if mem[_22755 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22755 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_22755 + 50 len 14] * t / t != mem[_22755 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22755 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22755 + 50 len 14] * t / mem[_22755 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_22755')), 14)))
                                        revert
                            else:
                                require stor118.length
                                require stor118.length
                                require address(stor118.field_0) != stakingTokenAddress
                                require 0 < stor118.length
                                mem[0] = 118
                                mem[mem[64] + 4] = stakingTokenAddress
                                require ext_code.size(address(stor118.field_0))
                                staticcall address(stor118.field_0).0x70a08231 with:
                                        gas gas_remaining wei
                                       args stakingTokenAddress
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4995 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _5097 = mem[_4995]
                                if not mem[_4995]:
                                    _5518 = mem[64]
                                    mem[64] = mem[64] + (32 * stor118.length) + 32
                                    mem[_5518] = stor118.length
                                    if not stor118.length:
                                        idx = 0
                                        t = 0
                                        while idx < stor118.length - 1:
                                            require idx < mem[_5518]
                                            require idx + 1 < mem[_5518]
                                            _9038 = mem[(32 * idx + 1) + _5518 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _5518 + 44 len 20]
                                            mem[mem[64] + 36] = address(_9038)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_9038)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9375 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9375] == mem[_9375 + 12 len 20]
                                            require ext_code.size(mem[_9375 + 12 len 20])
                                            staticcall mem[_9375 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _10722 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_10722] == mem[_10722 + 18 len 14]
                                            require mem[_10722 + 32] == mem[_10722 + 50 len 14]
                                            require mem[_10722 + 64] == mem[_10722 + 92 len 4]
                                            require idx < mem[_5518]
                                            require idx + 1 < mem[_5518]
                                            if mem[(32 * idx + 1) + _5518 + 44 len 20] < mem[(32 * idx) + _5518 + 44 len 20]:
                                                if not t:
                                                    if mem[_10722 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10722 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10722 + 18 len 14] * t / t != mem[_10722 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10722 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10722 + 18 len 14] * t / mem[_10722 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_10722')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_10722 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10722 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10722 + 50 len 14] * t / t != mem[_10722 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10722 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10722 + 50 len 14] * t / mem[_10722 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_10722')), 14)))
                                            revert
                                    else:
                                        mem[0] = 118
                                        mem[_5518 + 32] = address(stor118.field_0)
                                        idx = _5518 + 32
                                        t = 0
                                        while _5518 + (32 * stor118.length) > idx:
                                            mem[idx + 32] = stor118[t].field_256
                                            idx = idx + 32
                                            t = t + 1
                                            continue 
                                        idx = 0
                                        t = 0
                                        while idx < stor118.length - 1:
                                            require idx < mem[_5518]
                                            require idx + 1 < mem[_5518]
                                            _20573 = mem[(32 * idx + 1) + _5518 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _5518 + 44 len 20]
                                            mem[mem[64] + 36] = address(_20573)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_20573)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _20952 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_20952] == mem[_20952 + 12 len 20]
                                            require ext_code.size(mem[_20952 + 12 len 20])
                                            staticcall mem[_20952 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22761 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_22761] == mem[_22761 + 18 len 14]
                                            require mem[_22761 + 32] == mem[_22761 + 50 len 14]
                                            require mem[_22761 + 64] == mem[_22761 + 92 len 4]
                                            require idx < mem[_5518]
                                            require idx + 1 < mem[_5518]
                                            if mem[(32 * idx + 1) + _5518 + 44 len 20] < mem[(32 * idx) + _5518 + 44 len 20]:
                                                if not t:
                                                    if mem[_22761 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22761 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22761 + 18 len 14] * t / t != mem[_22761 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22761 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22761 + 18 len 14] * t / mem[_22761 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_22761')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_22761 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22761 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22761 + 50 len 14] * t / t != mem[_22761 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22761 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22761 + 50 len 14] * t / mem[_22761 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_22761')), 14)))
                                            revert
                                else:
                                    if 2 * mem[_4995] / mem[_4995] != 2:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _5620 = mem[64]
                                    mem[64] = mem[64] + (32 * stor118.length) + 32
                                    mem[_5620] = stor118.length
                                    if not stor118.length:
                                        idx = 0
                                        t = 2 * _5097
                                        while idx < stor118.length - 1:
                                            require idx < mem[_5620]
                                            require idx + 1 < mem[_5620]
                                            _9036 = mem[(32 * idx + 1) + _5620 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _5620 + 44 len 20]
                                            mem[mem[64] + 36] = address(_9036)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_9036)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9373 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9373] == mem[_9373 + 12 len 20]
                                            require ext_code.size(mem[_9373 + 12 len 20])
                                            staticcall mem[_9373 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _10719 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_10719] == mem[_10719 + 18 len 14]
                                            require mem[_10719 + 32] == mem[_10719 + 50 len 14]
                                            require mem[_10719 + 64] == mem[_10719 + 92 len 4]
                                            require idx < mem[_5620]
                                            require idx + 1 < mem[_5620]
                                            if mem[(32 * idx + 1) + _5620 + 44 len 20] < mem[(32 * idx) + _5620 + 44 len 20]:
                                                if not t:
                                                    if mem[_10719 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10719 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10719 + 18 len 14] * t / t != mem[_10719 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10719 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10719 + 18 len 14] * t / mem[_10719 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_10719')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_10719 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10719 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10719 + 50 len 14] * t / t != mem[_10719 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10719 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10719 + 50 len 14] * t / mem[_10719 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_10719')), 14)))
                                            revert
                                    else:
                                        mem[0] = 118
                                        mem[_5620 + 32] = address(stor118.field_0)
                                        idx = _5620 + 32
                                        t = 0
                                        while _5620 + (32 * stor118.length) > idx:
                                            mem[idx + 32] = stor118[t].field_256
                                            idx = idx + 32
                                            t = t + 1
                                            continue 
                                        idx = 0
                                        t = 2 * _5097
                                        while idx < stor118.length - 1:
                                            require idx < mem[_5620]
                                            require idx + 1 < mem[_5620]
                                            _20571 = mem[(32 * idx + 1) + _5620 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _5620 + 44 len 20]
                                            mem[mem[64] + 36] = address(_20571)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_20571)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _20950 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_20950] == mem[_20950 + 12 len 20]
                                            require ext_code.size(mem[_20950 + 12 len 20])
                                            staticcall mem[_20950 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22758 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_22758] == mem[_22758 + 18 len 14]
                                            require mem[_22758 + 32] == mem[_22758 + 50 len 14]
                                            require mem[_22758 + 64] == mem[_22758 + 92 len 4]
                                            require idx < mem[_5620]
                                            require idx + 1 < mem[_5620]
                                            if mem[(32 * idx + 1) + _5620 + 44 len 20] < mem[(32 * idx) + _5620 + 44 len 20]:
                                                if not t:
                                                    if mem[_22758 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22758 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22758 + 18 len 14] * t / t != mem[_22758 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22758 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22758 + 18 len 14] * t / mem[_22758 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_22758')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_22758 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22758 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22758 + 50 len 14] * t / t != mem[_22758 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22758 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22758 + 50 len 14] * t / mem[_22758 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_22758')), 14)))
                                            revert
                        else:
                            mem[ceil32(return_data.size) + 224] = address(stor119.field_256)
                            idx = ceil32(return_data.size) + 224
                            s = 1
                            while ceil32(return_data.size) + (32 * stor119.length) + 160 > idx:
                                mem[idx + 32] = stor119[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            idx = 0
                            s = (8760 * 24 * 3600 * ext_call.return_data[0]) - (8760 * 24 * 3600 * stor42D0) / rewardsDuration
                            while idx < stor119.length - 1:
                                require idx < mem[ceil32(return_data.size) + 160]
                                require idx + 1 < mem[ceil32(return_data.size) + 160]
                                _14458 = mem[(32 * idx + 1) + ceil32(return_data.size) + 192]
                                mem[mem[64] + 4] = mem[(32 * idx) + ceil32(return_data.size) + 204 len 20]
                                mem[mem[64] + 36] = address(_14458)
                                require ext_code.size(stor117)
                                staticcall stor117.getPair(address rg1, address rg2) with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4], address(_14458)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _15266 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_15266] == mem[_15266 + 12 len 20]
                                require ext_code.size(mem[_15266 + 12 len 20])
                                staticcall mem[_15266 + 12 len 20].getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _16428 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_16428] == mem[_16428 + 18 len 14]
                                require mem[_16428 + 32] == mem[_16428 + 50 len 14]
                                require mem[_16428 + 64] == mem[_16428 + 92 len 4]
                                require idx < mem[ceil32(return_data.size) + 160]
                                require idx + 1 < mem[ceil32(return_data.size) + 160]
                                if mem[(32 * idx + 1) + ceil32(return_data.size) + 204 len 20] < mem[(32 * idx) + ceil32(return_data.size) + 204 len 20]:
                                    if not s:
                                        if mem[_16428 + 50 len 14]:
                                            idx = idx + 1
                                            s = 0 / mem[_16428 + 50 len 14]
                                            continue 
                                    else:
                                        if mem[_16428 + 18 len 14] * s / s != mem[_16428 + 18 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_16428 + 50 len 14]:
                                            idx = idx + 1
                                            s = mem[_16428 + 18 len 14] * s / mem[_16428 + 50 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_16428')), 14)))
                                else:
                                    if not s:
                                        if mem[_16428 + 18 len 14]:
                                            idx = idx + 1
                                            s = 0 / mem[_16428 + 18 len 14]
                                            continue 
                                    else:
                                        if mem[_16428 + 50 len 14] * s / s != mem[_16428 + 50 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_16428 + 18 len 14]:
                                            idx = idx + 1
                                            s = mem[_16428 + 50 len 14] * s / mem[_16428 + 18 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_16428')), 14)))
                                revert
                            require stor118.length
                            mem[0] = 118
                            if address(stor118.field_0) == stakingTokenAddress:
                                _15409 = mem[64]
                                mem[64] = mem[64] + (32 * stor118.length) + 32
                                mem[_15409] = stor118.length
                                if not stor118.length:
                                    idx = 0
                                    t = totalSupply
                                    while idx < stor118.length - 1:
                                        require idx < mem[_15409]
                                        require idx + 1 < mem[_15409]
                                        _20563 = mem[(32 * idx + 1) + _15409 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _15409 + 44 len 20]
                                        mem[mem[64] + 36] = address(_20563)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_20563)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20942 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20942] == mem[_20942 + 12 len 20]
                                        require ext_code.size(mem[_20942 + 12 len 20])
                                        staticcall mem[_20942 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22746 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_22746] == mem[_22746 + 18 len 14]
                                        require mem[_22746 + 32] == mem[_22746 + 50 len 14]
                                        require mem[_22746 + 64] == mem[_22746 + 92 len 4]
                                        require idx < mem[_15409]
                                        require idx + 1 < mem[_15409]
                                        if mem[(32 * idx + 1) + _15409 + 44 len 20] < mem[(32 * idx) + _15409 + 44 len 20]:
                                            if not t:
                                                if mem[_22746 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22746 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_22746 + 18 len 14] * t / t != mem[_22746 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22746 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22746 + 18 len 14] * t / mem[_22746 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_22746')), 14)))
                                        else:
                                            if not t:
                                                if mem[_22746 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22746 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_22746 + 50 len 14] * t / t != mem[_22746 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22746 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22746 + 50 len 14] * t / mem[_22746 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_22746')), 14)))
                                        revert
                                    if s:
                                        if 10^18 * s / s != 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not t:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        return (10^18 * s / t)
                                    if t:
                                        return (0 / t)
                                    var64001 = 32
                                    revert with 0, 'SafeMath: division by zero', 0
                                mem[0] = 118
                                mem[_15409 + 32] = address(stor118.field_0)
                                idx = _15409 + 32
                                t = 0
                                while _15409 + (32 * stor118.length) > idx:
                                    mem[idx + 32] = stor118[t].field_256
                                    idx = idx + 32
                                    t = t + 1
                                    continue 
                                idx = 0
                                t = totalSupply
                                while idx < stor118.length - 1:
                                    require idx < mem[_15409]
                                    require idx + 1 < mem[_15409]
                                    _27705 = mem[(32 * idx + 1) + _15409 + 32]
                                    mem[mem[64] + 4] = mem[(32 * idx) + _15409 + 44 len 20]
                                    mem[mem[64] + 36] = address(_27705)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_27705)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _27832 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_27832] == mem[_27832 + 12 len 20]
                                    require ext_code.size(mem[_27832 + 12 len 20])
                                    staticcall mem[_27832 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _28433 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_28433] == mem[_28433 + 18 len 14]
                                    require mem[_28433 + 32] == mem[_28433 + 50 len 14]
                                    require mem[_28433 + 64] == mem[_28433 + 92 len 4]
                                    require idx < mem[_15409]
                                    require idx + 1 < mem[_15409]
                                    if mem[(32 * idx + 1) + _15409 + 44 len 20] < mem[(32 * idx) + _15409 + 44 len 20]:
                                        if not t:
                                            if mem[_28433 + 50 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_28433 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_28433 + 18 len 14] * t / t != mem[_28433 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_28433 + 50 len 14]:
                                                idx = idx + 1
                                                t = mem[_28433 + 18 len 14] * t / mem[_28433 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_28433')), 14)))
                                    else:
                                        if not t:
                                            if mem[_28433 + 18 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_28433 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_28433 + 50 len 14] * t / t != mem[_28433 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_28433 + 18 len 14]:
                                                idx = idx + 1
                                                t = mem[_28433 + 50 len 14] * t / mem[_28433 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_28433')), 14)))
                                    revert
                            else:
                                require stor118.length
                                require stor118.length
                                require address(stor118.field_0) != stakingTokenAddress
                                require 0 < stor118.length
                                mem[0] = 118
                                mem[mem[64] + 4] = stakingTokenAddress
                                require ext_code.size(address(stor118.field_0))
                                staticcall address(stor118.field_0).0x70a08231 with:
                                        gas gas_remaining wei
                                       args stakingTokenAddress
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _16427 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _16804 = mem[_16427]
                                if not mem[_16427]:
                                    _17783 = mem[64]
                                    mem[64] = mem[64] + (32 * stor118.length) + 32
                                    mem[_17783] = stor118.length
                                    if not stor118.length:
                                        idx = 0
                                        t = 0
                                        while idx < stor118.length - 1:
                                            require idx < mem[_17783]
                                            require idx + 1 < mem[_17783]
                                            _20567 = mem[(32 * idx + 1) + _17783 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _17783 + 44 len 20]
                                            mem[mem[64] + 36] = address(_20567)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_20567)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _20946 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_20946] == mem[_20946 + 12 len 20]
                                            require ext_code.size(mem[_20946 + 12 len 20])
                                            staticcall mem[_20946 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22752 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_22752] == mem[_22752 + 18 len 14]
                                            require mem[_22752 + 32] == mem[_22752 + 50 len 14]
                                            require mem[_22752 + 64] == mem[_22752 + 92 len 4]
                                            require idx < mem[_17783]
                                            require idx + 1 < mem[_17783]
                                            if mem[(32 * idx + 1) + _17783 + 44 len 20] < mem[(32 * idx) + _17783 + 44 len 20]:
                                                if not t:
                                                    if mem[_22752 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22752 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22752 + 18 len 14] * t / t != mem[_22752 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22752 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22752 + 18 len 14] * t / mem[_22752 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_22752')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_22752 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22752 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22752 + 50 len 14] * t / t != mem[_22752 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22752 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22752 + 50 len 14] * t / mem[_22752 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_22752')), 14)))
                                            revert
                                        if not s:
                                            if not t:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            return (0 / t)
                                        if 10^18 * s / s != 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not t:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        return (10^18 * s / t)
                                    mem[0] = 118
                                    mem[_17783 + 32] = address(stor118.field_0)
                                    idx = _17783 + 32
                                    t = 0
                                    while _17783 + (32 * stor118.length) > idx:
                                        mem[idx + 32] = stor118[t].field_256
                                        idx = idx + 32
                                        t = t + 1
                                        continue 
                                    idx = 0
                                    t = 0
                                    while idx < stor118.length - 1:
                                        require idx < mem[_17783]
                                        require idx + 1 < mem[_17783]
                                        _27709 = mem[(32 * idx + 1) + _17783 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _17783 + 44 len 20]
                                        mem[mem[64] + 36] = address(_27709)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_27709)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27836 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_27836] == mem[_27836 + 12 len 20]
                                        require ext_code.size(mem[_27836 + 12 len 20])
                                        staticcall mem[_27836 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _28439 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_28439] == mem[_28439 + 18 len 14]
                                        require mem[_28439 + 32] == mem[_28439 + 50 len 14]
                                        require mem[_28439 + 64] == mem[_28439 + 92 len 4]
                                        require idx < mem[_17783]
                                        require idx + 1 < mem[_17783]
                                        if mem[(32 * idx + 1) + _17783 + 44 len 20] < mem[(32 * idx) + _17783 + 44 len 20]:
                                            if not t:
                                                if mem[_28439 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_28439 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_28439 + 18 len 14] * t / t != mem[_28439 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_28439 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_28439 + 18 len 14] * t / mem[_28439 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_28439')), 14)))
                                        else:
                                            if not t:
                                                if mem[_28439 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_28439 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_28439 + 50 len 14] * t / t != mem[_28439 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_28439 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_28439 + 50 len 14] * t / mem[_28439 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_28439')), 14)))
                                        revert
                                    if s:
                                        if 10^18 * s / s != 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not t:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        return (10^18 * s / t)
                                    if t:
                                        return (0 / t)
                                    var83001 = 32
                                    revert with 0, 'SafeMath: division by zero', 0
                                if 2 * mem[_16427] / mem[_16427] != 2:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _17860 = mem[64]
                                mem[64] = mem[64] + (32 * stor118.length) + 32
                                mem[_17860] = stor118.length
                                if not stor118.length:
                                    idx = 0
                                    t = 2 * _16804
                                    while idx < stor118.length - 1:
                                        require idx < mem[_17860]
                                        require idx + 1 < mem[_17860]
                                        _20565 = mem[(32 * idx + 1) + _17860 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _17860 + 44 len 20]
                                        mem[mem[64] + 36] = address(_20565)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_20565)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20944 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20944] == mem[_20944 + 12 len 20]
                                        require ext_code.size(mem[_20944 + 12 len 20])
                                        staticcall mem[_20944 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22749 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_22749] == mem[_22749 + 18 len 14]
                                        require mem[_22749 + 32] == mem[_22749 + 50 len 14]
                                        require mem[_22749 + 64] == mem[_22749 + 92 len 4]
                                        require idx < mem[_17860]
                                        require idx + 1 < mem[_17860]
                                        if mem[(32 * idx + 1) + _17860 + 44 len 20] < mem[(32 * idx) + _17860 + 44 len 20]:
                                            if not t:
                                                if mem[_22749 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22749 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_22749 + 18 len 14] * t / t != mem[_22749 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22749 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22749 + 18 len 14] * t / mem[_22749 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_22749')), 14)))
                                        else:
                                            if not t:
                                                if mem[_22749 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22749 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_22749 + 50 len 14] * t / t != mem[_22749 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22749 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22749 + 50 len 14] * t / mem[_22749 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_22749')), 14)))
                                        revert
                                else:
                                    mem[0] = 118
                                    mem[_17860 + 32] = address(stor118.field_0)
                                    idx = _17860 + 32
                                    t = 0
                                    while _17860 + (32 * stor118.length) > idx:
                                        mem[idx + 32] = stor118[t].field_256
                                        idx = idx + 32
                                        t = t + 1
                                        continue 
                                    idx = 0
                                    t = 2 * _16804
                                    while idx < stor118.length - 1:
                                        require idx < mem[_17860]
                                        require idx + 1 < mem[_17860]
                                        _27707 = mem[(32 * idx + 1) + _17860 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _17860 + 44 len 20]
                                        mem[mem[64] + 36] = address(_27707)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_27707)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27834 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_27834] == mem[_27834 + 12 len 20]
                                        require ext_code.size(mem[_27834 + 12 len 20])
                                        staticcall mem[_27834 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _28436 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_28436] == mem[_28436 + 18 len 14]
                                        require mem[_28436 + 32] == mem[_28436 + 50 len 14]
                                        require mem[_28436 + 64] == mem[_28436 + 92 len 4]
                                        require idx < mem[_17860]
                                        require idx + 1 < mem[_17860]
                                        if mem[(32 * idx + 1) + _17860 + 44 len 20] < mem[(32 * idx) + _17860 + 44 len 20]:
                                            if not t:
                                                if mem[_28436 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_28436 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_28436 + 18 len 14] * t / t != mem[_28436 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_28436 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_28436 + 18 len 14] * t / mem[_28436 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_28436')), 14)))
                                        else:
                                            if not t:
                                                if mem[_28436 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_28436 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_28436 + 50 len 14] * t / t != mem[_28436 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_28436 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_28436 + 50 len 14] * t / mem[_28436 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_28436')), 14)))
                                        revert
            else:
                if block.timestamp >= periodFinish:
                    require 0 < stor119.length
                    mem[0] = 119
                    require address(stor119.field_0) == rewardsTokenAddress
                    mem[64] = ceil32(return_data.size) + (32 * stor119.length) + 128
                    mem[ceil32(return_data.size) + 96] = stor119.length
                    if lastUpdateTime < periodFinish:
                        if not stor119.length:
                            idx = 0
                            s = ext_call.return_data[0] - stor42D0
                            while idx < stor119.length - 1:
                                require idx < mem[ceil32(return_data.size) + 96]
                                require idx + 1 < mem[ceil32(return_data.size) + 96]
                                _4413 = mem[(32 * idx + 1) + ceil32(return_data.size) + 128]
                                mem[mem[64] + 4] = mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]
                                mem[mem[64] + 36] = address(_4413)
                                require ext_code.size(stor117)
                                staticcall stor117.getPair(address rg1, address rg2) with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4], address(_4413)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4565 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_4565] == mem[_4565 + 12 len 20]
                                require ext_code.size(mem[_4565 + 12 len 20])
                                staticcall mem[_4565 + 12 len 20].getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4960 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_4960] == mem[_4960 + 18 len 14]
                                require mem[_4960 + 32] == mem[_4960 + 50 len 14]
                                require mem[_4960 + 64] == mem[_4960 + 92 len 4]
                                require idx < mem[ceil32(return_data.size) + 96]
                                require idx + 1 < mem[ceil32(return_data.size) + 96]
                                if mem[(32 * idx + 1) + ceil32(return_data.size) + 140 len 20] < mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]:
                                    if not s:
                                        if mem[_4960 + 50 len 14]:
                                            idx = idx + 1
                                            s = 0 / mem[_4960 + 50 len 14]
                                            continue 
                                    else:
                                        if mem[_4960 + 18 len 14] * s / s != mem[_4960 + 18 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_4960 + 50 len 14]:
                                            idx = idx + 1
                                            s = mem[_4960 + 18 len 14] * s / mem[_4960 + 50 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_4960')), 14)))
                                else:
                                    if not s:
                                        if mem[_4960 + 18 len 14]:
                                            idx = idx + 1
                                            s = 0 / mem[_4960 + 18 len 14]
                                            continue 
                                    else:
                                        if mem[_4960 + 50 len 14] * s / s != mem[_4960 + 50 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_4960 + 18 len 14]:
                                            idx = idx + 1
                                            s = mem[_4960 + 50 len 14] * s / mem[_4960 + 18 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_4960')), 14)))
                                revert
                            require stor118.length
                            mem[0] = 118
                            if address(stor118.field_0) == stakingTokenAddress:
                                _4621 = mem[64]
                                mem[64] = mem[64] + (32 * stor118.length) + 32
                                mem[_4621] = stor118.length
                                if not stor118.length:
                                    idx = 0
                                    t = totalSupply
                                    while idx < stor118.length - 1:
                                        require idx < mem[_4621]
                                        require idx + 1 < mem[_4621]
                                        _8975 = mem[(32 * idx + 1) + _4621 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _4621 + 44 len 20]
                                        mem[mem[64] + 36] = address(_8975)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_8975)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9312 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9312] == mem[_9312 + 12 len 20]
                                        require ext_code.size(mem[_9312 + 12 len 20])
                                        staticcall mem[_9312 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _10615 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_10615] == mem[_10615 + 18 len 14]
                                        require mem[_10615 + 32] == mem[_10615 + 50 len 14]
                                        require mem[_10615 + 64] == mem[_10615 + 92 len 4]
                                        require idx < mem[_4621]
                                        require idx + 1 < mem[_4621]
                                        if mem[(32 * idx + 1) + _4621 + 44 len 20] < mem[(32 * idx) + _4621 + 44 len 20]:
                                            if not t:
                                                if mem[_10615 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_10615 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_10615 + 18 len 14] * t / t != mem[_10615 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_10615 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_10615 + 18 len 14] * t / mem[_10615 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_10615')), 14)))
                                        else:
                                            if not t:
                                                if mem[_10615 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_10615 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_10615 + 50 len 14] * t / t != mem[_10615 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_10615 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_10615 + 50 len 14] * t / mem[_10615 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_10615')), 14)))
                                        revert
                                else:
                                    mem[0] = 118
                                    mem[_4621 + 32] = address(stor118.field_0)
                                    idx = _4621 + 32
                                    t = 0
                                    while _4621 + (32 * stor118.length) > idx:
                                        mem[idx + 32] = stor118[t].field_256
                                        idx = idx + 32
                                        t = t + 1
                                        continue 
                                    idx = 0
                                    t = totalSupply
                                    while idx < stor118.length - 1:
                                        require idx < mem[_4621]
                                        require idx + 1 < mem[_4621]
                                        _20485 = mem[(32 * idx + 1) + _4621 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _4621 + 44 len 20]
                                        mem[mem[64] + 36] = address(_20485)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_20485)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20864 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20864] == mem[_20864 + 12 len 20]
                                        require ext_code.size(mem[_20864 + 12 len 20])
                                        staticcall mem[_20864 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22629 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_22629] == mem[_22629 + 18 len 14]
                                        require mem[_22629 + 32] == mem[_22629 + 50 len 14]
                                        require mem[_22629 + 64] == mem[_22629 + 92 len 4]
                                        require idx < mem[_4621]
                                        require idx + 1 < mem[_4621]
                                        if mem[(32 * idx + 1) + _4621 + 44 len 20] < mem[(32 * idx) + _4621 + 44 len 20]:
                                            if not t:
                                                if mem[_22629 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22629 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_22629 + 18 len 14] * t / t != mem[_22629 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22629 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22629 + 18 len 14] * t / mem[_22629 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_22629')), 14)))
                                        else:
                                            if not t:
                                                if mem[_22629 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22629 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_22629 + 50 len 14] * t / t != mem[_22629 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22629 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22629 + 50 len 14] * t / mem[_22629 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_22629')), 14)))
                                        revert
                            else:
                                require stor118.length
                                require stor118.length
                                require address(stor118.field_0) != stakingTokenAddress
                                require 0 < stor118.length
                                mem[0] = 118
                                mem[mem[64] + 4] = stakingTokenAddress
                                require ext_code.size(address(stor118.field_0))
                                staticcall address(stor118.field_0).0x70a08231 with:
                                        gas gas_remaining wei
                                       args stakingTokenAddress
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4959 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _5070 = mem[_4959]
                                if not mem[_4959]:
                                    _5491 = mem[64]
                                    mem[64] = mem[64] + (32 * stor118.length) + 32
                                    mem[_5491] = stor118.length
                                    if not stor118.length:
                                        idx = 0
                                        t = 0
                                        while idx < stor118.length - 1:
                                            require idx < mem[_5491]
                                            require idx + 1 < mem[_5491]
                                            _8979 = mem[(32 * idx + 1) + _5491 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _5491 + 44 len 20]
                                            mem[mem[64] + 36] = address(_8979)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_8979)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9316 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9316] == mem[_9316 + 12 len 20]
                                            require ext_code.size(mem[_9316 + 12 len 20])
                                            staticcall mem[_9316 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _10621 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_10621] == mem[_10621 + 18 len 14]
                                            require mem[_10621 + 32] == mem[_10621 + 50 len 14]
                                            require mem[_10621 + 64] == mem[_10621 + 92 len 4]
                                            require idx < mem[_5491]
                                            require idx + 1 < mem[_5491]
                                            if mem[(32 * idx + 1) + _5491 + 44 len 20] < mem[(32 * idx) + _5491 + 44 len 20]:
                                                if not t:
                                                    if mem[_10621 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10621 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10621 + 18 len 14] * t / t != mem[_10621 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10621 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10621 + 18 len 14] * t / mem[_10621 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_10621')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_10621 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10621 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10621 + 50 len 14] * t / t != mem[_10621 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10621 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10621 + 50 len 14] * t / mem[_10621 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_10621')), 14)))
                                            revert
                                    else:
                                        mem[0] = 118
                                        mem[_5491 + 32] = address(stor118.field_0)
                                        idx = _5491 + 32
                                        t = 0
                                        while _5491 + (32 * stor118.length) > idx:
                                            mem[idx + 32] = stor118[t].field_256
                                            idx = idx + 32
                                            t = t + 1
                                            continue 
                                        idx = 0
                                        t = 0
                                        while idx < stor118.length - 1:
                                            require idx < mem[_5491]
                                            require idx + 1 < mem[_5491]
                                            _20489 = mem[(32 * idx + 1) + _5491 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _5491 + 44 len 20]
                                            mem[mem[64] + 36] = address(_20489)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_20489)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _20868 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_20868] == mem[_20868 + 12 len 20]
                                            require ext_code.size(mem[_20868 + 12 len 20])
                                            staticcall mem[_20868 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22635 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_22635] == mem[_22635 + 18 len 14]
                                            require mem[_22635 + 32] == mem[_22635 + 50 len 14]
                                            require mem[_22635 + 64] == mem[_22635 + 92 len 4]
                                            require idx < mem[_5491]
                                            require idx + 1 < mem[_5491]
                                            if mem[(32 * idx + 1) + _5491 + 44 len 20] < mem[(32 * idx) + _5491 + 44 len 20]:
                                                if not t:
                                                    if mem[_22635 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22635 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22635 + 18 len 14] * t / t != mem[_22635 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22635 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22635 + 18 len 14] * t / mem[_22635 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_22635')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_22635 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22635 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22635 + 50 len 14] * t / t != mem[_22635 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22635 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22635 + 50 len 14] * t / mem[_22635 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_22635')), 14)))
                                            revert
                                else:
                                    if 2 * mem[_4959] / mem[_4959] != 2:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _5575 = mem[64]
                                    mem[64] = mem[64] + (32 * stor118.length) + 32
                                    mem[_5575] = stor118.length
                                    if not stor118.length:
                                        idx = 0
                                        t = 2 * _5070
                                        while idx < stor118.length - 1:
                                            require idx < mem[_5575]
                                            require idx + 1 < mem[_5575]
                                            _8977 = mem[(32 * idx + 1) + _5575 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _5575 + 44 len 20]
                                            mem[mem[64] + 36] = address(_8977)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_8977)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9314 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9314] == mem[_9314 + 12 len 20]
                                            require ext_code.size(mem[_9314 + 12 len 20])
                                            staticcall mem[_9314 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _10618 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_10618] == mem[_10618 + 18 len 14]
                                            require mem[_10618 + 32] == mem[_10618 + 50 len 14]
                                            require mem[_10618 + 64] == mem[_10618 + 92 len 4]
                                            require idx < mem[_5575]
                                            require idx + 1 < mem[_5575]
                                            if mem[(32 * idx + 1) + _5575 + 44 len 20] < mem[(32 * idx) + _5575 + 44 len 20]:
                                                if not t:
                                                    if mem[_10618 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10618 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10618 + 18 len 14] * t / t != mem[_10618 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10618 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10618 + 18 len 14] * t / mem[_10618 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_10618')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_10618 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10618 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10618 + 50 len 14] * t / t != mem[_10618 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10618 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10618 + 50 len 14] * t / mem[_10618 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_10618')), 14)))
                                            revert
                                    else:
                                        mem[0] = 118
                                        mem[_5575 + 32] = address(stor118.field_0)
                                        idx = _5575 + 32
                                        t = 0
                                        while _5575 + (32 * stor118.length) > idx:
                                            mem[idx + 32] = stor118[t].field_256
                                            idx = idx + 32
                                            t = t + 1
                                            continue 
                                        idx = 0
                                        t = 2 * _5070
                                        while idx < stor118.length - 1:
                                            require idx < mem[_5575]
                                            require idx + 1 < mem[_5575]
                                            _20487 = mem[(32 * idx + 1) + _5575 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _5575 + 44 len 20]
                                            mem[mem[64] + 36] = address(_20487)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_20487)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _20866 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_20866] == mem[_20866 + 12 len 20]
                                            require ext_code.size(mem[_20866 + 12 len 20])
                                            staticcall mem[_20866 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22632 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_22632] == mem[_22632 + 18 len 14]
                                            require mem[_22632 + 32] == mem[_22632 + 50 len 14]
                                            require mem[_22632 + 64] == mem[_22632 + 92 len 4]
                                            require idx < mem[_5575]
                                            require idx + 1 < mem[_5575]
                                            if mem[(32 * idx + 1) + _5575 + 44 len 20] < mem[(32 * idx) + _5575 + 44 len 20]:
                                                if not t:
                                                    if mem[_22632 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22632 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22632 + 18 len 14] * t / t != mem[_22632 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22632 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22632 + 18 len 14] * t / mem[_22632 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_22632')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_22632 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22632 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22632 + 50 len 14] * t / t != mem[_22632 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22632 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22632 + 50 len 14] * t / mem[_22632 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_22632')), 14)))
                                            revert
                        else:
                            mem[0] = 119
                            mem[ceil32(return_data.size) + 128] = address(stor119.field_0)
                            if (32 * stor119.length) + 32 <= 64:
                                idx = 0
                                s = ext_call.return_data[0] - stor42D0
                                while idx < stor119.length - 1:
                                    require idx < mem[ceil32(return_data.size) + 96]
                                    require idx + 1 < mem[ceil32(return_data.size) + 96]
                                    _4415 = mem[(32 * idx + 1) + ceil32(return_data.size) + 128]
                                    mem[mem[64] + 4] = mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]
                                    mem[mem[64] + 36] = address(_4415)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_4415)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4566 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_4566] == mem[_4566 + 12 len 20]
                                    require ext_code.size(mem[_4566 + 12 len 20])
                                    staticcall mem[_4566 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4964 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_4964] == mem[_4964 + 18 len 14]
                                    require mem[_4964 + 32] == mem[_4964 + 50 len 14]
                                    require mem[_4964 + 64] == mem[_4964 + 92 len 4]
                                    require idx < mem[ceil32(return_data.size) + 96]
                                    require idx + 1 < mem[ceil32(return_data.size) + 96]
                                    if mem[(32 * idx + 1) + ceil32(return_data.size) + 140 len 20] < mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]:
                                        if not s:
                                            if mem[_4964 + 50 len 14]:
                                                idx = idx + 1
                                                s = 0 / mem[_4964 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_4964 + 18 len 14] * s / s != mem[_4964 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_4964 + 50 len 14]:
                                                idx = idx + 1
                                                s = mem[_4964 + 18 len 14] * s / mem[_4964 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_4964')), 14)))
                                    else:
                                        if not s:
                                            if mem[_4964 + 18 len 14]:
                                                idx = idx + 1
                                                s = 0 / mem[_4964 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_4964 + 50 len 14] * s / s != mem[_4964 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_4964 + 18 len 14]:
                                                idx = idx + 1
                                                s = mem[_4964 + 50 len 14] * s / mem[_4964 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_4964')), 14)))
                                    revert
                                require stor118.length
                                mem[0] = 118
                                if address(stor118.field_0) == stakingTokenAddress:
                                    _4623 = mem[64]
                                    mem[64] = mem[64] + (32 * stor118.length) + 32
                                    mem[_4623] = stor118.length
                                    if not stor118.length:
                                        idx = 0
                                        t = totalSupply
                                        while idx < stor118.length - 1:
                                            require idx < mem[_4623]
                                            require idx + 1 < mem[_4623]
                                            _8982 = mem[(32 * idx + 1) + _4623 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _4623 + 44 len 20]
                                            mem[mem[64] + 36] = address(_8982)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_8982)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9319 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9319] == mem[_9319 + 12 len 20]
                                            require ext_code.size(mem[_9319 + 12 len 20])
                                            staticcall mem[_9319 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _10628 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_10628] == mem[_10628 + 18 len 14]
                                            require mem[_10628 + 32] == mem[_10628 + 50 len 14]
                                            require mem[_10628 + 64] == mem[_10628 + 92 len 4]
                                            require idx < mem[_4623]
                                            require idx + 1 < mem[_4623]
                                            if mem[(32 * idx + 1) + _4623 + 44 len 20] < mem[(32 * idx) + _4623 + 44 len 20]:
                                                if not t:
                                                    if mem[_10628 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10628 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10628 + 18 len 14] * t / t != mem[_10628 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10628 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10628 + 18 len 14] * t / mem[_10628 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_10628')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_10628 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10628 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10628 + 50 len 14] * t / t != mem[_10628 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10628 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10628 + 50 len 14] * t / mem[_10628 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_10628')), 14)))
                                            revert
                                    else:
                                        mem[0] = 118
                                        mem[_4623 + 32] = address(stor118.field_0)
                                        idx = _4623 + 32
                                        t = 0
                                        while _4623 + (32 * stor118.length) > idx:
                                            mem[idx + 32] = stor118[t].field_256
                                            idx = idx + 32
                                            t = t + 1
                                            continue 
                                        idx = 0
                                        t = totalSupply
                                        while idx < stor118.length - 1:
                                            require idx < mem[_4623]
                                            require idx + 1 < mem[_4623]
                                            _20497 = mem[(32 * idx + 1) + _4623 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _4623 + 44 len 20]
                                            mem[mem[64] + 36] = address(_20497)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_20497)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _20876 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_20876] == mem[_20876 + 12 len 20]
                                            require ext_code.size(mem[_20876 + 12 len 20])
                                            staticcall mem[_20876 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22647 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_22647] == mem[_22647 + 18 len 14]
                                            require mem[_22647 + 32] == mem[_22647 + 50 len 14]
                                            require mem[_22647 + 64] == mem[_22647 + 92 len 4]
                                            require idx < mem[_4623]
                                            require idx + 1 < mem[_4623]
                                            if mem[(32 * idx + 1) + _4623 + 44 len 20] < mem[(32 * idx) + _4623 + 44 len 20]:
                                                if not t:
                                                    if mem[_22647 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22647 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22647 + 18 len 14] * t / t != mem[_22647 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22647 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22647 + 18 len 14] * t / mem[_22647 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_22647')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_22647 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22647 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22647 + 50 len 14] * t / t != mem[_22647 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22647 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22647 + 50 len 14] * t / mem[_22647 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_22647')), 14)))
                                            revert
                                else:
                                    require stor118.length
                                    require stor118.length
                                    require address(stor118.field_0) != stakingTokenAddress
                                    require 0 < stor118.length
                                    mem[0] = 118
                                    mem[mem[64] + 4] = stakingTokenAddress
                                    require ext_code.size(address(stor118.field_0))
                                    staticcall address(stor118.field_0).0x70a08231 with:
                                            gas gas_remaining wei
                                           args stakingTokenAddress
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4963 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _5073 = mem[_4963]
                                    if not mem[_4963]:
                                        _5494 = mem[64]
                                        mem[64] = mem[64] + (32 * stor118.length) + 32
                                        mem[_5494] = stor118.length
                                        if not stor118.length:
                                            idx = 0
                                            t = 0
                                            while idx < stor118.length - 1:
                                                require idx < mem[_5494]
                                                require idx + 1 < mem[_5494]
                                                _8986 = mem[(32 * idx + 1) + _5494 + 32]
                                                mem[mem[64] + 4] = mem[(32 * idx) + _5494 + 44 len 20]
                                                mem[mem[64] + 36] = address(_8986)
                                                require ext_code.size(stor117)
                                                staticcall stor117.getPair(address rg1, address rg2) with:
                                                        gas gas_remaining wei
                                                       args mem[mem[64] + 4], address(_8986)
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _9323 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_9323] == mem[_9323 + 12 len 20]
                                                require ext_code.size(mem[_9323 + 12 len 20])
                                                staticcall mem[_9323 + 12 len 20].getReserves() with:
                                                        gas gas_remaining wei
                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _10634 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 96
                                                require mem[_10634] == mem[_10634 + 18 len 14]
                                                require mem[_10634 + 32] == mem[_10634 + 50 len 14]
                                                require mem[_10634 + 64] == mem[_10634 + 92 len 4]
                                                require idx < mem[_5494]
                                                require idx + 1 < mem[_5494]
                                                if mem[(32 * idx + 1) + _5494 + 44 len 20] < mem[(32 * idx) + _5494 + 44 len 20]:
                                                    if not t:
                                                        if mem[_10634 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_10634 + 50 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_10634 + 18 len 14] * t / t != mem[_10634 + 18 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_10634 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_10634 + 18 len 14] * t / mem[_10634 + 50 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_10634')), 14)))
                                                else:
                                                    if not t:
                                                        if mem[_10634 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_10634 + 18 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_10634 + 50 len 14] * t / t != mem[_10634 + 50 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_10634 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_10634 + 50 len 14] * t / mem[_10634 + 18 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_10634')), 14)))
                                                revert
                                        else:
                                            mem[0] = 118
                                            mem[_5494 + 32] = address(stor118.field_0)
                                            idx = _5494 + 32
                                            t = 0
                                            while _5494 + (32 * stor118.length) > idx:
                                                mem[idx + 32] = stor118[t].field_256
                                                idx = idx + 32
                                                t = t + 1
                                                continue 
                                            idx = 0
                                            t = 0
                                            while idx < stor118.length - 1:
                                                require idx < mem[_5494]
                                                require idx + 1 < mem[_5494]
                                                _20501 = mem[(32 * idx + 1) + _5494 + 32]
                                                mem[mem[64] + 4] = mem[(32 * idx) + _5494 + 44 len 20]
                                                mem[mem[64] + 36] = address(_20501)
                                                require ext_code.size(stor117)
                                                staticcall stor117.getPair(address rg1, address rg2) with:
                                                        gas gas_remaining wei
                                                       args mem[mem[64] + 4], address(_20501)
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _20880 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_20880] == mem[_20880 + 12 len 20]
                                                require ext_code.size(mem[_20880 + 12 len 20])
                                                staticcall mem[_20880 + 12 len 20].getReserves() with:
                                                        gas gas_remaining wei
                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _22653 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 96
                                                require mem[_22653] == mem[_22653 + 18 len 14]
                                                require mem[_22653 + 32] == mem[_22653 + 50 len 14]
                                                require mem[_22653 + 64] == mem[_22653 + 92 len 4]
                                                require idx < mem[_5494]
                                                require idx + 1 < mem[_5494]
                                                if mem[(32 * idx + 1) + _5494 + 44 len 20] < mem[(32 * idx) + _5494 + 44 len 20]:
                                                    if not t:
                                                        if mem[_22653 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_22653 + 50 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_22653 + 18 len 14] * t / t != mem[_22653 + 18 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_22653 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_22653 + 18 len 14] * t / mem[_22653 + 50 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_22653')), 14)))
                                                else:
                                                    if not t:
                                                        if mem[_22653 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_22653 + 18 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_22653 + 50 len 14] * t / t != mem[_22653 + 50 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_22653 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_22653 + 50 len 14] * t / mem[_22653 + 18 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_22653')), 14)))
                                                revert
                                    else:
                                        if 2 * mem[_4963] / mem[_4963] != 2:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _5580 = mem[64]
                                        mem[64] = mem[64] + (32 * stor118.length) + 32
                                        mem[_5580] = stor118.length
                                        if not stor118.length:
                                            idx = 0
                                            t = 2 * _5073
                                            while idx < stor118.length - 1:
                                                require idx < mem[_5580]
                                                require idx + 1 < mem[_5580]
                                                _8984 = mem[(32 * idx + 1) + _5580 + 32]
                                                mem[mem[64] + 4] = mem[(32 * idx) + _5580 + 44 len 20]
                                                mem[mem[64] + 36] = address(_8984)
                                                require ext_code.size(stor117)
                                                staticcall stor117.getPair(address rg1, address rg2) with:
                                                        gas gas_remaining wei
                                                       args mem[mem[64] + 4], address(_8984)
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _9321 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_9321] == mem[_9321 + 12 len 20]
                                                require ext_code.size(mem[_9321 + 12 len 20])
                                                staticcall mem[_9321 + 12 len 20].getReserves() with:
                                                        gas gas_remaining wei
                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _10631 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 96
                                                require mem[_10631] == mem[_10631 + 18 len 14]
                                                require mem[_10631 + 32] == mem[_10631 + 50 len 14]
                                                require mem[_10631 + 64] == mem[_10631 + 92 len 4]
                                                require idx < mem[_5580]
                                                require idx + 1 < mem[_5580]
                                                if mem[(32 * idx + 1) + _5580 + 44 len 20] < mem[(32 * idx) + _5580 + 44 len 20]:
                                                    if not t:
                                                        if mem[_10631 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_10631 + 50 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_10631 + 18 len 14] * t / t != mem[_10631 + 18 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_10631 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_10631 + 18 len 14] * t / mem[_10631 + 50 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_10631')), 14)))
                                                else:
                                                    if not t:
                                                        if mem[_10631 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_10631 + 18 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_10631 + 50 len 14] * t / t != mem[_10631 + 50 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_10631 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_10631 + 50 len 14] * t / mem[_10631 + 18 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_10631')), 14)))
                                                revert
                                        else:
                                            mem[0] = 118
                                            mem[_5580 + 32] = address(stor118.field_0)
                                            idx = _5580 + 32
                                            t = 0
                                            while _5580 + (32 * stor118.length) > idx:
                                                mem[idx + 32] = stor118[t].field_256
                                                idx = idx + 32
                                                t = t + 1
                                                continue 
                                            idx = 0
                                            t = 2 * _5073
                                            while idx < stor118.length - 1:
                                                require idx < mem[_5580]
                                                require idx + 1 < mem[_5580]
                                                _20499 = mem[(32 * idx + 1) + _5580 + 32]
                                                mem[mem[64] + 4] = mem[(32 * idx) + _5580 + 44 len 20]
                                                mem[mem[64] + 36] = address(_20499)
                                                require ext_code.size(stor117)
                                                staticcall stor117.getPair(address rg1, address rg2) with:
                                                        gas gas_remaining wei
                                                       args mem[mem[64] + 4], address(_20499)
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _20878 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_20878] == mem[_20878 + 12 len 20]
                                                require ext_code.size(mem[_20878 + 12 len 20])
                                                staticcall mem[_20878 + 12 len 20].getReserves() with:
                                                        gas gas_remaining wei
                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _22650 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 96
                                                require mem[_22650] == mem[_22650 + 18 len 14]
                                                require mem[_22650 + 32] == mem[_22650 + 50 len 14]
                                                require mem[_22650 + 64] == mem[_22650 + 92 len 4]
                                                require idx < mem[_5580]
                                                require idx + 1 < mem[_5580]
                                                if mem[(32 * idx + 1) + _5580 + 44 len 20] < mem[(32 * idx) + _5580 + 44 len 20]:
                                                    if not t:
                                                        if mem[_22650 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_22650 + 50 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_22650 + 18 len 14] * t / t != mem[_22650 + 18 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_22650 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_22650 + 18 len 14] * t / mem[_22650 + 50 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_22650')), 14)))
                                                else:
                                                    if not t:
                                                        if mem[_22650 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_22650 + 18 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_22650 + 50 len 14] * t / t != mem[_22650 + 50 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_22650 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_22650 + 50 len 14] * t / mem[_22650 + 18 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_22650')), 14)))
                                                revert
                            else:
                                mem[ceil32(return_data.size) + 160] = address(stor119.field_256)
                                idx = ceil32(return_data.size) + 160
                                s = 1
                                while ceil32(return_data.size) + (32 * stor119.length) + 96 > idx:
                                    mem[idx + 32] = stor119[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                idx = 0
                                s = ext_call.return_data[0] - stor42D0
                                while idx < stor119.length - 1:
                                    require idx < mem[ceil32(return_data.size) + 96]
                                    require idx + 1 < mem[ceil32(return_data.size) + 96]
                                    _14426 = mem[(32 * idx + 1) + ceil32(return_data.size) + 128]
                                    mem[mem[64] + 4] = mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]
                                    mem[mem[64] + 36] = address(_14426)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_14426)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _15238 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_15238] == mem[_15238 + 12 len 20]
                                    require ext_code.size(mem[_15238 + 12 len 20])
                                    staticcall mem[_15238 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _16364 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_16364] == mem[_16364 + 18 len 14]
                                    require mem[_16364 + 32] == mem[_16364 + 50 len 14]
                                    require mem[_16364 + 64] == mem[_16364 + 92 len 4]
                                    require idx < mem[ceil32(return_data.size) + 96]
                                    require idx + 1 < mem[ceil32(return_data.size) + 96]
                                    if mem[(32 * idx + 1) + ceil32(return_data.size) + 140 len 20] < mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]:
                                        if not s:
                                            if mem[_16364 + 50 len 14]:
                                                idx = idx + 1
                                                s = 0 / mem[_16364 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_16364 + 18 len 14] * s / s != mem[_16364 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_16364 + 50 len 14]:
                                                idx = idx + 1
                                                s = mem[_16364 + 18 len 14] * s / mem[_16364 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_16364')), 14)))
                                    else:
                                        if not s:
                                            if mem[_16364 + 18 len 14]:
                                                idx = idx + 1
                                                s = 0 / mem[_16364 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_16364 + 50 len 14] * s / s != mem[_16364 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_16364 + 18 len 14]:
                                                idx = idx + 1
                                                s = mem[_16364 + 50 len 14] * s / mem[_16364 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_16364')), 14)))
                                    revert
                                require stor118.length
                                mem[0] = 118
                                if address(stor118.field_0) == stakingTokenAddress:
                                    _15353 = mem[64]
                                    mem[64] = mem[64] + (32 * stor118.length) + 32
                                    mem[_15353] = stor118.length
                                    if not stor118.length:
                                        idx = 0
                                        t = totalSupply
                                        while idx < stor118.length - 1:
                                            require idx < mem[_15353]
                                            require idx + 1 < mem[_15353]
                                            _20491 = mem[(32 * idx + 1) + _15353 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _15353 + 44 len 20]
                                            mem[mem[64] + 36] = address(_20491)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_20491)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _20870 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_20870] == mem[_20870 + 12 len 20]
                                            require ext_code.size(mem[_20870 + 12 len 20])
                                            staticcall mem[_20870 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22638 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_22638] == mem[_22638 + 18 len 14]
                                            require mem[_22638 + 32] == mem[_22638 + 50 len 14]
                                            require mem[_22638 + 64] == mem[_22638 + 92 len 4]
                                            require idx < mem[_15353]
                                            require idx + 1 < mem[_15353]
                                            if mem[(32 * idx + 1) + _15353 + 44 len 20] < mem[(32 * idx) + _15353 + 44 len 20]:
                                                if not t:
                                                    if mem[_22638 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22638 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22638 + 18 len 14] * t / t != mem[_22638 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22638 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22638 + 18 len 14] * t / mem[_22638 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_22638')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_22638 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22638 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22638 + 50 len 14] * t / t != mem[_22638 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22638 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22638 + 50 len 14] * t / mem[_22638 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_22638')), 14)))
                                            revert
                                        if s:
                                            if 10^18 * s / s != 10^18:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not t:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            return (10^18 * s / t)
                                        if t:
                                            return (0 / t)
                                        var54001 = 32
                                        revert with 0, 'SafeMath: division by zero', 0
                                    mem[0] = 118
                                    mem[_15353 + 32] = address(stor118.field_0)
                                    idx = _15353 + 32
                                    t = 0
                                    while _15353 + (32 * stor118.length) > idx:
                                        mem[idx + 32] = stor118[t].field_256
                                        idx = idx + 32
                                        t = t + 1
                                        continue 
                                    idx = 0
                                    t = totalSupply
                                    while idx < stor118.length - 1:
                                        require idx < mem[_15353]
                                        require idx + 1 < mem[_15353]
                                        _27681 = mem[(32 * idx + 1) + _15353 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _15353 + 44 len 20]
                                        mem[mem[64] + 36] = address(_27681)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_27681)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27808 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_27808] == mem[_27808 + 12 len 20]
                                        require ext_code.size(mem[_27808 + 12 len 20])
                                        staticcall mem[_27808 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _28397 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_28397] == mem[_28397 + 18 len 14]
                                        require mem[_28397 + 32] == mem[_28397 + 50 len 14]
                                        require mem[_28397 + 64] == mem[_28397 + 92 len 4]
                                        require idx < mem[_15353]
                                        require idx + 1 < mem[_15353]
                                        if mem[(32 * idx + 1) + _15353 + 44 len 20] < mem[(32 * idx) + _15353 + 44 len 20]:
                                            if not t:
                                                if mem[_28397 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_28397 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_28397 + 18 len 14] * t / t != mem[_28397 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_28397 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_28397 + 18 len 14] * t / mem[_28397 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_28397')), 14)))
                                        else:
                                            if not t:
                                                if mem[_28397 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_28397 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_28397 + 50 len 14] * t / t != mem[_28397 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_28397 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_28397 + 50 len 14] * t / mem[_28397 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_28397')), 14)))
                                        revert
                                else:
                                    require stor118.length
                                    require stor118.length
                                    require address(stor118.field_0) != stakingTokenAddress
                                    require 0 < stor118.length
                                    mem[0] = 118
                                    mem[mem[64] + 4] = stakingTokenAddress
                                    require ext_code.size(address(stor118.field_0))
                                    staticcall address(stor118.field_0).0x70a08231 with:
                                            gas gas_remaining wei
                                           args stakingTokenAddress
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _16363 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _16728 = mem[_16363]
                                    if not mem[_16363]:
                                        _17771 = mem[64]
                                        mem[64] = mem[64] + (32 * stor118.length) + 32
                                        mem[_17771] = stor118.length
                                        if not stor118.length:
                                            idx = 0
                                            t = 0
                                            while idx < stor118.length - 1:
                                                require idx < mem[_17771]
                                                require idx + 1 < mem[_17771]
                                                _20495 = mem[(32 * idx + 1) + _17771 + 32]
                                                mem[mem[64] + 4] = mem[(32 * idx) + _17771 + 44 len 20]
                                                mem[mem[64] + 36] = address(_20495)
                                                require ext_code.size(stor117)
                                                staticcall stor117.getPair(address rg1, address rg2) with:
                                                        gas gas_remaining wei
                                                       args mem[mem[64] + 4], address(_20495)
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _20874 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_20874] == mem[_20874 + 12 len 20]
                                                require ext_code.size(mem[_20874 + 12 len 20])
                                                staticcall mem[_20874 + 12 len 20].getReserves() with:
                                                        gas gas_remaining wei
                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _22644 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 96
                                                require mem[_22644] == mem[_22644 + 18 len 14]
                                                require mem[_22644 + 32] == mem[_22644 + 50 len 14]
                                                require mem[_22644 + 64] == mem[_22644 + 92 len 4]
                                                require idx < mem[_17771]
                                                require idx + 1 < mem[_17771]
                                                if mem[(32 * idx + 1) + _17771 + 44 len 20] < mem[(32 * idx) + _17771 + 44 len 20]:
                                                    if not t:
                                                        if mem[_22644 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_22644 + 50 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_22644 + 18 len 14] * t / t != mem[_22644 + 18 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_22644 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_22644 + 18 len 14] * t / mem[_22644 + 50 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_22644')), 14)))
                                                else:
                                                    if not t:
                                                        if mem[_22644 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_22644 + 18 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_22644 + 50 len 14] * t / t != mem[_22644 + 50 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_22644 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_22644 + 50 len 14] * t / mem[_22644 + 18 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_22644')), 14)))
                                                revert
                                            if not s:
                                                if not t:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                return (0 / t)
                                            if 10^18 * s / s != 10^18:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not t:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            return (10^18 * s / t)
                                        mem[0] = 118
                                        mem[_17771 + 32] = address(stor118.field_0)
                                        idx = _17771 + 32
                                        t = 0
                                        while _17771 + (32 * stor118.length) > idx:
                                            mem[idx + 32] = stor118[t].field_256
                                            idx = idx + 32
                                            t = t + 1
                                            continue 
                                        idx = 0
                                        t = 0
                                        while idx < stor118.length - 1:
                                            require idx < mem[_17771]
                                            require idx + 1 < mem[_17771]
                                            _27685 = mem[(32 * idx + 1) + _17771 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _17771 + 44 len 20]
                                            mem[mem[64] + 36] = address(_27685)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_27685)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27812 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_27812] == mem[_27812 + 12 len 20]
                                            require ext_code.size(mem[_27812 + 12 len 20])
                                            staticcall mem[_27812 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _28403 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_28403] == mem[_28403 + 18 len 14]
                                            require mem[_28403 + 32] == mem[_28403 + 50 len 14]
                                            require mem[_28403 + 64] == mem[_28403 + 92 len 4]
                                            require idx < mem[_17771]
                                            require idx + 1 < mem[_17771]
                                            if mem[(32 * idx + 1) + _17771 + 44 len 20] < mem[(32 * idx) + _17771 + 44 len 20]:
                                                if not t:
                                                    if mem[_28403 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_28403 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_28403 + 18 len 14] * t / t != mem[_28403 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_28403 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_28403 + 18 len 14] * t / mem[_28403 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_28403')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_28403 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_28403 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_28403 + 50 len 14] * t / t != mem[_28403 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_28403 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_28403 + 50 len 14] * t / mem[_28403 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_28403')), 14)))
                                            revert
                                        if s:
                                            if 10^18 * s / s != 10^18:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not t:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            return (10^18 * s / t)
                                        if t:
                                            return (0 / t)
                                        var73001 = 32
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if 2 * mem[_16363] / mem[_16363] != 2:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _17816 = mem[64]
                                    mem[64] = mem[64] + (32 * stor118.length) + 32
                                    mem[_17816] = stor118.length
                                    if not stor118.length:
                                        idx = 0
                                        t = 2 * _16728
                                        while idx < stor118.length - 1:
                                            require idx < mem[_17816]
                                            require idx + 1 < mem[_17816]
                                            _20493 = mem[(32 * idx + 1) + _17816 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _17816 + 44 len 20]
                                            mem[mem[64] + 36] = address(_20493)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_20493)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _20872 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_20872] == mem[_20872 + 12 len 20]
                                            require ext_code.size(mem[_20872 + 12 len 20])
                                            staticcall mem[_20872 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22641 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_22641] == mem[_22641 + 18 len 14]
                                            require mem[_22641 + 32] == mem[_22641 + 50 len 14]
                                            require mem[_22641 + 64] == mem[_22641 + 92 len 4]
                                            require idx < mem[_17816]
                                            require idx + 1 < mem[_17816]
                                            if mem[(32 * idx + 1) + _17816 + 44 len 20] < mem[(32 * idx) + _17816 + 44 len 20]:
                                                if not t:
                                                    if mem[_22641 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22641 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22641 + 18 len 14] * t / t != mem[_22641 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22641 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22641 + 18 len 14] * t / mem[_22641 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_22641')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_22641 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22641 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22641 + 50 len 14] * t / t != mem[_22641 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22641 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22641 + 50 len 14] * t / mem[_22641 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_22641')), 14)))
                                            revert
                                    else:
                                        mem[0] = 118
                                        mem[_17816 + 32] = address(stor118.field_0)
                                        idx = _17816 + 32
                                        t = 0
                                        while _17816 + (32 * stor118.length) > idx:
                                            mem[idx + 32] = stor118[t].field_256
                                            idx = idx + 32
                                            t = t + 1
                                            continue 
                                        idx = 0
                                        t = 2 * _16728
                                        while idx < stor118.length - 1:
                                            require idx < mem[_17816]
                                            require idx + 1 < mem[_17816]
                                            _27683 = mem[(32 * idx + 1) + _17816 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _17816 + 44 len 20]
                                            mem[mem[64] + 36] = address(_27683)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_27683)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27810 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_27810] == mem[_27810 + 12 len 20]
                                            require ext_code.size(mem[_27810 + 12 len 20])
                                            staticcall mem[_27810 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _28400 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_28400] == mem[_28400 + 18 len 14]
                                            require mem[_28400 + 32] == mem[_28400 + 50 len 14]
                                            require mem[_28400 + 64] == mem[_28400 + 92 len 4]
                                            require idx < mem[_17816]
                                            require idx + 1 < mem[_17816]
                                            if mem[(32 * idx + 1) + _17816 + 44 len 20] < mem[(32 * idx) + _17816 + 44 len 20]:
                                                if not t:
                                                    if mem[_28400 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_28400 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_28400 + 18 len 14] * t / t != mem[_28400 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_28400 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_28400 + 18 len 14] * t / mem[_28400 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_28400')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_28400 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_28400 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_28400 + 50 len 14] * t / t != mem[_28400 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_28400 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_28400 + 50 len 14] * t / mem[_28400 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_28400')), 14)))
                                            revert
                    else:
                        if not stor119.length:
                            idx = 0
                            s = 0
                            while idx < stor119.length - 1:
                                require idx < mem[ceil32(return_data.size) + 96]
                                require idx + 1 < mem[ceil32(return_data.size) + 96]
                                _4417 = mem[(32 * idx + 1) + ceil32(return_data.size) + 128]
                                mem[mem[64] + 4] = mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]
                                mem[mem[64] + 36] = address(_4417)
                                require ext_code.size(stor117)
                                staticcall stor117.getPair(address rg1, address rg2) with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4], address(_4417)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4567 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_4567] == mem[_4567 + 12 len 20]
                                require ext_code.size(mem[_4567 + 12 len 20])
                                staticcall mem[_4567 + 12 len 20].getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4968 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_4968] == mem[_4968 + 18 len 14]
                                require mem[_4968 + 32] == mem[_4968 + 50 len 14]
                                require mem[_4968 + 64] == mem[_4968 + 92 len 4]
                                require idx < mem[ceil32(return_data.size) + 96]
                                require idx + 1 < mem[ceil32(return_data.size) + 96]
                                if mem[(32 * idx + 1) + ceil32(return_data.size) + 140 len 20] < mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]:
                                    if not s:
                                        if mem[_4968 + 50 len 14]:
                                            idx = idx + 1
                                            s = 0 / mem[_4968 + 50 len 14]
                                            continue 
                                    else:
                                        if mem[_4968 + 18 len 14] * s / s != mem[_4968 + 18 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_4968 + 50 len 14]:
                                            idx = idx + 1
                                            s = mem[_4968 + 18 len 14] * s / mem[_4968 + 50 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_4968')), 14)))
                                else:
                                    if not s:
                                        if mem[_4968 + 18 len 14]:
                                            idx = idx + 1
                                            s = 0 / mem[_4968 + 18 len 14]
                                            continue 
                                    else:
                                        if mem[_4968 + 50 len 14] * s / s != mem[_4968 + 50 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_4968 + 18 len 14]:
                                            idx = idx + 1
                                            s = mem[_4968 + 50 len 14] * s / mem[_4968 + 18 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_4968')), 14)))
                                revert
                            require stor118.length
                            mem[0] = 118
                            if address(stor118.field_0) == stakingTokenAddress:
                                _4625 = mem[64]
                                mem[64] = mem[64] + (32 * stor118.length) + 32
                                mem[_4625] = stor118.length
                                if not stor118.length:
                                    idx = 0
                                    t = totalSupply
                                    while idx < stor118.length - 1:
                                        require idx < mem[_4625]
                                        require idx + 1 < mem[_4625]
                                        _8988 = mem[(32 * idx + 1) + _4625 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _4625 + 44 len 20]
                                        mem[mem[64] + 36] = address(_8988)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_8988)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9325 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9325] == mem[_9325 + 12 len 20]
                                        require ext_code.size(mem[_9325 + 12 len 20])
                                        staticcall mem[_9325 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _10637 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_10637] == mem[_10637 + 18 len 14]
                                        require mem[_10637 + 32] == mem[_10637 + 50 len 14]
                                        require mem[_10637 + 64] == mem[_10637 + 92 len 4]
                                        require idx < mem[_4625]
                                        require idx + 1 < mem[_4625]
                                        if mem[(32 * idx + 1) + _4625 + 44 len 20] < mem[(32 * idx) + _4625 + 44 len 20]:
                                            if not t:
                                                if mem[_10637 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_10637 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_10637 + 18 len 14] * t / t != mem[_10637 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_10637 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_10637 + 18 len 14] * t / mem[_10637 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_10637')), 14)))
                                        else:
                                            if not t:
                                                if mem[_10637 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_10637 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_10637 + 50 len 14] * t / t != mem[_10637 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_10637 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_10637 + 50 len 14] * t / mem[_10637 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_10637')), 14)))
                                        revert
                                else:
                                    mem[0] = 118
                                    mem[_4625 + 32] = address(stor118.field_0)
                                    idx = _4625 + 32
                                    t = 0
                                    while _4625 + (32 * stor118.length) > idx:
                                        mem[idx + 32] = stor118[t].field_256
                                        idx = idx + 32
                                        t = t + 1
                                        continue 
                                    idx = 0
                                    t = totalSupply
                                    while idx < stor118.length - 1:
                                        require idx < mem[_4625]
                                        require idx + 1 < mem[_4625]
                                        _20503 = mem[(32 * idx + 1) + _4625 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _4625 + 44 len 20]
                                        mem[mem[64] + 36] = address(_20503)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_20503)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20882 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20882] == mem[_20882 + 12 len 20]
                                        require ext_code.size(mem[_20882 + 12 len 20])
                                        staticcall mem[_20882 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22656 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_22656] == mem[_22656 + 18 len 14]
                                        require mem[_22656 + 32] == mem[_22656 + 50 len 14]
                                        require mem[_22656 + 64] == mem[_22656 + 92 len 4]
                                        require idx < mem[_4625]
                                        require idx + 1 < mem[_4625]
                                        if mem[(32 * idx + 1) + _4625 + 44 len 20] < mem[(32 * idx) + _4625 + 44 len 20]:
                                            if not t:
                                                if mem[_22656 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22656 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_22656 + 18 len 14] * t / t != mem[_22656 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22656 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22656 + 18 len 14] * t / mem[_22656 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_22656')), 14)))
                                        else:
                                            if not t:
                                                if mem[_22656 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22656 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_22656 + 50 len 14] * t / t != mem[_22656 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22656 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22656 + 50 len 14] * t / mem[_22656 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_22656')), 14)))
                                        revert
                            else:
                                require stor118.length
                                require stor118.length
                                require address(stor118.field_0) != stakingTokenAddress
                                require 0 < stor118.length
                                mem[0] = 118
                                mem[mem[64] + 4] = stakingTokenAddress
                                require ext_code.size(address(stor118.field_0))
                                staticcall address(stor118.field_0).0x70a08231 with:
                                        gas gas_remaining wei
                                       args stakingTokenAddress
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4967 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _5076 = mem[_4967]
                                if not mem[_4967]:
                                    _5497 = mem[64]
                                    mem[64] = mem[64] + (32 * stor118.length) + 32
                                    mem[_5497] = stor118.length
                                    if not stor118.length:
                                        idx = 0
                                        t = 0
                                        while idx < stor118.length - 1:
                                            require idx < mem[_5497]
                                            require idx + 1 < mem[_5497]
                                            _8992 = mem[(32 * idx + 1) + _5497 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _5497 + 44 len 20]
                                            mem[mem[64] + 36] = address(_8992)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_8992)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9329 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9329] == mem[_9329 + 12 len 20]
                                            require ext_code.size(mem[_9329 + 12 len 20])
                                            staticcall mem[_9329 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _10643 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_10643] == mem[_10643 + 18 len 14]
                                            require mem[_10643 + 32] == mem[_10643 + 50 len 14]
                                            require mem[_10643 + 64] == mem[_10643 + 92 len 4]
                                            require idx < mem[_5497]
                                            require idx + 1 < mem[_5497]
                                            if mem[(32 * idx + 1) + _5497 + 44 len 20] < mem[(32 * idx) + _5497 + 44 len 20]:
                                                if not t:
                                                    if mem[_10643 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10643 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10643 + 18 len 14] * t / t != mem[_10643 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10643 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10643 + 18 len 14] * t / mem[_10643 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_10643')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_10643 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10643 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10643 + 50 len 14] * t / t != mem[_10643 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10643 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10643 + 50 len 14] * t / mem[_10643 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_10643')), 14)))
                                            revert
                                    else:
                                        mem[0] = 118
                                        mem[_5497 + 32] = address(stor118.field_0)
                                        idx = _5497 + 32
                                        t = 0
                                        while _5497 + (32 * stor118.length) > idx:
                                            mem[idx + 32] = stor118[t].field_256
                                            idx = idx + 32
                                            t = t + 1
                                            continue 
                                        idx = 0
                                        t = 0
                                        while idx < stor118.length - 1:
                                            require idx < mem[_5497]
                                            require idx + 1 < mem[_5497]
                                            _20507 = mem[(32 * idx + 1) + _5497 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _5497 + 44 len 20]
                                            mem[mem[64] + 36] = address(_20507)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_20507)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _20886 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_20886] == mem[_20886 + 12 len 20]
                                            require ext_code.size(mem[_20886 + 12 len 20])
                                            staticcall mem[_20886 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22662 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_22662] == mem[_22662 + 18 len 14]
                                            require mem[_22662 + 32] == mem[_22662 + 50 len 14]
                                            require mem[_22662 + 64] == mem[_22662 + 92 len 4]
                                            require idx < mem[_5497]
                                            require idx + 1 < mem[_5497]
                                            if mem[(32 * idx + 1) + _5497 + 44 len 20] < mem[(32 * idx) + _5497 + 44 len 20]:
                                                if not t:
                                                    if mem[_22662 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22662 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22662 + 18 len 14] * t / t != mem[_22662 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22662 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22662 + 18 len 14] * t / mem[_22662 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_22662')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_22662 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22662 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22662 + 50 len 14] * t / t != mem[_22662 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22662 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22662 + 50 len 14] * t / mem[_22662 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_22662')), 14)))
                                            revert
                                else:
                                    if 2 * mem[_4967] / mem[_4967] != 2:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _5585 = mem[64]
                                    mem[64] = mem[64] + (32 * stor118.length) + 32
                                    mem[_5585] = stor118.length
                                    if not stor118.length:
                                        idx = 0
                                        t = 2 * _5076
                                        while idx < stor118.length - 1:
                                            require idx < mem[_5585]
                                            require idx + 1 < mem[_5585]
                                            _8990 = mem[(32 * idx + 1) + _5585 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _5585 + 44 len 20]
                                            mem[mem[64] + 36] = address(_8990)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_8990)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9327 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9327] == mem[_9327 + 12 len 20]
                                            require ext_code.size(mem[_9327 + 12 len 20])
                                            staticcall mem[_9327 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _10640 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_10640] == mem[_10640 + 18 len 14]
                                            require mem[_10640 + 32] == mem[_10640 + 50 len 14]
                                            require mem[_10640 + 64] == mem[_10640 + 92 len 4]
                                            require idx < mem[_5585]
                                            require idx + 1 < mem[_5585]
                                            if mem[(32 * idx + 1) + _5585 + 44 len 20] < mem[(32 * idx) + _5585 + 44 len 20]:
                                                if not t:
                                                    if mem[_10640 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10640 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10640 + 18 len 14] * t / t != mem[_10640 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10640 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10640 + 18 len 14] * t / mem[_10640 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_10640')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_10640 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10640 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10640 + 50 len 14] * t / t != mem[_10640 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10640 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10640 + 50 len 14] * t / mem[_10640 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_10640')), 14)))
                                            revert
                                    else:
                                        mem[0] = 118
                                        mem[_5585 + 32] = address(stor118.field_0)
                                        idx = _5585 + 32
                                        t = 0
                                        while _5585 + (32 * stor118.length) > idx:
                                            mem[idx + 32] = stor118[t].field_256
                                            idx = idx + 32
                                            t = t + 1
                                            continue 
                                        idx = 0
                                        t = 2 * _5076
                                        while idx < stor118.length - 1:
                                            require idx < mem[_5585]
                                            require idx + 1 < mem[_5585]
                                            _20505 = mem[(32 * idx + 1) + _5585 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _5585 + 44 len 20]
                                            mem[mem[64] + 36] = address(_20505)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_20505)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _20884 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_20884] == mem[_20884 + 12 len 20]
                                            require ext_code.size(mem[_20884 + 12 len 20])
                                            staticcall mem[_20884 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22659 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_22659] == mem[_22659 + 18 len 14]
                                            require mem[_22659 + 32] == mem[_22659 + 50 len 14]
                                            require mem[_22659 + 64] == mem[_22659 + 92 len 4]
                                            require idx < mem[_5585]
                                            require idx + 1 < mem[_5585]
                                            if mem[(32 * idx + 1) + _5585 + 44 len 20] < mem[(32 * idx) + _5585 + 44 len 20]:
                                                if not t:
                                                    if mem[_22659 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22659 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22659 + 18 len 14] * t / t != mem[_22659 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22659 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22659 + 18 len 14] * t / mem[_22659 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_22659')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_22659 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22659 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22659 + 50 len 14] * t / t != mem[_22659 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22659 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22659 + 50 len 14] * t / mem[_22659 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_22659')), 14)))
                                            revert
                        else:
                            mem[0] = 119
                            mem[ceil32(return_data.size) + 128] = address(stor119.field_0)
                            if (32 * stor119.length) + 32 <= 64:
                                idx = 0
                                s = 0
                                while idx < stor119.length - 1:
                                    require idx < mem[ceil32(return_data.size) + 96]
                                    require idx + 1 < mem[ceil32(return_data.size) + 96]
                                    _4419 = mem[(32 * idx + 1) + ceil32(return_data.size) + 128]
                                    mem[mem[64] + 4] = mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]
                                    mem[mem[64] + 36] = address(_4419)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_4419)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4568 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_4568] == mem[_4568 + 12 len 20]
                                    require ext_code.size(mem[_4568 + 12 len 20])
                                    staticcall mem[_4568 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4972 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_4972] == mem[_4972 + 18 len 14]
                                    require mem[_4972 + 32] == mem[_4972 + 50 len 14]
                                    require mem[_4972 + 64] == mem[_4972 + 92 len 4]
                                    require idx < mem[ceil32(return_data.size) + 96]
                                    require idx + 1 < mem[ceil32(return_data.size) + 96]
                                    if mem[(32 * idx + 1) + ceil32(return_data.size) + 140 len 20] < mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]:
                                        if not s:
                                            if mem[_4972 + 50 len 14]:
                                                idx = idx + 1
                                                s = 0 / mem[_4972 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_4972 + 18 len 14] * s / s != mem[_4972 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_4972 + 50 len 14]:
                                                idx = idx + 1
                                                s = mem[_4972 + 18 len 14] * s / mem[_4972 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_4972')), 14)))
                                    else:
                                        if not s:
                                            if mem[_4972 + 18 len 14]:
                                                idx = idx + 1
                                                s = 0 / mem[_4972 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_4972 + 50 len 14] * s / s != mem[_4972 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_4972 + 18 len 14]:
                                                idx = idx + 1
                                                s = mem[_4972 + 50 len 14] * s / mem[_4972 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_4972')), 14)))
                                    revert
                                require stor118.length
                                mem[0] = 118
                                if address(stor118.field_0) == stakingTokenAddress:
                                    _4627 = mem[64]
                                    mem[64] = mem[64] + (32 * stor118.length) + 32
                                    mem[_4627] = stor118.length
                                    if not stor118.length:
                                        idx = 0
                                        t = totalSupply
                                        while idx < stor118.length - 1:
                                            require idx < mem[_4627]
                                            require idx + 1 < mem[_4627]
                                            _8995 = mem[(32 * idx + 1) + _4627 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _4627 + 44 len 20]
                                            mem[mem[64] + 36] = address(_8995)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_8995)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9332 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9332] == mem[_9332 + 12 len 20]
                                            require ext_code.size(mem[_9332 + 12 len 20])
                                            staticcall mem[_9332 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _10650 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_10650] == mem[_10650 + 18 len 14]
                                            require mem[_10650 + 32] == mem[_10650 + 50 len 14]
                                            require mem[_10650 + 64] == mem[_10650 + 92 len 4]
                                            require idx < mem[_4627]
                                            require idx + 1 < mem[_4627]
                                            if mem[(32 * idx + 1) + _4627 + 44 len 20] < mem[(32 * idx) + _4627 + 44 len 20]:
                                                if not t:
                                                    if mem[_10650 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10650 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10650 + 18 len 14] * t / t != mem[_10650 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10650 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10650 + 18 len 14] * t / mem[_10650 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_10650')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_10650 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10650 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10650 + 50 len 14] * t / t != mem[_10650 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10650 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10650 + 50 len 14] * t / mem[_10650 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_10650')), 14)))
                                            revert
                                    else:
                                        mem[0] = 118
                                        mem[_4627 + 32] = address(stor118.field_0)
                                        idx = _4627 + 32
                                        t = 0
                                        while _4627 + (32 * stor118.length) > idx:
                                            mem[idx + 32] = stor118[t].field_256
                                            idx = idx + 32
                                            t = t + 1
                                            continue 
                                        idx = 0
                                        t = totalSupply
                                        while idx < stor118.length - 1:
                                            require idx < mem[_4627]
                                            require idx + 1 < mem[_4627]
                                            _20515 = mem[(32 * idx + 1) + _4627 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _4627 + 44 len 20]
                                            mem[mem[64] + 36] = address(_20515)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_20515)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _20894 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_20894] == mem[_20894 + 12 len 20]
                                            require ext_code.size(mem[_20894 + 12 len 20])
                                            staticcall mem[_20894 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22674 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_22674] == mem[_22674 + 18 len 14]
                                            require mem[_22674 + 32] == mem[_22674 + 50 len 14]
                                            require mem[_22674 + 64] == mem[_22674 + 92 len 4]
                                            require idx < mem[_4627]
                                            require idx + 1 < mem[_4627]
                                            if mem[(32 * idx + 1) + _4627 + 44 len 20] < mem[(32 * idx) + _4627 + 44 len 20]:
                                                if not t:
                                                    if mem[_22674 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22674 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22674 + 18 len 14] * t / t != mem[_22674 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22674 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22674 + 18 len 14] * t / mem[_22674 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_22674')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_22674 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22674 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22674 + 50 len 14] * t / t != mem[_22674 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22674 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22674 + 50 len 14] * t / mem[_22674 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_22674')), 14)))
                                            revert
                                else:
                                    require stor118.length
                                    require stor118.length
                                    require address(stor118.field_0) != stakingTokenAddress
                                    require 0 < stor118.length
                                    mem[0] = 118
                                    mem[mem[64] + 4] = stakingTokenAddress
                                    require ext_code.size(address(stor118.field_0))
                                    staticcall address(stor118.field_0).0x70a08231 with:
                                            gas gas_remaining wei
                                           args stakingTokenAddress
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4971 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _5079 = mem[_4971]
                                    if not mem[_4971]:
                                        _5500 = mem[64]
                                        mem[64] = mem[64] + (32 * stor118.length) + 32
                                        mem[_5500] = stor118.length
                                        if not stor118.length:
                                            idx = 0
                                            t = 0
                                            while idx < stor118.length - 1:
                                                require idx < mem[_5500]
                                                require idx + 1 < mem[_5500]
                                                _8999 = mem[(32 * idx + 1) + _5500 + 32]
                                                mem[mem[64] + 4] = mem[(32 * idx) + _5500 + 44 len 20]
                                                mem[mem[64] + 36] = address(_8999)
                                                require ext_code.size(stor117)
                                                staticcall stor117.getPair(address rg1, address rg2) with:
                                                        gas gas_remaining wei
                                                       args mem[mem[64] + 4], address(_8999)
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _9336 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_9336] == mem[_9336 + 12 len 20]
                                                require ext_code.size(mem[_9336 + 12 len 20])
                                                staticcall mem[_9336 + 12 len 20].getReserves() with:
                                                        gas gas_remaining wei
                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _10656 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 96
                                                require mem[_10656] == mem[_10656 + 18 len 14]
                                                require mem[_10656 + 32] == mem[_10656 + 50 len 14]
                                                require mem[_10656 + 64] == mem[_10656 + 92 len 4]
                                                require idx < mem[_5500]
                                                require idx + 1 < mem[_5500]
                                                if mem[(32 * idx + 1) + _5500 + 44 len 20] < mem[(32 * idx) + _5500 + 44 len 20]:
                                                    if not t:
                                                        if mem[_10656 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_10656 + 50 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_10656 + 18 len 14] * t / t != mem[_10656 + 18 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_10656 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_10656 + 18 len 14] * t / mem[_10656 + 50 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_10656')), 14)))
                                                else:
                                                    if not t:
                                                        if mem[_10656 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_10656 + 18 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_10656 + 50 len 14] * t / t != mem[_10656 + 50 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_10656 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_10656 + 50 len 14] * t / mem[_10656 + 18 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_10656')), 14)))
                                                revert
                                        else:
                                            mem[0] = 118
                                            mem[_5500 + 32] = address(stor118.field_0)
                                            idx = _5500 + 32
                                            t = 0
                                            while _5500 + (32 * stor118.length) > idx:
                                                mem[idx + 32] = stor118[t].field_256
                                                idx = idx + 32
                                                t = t + 1
                                                continue 
                                            idx = 0
                                            t = 0
                                            while idx < stor118.length - 1:
                                                require idx < mem[_5500]
                                                require idx + 1 < mem[_5500]
                                                _20519 = mem[(32 * idx + 1) + _5500 + 32]
                                                mem[mem[64] + 4] = mem[(32 * idx) + _5500 + 44 len 20]
                                                mem[mem[64] + 36] = address(_20519)
                                                require ext_code.size(stor117)
                                                staticcall stor117.getPair(address rg1, address rg2) with:
                                                        gas gas_remaining wei
                                                       args mem[mem[64] + 4], address(_20519)
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _20898 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_20898] == mem[_20898 + 12 len 20]
                                                require ext_code.size(mem[_20898 + 12 len 20])
                                                staticcall mem[_20898 + 12 len 20].getReserves() with:
                                                        gas gas_remaining wei
                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _22680 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 96
                                                require mem[_22680] == mem[_22680 + 18 len 14]
                                                require mem[_22680 + 32] == mem[_22680 + 50 len 14]
                                                require mem[_22680 + 64] == mem[_22680 + 92 len 4]
                                                require idx < mem[_5500]
                                                require idx + 1 < mem[_5500]
                                                if mem[(32 * idx + 1) + _5500 + 44 len 20] < mem[(32 * idx) + _5500 + 44 len 20]:
                                                    if not t:
                                                        if mem[_22680 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_22680 + 50 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_22680 + 18 len 14] * t / t != mem[_22680 + 18 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_22680 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_22680 + 18 len 14] * t / mem[_22680 + 50 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_22680')), 14)))
                                                else:
                                                    if not t:
                                                        if mem[_22680 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_22680 + 18 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_22680 + 50 len 14] * t / t != mem[_22680 + 50 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_22680 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_22680 + 50 len 14] * t / mem[_22680 + 18 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_22680')), 14)))
                                                revert
                                    else:
                                        if 2 * mem[_4971] / mem[_4971] != 2:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _5590 = mem[64]
                                        mem[64] = mem[64] + (32 * stor118.length) + 32
                                        mem[_5590] = stor118.length
                                        if not stor118.length:
                                            idx = 0
                                            t = 2 * _5079
                                            while idx < stor118.length - 1:
                                                require idx < mem[_5590]
                                                require idx + 1 < mem[_5590]
                                                _8997 = mem[(32 * idx + 1) + _5590 + 32]
                                                mem[mem[64] + 4] = mem[(32 * idx) + _5590 + 44 len 20]
                                                mem[mem[64] + 36] = address(_8997)
                                                require ext_code.size(stor117)
                                                staticcall stor117.getPair(address rg1, address rg2) with:
                                                        gas gas_remaining wei
                                                       args mem[mem[64] + 4], address(_8997)
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _9334 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_9334] == mem[_9334 + 12 len 20]
                                                require ext_code.size(mem[_9334 + 12 len 20])
                                                staticcall mem[_9334 + 12 len 20].getReserves() with:
                                                        gas gas_remaining wei
                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _10653 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 96
                                                require mem[_10653] == mem[_10653 + 18 len 14]
                                                require mem[_10653 + 32] == mem[_10653 + 50 len 14]
                                                require mem[_10653 + 64] == mem[_10653 + 92 len 4]
                                                require idx < mem[_5590]
                                                require idx + 1 < mem[_5590]
                                                if mem[(32 * idx + 1) + _5590 + 44 len 20] < mem[(32 * idx) + _5590 + 44 len 20]:
                                                    if not t:
                                                        if mem[_10653 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_10653 + 50 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_10653 + 18 len 14] * t / t != mem[_10653 + 18 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_10653 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_10653 + 18 len 14] * t / mem[_10653 + 50 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_10653')), 14)))
                                                else:
                                                    if not t:
                                                        if mem[_10653 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_10653 + 18 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_10653 + 50 len 14] * t / t != mem[_10653 + 50 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_10653 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_10653 + 50 len 14] * t / mem[_10653 + 18 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_10653')), 14)))
                                                revert
                                        else:
                                            mem[0] = 118
                                            mem[_5590 + 32] = address(stor118.field_0)
                                            idx = _5590 + 32
                                            t = 0
                                            while _5590 + (32 * stor118.length) > idx:
                                                mem[idx + 32] = stor118[t].field_256
                                                idx = idx + 32
                                                t = t + 1
                                                continue 
                                            idx = 0
                                            t = 2 * _5079
                                            while idx < stor118.length - 1:
                                                require idx < mem[_5590]
                                                require idx + 1 < mem[_5590]
                                                _20517 = mem[(32 * idx + 1) + _5590 + 32]
                                                mem[mem[64] + 4] = mem[(32 * idx) + _5590 + 44 len 20]
                                                mem[mem[64] + 36] = address(_20517)
                                                require ext_code.size(stor117)
                                                staticcall stor117.getPair(address rg1, address rg2) with:
                                                        gas gas_remaining wei
                                                       args mem[mem[64] + 4], address(_20517)
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _20896 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_20896] == mem[_20896 + 12 len 20]
                                                require ext_code.size(mem[_20896 + 12 len 20])
                                                staticcall mem[_20896 + 12 len 20].getReserves() with:
                                                        gas gas_remaining wei
                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _22677 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 96
                                                require mem[_22677] == mem[_22677 + 18 len 14]
                                                require mem[_22677 + 32] == mem[_22677 + 50 len 14]
                                                require mem[_22677 + 64] == mem[_22677 + 92 len 4]
                                                require idx < mem[_5590]
                                                require idx + 1 < mem[_5590]
                                                if mem[(32 * idx + 1) + _5590 + 44 len 20] < mem[(32 * idx) + _5590 + 44 len 20]:
                                                    if not t:
                                                        if mem[_22677 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_22677 + 50 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_22677 + 18 len 14] * t / t != mem[_22677 + 18 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_22677 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_22677 + 18 len 14] * t / mem[_22677 + 50 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_22677')), 14)))
                                                else:
                                                    if not t:
                                                        if mem[_22677 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_22677 + 18 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_22677 + 50 len 14] * t / t != mem[_22677 + 50 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_22677 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_22677 + 50 len 14] * t / mem[_22677 + 18 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_22677')), 14)))
                                                revert
                            else:
                                mem[ceil32(return_data.size) + 160] = address(stor119.field_256)
                                idx = ceil32(return_data.size) + 160
                                s = 1
                                while ceil32(return_data.size) + (32 * stor119.length) + 96 > idx:
                                    mem[idx + 32] = stor119[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                idx = 0
                                s = 0
                                while idx < stor119.length - 1:
                                    require idx < mem[ceil32(return_data.size) + 96]
                                    require idx + 1 < mem[ceil32(return_data.size) + 96]
                                    _14434 = mem[(32 * idx + 1) + ceil32(return_data.size) + 128]
                                    mem[mem[64] + 4] = mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]
                                    mem[mem[64] + 36] = address(_14434)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_14434)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _15245 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_15245] == mem[_15245 + 12 len 20]
                                    require ext_code.size(mem[_15245 + 12 len 20])
                                    staticcall mem[_15245 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _16380 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_16380] == mem[_16380 + 18 len 14]
                                    require mem[_16380 + 32] == mem[_16380 + 50 len 14]
                                    require mem[_16380 + 64] == mem[_16380 + 92 len 4]
                                    require idx < mem[ceil32(return_data.size) + 96]
                                    require idx + 1 < mem[ceil32(return_data.size) + 96]
                                    if mem[(32 * idx + 1) + ceil32(return_data.size) + 140 len 20] < mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]:
                                        if not s:
                                            if mem[_16380 + 50 len 14]:
                                                idx = idx + 1
                                                s = 0 / mem[_16380 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_16380 + 18 len 14] * s / s != mem[_16380 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_16380 + 50 len 14]:
                                                idx = idx + 1
                                                s = mem[_16380 + 18 len 14] * s / mem[_16380 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_16380')), 14)))
                                    else:
                                        if not s:
                                            if mem[_16380 + 18 len 14]:
                                                idx = idx + 1
                                                s = 0 / mem[_16380 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_16380 + 50 len 14] * s / s != mem[_16380 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_16380 + 18 len 14]:
                                                idx = idx + 1
                                                s = mem[_16380 + 50 len 14] * s / mem[_16380 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_16380')), 14)))
                                    revert
                                require stor118.length
                                mem[0] = 118
                                if address(stor118.field_0) == stakingTokenAddress:
                                    _15367 = mem[64]
                                    mem[64] = mem[64] + (32 * stor118.length) + 32
                                    mem[_15367] = stor118.length
                                    if not stor118.length:
                                        idx = 0
                                        t = totalSupply
                                        while idx < stor118.length - 1:
                                            require idx < mem[_15367]
                                            require idx + 1 < mem[_15367]
                                            _20509 = mem[(32 * idx + 1) + _15367 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _15367 + 44 len 20]
                                            mem[mem[64] + 36] = address(_20509)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_20509)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _20888 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_20888] == mem[_20888 + 12 len 20]
                                            require ext_code.size(mem[_20888 + 12 len 20])
                                            staticcall mem[_20888 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22665 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_22665] == mem[_22665 + 18 len 14]
                                            require mem[_22665 + 32] == mem[_22665 + 50 len 14]
                                            require mem[_22665 + 64] == mem[_22665 + 92 len 4]
                                            require idx < mem[_15367]
                                            require idx + 1 < mem[_15367]
                                            if mem[(32 * idx + 1) + _15367 + 44 len 20] < mem[(32 * idx) + _15367 + 44 len 20]:
                                                if not t:
                                                    if mem[_22665 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22665 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22665 + 18 len 14] * t / t != mem[_22665 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22665 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22665 + 18 len 14] * t / mem[_22665 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_22665')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_22665 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22665 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22665 + 50 len 14] * t / t != mem[_22665 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22665 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22665 + 50 len 14] * t / mem[_22665 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_22665')), 14)))
                                            revert
                                        if s:
                                            if 10^18 * s / s != 10^18:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not t:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            return (10^18 * s / t)
                                        if t:
                                            return (0 / t)
                                        var55001 = 32
                                        revert with 0, 'SafeMath: division by zero', 0
                                    mem[0] = 118
                                    mem[_15367 + 32] = address(stor118.field_0)
                                    idx = _15367 + 32
                                    t = 0
                                    while _15367 + (32 * stor118.length) > idx:
                                        mem[idx + 32] = stor118[t].field_256
                                        idx = idx + 32
                                        t = t + 1
                                        continue 
                                    idx = 0
                                    t = totalSupply
                                    while idx < stor118.length - 1:
                                        require idx < mem[_15367]
                                        require idx + 1 < mem[_15367]
                                        _27687 = mem[(32 * idx + 1) + _15367 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _15367 + 44 len 20]
                                        mem[mem[64] + 36] = address(_27687)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_27687)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27814 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_27814] == mem[_27814 + 12 len 20]
                                        require ext_code.size(mem[_27814 + 12 len 20])
                                        staticcall mem[_27814 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _28406 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_28406] == mem[_28406 + 18 len 14]
                                        require mem[_28406 + 32] == mem[_28406 + 50 len 14]
                                        require mem[_28406 + 64] == mem[_28406 + 92 len 4]
                                        require idx < mem[_15367]
                                        require idx + 1 < mem[_15367]
                                        if mem[(32 * idx + 1) + _15367 + 44 len 20] < mem[(32 * idx) + _15367 + 44 len 20]:
                                            if not t:
                                                if mem[_28406 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_28406 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_28406 + 18 len 14] * t / t != mem[_28406 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_28406 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_28406 + 18 len 14] * t / mem[_28406 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_28406')), 14)))
                                        else:
                                            if not t:
                                                if mem[_28406 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_28406 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_28406 + 50 len 14] * t / t != mem[_28406 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_28406 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_28406 + 50 len 14] * t / mem[_28406 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_28406')), 14)))
                                        revert
                                else:
                                    require stor118.length
                                    require stor118.length
                                    require address(stor118.field_0) != stakingTokenAddress
                                    require 0 < stor118.length
                                    mem[0] = 118
                                    mem[mem[64] + 4] = stakingTokenAddress
                                    require ext_code.size(address(stor118.field_0))
                                    staticcall address(stor118.field_0).0x70a08231 with:
                                            gas gas_remaining wei
                                           args stakingTokenAddress
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _16379 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _16747 = mem[_16379]
                                    if not mem[_16379]:
                                        _17774 = mem[64]
                                        mem[64] = mem[64] + (32 * stor118.length) + 32
                                        mem[_17774] = stor118.length
                                        if not stor118.length:
                                            idx = 0
                                            t = 0
                                            while idx < stor118.length - 1:
                                                require idx < mem[_17774]
                                                require idx + 1 < mem[_17774]
                                                _20513 = mem[(32 * idx + 1) + _17774 + 32]
                                                mem[mem[64] + 4] = mem[(32 * idx) + _17774 + 44 len 20]
                                                mem[mem[64] + 36] = address(_20513)
                                                require ext_code.size(stor117)
                                                staticcall stor117.getPair(address rg1, address rg2) with:
                                                        gas gas_remaining wei
                                                       args mem[mem[64] + 4], address(_20513)
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _20892 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_20892] == mem[_20892 + 12 len 20]
                                                require ext_code.size(mem[_20892 + 12 len 20])
                                                staticcall mem[_20892 + 12 len 20].getReserves() with:
                                                        gas gas_remaining wei
                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _22671 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 96
                                                require mem[_22671] == mem[_22671 + 18 len 14]
                                                require mem[_22671 + 32] == mem[_22671 + 50 len 14]
                                                require mem[_22671 + 64] == mem[_22671 + 92 len 4]
                                                require idx < mem[_17774]
                                                require idx + 1 < mem[_17774]
                                                if mem[(32 * idx + 1) + _17774 + 44 len 20] < mem[(32 * idx) + _17774 + 44 len 20]:
                                                    if not t:
                                                        if mem[_22671 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_22671 + 50 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_22671 + 18 len 14] * t / t != mem[_22671 + 18 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_22671 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_22671 + 18 len 14] * t / mem[_22671 + 50 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_22671')), 14)))
                                                else:
                                                    if not t:
                                                        if mem[_22671 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_22671 + 18 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_22671 + 50 len 14] * t / t != mem[_22671 + 50 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_22671 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_22671 + 50 len 14] * t / mem[_22671 + 18 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_22671')), 14)))
                                                revert
                                            if not s:
                                                if not t:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                return (0 / t)
                                            if 10^18 * s / s != 10^18:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not t:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            return (10^18 * s / t)
                                        mem[0] = 118
                                        mem[_17774 + 32] = address(stor118.field_0)
                                        idx = _17774 + 32
                                        t = 0
                                        while _17774 + (32 * stor118.length) > idx:
                                            mem[idx + 32] = stor118[t].field_256
                                            idx = idx + 32
                                            t = t + 1
                                            continue 
                                        idx = 0
                                        t = 0
                                        while idx < stor118.length - 1:
                                            require idx < mem[_17774]
                                            require idx + 1 < mem[_17774]
                                            _27691 = mem[(32 * idx + 1) + _17774 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _17774 + 44 len 20]
                                            mem[mem[64] + 36] = address(_27691)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_27691)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27818 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_27818] == mem[_27818 + 12 len 20]
                                            require ext_code.size(mem[_27818 + 12 len 20])
                                            staticcall mem[_27818 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _28412 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_28412] == mem[_28412 + 18 len 14]
                                            require mem[_28412 + 32] == mem[_28412 + 50 len 14]
                                            require mem[_28412 + 64] == mem[_28412 + 92 len 4]
                                            require idx < mem[_17774]
                                            require idx + 1 < mem[_17774]
                                            if mem[(32 * idx + 1) + _17774 + 44 len 20] < mem[(32 * idx) + _17774 + 44 len 20]:
                                                if not t:
                                                    if mem[_28412 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_28412 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_28412 + 18 len 14] * t / t != mem[_28412 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_28412 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_28412 + 18 len 14] * t / mem[_28412 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_28412')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_28412 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_28412 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_28412 + 50 len 14] * t / t != mem[_28412 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_28412 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_28412 + 50 len 14] * t / mem[_28412 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_28412')), 14)))
                                            revert
                                        if s:
                                            if 10^18 * s / s != 10^18:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not t:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            return (10^18 * s / t)
                                        if t:
                                            return (0 / t)
                                        var74001 = 32
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if 2 * mem[_16379] / mem[_16379] != 2:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _17827 = mem[64]
                                    mem[64] = mem[64] + (32 * stor118.length) + 32
                                    mem[_17827] = stor118.length
                                    if not stor118.length:
                                        idx = 0
                                        t = 2 * _16747
                                        while idx < stor118.length - 1:
                                            require idx < mem[_17827]
                                            require idx + 1 < mem[_17827]
                                            _20511 = mem[(32 * idx + 1) + _17827 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _17827 + 44 len 20]
                                            mem[mem[64] + 36] = address(_20511)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_20511)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _20890 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_20890] == mem[_20890 + 12 len 20]
                                            require ext_code.size(mem[_20890 + 12 len 20])
                                            staticcall mem[_20890 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22668 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_22668] == mem[_22668 + 18 len 14]
                                            require mem[_22668 + 32] == mem[_22668 + 50 len 14]
                                            require mem[_22668 + 64] == mem[_22668 + 92 len 4]
                                            require idx < mem[_17827]
                                            require idx + 1 < mem[_17827]
                                            if mem[(32 * idx + 1) + _17827 + 44 len 20] < mem[(32 * idx) + _17827 + 44 len 20]:
                                                if not t:
                                                    if mem[_22668 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22668 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22668 + 18 len 14] * t / t != mem[_22668 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22668 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22668 + 18 len 14] * t / mem[_22668 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_22668')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_22668 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22668 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22668 + 50 len 14] * t / t != mem[_22668 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22668 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22668 + 50 len 14] * t / mem[_22668 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_22668')), 14)))
                                            revert
                                    else:
                                        mem[0] = 118
                                        mem[_17827 + 32] = address(stor118.field_0)
                                        idx = _17827 + 32
                                        t = 0
                                        while _17827 + (32 * stor118.length) > idx:
                                            mem[idx + 32] = stor118[t].field_256
                                            idx = idx + 32
                                            t = t + 1
                                            continue 
                                        idx = 0
                                        t = 2 * _16747
                                        while idx < stor118.length - 1:
                                            require idx < mem[_17827]
                                            require idx + 1 < mem[_17827]
                                            _27689 = mem[(32 * idx + 1) + _17827 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _17827 + 44 len 20]
                                            mem[mem[64] + 36] = address(_27689)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_27689)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27816 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_27816] == mem[_27816 + 12 len 20]
                                            require ext_code.size(mem[_27816 + 12 len 20])
                                            staticcall mem[_27816 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _28409 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_28409] == mem[_28409 + 18 len 14]
                                            require mem[_28409 + 32] == mem[_28409 + 50 len 14]
                                            require mem[_28409 + 64] == mem[_28409 + 92 len 4]
                                            require idx < mem[_17827]
                                            require idx + 1 < mem[_17827]
                                            if mem[(32 * idx + 1) + _17827 + 44 len 20] < mem[(32 * idx) + _17827 + 44 len 20]:
                                                if not t:
                                                    if mem[_28409 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_28409 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_28409 + 18 len 14] * t / t != mem[_28409 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_28409 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_28409 + 18 len 14] * t / mem[_28409 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_28409')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_28409 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_28409 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_28409 + 50 len 14] * t / t != mem[_28409 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_28409 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_28409 + 50 len 14] * t / mem[_28409 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_28409')), 14)))
                                            revert
                else:
                    mem[ceil32(return_data.size) + 96] = 30
                    mem[ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                    if lastUpdateTime > periodFinish:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if not ext_call.return_data[0] - stor42D0:
                        mem[ceil32(return_data.size) + 160] = 26
                        mem[ceil32(return_data.size) + 192] = 'SafeMath: division by zero'
                        if not periodFinish - lastUpdateTime:
                            revert with 0, 'SafeMath: division by zero', 0
                        require 0 < stor119.length
                        mem[0] = 119
                        require address(stor119.field_0) == rewardsTokenAddress
                        mem[64] = ceil32(return_data.size) + (32 * stor119.length) + 256
                        mem[ceil32(return_data.size) + 224] = stor119.length
                        if not stor119.length:
                            idx = 0
                            s = 0 / periodFinish - lastUpdateTime
                            while idx < stor119.length - 1:
                                require idx < mem[ceil32(return_data.size) + 224]
                                require idx + 1 < mem[ceil32(return_data.size) + 224]
                                _4425 = mem[(32 * idx + 1) + ceil32(return_data.size) + 256]
                                mem[mem[64] + 4] = mem[(32 * idx) + ceil32(return_data.size) + 268 len 20]
                                mem[mem[64] + 36] = address(_4425)
                                require ext_code.size(stor117)
                                staticcall stor117.getPair(address rg1, address rg2) with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4], address(_4425)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4571 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_4571] == mem[_4571 + 12 len 20]
                                require ext_code.size(mem[_4571 + 12 len 20])
                                staticcall mem[_4571 + 12 len 20].getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4984 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_4984] == mem[_4984 + 18 len 14]
                                require mem[_4984 + 32] == mem[_4984 + 50 len 14]
                                require mem[_4984 + 64] == mem[_4984 + 92 len 4]
                                require idx < mem[ceil32(return_data.size) + 224]
                                require idx + 1 < mem[ceil32(return_data.size) + 224]
                                if mem[(32 * idx + 1) + ceil32(return_data.size) + 268 len 20] < mem[(32 * idx) + ceil32(return_data.size) + 268 len 20]:
                                    if not s:
                                        if mem[_4984 + 50 len 14]:
                                            idx = idx + 1
                                            s = 0 / mem[_4984 + 50 len 14]
                                            continue 
                                    else:
                                        if mem[_4984 + 18 len 14] * s / s != mem[_4984 + 18 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_4984 + 50 len 14]:
                                            idx = idx + 1
                                            s = mem[_4984 + 18 len 14] * s / mem[_4984 + 50 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_4984')), 14)))
                                else:
                                    if not s:
                                        if mem[_4984 + 18 len 14]:
                                            idx = idx + 1
                                            s = 0 / mem[_4984 + 18 len 14]
                                            continue 
                                    else:
                                        if mem[_4984 + 50 len 14] * s / s != mem[_4984 + 50 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_4984 + 18 len 14]:
                                            idx = idx + 1
                                            s = mem[_4984 + 50 len 14] * s / mem[_4984 + 18 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_4984')), 14)))
                                revert
                            require stor118.length
                            mem[0] = 118
                            if address(stor118.field_0) == stakingTokenAddress:
                                _4633 = mem[64]
                                mem[64] = mem[64] + (32 * stor118.length) + 32
                                mem[_4633] = stor118.length
                                if not stor118.length:
                                    idx = 0
                                    t = totalSupply
                                    while idx < stor118.length - 1:
                                        require idx < mem[_4633]
                                        require idx + 1 < mem[_4633]
                                        _9014 = mem[(32 * idx + 1) + _4633 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _4633 + 44 len 20]
                                        mem[mem[64] + 36] = address(_9014)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_9014)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9351 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9351] == mem[_9351 + 12 len 20]
                                        require ext_code.size(mem[_9351 + 12 len 20])
                                        staticcall mem[_9351 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _10681 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_10681] == mem[_10681 + 18 len 14]
                                        require mem[_10681 + 32] == mem[_10681 + 50 len 14]
                                        require mem[_10681 + 64] == mem[_10681 + 92 len 4]
                                        require idx < mem[_4633]
                                        require idx + 1 < mem[_4633]
                                        if mem[(32 * idx + 1) + _4633 + 44 len 20] < mem[(32 * idx) + _4633 + 44 len 20]:
                                            if not t:
                                                if mem[_10681 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_10681 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_10681 + 18 len 14] * t / t != mem[_10681 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_10681 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_10681 + 18 len 14] * t / mem[_10681 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_10681')), 14)))
                                        else:
                                            if not t:
                                                if mem[_10681 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_10681 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_10681 + 50 len 14] * t / t != mem[_10681 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_10681 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_10681 + 50 len 14] * t / mem[_10681 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_10681')), 14)))
                                        revert
                                else:
                                    mem[0] = 118
                                    mem[_4633 + 32] = address(stor118.field_0)
                                    idx = _4633 + 32
                                    t = 0
                                    while _4633 + (32 * stor118.length) > idx:
                                        mem[idx + 32] = stor118[t].field_256
                                        idx = idx + 32
                                        t = t + 1
                                        continue 
                                    idx = 0
                                    t = totalSupply
                                    while idx < stor118.length - 1:
                                        require idx < mem[_4633]
                                        require idx + 1 < mem[_4633]
                                        _20539 = mem[(32 * idx + 1) + _4633 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _4633 + 44 len 20]
                                        mem[mem[64] + 36] = address(_20539)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_20539)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20918 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20918] == mem[_20918 + 12 len 20]
                                        require ext_code.size(mem[_20918 + 12 len 20])
                                        staticcall mem[_20918 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22710 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_22710] == mem[_22710 + 18 len 14]
                                        require mem[_22710 + 32] == mem[_22710 + 50 len 14]
                                        require mem[_22710 + 64] == mem[_22710 + 92 len 4]
                                        require idx < mem[_4633]
                                        require idx + 1 < mem[_4633]
                                        if mem[(32 * idx + 1) + _4633 + 44 len 20] < mem[(32 * idx) + _4633 + 44 len 20]:
                                            if not t:
                                                if mem[_22710 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22710 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_22710 + 18 len 14] * t / t != mem[_22710 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22710 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22710 + 18 len 14] * t / mem[_22710 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_22710')), 14)))
                                        else:
                                            if not t:
                                                if mem[_22710 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22710 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_22710 + 50 len 14] * t / t != mem[_22710 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22710 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22710 + 50 len 14] * t / mem[_22710 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_22710')), 14)))
                                        revert
                            else:
                                require stor118.length
                                require stor118.length
                                require address(stor118.field_0) != stakingTokenAddress
                                require 0 < stor118.length
                                mem[0] = 118
                                mem[mem[64] + 4] = stakingTokenAddress
                                require ext_code.size(address(stor118.field_0))
                                staticcall address(stor118.field_0).0x70a08231 with:
                                        gas gas_remaining wei
                                       args stakingTokenAddress
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4983 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _5088 = mem[_4983]
                                if not mem[_4983]:
                                    _5509 = mem[64]
                                    mem[64] = mem[64] + (32 * stor118.length) + 32
                                    mem[_5509] = stor118.length
                                    if not stor118.length:
                                        idx = 0
                                        t = 0
                                        while idx < stor118.length - 1:
                                            require idx < mem[_5509]
                                            require idx + 1 < mem[_5509]
                                            _9018 = mem[(32 * idx + 1) + _5509 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _5509 + 44 len 20]
                                            mem[mem[64] + 36] = address(_9018)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_9018)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9355 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9355] == mem[_9355 + 12 len 20]
                                            require ext_code.size(mem[_9355 + 12 len 20])
                                            staticcall mem[_9355 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _10687 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_10687] == mem[_10687 + 18 len 14]
                                            require mem[_10687 + 32] == mem[_10687 + 50 len 14]
                                            require mem[_10687 + 64] == mem[_10687 + 92 len 4]
                                            require idx < mem[_5509]
                                            require idx + 1 < mem[_5509]
                                            if mem[(32 * idx + 1) + _5509 + 44 len 20] < mem[(32 * idx) + _5509 + 44 len 20]:
                                                if not t:
                                                    if mem[_10687 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10687 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10687 + 18 len 14] * t / t != mem[_10687 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10687 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10687 + 18 len 14] * t / mem[_10687 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_10687')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_10687 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10687 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10687 + 50 len 14] * t / t != mem[_10687 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10687 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10687 + 50 len 14] * t / mem[_10687 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_10687')), 14)))
                                            revert
                                    else:
                                        mem[0] = 118
                                        mem[_5509 + 32] = address(stor118.field_0)
                                        idx = _5509 + 32
                                        t = 0
                                        while _5509 + (32 * stor118.length) > idx:
                                            mem[idx + 32] = stor118[t].field_256
                                            idx = idx + 32
                                            t = t + 1
                                            continue 
                                        idx = 0
                                        t = 0
                                        while idx < stor118.length - 1:
                                            require idx < mem[_5509]
                                            require idx + 1 < mem[_5509]
                                            _20543 = mem[(32 * idx + 1) + _5509 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _5509 + 44 len 20]
                                            mem[mem[64] + 36] = address(_20543)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_20543)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _20922 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_20922] == mem[_20922 + 12 len 20]
                                            require ext_code.size(mem[_20922 + 12 len 20])
                                            staticcall mem[_20922 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22716 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_22716] == mem[_22716 + 18 len 14]
                                            require mem[_22716 + 32] == mem[_22716 + 50 len 14]
                                            require mem[_22716 + 64] == mem[_22716 + 92 len 4]
                                            require idx < mem[_5509]
                                            require idx + 1 < mem[_5509]
                                            if mem[(32 * idx + 1) + _5509 + 44 len 20] < mem[(32 * idx) + _5509 + 44 len 20]:
                                                if not t:
                                                    if mem[_22716 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22716 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22716 + 18 len 14] * t / t != mem[_22716 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22716 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22716 + 18 len 14] * t / mem[_22716 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_22716')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_22716 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22716 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22716 + 50 len 14] * t / t != mem[_22716 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22716 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22716 + 50 len 14] * t / mem[_22716 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_22716')), 14)))
                                            revert
                                else:
                                    if 2 * mem[_4983] / mem[_4983] != 2:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _5605 = mem[64]
                                    mem[64] = mem[64] + (32 * stor118.length) + 32
                                    mem[_5605] = stor118.length
                                    if not stor118.length:
                                        idx = 0
                                        t = 2 * _5088
                                        while idx < stor118.length - 1:
                                            require idx < mem[_5605]
                                            require idx + 1 < mem[_5605]
                                            _9016 = mem[(32 * idx + 1) + _5605 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _5605 + 44 len 20]
                                            mem[mem[64] + 36] = address(_9016)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_9016)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9353 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9353] == mem[_9353 + 12 len 20]
                                            require ext_code.size(mem[_9353 + 12 len 20])
                                            staticcall mem[_9353 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _10684 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_10684] == mem[_10684 + 18 len 14]
                                            require mem[_10684 + 32] == mem[_10684 + 50 len 14]
                                            require mem[_10684 + 64] == mem[_10684 + 92 len 4]
                                            require idx < mem[_5605]
                                            require idx + 1 < mem[_5605]
                                            if mem[(32 * idx + 1) + _5605 + 44 len 20] < mem[(32 * idx) + _5605 + 44 len 20]:
                                                if not t:
                                                    if mem[_10684 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10684 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10684 + 18 len 14] * t / t != mem[_10684 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10684 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10684 + 18 len 14] * t / mem[_10684 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_10684')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_10684 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10684 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10684 + 50 len 14] * t / t != mem[_10684 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10684 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10684 + 50 len 14] * t / mem[_10684 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_10684')), 14)))
                                            revert
                                    else:
                                        mem[0] = 118
                                        mem[_5605 + 32] = address(stor118.field_0)
                                        idx = _5605 + 32
                                        t = 0
                                        while _5605 + (32 * stor118.length) > idx:
                                            mem[idx + 32] = stor118[t].field_256
                                            idx = idx + 32
                                            t = t + 1
                                            continue 
                                        idx = 0
                                        t = 2 * _5088
                                        while idx < stor118.length - 1:
                                            require idx < mem[_5605]
                                            require idx + 1 < mem[_5605]
                                            _20541 = mem[(32 * idx + 1) + _5605 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _5605 + 44 len 20]
                                            mem[mem[64] + 36] = address(_20541)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_20541)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _20920 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_20920] == mem[_20920 + 12 len 20]
                                            require ext_code.size(mem[_20920 + 12 len 20])
                                            staticcall mem[_20920 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22713 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_22713] == mem[_22713 + 18 len 14]
                                            require mem[_22713 + 32] == mem[_22713 + 50 len 14]
                                            require mem[_22713 + 64] == mem[_22713 + 92 len 4]
                                            require idx < mem[_5605]
                                            require idx + 1 < mem[_5605]
                                            if mem[(32 * idx + 1) + _5605 + 44 len 20] < mem[(32 * idx) + _5605 + 44 len 20]:
                                                if not t:
                                                    if mem[_22713 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22713 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22713 + 18 len 14] * t / t != mem[_22713 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22713 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22713 + 18 len 14] * t / mem[_22713 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_22713')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_22713 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22713 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22713 + 50 len 14] * t / t != mem[_22713 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22713 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22713 + 50 len 14] * t / mem[_22713 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_22713')), 14)))
                                            revert
                        else:
                            mem[0] = 119
                            mem[ceil32(return_data.size) + 256] = address(stor119.field_0)
                            if (32 * stor119.length) + 32 <= 64:
                                idx = 0
                                s = 0 / periodFinish - lastUpdateTime
                                while idx < stor119.length - 1:
                                    require idx < mem[ceil32(return_data.size) + 224]
                                    require idx + 1 < mem[ceil32(return_data.size) + 224]
                                    _4427 = mem[(32 * idx + 1) + ceil32(return_data.size) + 256]
                                    mem[mem[64] + 4] = mem[(32 * idx) + ceil32(return_data.size) + 268 len 20]
                                    mem[mem[64] + 36] = address(_4427)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_4427)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4572 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_4572] == mem[_4572 + 12 len 20]
                                    require ext_code.size(mem[_4572 + 12 len 20])
                                    staticcall mem[_4572 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4988 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_4988] == mem[_4988 + 18 len 14]
                                    require mem[_4988 + 32] == mem[_4988 + 50 len 14]
                                    require mem[_4988 + 64] == mem[_4988 + 92 len 4]
                                    require idx < mem[ceil32(return_data.size) + 224]
                                    require idx + 1 < mem[ceil32(return_data.size) + 224]
                                    if mem[(32 * idx + 1) + ceil32(return_data.size) + 268 len 20] < mem[(32 * idx) + ceil32(return_data.size) + 268 len 20]:
                                        if not s:
                                            if mem[_4988 + 50 len 14]:
                                                idx = idx + 1
                                                s = 0 / mem[_4988 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_4988 + 18 len 14] * s / s != mem[_4988 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_4988 + 50 len 14]:
                                                idx = idx + 1
                                                s = mem[_4988 + 18 len 14] * s / mem[_4988 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_4988')), 14)))
                                    else:
                                        if not s:
                                            if mem[_4988 + 18 len 14]:
                                                idx = idx + 1
                                                s = 0 / mem[_4988 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_4988 + 50 len 14] * s / s != mem[_4988 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_4988 + 18 len 14]:
                                                idx = idx + 1
                                                s = mem[_4988 + 50 len 14] * s / mem[_4988 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_4988')), 14)))
                                    revert
                                require stor118.length
                                mem[0] = 118
                                if address(stor118.field_0) == stakingTokenAddress:
                                    _4635 = mem[64]
                                    mem[64] = mem[64] + (32 * stor118.length) + 32
                                    mem[_4635] = stor118.length
                                    if not stor118.length:
                                        idx = 0
                                        t = totalSupply
                                        while idx < stor118.length - 1:
                                            require idx < mem[_4635]
                                            require idx + 1 < mem[_4635]
                                            _9021 = mem[(32 * idx + 1) + _4635 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _4635 + 44 len 20]
                                            mem[mem[64] + 36] = address(_9021)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_9021)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9358 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9358] == mem[_9358 + 12 len 20]
                                            require ext_code.size(mem[_9358 + 12 len 20])
                                            staticcall mem[_9358 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _10694 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_10694] == mem[_10694 + 18 len 14]
                                            require mem[_10694 + 32] == mem[_10694 + 50 len 14]
                                            require mem[_10694 + 64] == mem[_10694 + 92 len 4]
                                            require idx < mem[_4635]
                                            require idx + 1 < mem[_4635]
                                            if mem[(32 * idx + 1) + _4635 + 44 len 20] < mem[(32 * idx) + _4635 + 44 len 20]:
                                                if not t:
                                                    if mem[_10694 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10694 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10694 + 18 len 14] * t / t != mem[_10694 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10694 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10694 + 18 len 14] * t / mem[_10694 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_10694')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_10694 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10694 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10694 + 50 len 14] * t / t != mem[_10694 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10694 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10694 + 50 len 14] * t / mem[_10694 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_10694')), 14)))
                                            revert
                                    else:
                                        mem[0] = 118
                                        mem[_4635 + 32] = address(stor118.field_0)
                                        idx = _4635 + 32
                                        t = 0
                                        while _4635 + (32 * stor118.length) > idx:
                                            mem[idx + 32] = stor118[t].field_256
                                            idx = idx + 32
                                            t = t + 1
                                            continue 
                                        idx = 0
                                        t = totalSupply
                                        while idx < stor118.length - 1:
                                            require idx < mem[_4635]
                                            require idx + 1 < mem[_4635]
                                            _20551 = mem[(32 * idx + 1) + _4635 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _4635 + 44 len 20]
                                            mem[mem[64] + 36] = address(_20551)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_20551)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _20930 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_20930] == mem[_20930 + 12 len 20]
                                            require ext_code.size(mem[_20930 + 12 len 20])
                                            staticcall mem[_20930 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22728 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_22728] == mem[_22728 + 18 len 14]
                                            require mem[_22728 + 32] == mem[_22728 + 50 len 14]
                                            require mem[_22728 + 64] == mem[_22728 + 92 len 4]
                                            require idx < mem[_4635]
                                            require idx + 1 < mem[_4635]
                                            if mem[(32 * idx + 1) + _4635 + 44 len 20] < mem[(32 * idx) + _4635 + 44 len 20]:
                                                if not t:
                                                    if mem[_22728 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22728 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22728 + 18 len 14] * t / t != mem[_22728 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22728 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22728 + 18 len 14] * t / mem[_22728 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_22728')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_22728 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22728 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22728 + 50 len 14] * t / t != mem[_22728 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22728 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22728 + 50 len 14] * t / mem[_22728 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_22728')), 14)))
                                            revert
                                else:
                                    require stor118.length
                                    require stor118.length
                                    require address(stor118.field_0) != stakingTokenAddress
                                    require 0 < stor118.length
                                    mem[0] = 118
                                    mem[mem[64] + 4] = stakingTokenAddress
                                    require ext_code.size(address(stor118.field_0))
                                    staticcall address(stor118.field_0).0x70a08231 with:
                                            gas gas_remaining wei
                                           args stakingTokenAddress
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4987 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _5091 = mem[_4987]
                                    if not mem[_4987]:
                                        _5512 = mem[64]
                                        mem[64] = mem[64] + (32 * stor118.length) + 32
                                        mem[_5512] = stor118.length
                                        if not stor118.length:
                                            idx = 0
                                            t = 0
                                            while idx < stor118.length - 1:
                                                require idx < mem[_5512]
                                                require idx + 1 < mem[_5512]
                                                _9025 = mem[(32 * idx + 1) + _5512 + 32]
                                                mem[mem[64] + 4] = mem[(32 * idx) + _5512 + 44 len 20]
                                                mem[mem[64] + 36] = address(_9025)
                                                require ext_code.size(stor117)
                                                staticcall stor117.getPair(address rg1, address rg2) with:
                                                        gas gas_remaining wei
                                                       args mem[mem[64] + 4], address(_9025)
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _9362 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_9362] == mem[_9362 + 12 len 20]
                                                require ext_code.size(mem[_9362 + 12 len 20])
                                                staticcall mem[_9362 + 12 len 20].getReserves() with:
                                                        gas gas_remaining wei
                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _10700 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 96
                                                require mem[_10700] == mem[_10700 + 18 len 14]
                                                require mem[_10700 + 32] == mem[_10700 + 50 len 14]
                                                require mem[_10700 + 64] == mem[_10700 + 92 len 4]
                                                require idx < mem[_5512]
                                                require idx + 1 < mem[_5512]
                                                if mem[(32 * idx + 1) + _5512 + 44 len 20] < mem[(32 * idx) + _5512 + 44 len 20]:
                                                    if not t:
                                                        if mem[_10700 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_10700 + 50 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_10700 + 18 len 14] * t / t != mem[_10700 + 18 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_10700 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_10700 + 18 len 14] * t / mem[_10700 + 50 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_10700')), 14)))
                                                else:
                                                    if not t:
                                                        if mem[_10700 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_10700 + 18 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_10700 + 50 len 14] * t / t != mem[_10700 + 50 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_10700 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_10700 + 50 len 14] * t / mem[_10700 + 18 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_10700')), 14)))
                                                revert
                                        else:
                                            mem[0] = 118
                                            mem[_5512 + 32] = address(stor118.field_0)
                                            idx = _5512 + 32
                                            t = 0
                                            while _5512 + (32 * stor118.length) > idx:
                                                mem[idx + 32] = stor118[t].field_256
                                                idx = idx + 32
                                                t = t + 1
                                                continue 
                                            idx = 0
                                            t = 0
                                            while idx < stor118.length - 1:
                                                require idx < mem[_5512]
                                                require idx + 1 < mem[_5512]
                                                _20555 = mem[(32 * idx + 1) + _5512 + 32]
                                                mem[mem[64] + 4] = mem[(32 * idx) + _5512 + 44 len 20]
                                                mem[mem[64] + 36] = address(_20555)
                                                require ext_code.size(stor117)
                                                staticcall stor117.getPair(address rg1, address rg2) with:
                                                        gas gas_remaining wei
                                                       args mem[mem[64] + 4], address(_20555)
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _20934 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_20934] == mem[_20934 + 12 len 20]
                                                require ext_code.size(mem[_20934 + 12 len 20])
                                                staticcall mem[_20934 + 12 len 20].getReserves() with:
                                                        gas gas_remaining wei
                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _22734 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 96
                                                require mem[_22734] == mem[_22734 + 18 len 14]
                                                require mem[_22734 + 32] == mem[_22734 + 50 len 14]
                                                require mem[_22734 + 64] == mem[_22734 + 92 len 4]
                                                require idx < mem[_5512]
                                                require idx + 1 < mem[_5512]
                                                if mem[(32 * idx + 1) + _5512 + 44 len 20] < mem[(32 * idx) + _5512 + 44 len 20]:
                                                    if not t:
                                                        if mem[_22734 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_22734 + 50 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_22734 + 18 len 14] * t / t != mem[_22734 + 18 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_22734 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_22734 + 18 len 14] * t / mem[_22734 + 50 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_22734')), 14)))
                                                else:
                                                    if not t:
                                                        if mem[_22734 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_22734 + 18 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_22734 + 50 len 14] * t / t != mem[_22734 + 50 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_22734 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_22734 + 50 len 14] * t / mem[_22734 + 18 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_22734')), 14)))
                                                revert
                                    else:
                                        if 2 * mem[_4987] / mem[_4987] != 2:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _5610 = mem[64]
                                        mem[64] = mem[64] + (32 * stor118.length) + 32
                                        mem[_5610] = stor118.length
                                        if not stor118.length:
                                            idx = 0
                                            t = 2 * _5091
                                            while idx < stor118.length - 1:
                                                require idx < mem[_5610]
                                                require idx + 1 < mem[_5610]
                                                _9023 = mem[(32 * idx + 1) + _5610 + 32]
                                                mem[mem[64] + 4] = mem[(32 * idx) + _5610 + 44 len 20]
                                                mem[mem[64] + 36] = address(_9023)
                                                require ext_code.size(stor117)
                                                staticcall stor117.getPair(address rg1, address rg2) with:
                                                        gas gas_remaining wei
                                                       args mem[mem[64] + 4], address(_9023)
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _9360 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_9360] == mem[_9360 + 12 len 20]
                                                require ext_code.size(mem[_9360 + 12 len 20])
                                                staticcall mem[_9360 + 12 len 20].getReserves() with:
                                                        gas gas_remaining wei
                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _10697 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 96
                                                require mem[_10697] == mem[_10697 + 18 len 14]
                                                require mem[_10697 + 32] == mem[_10697 + 50 len 14]
                                                require mem[_10697 + 64] == mem[_10697 + 92 len 4]
                                                require idx < mem[_5610]
                                                require idx + 1 < mem[_5610]
                                                if mem[(32 * idx + 1) + _5610 + 44 len 20] < mem[(32 * idx) + _5610 + 44 len 20]:
                                                    if not t:
                                                        if mem[_10697 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_10697 + 50 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_10697 + 18 len 14] * t / t != mem[_10697 + 18 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_10697 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_10697 + 18 len 14] * t / mem[_10697 + 50 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_10697')), 14)))
                                                else:
                                                    if not t:
                                                        if mem[_10697 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_10697 + 18 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_10697 + 50 len 14] * t / t != mem[_10697 + 50 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_10697 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_10697 + 50 len 14] * t / mem[_10697 + 18 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_10697')), 14)))
                                                revert
                                        else:
                                            mem[0] = 118
                                            mem[_5610 + 32] = address(stor118.field_0)
                                            idx = _5610 + 32
                                            t = 0
                                            while _5610 + (32 * stor118.length) > idx:
                                                mem[idx + 32] = stor118[t].field_256
                                                idx = idx + 32
                                                t = t + 1
                                                continue 
                                            idx = 0
                                            t = 2 * _5091
                                            while idx < stor118.length - 1:
                                                require idx < mem[_5610]
                                                require idx + 1 < mem[_5610]
                                                _20553 = mem[(32 * idx + 1) + _5610 + 32]
                                                mem[mem[64] + 4] = mem[(32 * idx) + _5610 + 44 len 20]
                                                mem[mem[64] + 36] = address(_20553)
                                                require ext_code.size(stor117)
                                                staticcall stor117.getPair(address rg1, address rg2) with:
                                                        gas gas_remaining wei
                                                       args mem[mem[64] + 4], address(_20553)
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _20932 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_20932] == mem[_20932 + 12 len 20]
                                                require ext_code.size(mem[_20932 + 12 len 20])
                                                staticcall mem[_20932 + 12 len 20].getReserves() with:
                                                        gas gas_remaining wei
                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _22731 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 96
                                                require mem[_22731] == mem[_22731 + 18 len 14]
                                                require mem[_22731 + 32] == mem[_22731 + 50 len 14]
                                                require mem[_22731 + 64] == mem[_22731 + 92 len 4]
                                                require idx < mem[_5610]
                                                require idx + 1 < mem[_5610]
                                                if mem[(32 * idx + 1) + _5610 + 44 len 20] < mem[(32 * idx) + _5610 + 44 len 20]:
                                                    if not t:
                                                        if mem[_22731 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_22731 + 50 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_22731 + 18 len 14] * t / t != mem[_22731 + 18 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_22731 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_22731 + 18 len 14] * t / mem[_22731 + 50 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_22731')), 14)))
                                                else:
                                                    if not t:
                                                        if mem[_22731 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_22731 + 18 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_22731 + 50 len 14] * t / t != mem[_22731 + 50 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_22731 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_22731 + 50 len 14] * t / mem[_22731 + 18 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_22731')), 14)))
                                                revert
                            else:
                                mem[ceil32(return_data.size) + 288] = address(stor119.field_256)
                                idx = ceil32(return_data.size) + 288
                                s = 1
                                while ceil32(return_data.size) + (32 * stor119.length) + 224 > idx:
                                    mem[idx + 32] = stor119[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                idx = 0
                                s = 0 / periodFinish - lastUpdateTime
                                while idx < stor119.length - 1:
                                    require idx < mem[ceil32(return_data.size) + 224]
                                    require idx + 1 < mem[ceil32(return_data.size) + 224]
                                    _14450 = mem[(32 * idx + 1) + ceil32(return_data.size) + 256]
                                    mem[mem[64] + 4] = mem[(32 * idx) + ceil32(return_data.size) + 268 len 20]
                                    mem[mem[64] + 36] = address(_14450)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_14450)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _15259 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_15259] == mem[_15259 + 12 len 20]
                                    require ext_code.size(mem[_15259 + 12 len 20])
                                    staticcall mem[_15259 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _16412 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_16412] == mem[_16412 + 18 len 14]
                                    require mem[_16412 + 32] == mem[_16412 + 50 len 14]
                                    require mem[_16412 + 64] == mem[_16412 + 92 len 4]
                                    require idx < mem[ceil32(return_data.size) + 224]
                                    require idx + 1 < mem[ceil32(return_data.size) + 224]
                                    if mem[(32 * idx + 1) + ceil32(return_data.size) + 268 len 20] < mem[(32 * idx) + ceil32(return_data.size) + 268 len 20]:
                                        if not s:
                                            if mem[_16412 + 50 len 14]:
                                                idx = idx + 1
                                                s = 0 / mem[_16412 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_16412 + 18 len 14] * s / s != mem[_16412 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_16412 + 50 len 14]:
                                                idx = idx + 1
                                                s = mem[_16412 + 18 len 14] * s / mem[_16412 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_16412')), 14)))
                                    else:
                                        if not s:
                                            if mem[_16412 + 18 len 14]:
                                                idx = idx + 1
                                                s = 0 / mem[_16412 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_16412 + 50 len 14] * s / s != mem[_16412 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_16412 + 18 len 14]:
                                                idx = idx + 1
                                                s = mem[_16412 + 50 len 14] * s / mem[_16412 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_16412')), 14)))
                                    revert
                                require stor118.length
                                mem[0] = 118
                                if address(stor118.field_0) == stakingTokenAddress:
                                    _15395 = mem[64]
                                    mem[64] = mem[64] + (32 * stor118.length) + 32
                                    mem[_15395] = stor118.length
                                    if not stor118.length:
                                        idx = 0
                                        t = totalSupply
                                        while idx < stor118.length - 1:
                                            require idx < mem[_15395]
                                            require idx + 1 < mem[_15395]
                                            _20545 = mem[(32 * idx + 1) + _15395 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _15395 + 44 len 20]
                                            mem[mem[64] + 36] = address(_20545)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_20545)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _20924 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_20924] == mem[_20924 + 12 len 20]
                                            require ext_code.size(mem[_20924 + 12 len 20])
                                            staticcall mem[_20924 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22719 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_22719] == mem[_22719 + 18 len 14]
                                            require mem[_22719 + 32] == mem[_22719 + 50 len 14]
                                            require mem[_22719 + 64] == mem[_22719 + 92 len 4]
                                            require idx < mem[_15395]
                                            require idx + 1 < mem[_15395]
                                            if mem[(32 * idx + 1) + _15395 + 44 len 20] < mem[(32 * idx) + _15395 + 44 len 20]:
                                                if not t:
                                                    if mem[_22719 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22719 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22719 + 18 len 14] * t / t != mem[_22719 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22719 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22719 + 18 len 14] * t / mem[_22719 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_22719')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_22719 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22719 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22719 + 50 len 14] * t / t != mem[_22719 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22719 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22719 + 50 len 14] * t / mem[_22719 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_22719')), 14)))
                                            revert
                                        if s:
                                            if 10^18 * s / s != 10^18:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not t:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            return (10^18 * s / t)
                                        if t:
                                            return (0 / t)
                                        var69001 = 32
                                        revert with 0, 'SafeMath: division by zero', 0
                                    mem[0] = 118
                                    mem[_15395 + 32] = address(stor118.field_0)
                                    idx = _15395 + 32
                                    t = 0
                                    while _15395 + (32 * stor118.length) > idx:
                                        mem[idx + 32] = stor118[t].field_256
                                        idx = idx + 32
                                        t = t + 1
                                        continue 
                                    idx = 0
                                    t = totalSupply
                                    while idx < stor118.length - 1:
                                        require idx < mem[_15395]
                                        require idx + 1 < mem[_15395]
                                        _27699 = mem[(32 * idx + 1) + _15395 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _15395 + 44 len 20]
                                        mem[mem[64] + 36] = address(_27699)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_27699)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27826 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_27826] == mem[_27826 + 12 len 20]
                                        require ext_code.size(mem[_27826 + 12 len 20])
                                        staticcall mem[_27826 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _28424 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_28424] == mem[_28424 + 18 len 14]
                                        require mem[_28424 + 32] == mem[_28424 + 50 len 14]
                                        require mem[_28424 + 64] == mem[_28424 + 92 len 4]
                                        require idx < mem[_15395]
                                        require idx + 1 < mem[_15395]
                                        if mem[(32 * idx + 1) + _15395 + 44 len 20] < mem[(32 * idx) + _15395 + 44 len 20]:
                                            if not t:
                                                if mem[_28424 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_28424 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_28424 + 18 len 14] * t / t != mem[_28424 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_28424 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_28424 + 18 len 14] * t / mem[_28424 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_28424')), 14)))
                                        else:
                                            if not t:
                                                if mem[_28424 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_28424 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_28424 + 50 len 14] * t / t != mem[_28424 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_28424 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_28424 + 50 len 14] * t / mem[_28424 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_28424')), 14)))
                                        revert
                                else:
                                    require stor118.length
                                    require stor118.length
                                    require address(stor118.field_0) != stakingTokenAddress
                                    require 0 < stor118.length
                                    mem[0] = 118
                                    mem[mem[64] + 4] = stakingTokenAddress
                                    require ext_code.size(address(stor118.field_0))
                                    staticcall address(stor118.field_0).0x70a08231 with:
                                            gas gas_remaining wei
                                           args stakingTokenAddress
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _16411 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _16785 = mem[_16411]
                                    if not mem[_16411]:
                                        _17780 = mem[64]
                                        mem[64] = mem[64] + (32 * stor118.length) + 32
                                        mem[_17780] = stor118.length
                                        if not stor118.length:
                                            idx = 0
                                            t = 0
                                            while idx < stor118.length - 1:
                                                require idx < mem[_17780]
                                                require idx + 1 < mem[_17780]
                                                _20549 = mem[(32 * idx + 1) + _17780 + 32]
                                                mem[mem[64] + 4] = mem[(32 * idx) + _17780 + 44 len 20]
                                                mem[mem[64] + 36] = address(_20549)
                                                require ext_code.size(stor117)
                                                staticcall stor117.getPair(address rg1, address rg2) with:
                                                        gas gas_remaining wei
                                                       args mem[mem[64] + 4], address(_20549)
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _20928 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_20928] == mem[_20928 + 12 len 20]
                                                require ext_code.size(mem[_20928 + 12 len 20])
                                                staticcall mem[_20928 + 12 len 20].getReserves() with:
                                                        gas gas_remaining wei
                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _22725 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 96
                                                require mem[_22725] == mem[_22725 + 18 len 14]
                                                require mem[_22725 + 32] == mem[_22725 + 50 len 14]
                                                require mem[_22725 + 64] == mem[_22725 + 92 len 4]
                                                require idx < mem[_17780]
                                                require idx + 1 < mem[_17780]
                                                if mem[(32 * idx + 1) + _17780 + 44 len 20] < mem[(32 * idx) + _17780 + 44 len 20]:
                                                    if not t:
                                                        if mem[_22725 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_22725 + 50 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_22725 + 18 len 14] * t / t != mem[_22725 + 18 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_22725 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_22725 + 18 len 14] * t / mem[_22725 + 50 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_22725')), 14)))
                                                else:
                                                    if not t:
                                                        if mem[_22725 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_22725 + 18 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_22725 + 50 len 14] * t / t != mem[_22725 + 50 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_22725 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_22725 + 50 len 14] * t / mem[_22725 + 18 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_22725')), 14)))
                                                revert
                                            if not s:
                                                if not t:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                return (0 / t)
                                            if 10^18 * s / s != 10^18:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not t:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            return (10^18 * s / t)
                                        mem[0] = 118
                                        mem[_17780 + 32] = address(stor118.field_0)
                                        idx = _17780 + 32
                                        t = 0
                                        while _17780 + (32 * stor118.length) > idx:
                                            mem[idx + 32] = stor118[t].field_256
                                            idx = idx + 32
                                            t = t + 1
                                            continue 
                                        idx = 0
                                        t = 0
                                        while idx < stor118.length - 1:
                                            require idx < mem[_17780]
                                            require idx + 1 < mem[_17780]
                                            _27703 = mem[(32 * idx + 1) + _17780 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _17780 + 44 len 20]
                                            mem[mem[64] + 36] = address(_27703)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_27703)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27830 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_27830] == mem[_27830 + 12 len 20]
                                            require ext_code.size(mem[_27830 + 12 len 20])
                                            staticcall mem[_27830 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _28430 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_28430] == mem[_28430 + 18 len 14]
                                            require mem[_28430 + 32] == mem[_28430 + 50 len 14]
                                            require mem[_28430 + 64] == mem[_28430 + 92 len 4]
                                            require idx < mem[_17780]
                                            require idx + 1 < mem[_17780]
                                            if mem[(32 * idx + 1) + _17780 + 44 len 20] < mem[(32 * idx) + _17780 + 44 len 20]:
                                                if not t:
                                                    if mem[_28430 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_28430 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_28430 + 18 len 14] * t / t != mem[_28430 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_28430 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_28430 + 18 len 14] * t / mem[_28430 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_28430')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_28430 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_28430 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_28430 + 50 len 14] * t / t != mem[_28430 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_28430 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_28430 + 50 len 14] * t / mem[_28430 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_28430')), 14)))
                                            revert
                                        if s:
                                            if 10^18 * s / s != 10^18:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not t:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            return (10^18 * s / t)
                                        if t:
                                            return (0 / t)
                                        var88001 = 32
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if 2 * mem[_16411] / mem[_16411] != 2:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _17849 = mem[64]
                                    mem[64] = mem[64] + (32 * stor118.length) + 32
                                    mem[_17849] = stor118.length
                                    if not stor118.length:
                                        idx = 0
                                        t = 2 * _16785
                                        while idx < stor118.length - 1:
                                            require idx < mem[_17849]
                                            require idx + 1 < mem[_17849]
                                            _20547 = mem[(32 * idx + 1) + _17849 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _17849 + 44 len 20]
                                            mem[mem[64] + 36] = address(_20547)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_20547)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _20926 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_20926] == mem[_20926 + 12 len 20]
                                            require ext_code.size(mem[_20926 + 12 len 20])
                                            staticcall mem[_20926 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22722 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_22722] == mem[_22722 + 18 len 14]
                                            require mem[_22722 + 32] == mem[_22722 + 50 len 14]
                                            require mem[_22722 + 64] == mem[_22722 + 92 len 4]
                                            require idx < mem[_17849]
                                            require idx + 1 < mem[_17849]
                                            if mem[(32 * idx + 1) + _17849 + 44 len 20] < mem[(32 * idx) + _17849 + 44 len 20]:
                                                if not t:
                                                    if mem[_22722 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22722 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22722 + 18 len 14] * t / t != mem[_22722 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22722 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22722 + 18 len 14] * t / mem[_22722 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_22722')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_22722 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22722 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22722 + 50 len 14] * t / t != mem[_22722 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22722 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22722 + 50 len 14] * t / mem[_22722 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_22722')), 14)))
                                            revert
                                    else:
                                        mem[0] = 118
                                        mem[_17849 + 32] = address(stor118.field_0)
                                        idx = _17849 + 32
                                        t = 0
                                        while _17849 + (32 * stor118.length) > idx:
                                            mem[idx + 32] = stor118[t].field_256
                                            idx = idx + 32
                                            t = t + 1
                                            continue 
                                        idx = 0
                                        t = 2 * _16785
                                        while idx < stor118.length - 1:
                                            require idx < mem[_17849]
                                            require idx + 1 < mem[_17849]
                                            _27701 = mem[(32 * idx + 1) + _17849 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _17849 + 44 len 20]
                                            mem[mem[64] + 36] = address(_27701)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_27701)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27828 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_27828] == mem[_27828 + 12 len 20]
                                            require ext_code.size(mem[_27828 + 12 len 20])
                                            staticcall mem[_27828 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _28427 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_28427] == mem[_28427 + 18 len 14]
                                            require mem[_28427 + 32] == mem[_28427 + 50 len 14]
                                            require mem[_28427 + 64] == mem[_28427 + 92 len 4]
                                            require idx < mem[_17849]
                                            require idx + 1 < mem[_17849]
                                            if mem[(32 * idx + 1) + _17849 + 44 len 20] < mem[(32 * idx) + _17849 + 44 len 20]:
                                                if not t:
                                                    if mem[_28427 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_28427 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_28427 + 18 len 14] * t / t != mem[_28427 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_28427 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_28427 + 18 len 14] * t / mem[_28427 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_28427')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_28427 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_28427 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_28427 + 50 len 14] * t / t != mem[_28427 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_28427 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_28427 + 50 len 14] * t / mem[_28427 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_28427')), 14)))
                                            revert
                    else:
                        if (8760 * 24 * 3600 * ext_call.return_data[0]) - (8760 * 24 * 3600 * stor42D0) / ext_call.return_data[0] - stor42D0 != 8760 * 24 * 3600:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[ceil32(return_data.size) + 160] = 26
                        mem[ceil32(return_data.size) + 192] = 'SafeMath: division by zero'
                        if not periodFinish - lastUpdateTime:
                            revert with 0, 'SafeMath: division by zero', 0
                        require 0 < stor119.length
                        mem[0] = 119
                        require address(stor119.field_0) == rewardsTokenAddress
                        mem[64] = ceil32(return_data.size) + (32 * stor119.length) + 256
                        mem[ceil32(return_data.size) + 224] = stor119.length
                        if not stor119.length:
                            idx = 0
                            s = (8760 * 24 * 3600 * ext_call.return_data[0]) - (8760 * 24 * 3600 * stor42D0) / periodFinish - lastUpdateTime
                            while idx < stor119.length - 1:
                                require idx < mem[ceil32(return_data.size) + 224]
                                require idx + 1 < mem[ceil32(return_data.size) + 224]
                                _4421 = mem[(32 * idx + 1) + ceil32(return_data.size) + 256]
                                mem[mem[64] + 4] = mem[(32 * idx) + ceil32(return_data.size) + 268 len 20]
                                mem[mem[64] + 36] = address(_4421)
                                require ext_code.size(stor117)
                                staticcall stor117.getPair(address rg1, address rg2) with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4], address(_4421)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4569 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_4569] == mem[_4569 + 12 len 20]
                                require ext_code.size(mem[_4569 + 12 len 20])
                                staticcall mem[_4569 + 12 len 20].getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4976 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_4976] == mem[_4976 + 18 len 14]
                                require mem[_4976 + 32] == mem[_4976 + 50 len 14]
                                require mem[_4976 + 64] == mem[_4976 + 92 len 4]
                                require idx < mem[ceil32(return_data.size) + 224]
                                require idx + 1 < mem[ceil32(return_data.size) + 224]
                                if mem[(32 * idx + 1) + ceil32(return_data.size) + 268 len 20] < mem[(32 * idx) + ceil32(return_data.size) + 268 len 20]:
                                    if not s:
                                        if mem[_4976 + 50 len 14]:
                                            idx = idx + 1
                                            s = 0 / mem[_4976 + 50 len 14]
                                            continue 
                                    else:
                                        if mem[_4976 + 18 len 14] * s / s != mem[_4976 + 18 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_4976 + 50 len 14]:
                                            idx = idx + 1
                                            s = mem[_4976 + 18 len 14] * s / mem[_4976 + 50 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_4976')), 14)))
                                else:
                                    if not s:
                                        if mem[_4976 + 18 len 14]:
                                            idx = idx + 1
                                            s = 0 / mem[_4976 + 18 len 14]
                                            continue 
                                    else:
                                        if mem[_4976 + 50 len 14] * s / s != mem[_4976 + 50 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_4976 + 18 len 14]:
                                            idx = idx + 1
                                            s = mem[_4976 + 50 len 14] * s / mem[_4976 + 18 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_4976')), 14)))
                                revert
                            require stor118.length
                            mem[0] = 118
                            if address(stor118.field_0) == stakingTokenAddress:
                                _4629 = mem[64]
                                mem[64] = mem[64] + (32 * stor118.length) + 32
                                mem[_4629] = stor118.length
                                if not stor118.length:
                                    idx = 0
                                    t = totalSupply
                                    while idx < stor118.length - 1:
                                        require idx < mem[_4629]
                                        require idx + 1 < mem[_4629]
                                        _9001 = mem[(32 * idx + 1) + _4629 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _4629 + 44 len 20]
                                        mem[mem[64] + 36] = address(_9001)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_9001)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9338 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9338] == mem[_9338 + 12 len 20]
                                        require ext_code.size(mem[_9338 + 12 len 20])
                                        staticcall mem[_9338 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _10659 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_10659] == mem[_10659 + 18 len 14]
                                        require mem[_10659 + 32] == mem[_10659 + 50 len 14]
                                        require mem[_10659 + 64] == mem[_10659 + 92 len 4]
                                        require idx < mem[_4629]
                                        require idx + 1 < mem[_4629]
                                        if mem[(32 * idx + 1) + _4629 + 44 len 20] < mem[(32 * idx) + _4629 + 44 len 20]:
                                            if not t:
                                                if mem[_10659 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_10659 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_10659 + 18 len 14] * t / t != mem[_10659 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_10659 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_10659 + 18 len 14] * t / mem[_10659 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_10659')), 14)))
                                        else:
                                            if not t:
                                                if mem[_10659 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_10659 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_10659 + 50 len 14] * t / t != mem[_10659 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_10659 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_10659 + 50 len 14] * t / mem[_10659 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_10659')), 14)))
                                        revert
                                else:
                                    mem[0] = 118
                                    mem[_4629 + 32] = address(stor118.field_0)
                                    idx = _4629 + 32
                                    t = 0
                                    while _4629 + (32 * stor118.length) > idx:
                                        mem[idx + 32] = stor118[t].field_256
                                        idx = idx + 32
                                        t = t + 1
                                        continue 
                                    idx = 0
                                    t = totalSupply
                                    while idx < stor118.length - 1:
                                        require idx < mem[_4629]
                                        require idx + 1 < mem[_4629]
                                        _20521 = mem[(32 * idx + 1) + _4629 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _4629 + 44 len 20]
                                        mem[mem[64] + 36] = address(_20521)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_20521)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20900 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20900] == mem[_20900 + 12 len 20]
                                        require ext_code.size(mem[_20900 + 12 len 20])
                                        staticcall mem[_20900 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22683 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_22683] == mem[_22683 + 18 len 14]
                                        require mem[_22683 + 32] == mem[_22683 + 50 len 14]
                                        require mem[_22683 + 64] == mem[_22683 + 92 len 4]
                                        require idx < mem[_4629]
                                        require idx + 1 < mem[_4629]
                                        if mem[(32 * idx + 1) + _4629 + 44 len 20] < mem[(32 * idx) + _4629 + 44 len 20]:
                                            if not t:
                                                if mem[_22683 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22683 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_22683 + 18 len 14] * t / t != mem[_22683 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22683 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22683 + 18 len 14] * t / mem[_22683 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_22683')), 14)))
                                        else:
                                            if not t:
                                                if mem[_22683 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22683 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_22683 + 50 len 14] * t / t != mem[_22683 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22683 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22683 + 50 len 14] * t / mem[_22683 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_22683')), 14)))
                                        revert
                            else:
                                require stor118.length
                                require stor118.length
                                require address(stor118.field_0) != stakingTokenAddress
                                require 0 < stor118.length
                                mem[0] = 118
                                mem[mem[64] + 4] = stakingTokenAddress
                                require ext_code.size(address(stor118.field_0))
                                staticcall address(stor118.field_0).0x70a08231 with:
                                        gas gas_remaining wei
                                       args stakingTokenAddress
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4975 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _5082 = mem[_4975]
                                if not mem[_4975]:
                                    _5503 = mem[64]
                                    mem[64] = mem[64] + (32 * stor118.length) + 32
                                    mem[_5503] = stor118.length
                                    if not stor118.length:
                                        idx = 0
                                        t = 0
                                        while idx < stor118.length - 1:
                                            require idx < mem[_5503]
                                            require idx + 1 < mem[_5503]
                                            _9005 = mem[(32 * idx + 1) + _5503 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _5503 + 44 len 20]
                                            mem[mem[64] + 36] = address(_9005)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_9005)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9342 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9342] == mem[_9342 + 12 len 20]
                                            require ext_code.size(mem[_9342 + 12 len 20])
                                            staticcall mem[_9342 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _10665 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_10665] == mem[_10665 + 18 len 14]
                                            require mem[_10665 + 32] == mem[_10665 + 50 len 14]
                                            require mem[_10665 + 64] == mem[_10665 + 92 len 4]
                                            require idx < mem[_5503]
                                            require idx + 1 < mem[_5503]
                                            if mem[(32 * idx + 1) + _5503 + 44 len 20] < mem[(32 * idx) + _5503 + 44 len 20]:
                                                if not t:
                                                    if mem[_10665 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10665 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10665 + 18 len 14] * t / t != mem[_10665 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10665 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10665 + 18 len 14] * t / mem[_10665 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_10665')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_10665 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10665 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10665 + 50 len 14] * t / t != mem[_10665 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10665 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10665 + 50 len 14] * t / mem[_10665 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_10665')), 14)))
                                            revert
                                    else:
                                        mem[0] = 118
                                        mem[_5503 + 32] = address(stor118.field_0)
                                        idx = _5503 + 32
                                        t = 0
                                        while _5503 + (32 * stor118.length) > idx:
                                            mem[idx + 32] = stor118[t].field_256
                                            idx = idx + 32
                                            t = t + 1
                                            continue 
                                        idx = 0
                                        t = 0
                                        while idx < stor118.length - 1:
                                            require idx < mem[_5503]
                                            require idx + 1 < mem[_5503]
                                            _20525 = mem[(32 * idx + 1) + _5503 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _5503 + 44 len 20]
                                            mem[mem[64] + 36] = address(_20525)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_20525)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _20904 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_20904] == mem[_20904 + 12 len 20]
                                            require ext_code.size(mem[_20904 + 12 len 20])
                                            staticcall mem[_20904 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22689 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_22689] == mem[_22689 + 18 len 14]
                                            require mem[_22689 + 32] == mem[_22689 + 50 len 14]
                                            require mem[_22689 + 64] == mem[_22689 + 92 len 4]
                                            require idx < mem[_5503]
                                            require idx + 1 < mem[_5503]
                                            if mem[(32 * idx + 1) + _5503 + 44 len 20] < mem[(32 * idx) + _5503 + 44 len 20]:
                                                if not t:
                                                    if mem[_22689 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22689 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22689 + 18 len 14] * t / t != mem[_22689 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22689 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22689 + 18 len 14] * t / mem[_22689 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_22689')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_22689 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22689 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22689 + 50 len 14] * t / t != mem[_22689 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22689 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22689 + 50 len 14] * t / mem[_22689 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_22689')), 14)))
                                            revert
                                else:
                                    if 2 * mem[_4975] / mem[_4975] != 2:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _5595 = mem[64]
                                    mem[64] = mem[64] + (32 * stor118.length) + 32
                                    mem[_5595] = stor118.length
                                    if not stor118.length:
                                        idx = 0
                                        t = 2 * _5082
                                        while idx < stor118.length - 1:
                                            require idx < mem[_5595]
                                            require idx + 1 < mem[_5595]
                                            _9003 = mem[(32 * idx + 1) + _5595 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _5595 + 44 len 20]
                                            mem[mem[64] + 36] = address(_9003)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_9003)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9340 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9340] == mem[_9340 + 12 len 20]
                                            require ext_code.size(mem[_9340 + 12 len 20])
                                            staticcall mem[_9340 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _10662 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_10662] == mem[_10662 + 18 len 14]
                                            require mem[_10662 + 32] == mem[_10662 + 50 len 14]
                                            require mem[_10662 + 64] == mem[_10662 + 92 len 4]
                                            require idx < mem[_5595]
                                            require idx + 1 < mem[_5595]
                                            if mem[(32 * idx + 1) + _5595 + 44 len 20] < mem[(32 * idx) + _5595 + 44 len 20]:
                                                if not t:
                                                    if mem[_10662 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10662 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10662 + 18 len 14] * t / t != mem[_10662 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10662 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10662 + 18 len 14] * t / mem[_10662 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_10662')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_10662 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10662 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10662 + 50 len 14] * t / t != mem[_10662 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10662 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10662 + 50 len 14] * t / mem[_10662 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_10662')), 14)))
                                            revert
                                    else:
                                        mem[0] = 118
                                        mem[_5595 + 32] = address(stor118.field_0)
                                        idx = _5595 + 32
                                        t = 0
                                        while _5595 + (32 * stor118.length) > idx:
                                            mem[idx + 32] = stor118[t].field_256
                                            idx = idx + 32
                                            t = t + 1
                                            continue 
                                        idx = 0
                                        t = 2 * _5082
                                        while idx < stor118.length - 1:
                                            require idx < mem[_5595]
                                            require idx + 1 < mem[_5595]
                                            _20523 = mem[(32 * idx + 1) + _5595 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _5595 + 44 len 20]
                                            mem[mem[64] + 36] = address(_20523)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_20523)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _20902 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_20902] == mem[_20902 + 12 len 20]
                                            require ext_code.size(mem[_20902 + 12 len 20])
                                            staticcall mem[_20902 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22686 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_22686] == mem[_22686 + 18 len 14]
                                            require mem[_22686 + 32] == mem[_22686 + 50 len 14]
                                            require mem[_22686 + 64] == mem[_22686 + 92 len 4]
                                            require idx < mem[_5595]
                                            require idx + 1 < mem[_5595]
                                            if mem[(32 * idx + 1) + _5595 + 44 len 20] < mem[(32 * idx) + _5595 + 44 len 20]:
                                                if not t:
                                                    if mem[_22686 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22686 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22686 + 18 len 14] * t / t != mem[_22686 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22686 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22686 + 18 len 14] * t / mem[_22686 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_22686')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_22686 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22686 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22686 + 50 len 14] * t / t != mem[_22686 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22686 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22686 + 50 len 14] * t / mem[_22686 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_22686')), 14)))
                                            revert
                        else:
                            mem[0] = 119
                            mem[ceil32(return_data.size) + 256] = address(stor119.field_0)
                            if (32 * stor119.length) + 32 <= 64:
                                idx = 0
                                s = (8760 * 24 * 3600 * ext_call.return_data[0]) - (8760 * 24 * 3600 * stor42D0) / periodFinish - lastUpdateTime
                                while idx < stor119.length - 1:
                                    require idx < mem[ceil32(return_data.size) + 224]
                                    require idx + 1 < mem[ceil32(return_data.size) + 224]
                                    _4423 = mem[(32 * idx + 1) + ceil32(return_data.size) + 256]
                                    mem[mem[64] + 4] = mem[(32 * idx) + ceil32(return_data.size) + 268 len 20]
                                    mem[mem[64] + 36] = address(_4423)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_4423)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4570 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_4570] == mem[_4570 + 12 len 20]
                                    require ext_code.size(mem[_4570 + 12 len 20])
                                    staticcall mem[_4570 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4980 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_4980] == mem[_4980 + 18 len 14]
                                    require mem[_4980 + 32] == mem[_4980 + 50 len 14]
                                    require mem[_4980 + 64] == mem[_4980 + 92 len 4]
                                    require idx < mem[ceil32(return_data.size) + 224]
                                    require idx + 1 < mem[ceil32(return_data.size) + 224]
                                    if mem[(32 * idx + 1) + ceil32(return_data.size) + 268 len 20] < mem[(32 * idx) + ceil32(return_data.size) + 268 len 20]:
                                        if not s:
                                            if mem[_4980 + 50 len 14]:
                                                idx = idx + 1
                                                s = 0 / mem[_4980 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_4980 + 18 len 14] * s / s != mem[_4980 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_4980 + 50 len 14]:
                                                idx = idx + 1
                                                s = mem[_4980 + 18 len 14] * s / mem[_4980 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_4980')), 14)))
                                    else:
                                        if not s:
                                            if mem[_4980 + 18 len 14]:
                                                idx = idx + 1
                                                s = 0 / mem[_4980 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_4980 + 50 len 14] * s / s != mem[_4980 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_4980 + 18 len 14]:
                                                idx = idx + 1
                                                s = mem[_4980 + 50 len 14] * s / mem[_4980 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_4980')), 14)))
                                    revert
                                require stor118.length
                                mem[0] = 118
                                if address(stor118.field_0) == stakingTokenAddress:
                                    _4631 = mem[64]
                                    mem[64] = mem[64] + (32 * stor118.length) + 32
                                    mem[_4631] = stor118.length
                                    if not stor118.length:
                                        idx = 0
                                        t = totalSupply
                                        while idx < stor118.length - 1:
                                            require idx < mem[_4631]
                                            require idx + 1 < mem[_4631]
                                            _9008 = mem[(32 * idx + 1) + _4631 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _4631 + 44 len 20]
                                            mem[mem[64] + 36] = address(_9008)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_9008)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9345 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9345] == mem[_9345 + 12 len 20]
                                            require ext_code.size(mem[_9345 + 12 len 20])
                                            staticcall mem[_9345 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _10672 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_10672] == mem[_10672 + 18 len 14]
                                            require mem[_10672 + 32] == mem[_10672 + 50 len 14]
                                            require mem[_10672 + 64] == mem[_10672 + 92 len 4]
                                            require idx < mem[_4631]
                                            require idx + 1 < mem[_4631]
                                            if mem[(32 * idx + 1) + _4631 + 44 len 20] < mem[(32 * idx) + _4631 + 44 len 20]:
                                                if not t:
                                                    if mem[_10672 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10672 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10672 + 18 len 14] * t / t != mem[_10672 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10672 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10672 + 18 len 14] * t / mem[_10672 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_10672')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_10672 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10672 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10672 + 50 len 14] * t / t != mem[_10672 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10672 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10672 + 50 len 14] * t / mem[_10672 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_10672')), 14)))
                                            revert
                                    else:
                                        mem[0] = 118
                                        mem[_4631 + 32] = address(stor118.field_0)
                                        idx = _4631 + 32
                                        t = 0
                                        while _4631 + (32 * stor118.length) > idx:
                                            mem[idx + 32] = stor118[t].field_256
                                            idx = idx + 32
                                            t = t + 1
                                            continue 
                                        idx = 0
                                        t = totalSupply
                                        while idx < stor118.length - 1:
                                            require idx < mem[_4631]
                                            require idx + 1 < mem[_4631]
                                            _20533 = mem[(32 * idx + 1) + _4631 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _4631 + 44 len 20]
                                            mem[mem[64] + 36] = address(_20533)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_20533)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _20912 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_20912] == mem[_20912 + 12 len 20]
                                            require ext_code.size(mem[_20912 + 12 len 20])
                                            staticcall mem[_20912 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22701 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_22701] == mem[_22701 + 18 len 14]
                                            require mem[_22701 + 32] == mem[_22701 + 50 len 14]
                                            require mem[_22701 + 64] == mem[_22701 + 92 len 4]
                                            require idx < mem[_4631]
                                            require idx + 1 < mem[_4631]
                                            if mem[(32 * idx + 1) + _4631 + 44 len 20] < mem[(32 * idx) + _4631 + 44 len 20]:
                                                if not t:
                                                    if mem[_22701 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22701 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22701 + 18 len 14] * t / t != mem[_22701 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22701 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22701 + 18 len 14] * t / mem[_22701 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_22701')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_22701 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22701 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22701 + 50 len 14] * t / t != mem[_22701 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22701 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22701 + 50 len 14] * t / mem[_22701 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_22701')), 14)))
                                            revert
                                else:
                                    require stor118.length
                                    require stor118.length
                                    require address(stor118.field_0) != stakingTokenAddress
                                    require 0 < stor118.length
                                    mem[0] = 118
                                    mem[mem[64] + 4] = stakingTokenAddress
                                    require ext_code.size(address(stor118.field_0))
                                    staticcall address(stor118.field_0).0x70a08231 with:
                                            gas gas_remaining wei
                                           args stakingTokenAddress
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4979 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _5085 = mem[_4979]
                                    if not mem[_4979]:
                                        _5506 = mem[64]
                                        mem[64] = mem[64] + (32 * stor118.length) + 32
                                        mem[_5506] = stor118.length
                                        if not stor118.length:
                                            idx = 0
                                            t = 0
                                            while idx < stor118.length - 1:
                                                require idx < mem[_5506]
                                                require idx + 1 < mem[_5506]
                                                _9012 = mem[(32 * idx + 1) + _5506 + 32]
                                                mem[mem[64] + 4] = mem[(32 * idx) + _5506 + 44 len 20]
                                                mem[mem[64] + 36] = address(_9012)
                                                require ext_code.size(stor117)
                                                staticcall stor117.getPair(address rg1, address rg2) with:
                                                        gas gas_remaining wei
                                                       args mem[mem[64] + 4], address(_9012)
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _9349 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_9349] == mem[_9349 + 12 len 20]
                                                require ext_code.size(mem[_9349 + 12 len 20])
                                                staticcall mem[_9349 + 12 len 20].getReserves() with:
                                                        gas gas_remaining wei
                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _10678 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 96
                                                require mem[_10678] == mem[_10678 + 18 len 14]
                                                require mem[_10678 + 32] == mem[_10678 + 50 len 14]
                                                require mem[_10678 + 64] == mem[_10678 + 92 len 4]
                                                require idx < mem[_5506]
                                                require idx + 1 < mem[_5506]
                                                if mem[(32 * idx + 1) + _5506 + 44 len 20] < mem[(32 * idx) + _5506 + 44 len 20]:
                                                    if not t:
                                                        if mem[_10678 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_10678 + 50 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_10678 + 18 len 14] * t / t != mem[_10678 + 18 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_10678 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_10678 + 18 len 14] * t / mem[_10678 + 50 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_10678')), 14)))
                                                else:
                                                    if not t:
                                                        if mem[_10678 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_10678 + 18 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_10678 + 50 len 14] * t / t != mem[_10678 + 50 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_10678 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_10678 + 50 len 14] * t / mem[_10678 + 18 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_10678')), 14)))
                                                revert
                                        else:
                                            mem[0] = 118
                                            mem[_5506 + 32] = address(stor118.field_0)
                                            idx = _5506 + 32
                                            t = 0
                                            while _5506 + (32 * stor118.length) > idx:
                                                mem[idx + 32] = stor118[t].field_256
                                                idx = idx + 32
                                                t = t + 1
                                                continue 
                                            idx = 0
                                            t = 0
                                            while idx < stor118.length - 1:
                                                require idx < mem[_5506]
                                                require idx + 1 < mem[_5506]
                                                _20537 = mem[(32 * idx + 1) + _5506 + 32]
                                                mem[mem[64] + 4] = mem[(32 * idx) + _5506 + 44 len 20]
                                                mem[mem[64] + 36] = address(_20537)
                                                require ext_code.size(stor117)
                                                staticcall stor117.getPair(address rg1, address rg2) with:
                                                        gas gas_remaining wei
                                                       args mem[mem[64] + 4], address(_20537)
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _20916 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_20916] == mem[_20916 + 12 len 20]
                                                require ext_code.size(mem[_20916 + 12 len 20])
                                                staticcall mem[_20916 + 12 len 20].getReserves() with:
                                                        gas gas_remaining wei
                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _22707 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 96
                                                require mem[_22707] == mem[_22707 + 18 len 14]
                                                require mem[_22707 + 32] == mem[_22707 + 50 len 14]
                                                require mem[_22707 + 64] == mem[_22707 + 92 len 4]
                                                require idx < mem[_5506]
                                                require idx + 1 < mem[_5506]
                                                if mem[(32 * idx + 1) + _5506 + 44 len 20] < mem[(32 * idx) + _5506 + 44 len 20]:
                                                    if not t:
                                                        if mem[_22707 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_22707 + 50 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_22707 + 18 len 14] * t / t != mem[_22707 + 18 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_22707 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_22707 + 18 len 14] * t / mem[_22707 + 50 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_22707')), 14)))
                                                else:
                                                    if not t:
                                                        if mem[_22707 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_22707 + 18 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_22707 + 50 len 14] * t / t != mem[_22707 + 50 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_22707 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_22707 + 50 len 14] * t / mem[_22707 + 18 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_22707')), 14)))
                                                revert
                                    else:
                                        if 2 * mem[_4979] / mem[_4979] != 2:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _5600 = mem[64]
                                        mem[64] = mem[64] + (32 * stor118.length) + 32
                                        mem[_5600] = stor118.length
                                        if not stor118.length:
                                            idx = 0
                                            t = 2 * _5085
                                            while idx < stor118.length - 1:
                                                require idx < mem[_5600]
                                                require idx + 1 < mem[_5600]
                                                _9010 = mem[(32 * idx + 1) + _5600 + 32]
                                                mem[mem[64] + 4] = mem[(32 * idx) + _5600 + 44 len 20]
                                                mem[mem[64] + 36] = address(_9010)
                                                require ext_code.size(stor117)
                                                staticcall stor117.getPair(address rg1, address rg2) with:
                                                        gas gas_remaining wei
                                                       args mem[mem[64] + 4], address(_9010)
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _9347 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_9347] == mem[_9347 + 12 len 20]
                                                require ext_code.size(mem[_9347 + 12 len 20])
                                                staticcall mem[_9347 + 12 len 20].getReserves() with:
                                                        gas gas_remaining wei
                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _10675 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 96
                                                require mem[_10675] == mem[_10675 + 18 len 14]
                                                require mem[_10675 + 32] == mem[_10675 + 50 len 14]
                                                require mem[_10675 + 64] == mem[_10675 + 92 len 4]
                                                require idx < mem[_5600]
                                                require idx + 1 < mem[_5600]
                                                if mem[(32 * idx + 1) + _5600 + 44 len 20] < mem[(32 * idx) + _5600 + 44 len 20]:
                                                    if not t:
                                                        if mem[_10675 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_10675 + 50 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_10675 + 18 len 14] * t / t != mem[_10675 + 18 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_10675 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_10675 + 18 len 14] * t / mem[_10675 + 50 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_10675')), 14)))
                                                else:
                                                    if not t:
                                                        if mem[_10675 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_10675 + 18 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_10675 + 50 len 14] * t / t != mem[_10675 + 50 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_10675 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_10675 + 50 len 14] * t / mem[_10675 + 18 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_10675')), 14)))
                                                revert
                                        else:
                                            mem[0] = 118
                                            mem[_5600 + 32] = address(stor118.field_0)
                                            idx = _5600 + 32
                                            t = 0
                                            while _5600 + (32 * stor118.length) > idx:
                                                mem[idx + 32] = stor118[t].field_256
                                                idx = idx + 32
                                                t = t + 1
                                                continue 
                                            idx = 0
                                            t = 2 * _5085
                                            while idx < stor118.length - 1:
                                                require idx < mem[_5600]
                                                require idx + 1 < mem[_5600]
                                                _20535 = mem[(32 * idx + 1) + _5600 + 32]
                                                mem[mem[64] + 4] = mem[(32 * idx) + _5600 + 44 len 20]
                                                mem[mem[64] + 36] = address(_20535)
                                                require ext_code.size(stor117)
                                                staticcall stor117.getPair(address rg1, address rg2) with:
                                                        gas gas_remaining wei
                                                       args mem[mem[64] + 4], address(_20535)
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _20914 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_20914] == mem[_20914 + 12 len 20]
                                                require ext_code.size(mem[_20914 + 12 len 20])
                                                staticcall mem[_20914 + 12 len 20].getReserves() with:
                                                        gas gas_remaining wei
                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _22704 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 96
                                                require mem[_22704] == mem[_22704 + 18 len 14]
                                                require mem[_22704 + 32] == mem[_22704 + 50 len 14]
                                                require mem[_22704 + 64] == mem[_22704 + 92 len 4]
                                                require idx < mem[_5600]
                                                require idx + 1 < mem[_5600]
                                                if mem[(32 * idx + 1) + _5600 + 44 len 20] < mem[(32 * idx) + _5600 + 44 len 20]:
                                                    if not t:
                                                        if mem[_22704 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_22704 + 50 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_22704 + 18 len 14] * t / t != mem[_22704 + 18 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_22704 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_22704 + 18 len 14] * t / mem[_22704 + 50 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_22704')), 14)))
                                                else:
                                                    if not t:
                                                        if mem[_22704 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_22704 + 18 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_22704 + 50 len 14] * t / t != mem[_22704 + 50 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_22704 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_22704 + 50 len 14] * t / mem[_22704 + 18 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_22704')), 14)))
                                                revert
                            else:
                                mem[ceil32(return_data.size) + 288] = address(stor119.field_256)
                                idx = ceil32(return_data.size) + 288
                                s = 1
                                while ceil32(return_data.size) + (32 * stor119.length) + 224 > idx:
                                    mem[idx + 32] = stor119[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                idx = 0
                                s = (8760 * 24 * 3600 * ext_call.return_data[0]) - (8760 * 24 * 3600 * stor42D0) / periodFinish - lastUpdateTime
                                while idx < stor119.length - 1:
                                    require idx < mem[ceil32(return_data.size) + 224]
                                    require idx + 1 < mem[ceil32(return_data.size) + 224]
                                    _14442 = mem[(32 * idx + 1) + ceil32(return_data.size) + 256]
                                    mem[mem[64] + 4] = mem[(32 * idx) + ceil32(return_data.size) + 268 len 20]
                                    mem[mem[64] + 36] = address(_14442)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_14442)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _15252 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_15252] == mem[_15252 + 12 len 20]
                                    require ext_code.size(mem[_15252 + 12 len 20])
                                    staticcall mem[_15252 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _16396 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_16396] == mem[_16396 + 18 len 14]
                                    require mem[_16396 + 32] == mem[_16396 + 50 len 14]
                                    require mem[_16396 + 64] == mem[_16396 + 92 len 4]
                                    require idx < mem[ceil32(return_data.size) + 224]
                                    require idx + 1 < mem[ceil32(return_data.size) + 224]
                                    if mem[(32 * idx + 1) + ceil32(return_data.size) + 268 len 20] < mem[(32 * idx) + ceil32(return_data.size) + 268 len 20]:
                                        if not s:
                                            if mem[_16396 + 50 len 14]:
                                                idx = idx + 1
                                                s = 0 / mem[_16396 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_16396 + 18 len 14] * s / s != mem[_16396 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_16396 + 50 len 14]:
                                                idx = idx + 1
                                                s = mem[_16396 + 18 len 14] * s / mem[_16396 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_16396')), 14)))
                                    else:
                                        if not s:
                                            if mem[_16396 + 18 len 14]:
                                                idx = idx + 1
                                                s = 0 / mem[_16396 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_16396 + 50 len 14] * s / s != mem[_16396 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_16396 + 18 len 14]:
                                                idx = idx + 1
                                                s = mem[_16396 + 50 len 14] * s / mem[_16396 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_16396')), 14)))
                                    revert
                                require stor118.length
                                mem[0] = 118
                                if address(stor118.field_0) == stakingTokenAddress:
                                    _15381 = mem[64]
                                    mem[64] = mem[64] + (32 * stor118.length) + 32
                                    mem[_15381] = stor118.length
                                    if not stor118.length:
                                        idx = 0
                                        t = totalSupply
                                        while idx < stor118.length - 1:
                                            require idx < mem[_15381]
                                            require idx + 1 < mem[_15381]
                                            _20527 = mem[(32 * idx + 1) + _15381 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _15381 + 44 len 20]
                                            mem[mem[64] + 36] = address(_20527)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_20527)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _20906 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_20906] == mem[_20906 + 12 len 20]
                                            require ext_code.size(mem[_20906 + 12 len 20])
                                            staticcall mem[_20906 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22692 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_22692] == mem[_22692 + 18 len 14]
                                            require mem[_22692 + 32] == mem[_22692 + 50 len 14]
                                            require mem[_22692 + 64] == mem[_22692 + 92 len 4]
                                            require idx < mem[_15381]
                                            require idx + 1 < mem[_15381]
                                            if mem[(32 * idx + 1) + _15381 + 44 len 20] < mem[(32 * idx) + _15381 + 44 len 20]:
                                                if not t:
                                                    if mem[_22692 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22692 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22692 + 18 len 14] * t / t != mem[_22692 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22692 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22692 + 18 len 14] * t / mem[_22692 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_22692')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_22692 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22692 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22692 + 50 len 14] * t / t != mem[_22692 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22692 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22692 + 50 len 14] * t / mem[_22692 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_22692')), 14)))
                                            revert
                                        if s:
                                            if 10^18 * s / s != 10^18:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not t:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            return (10^18 * s / t)
                                        if t:
                                            return (0 / t)
                                        var70001 = 32
                                        revert with 0, 'SafeMath: division by zero', 0
                                    mem[0] = 118
                                    mem[_15381 + 32] = address(stor118.field_0)
                                    idx = _15381 + 32
                                    t = 0
                                    while _15381 + (32 * stor118.length) > idx:
                                        mem[idx + 32] = stor118[t].field_256
                                        idx = idx + 32
                                        t = t + 1
                                        continue 
                                    idx = 0
                                    t = totalSupply
                                    while idx < stor118.length - 1:
                                        require idx < mem[_15381]
                                        require idx + 1 < mem[_15381]
                                        _27693 = mem[(32 * idx + 1) + _15381 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _15381 + 44 len 20]
                                        mem[mem[64] + 36] = address(_27693)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_27693)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27820 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_27820] == mem[_27820 + 12 len 20]
                                        require ext_code.size(mem[_27820 + 12 len 20])
                                        staticcall mem[_27820 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _28415 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_28415] == mem[_28415 + 18 len 14]
                                        require mem[_28415 + 32] == mem[_28415 + 50 len 14]
                                        require mem[_28415 + 64] == mem[_28415 + 92 len 4]
                                        require idx < mem[_15381]
                                        require idx + 1 < mem[_15381]
                                        if mem[(32 * idx + 1) + _15381 + 44 len 20] < mem[(32 * idx) + _15381 + 44 len 20]:
                                            if not t:
                                                if mem[_28415 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_28415 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_28415 + 18 len 14] * t / t != mem[_28415 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_28415 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_28415 + 18 len 14] * t / mem[_28415 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_28415')), 14)))
                                        else:
                                            if not t:
                                                if mem[_28415 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_28415 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_28415 + 50 len 14] * t / t != mem[_28415 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_28415 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_28415 + 50 len 14] * t / mem[_28415 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_28415')), 14)))
                                        revert
                                else:
                                    require stor118.length
                                    require stor118.length
                                    require address(stor118.field_0) != stakingTokenAddress
                                    require 0 < stor118.length
                                    mem[0] = 118
                                    mem[mem[64] + 4] = stakingTokenAddress
                                    require ext_code.size(address(stor118.field_0))
                                    staticcall address(stor118.field_0).0x70a08231 with:
                                            gas gas_remaining wei
                                           args stakingTokenAddress
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _16395 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _16766 = mem[_16395]
                                    if not mem[_16395]:
                                        _17777 = mem[64]
                                        mem[64] = mem[64] + (32 * stor118.length) + 32
                                        mem[_17777] = stor118.length
                                        if not stor118.length:
                                            idx = 0
                                            t = 0
                                            while idx < stor118.length - 1:
                                                require idx < mem[_17777]
                                                require idx + 1 < mem[_17777]
                                                _20531 = mem[(32 * idx + 1) + _17777 + 32]
                                                mem[mem[64] + 4] = mem[(32 * idx) + _17777 + 44 len 20]
                                                mem[mem[64] + 36] = address(_20531)
                                                require ext_code.size(stor117)
                                                staticcall stor117.getPair(address rg1, address rg2) with:
                                                        gas gas_remaining wei
                                                       args mem[mem[64] + 4], address(_20531)
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _20910 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_20910] == mem[_20910 + 12 len 20]
                                                require ext_code.size(mem[_20910 + 12 len 20])
                                                staticcall mem[_20910 + 12 len 20].getReserves() with:
                                                        gas gas_remaining wei
                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _22698 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 96
                                                require mem[_22698] == mem[_22698 + 18 len 14]
                                                require mem[_22698 + 32] == mem[_22698 + 50 len 14]
                                                require mem[_22698 + 64] == mem[_22698 + 92 len 4]
                                                require idx < mem[_17777]
                                                require idx + 1 < mem[_17777]
                                                if mem[(32 * idx + 1) + _17777 + 44 len 20] < mem[(32 * idx) + _17777 + 44 len 20]:
                                                    if not t:
                                                        if mem[_22698 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_22698 + 50 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_22698 + 18 len 14] * t / t != mem[_22698 + 18 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_22698 + 50 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_22698 + 18 len 14] * t / mem[_22698 + 50 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_22698')), 14)))
                                                else:
                                                    if not t:
                                                        if mem[_22698 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = 0 / mem[_22698 + 18 len 14]
                                                            continue 
                                                    else:
                                                        if mem[_22698 + 50 len 14] * t / t != mem[_22698 + 50 len 14]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[_22698 + 18 len 14]:
                                                            idx = idx + 1
                                                            t = mem[_22698 + 50 len 14] * t / mem[_22698 + 18 len 14]
                                                            continue 
                                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_22698')), 14)))
                                                revert
                                            if not s:
                                                if not t:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                return (0 / t)
                                            if 10^18 * s / s != 10^18:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not t:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            return (10^18 * s / t)
                                        mem[0] = 118
                                        mem[_17777 + 32] = address(stor118.field_0)
                                        idx = _17777 + 32
                                        t = 0
                                        while _17777 + (32 * stor118.length) > idx:
                                            mem[idx + 32] = stor118[t].field_256
                                            idx = idx + 32
                                            t = t + 1
                                            continue 
                                        idx = 0
                                        t = 0
                                        while idx < stor118.length - 1:
                                            require idx < mem[_17777]
                                            require idx + 1 < mem[_17777]
                                            _27697 = mem[(32 * idx + 1) + _17777 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _17777 + 44 len 20]
                                            mem[mem[64] + 36] = address(_27697)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_27697)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27824 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_27824] == mem[_27824 + 12 len 20]
                                            require ext_code.size(mem[_27824 + 12 len 20])
                                            staticcall mem[_27824 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _28421 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_28421] == mem[_28421 + 18 len 14]
                                            require mem[_28421 + 32] == mem[_28421 + 50 len 14]
                                            require mem[_28421 + 64] == mem[_28421 + 92 len 4]
                                            require idx < mem[_17777]
                                            require idx + 1 < mem[_17777]
                                            if mem[(32 * idx + 1) + _17777 + 44 len 20] < mem[(32 * idx) + _17777 + 44 len 20]:
                                                if not t:
                                                    if mem[_28421 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_28421 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_28421 + 18 len 14] * t / t != mem[_28421 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_28421 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_28421 + 18 len 14] * t / mem[_28421 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_28421')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_28421 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_28421 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_28421 + 50 len 14] * t / t != mem[_28421 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_28421 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_28421 + 50 len 14] * t / mem[_28421 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_28421')), 14)))
                                            revert
                                        if s:
                                            if 10^18 * s / s != 10^18:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not t:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            return (10^18 * s / t)
                                        if t:
                                            return (0 / t)
                                        var89001 = 32
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if 2 * mem[_16395] / mem[_16395] != 2:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _17838 = mem[64]
                                    mem[64] = mem[64] + (32 * stor118.length) + 32
                                    mem[_17838] = stor118.length
                                    if not stor118.length:
                                        idx = 0
                                        t = 2 * _16766
                                        while idx < stor118.length - 1:
                                            require idx < mem[_17838]
                                            require idx + 1 < mem[_17838]
                                            _20529 = mem[(32 * idx + 1) + _17838 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _17838 + 44 len 20]
                                            mem[mem[64] + 36] = address(_20529)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_20529)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _20908 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_20908] == mem[_20908 + 12 len 20]
                                            require ext_code.size(mem[_20908 + 12 len 20])
                                            staticcall mem[_20908 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22695 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_22695] == mem[_22695 + 18 len 14]
                                            require mem[_22695 + 32] == mem[_22695 + 50 len 14]
                                            require mem[_22695 + 64] == mem[_22695 + 92 len 4]
                                            require idx < mem[_17838]
                                            require idx + 1 < mem[_17838]
                                            if mem[(32 * idx + 1) + _17838 + 44 len 20] < mem[(32 * idx) + _17838 + 44 len 20]:
                                                if not t:
                                                    if mem[_22695 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22695 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22695 + 18 len 14] * t / t != mem[_22695 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22695 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22695 + 18 len 14] * t / mem[_22695 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_22695')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_22695 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22695 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22695 + 50 len 14] * t / t != mem[_22695 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22695 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22695 + 50 len 14] * t / mem[_22695 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_22695')), 14)))
                                            revert
                                    else:
                                        mem[0] = 118
                                        mem[_17838 + 32] = address(stor118.field_0)
                                        idx = _17838 + 32
                                        t = 0
                                        while _17838 + (32 * stor118.length) > idx:
                                            mem[idx + 32] = stor118[t].field_256
                                            idx = idx + 32
                                            t = t + 1
                                            continue 
                                        idx = 0
                                        t = 2 * _16766
                                        while idx < stor118.length - 1:
                                            require idx < mem[_17838]
                                            require idx + 1 < mem[_17838]
                                            _27695 = mem[(32 * idx + 1) + _17838 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _17838 + 44 len 20]
                                            mem[mem[64] + 36] = address(_27695)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_27695)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _27822 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_27822] == mem[_27822 + 12 len 20]
                                            require ext_code.size(mem[_27822 + 12 len 20])
                                            staticcall mem[_27822 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _28418 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_28418] == mem[_28418 + 18 len 14]
                                            require mem[_28418 + 32] == mem[_28418 + 50 len 14]
                                            require mem[_28418 + 64] == mem[_28418 + 92 len 4]
                                            require idx < mem[_17838]
                                            require idx + 1 < mem[_17838]
                                            if mem[(32 * idx + 1) + _17838 + 44 len 20] < mem[(32 * idx) + _17838 + 44 len 20]:
                                                if not t:
                                                    if mem[_28418 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_28418 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_28418 + 18 len 14] * t / t != mem[_28418 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_28418 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_28418 + 18 len 14] * t / mem[_28418 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_28418')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_28418 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_28418 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_28418 + 50 len 14] * t / t != mem[_28418 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_28418 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_28418 + 50 len 14] * t / mem[_28418 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_28418')), 14)))
                                            revert
        else:
            if block.timestamp + 1 < block.timestamp:
                revert with 0, 'SafeMath: addition overflow'
            if rewardsDuration < 0:
                revert with 0, 'SafeMath: addition overflow'
            mem[ceil32(return_data.size) + 96] = 30
            mem[ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
            if begin > rewardsDuration + block.timestamp + 1:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if rewardsDuration + block.timestamp < block.timestamp:
                revert with 0, 'SafeMath: addition overflow'
            mem[ceil32(return_data.size) + 160] = 30
            mem[ceil32(return_data.size) + 192] = 'SafeMath: subtraction overflow'
            if begin > rewardsDuration + block.timestamp:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if not ext_call.return_data[0] - stor42D0:
                mem[ceil32(return_data.size) + 224] = 26
                mem[ceil32(return_data.size) + 256] = 'SafeMath: division by zero'
                if not rewardsDuration + block.timestamp + -begin + 1:
                    revert with 0, 'SafeMath: division by zero', 0
                mem[ceil32(return_data.size) + 288] = 30
                mem[ceil32(return_data.size) + 320] = 'SafeMath: subtraction overflow'
                if 0 / rewardsDuration + block.timestamp + -begin + 1 > ext_call.return_data[0] - stor42D0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                require 0 < stor119.length
                mem[0] = 119
                require address(stor119.field_0) == rewardsTokenAddress
                mem[64] = ceil32(return_data.size) + (32 * stor119.length) + 384
                mem[ceil32(return_data.size) + 352] = stor119.length
                if not stor119.length:
                    idx = 0
                    s = ext_call.return_data[0] - stor42D0 - (0 / rewardsDuration + block.timestamp + -begin + 1)
                    while idx < stor119.length - 1:
                        require idx < mem[ceil32(return_data.size) + 352]
                        require idx + 1 < mem[ceil32(return_data.size) + 352]
                        _4445 = mem[(32 * idx + 1) + ceil32(return_data.size) + 384]
                        mem[mem[64] + 4] = mem[(32 * idx) + ceil32(return_data.size) + 396 len 20]
                        mem[mem[64] + 36] = address(_4445)
                        require ext_code.size(stor117)
                        staticcall stor117.getPair(address rg1, address rg2) with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4], address(_4445)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4581 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_4581] == mem[_4581 + 12 len 20]
                        require ext_code.size(mem[_4581 + 12 len 20])
                        staticcall mem[_4581 + 12 len 20].getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _5024 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        require mem[_5024] == mem[_5024 + 18 len 14]
                        require mem[_5024 + 32] == mem[_5024 + 50 len 14]
                        require mem[_5024 + 64] == mem[_5024 + 92 len 4]
                        require idx < mem[ceil32(return_data.size) + 352]
                        require idx + 1 < mem[ceil32(return_data.size) + 352]
                        if mem[(32 * idx + 1) + ceil32(return_data.size) + 396 len 20] < mem[(32 * idx) + ceil32(return_data.size) + 396 len 20]:
                            if not s:
                                if mem[_5024 + 50 len 14]:
                                    idx = idx + 1
                                    s = 0 / mem[_5024 + 50 len 14]
                                    continue 
                            else:
                                if mem[_5024 + 18 len 14] * s / s != mem[_5024 + 18 len 14]:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if mem[_5024 + 50 len 14]:
                                    idx = idx + 1
                                    s = mem[_5024 + 18 len 14] * s / mem[_5024 + 50 len 14]
                                    continue 
                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_5024')), 14)))
                        else:
                            if not s:
                                if mem[_5024 + 18 len 14]:
                                    idx = idx + 1
                                    s = 0 / mem[_5024 + 18 len 14]
                                    continue 
                            else:
                                if mem[_5024 + 50 len 14] * s / s != mem[_5024 + 50 len 14]:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if mem[_5024 + 18 len 14]:
                                    idx = idx + 1
                                    s = mem[_5024 + 50 len 14] * s / mem[_5024 + 18 len 14]
                                    continue 
                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_5024')), 14)))
                        revert
                    require stor118.length
                    mem[0] = 118
                    if address(stor118.field_0) == stakingTokenAddress:
                        _4653 = mem[64]
                        mem[64] = mem[64] + (32 * stor118.length) + 32
                        mem[_4653] = stor118.length
                        if not stor118.length:
                            idx = 0
                            t = totalSupply
                            while idx < stor118.length - 1:
                                require idx < mem[_4653]
                                require idx + 1 < mem[_4653]
                                _9079 = mem[(32 * idx + 1) + _4653 + 32]
                                mem[mem[64] + 4] = mem[(32 * idx) + _4653 + 44 len 20]
                                mem[mem[64] + 36] = address(_9079)
                                require ext_code.size(stor117)
                                staticcall stor117.getPair(address rg1, address rg2) with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4], address(_9079)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _9416 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_9416] == mem[_9416 + 12 len 20]
                                require ext_code.size(mem[_9416 + 12 len 20])
                                staticcall mem[_9416 + 12 len 20].getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10791 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10791] == mem[_10791 + 18 len 14]
                                require mem[_10791 + 32] == mem[_10791 + 50 len 14]
                                require mem[_10791 + 64] == mem[_10791 + 92 len 4]
                                require idx < mem[_4653]
                                require idx + 1 < mem[_4653]
                                if mem[(32 * idx + 1) + _4653 + 44 len 20] < mem[(32 * idx) + _4653 + 44 len 20]:
                                    if not t:
                                        if mem[_10791 + 50 len 14]:
                                            idx = idx + 1
                                            t = 0 / mem[_10791 + 50 len 14]
                                            continue 
                                    else:
                                        if mem[_10791 + 18 len 14] * t / t != mem[_10791 + 18 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_10791 + 50 len 14]:
                                            idx = idx + 1
                                            t = mem[_10791 + 18 len 14] * t / mem[_10791 + 50 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_10791')), 14)))
                                else:
                                    if not t:
                                        if mem[_10791 + 18 len 14]:
                                            idx = idx + 1
                                            t = 0 / mem[_10791 + 18 len 14]
                                            continue 
                                    else:
                                        if mem[_10791 + 50 len 14] * t / t != mem[_10791 + 50 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_10791 + 18 len 14]:
                                            idx = idx + 1
                                            t = mem[_10791 + 50 len 14] * t / mem[_10791 + 18 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_10791')), 14)))
                                revert
                        else:
                            mem[0] = 118
                            mem[_4653 + 32] = address(stor118.field_0)
                            idx = _4653 + 32
                            t = 0
                            while _4653 + (32 * stor118.length) > idx:
                                mem[idx + 32] = stor118[t].field_256
                                idx = idx + 32
                                t = t + 1
                                continue 
                            idx = 0
                            t = totalSupply
                            while idx < stor118.length - 1:
                                require idx < mem[_4653]
                                require idx + 1 < mem[_4653]
                                _20629 = mem[(32 * idx + 1) + _4653 + 32]
                                mem[mem[64] + 4] = mem[(32 * idx) + _4653 + 44 len 20]
                                mem[mem[64] + 36] = address(_20629)
                                require ext_code.size(stor117)
                                staticcall stor117.getPair(address rg1, address rg2) with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4], address(_20629)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _21008 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_21008] == mem[_21008 + 12 len 20]
                                require ext_code.size(mem[_21008 + 12 len 20])
                                staticcall mem[_21008 + 12 len 20].getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _22845 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_22845] == mem[_22845 + 18 len 14]
                                require mem[_22845 + 32] == mem[_22845 + 50 len 14]
                                require mem[_22845 + 64] == mem[_22845 + 92 len 4]
                                require idx < mem[_4653]
                                require idx + 1 < mem[_4653]
                                if mem[(32 * idx + 1) + _4653 + 44 len 20] < mem[(32 * idx) + _4653 + 44 len 20]:
                                    if not t:
                                        if mem[_22845 + 50 len 14]:
                                            idx = idx + 1
                                            t = 0 / mem[_22845 + 50 len 14]
                                            continue 
                                    else:
                                        if mem[_22845 + 18 len 14] * t / t != mem[_22845 + 18 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_22845 + 50 len 14]:
                                            idx = idx + 1
                                            t = mem[_22845 + 18 len 14] * t / mem[_22845 + 50 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_22845')), 14)))
                                else:
                                    if not t:
                                        if mem[_22845 + 18 len 14]:
                                            idx = idx + 1
                                            t = 0 / mem[_22845 + 18 len 14]
                                            continue 
                                    else:
                                        if mem[_22845 + 50 len 14] * t / t != mem[_22845 + 50 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_22845 + 18 len 14]:
                                            idx = idx + 1
                                            t = mem[_22845 + 50 len 14] * t / mem[_22845 + 18 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_22845')), 14)))
                                revert
                    else:
                        require stor118.length
                        require stor118.length
                        require address(stor118.field_0) != stakingTokenAddress
                        require 0 < stor118.length
                        mem[0] = 118
                        mem[mem[64] + 4] = stakingTokenAddress
                        require ext_code.size(address(stor118.field_0))
                        staticcall address(stor118.field_0).0x70a08231 with:
                                gas gas_remaining wei
                               args stakingTokenAddress
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _5023 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _5118 = mem[_5023]
                        if not mem[_5023]:
                            _5539 = mem[64]
                            mem[64] = mem[64] + (32 * stor118.length) + 32
                            mem[_5539] = stor118.length
                            if not stor118.length:
                                idx = 0
                                t = 0
                                while idx < stor118.length - 1:
                                    require idx < mem[_5539]
                                    require idx + 1 < mem[_5539]
                                    _9083 = mem[(32 * idx + 1) + _5539 + 32]
                                    mem[mem[64] + 4] = mem[(32 * idx) + _5539 + 44 len 20]
                                    mem[mem[64] + 36] = address(_9083)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_9083)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9420 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_9420] == mem[_9420 + 12 len 20]
                                    require ext_code.size(mem[_9420 + 12 len 20])
                                    staticcall mem[_9420 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10797 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_10797] == mem[_10797 + 18 len 14]
                                    require mem[_10797 + 32] == mem[_10797 + 50 len 14]
                                    require mem[_10797 + 64] == mem[_10797 + 92 len 4]
                                    require idx < mem[_5539]
                                    require idx + 1 < mem[_5539]
                                    if mem[(32 * idx + 1) + _5539 + 44 len 20] < mem[(32 * idx) + _5539 + 44 len 20]:
                                        if not t:
                                            if mem[_10797 + 50 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_10797 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_10797 + 18 len 14] * t / t != mem[_10797 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_10797 + 50 len 14]:
                                                idx = idx + 1
                                                t = mem[_10797 + 18 len 14] * t / mem[_10797 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_10797')), 14)))
                                    else:
                                        if not t:
                                            if mem[_10797 + 18 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_10797 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_10797 + 50 len 14] * t / t != mem[_10797 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_10797 + 18 len 14]:
                                                idx = idx + 1
                                                t = mem[_10797 + 50 len 14] * t / mem[_10797 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_10797')), 14)))
                                    revert
                            else:
                                mem[0] = 118
                                mem[_5539 + 32] = address(stor118.field_0)
                                idx = _5539 + 32
                                t = 0
                                while _5539 + (32 * stor118.length) > idx:
                                    mem[idx + 32] = stor118[t].field_256
                                    idx = idx + 32
                                    t = t + 1
                                    continue 
                                idx = 0
                                t = 0
                                while idx < stor118.length - 1:
                                    require idx < mem[_5539]
                                    require idx + 1 < mem[_5539]
                                    _20633 = mem[(32 * idx + 1) + _5539 + 32]
                                    mem[mem[64] + 4] = mem[(32 * idx) + _5539 + 44 len 20]
                                    mem[mem[64] + 36] = address(_20633)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_20633)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21012 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_21012] == mem[_21012 + 12 len 20]
                                    require ext_code.size(mem[_21012 + 12 len 20])
                                    staticcall mem[_21012 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _22851 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_22851] == mem[_22851 + 18 len 14]
                                    require mem[_22851 + 32] == mem[_22851 + 50 len 14]
                                    require mem[_22851 + 64] == mem[_22851 + 92 len 4]
                                    require idx < mem[_5539]
                                    require idx + 1 < mem[_5539]
                                    if mem[(32 * idx + 1) + _5539 + 44 len 20] < mem[(32 * idx) + _5539 + 44 len 20]:
                                        if not t:
                                            if mem[_22851 + 50 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_22851 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_22851 + 18 len 14] * t / t != mem[_22851 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_22851 + 50 len 14]:
                                                idx = idx + 1
                                                t = mem[_22851 + 18 len 14] * t / mem[_22851 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_22851')), 14)))
                                    else:
                                        if not t:
                                            if mem[_22851 + 18 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_22851 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_22851 + 50 len 14] * t / t != mem[_22851 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_22851 + 18 len 14]:
                                                idx = idx + 1
                                                t = mem[_22851 + 50 len 14] * t / mem[_22851 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_22851')), 14)))
                                    revert
                        else:
                            if 2 * mem[_5023] / mem[_5023] != 2:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _5655 = mem[64]
                            mem[64] = mem[64] + (32 * stor118.length) + 32
                            mem[_5655] = stor118.length
                            if not stor118.length:
                                idx = 0
                                t = 2 * _5118
                                while idx < stor118.length - 1:
                                    require idx < mem[_5655]
                                    require idx + 1 < mem[_5655]
                                    _9081 = mem[(32 * idx + 1) + _5655 + 32]
                                    mem[mem[64] + 4] = mem[(32 * idx) + _5655 + 44 len 20]
                                    mem[mem[64] + 36] = address(_9081)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_9081)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9418 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_9418] == mem[_9418 + 12 len 20]
                                    require ext_code.size(mem[_9418 + 12 len 20])
                                    staticcall mem[_9418 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10794 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_10794] == mem[_10794 + 18 len 14]
                                    require mem[_10794 + 32] == mem[_10794 + 50 len 14]
                                    require mem[_10794 + 64] == mem[_10794 + 92 len 4]
                                    require idx < mem[_5655]
                                    require idx + 1 < mem[_5655]
                                    if mem[(32 * idx + 1) + _5655 + 44 len 20] < mem[(32 * idx) + _5655 + 44 len 20]:
                                        if not t:
                                            if mem[_10794 + 50 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_10794 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_10794 + 18 len 14] * t / t != mem[_10794 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_10794 + 50 len 14]:
                                                idx = idx + 1
                                                t = mem[_10794 + 18 len 14] * t / mem[_10794 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_10794')), 14)))
                                    else:
                                        if not t:
                                            if mem[_10794 + 18 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_10794 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_10794 + 50 len 14] * t / t != mem[_10794 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_10794 + 18 len 14]:
                                                idx = idx + 1
                                                t = mem[_10794 + 50 len 14] * t / mem[_10794 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_10794')), 14)))
                                    revert
                            else:
                                mem[0] = 118
                                mem[_5655 + 32] = address(stor118.field_0)
                                idx = _5655 + 32
                                t = 0
                                while _5655 + (32 * stor118.length) > idx:
                                    mem[idx + 32] = stor118[t].field_256
                                    idx = idx + 32
                                    t = t + 1
                                    continue 
                                idx = 0
                                t = 2 * _5118
                                while idx < stor118.length - 1:
                                    require idx < mem[_5655]
                                    require idx + 1 < mem[_5655]
                                    _20631 = mem[(32 * idx + 1) + _5655 + 32]
                                    mem[mem[64] + 4] = mem[(32 * idx) + _5655 + 44 len 20]
                                    mem[mem[64] + 36] = address(_20631)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_20631)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21010 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_21010] == mem[_21010 + 12 len 20]
                                    require ext_code.size(mem[_21010 + 12 len 20])
                                    staticcall mem[_21010 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _22848 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_22848] == mem[_22848 + 18 len 14]
                                    require mem[_22848 + 32] == mem[_22848 + 50 len 14]
                                    require mem[_22848 + 64] == mem[_22848 + 92 len 4]
                                    require idx < mem[_5655]
                                    require idx + 1 < mem[_5655]
                                    if mem[(32 * idx + 1) + _5655 + 44 len 20] < mem[(32 * idx) + _5655 + 44 len 20]:
                                        if not t:
                                            if mem[_22848 + 50 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_22848 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_22848 + 18 len 14] * t / t != mem[_22848 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_22848 + 50 len 14]:
                                                idx = idx + 1
                                                t = mem[_22848 + 18 len 14] * t / mem[_22848 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_22848')), 14)))
                                    else:
                                        if not t:
                                            if mem[_22848 + 18 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_22848 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_22848 + 50 len 14] * t / t != mem[_22848 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_22848 + 18 len 14]:
                                                idx = idx + 1
                                                t = mem[_22848 + 50 len 14] * t / mem[_22848 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_22848')), 14)))
                                    revert
                else:
                    mem[0] = 119
                    mem[ceil32(return_data.size) + 384] = address(stor119.field_0)
                    if (32 * stor119.length) + 32 <= 64:
                        idx = 0
                        s = ext_call.return_data[0] - stor42D0 - (0 / rewardsDuration + block.timestamp + -begin + 1)
                        while idx < stor119.length - 1:
                            require idx < mem[ceil32(return_data.size) + 352]
                            require idx + 1 < mem[ceil32(return_data.size) + 352]
                            _4447 = mem[(32 * idx + 1) + ceil32(return_data.size) + 384]
                            mem[mem[64] + 4] = mem[(32 * idx) + ceil32(return_data.size) + 396 len 20]
                            mem[mem[64] + 36] = address(_4447)
                            require ext_code.size(stor117)
                            staticcall stor117.getPair(address rg1, address rg2) with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4], address(_4447)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4582 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_4582] == mem[_4582 + 12 len 20]
                            require ext_code.size(mem[_4582 + 12 len 20])
                            staticcall mem[_4582 + 12 len 20].getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _5028 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_5028] == mem[_5028 + 18 len 14]
                            require mem[_5028 + 32] == mem[_5028 + 50 len 14]
                            require mem[_5028 + 64] == mem[_5028 + 92 len 4]
                            require idx < mem[ceil32(return_data.size) + 352]
                            require idx + 1 < mem[ceil32(return_data.size) + 352]
                            if mem[(32 * idx + 1) + ceil32(return_data.size) + 396 len 20] < mem[(32 * idx) + ceil32(return_data.size) + 396 len 20]:
                                if not s:
                                    if mem[_5028 + 50 len 14]:
                                        idx = idx + 1
                                        s = 0 / mem[_5028 + 50 len 14]
                                        continue 
                                else:
                                    if mem[_5028 + 18 len 14] * s / s != mem[_5028 + 18 len 14]:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if mem[_5028 + 50 len 14]:
                                        idx = idx + 1
                                        s = mem[_5028 + 18 len 14] * s / mem[_5028 + 50 len 14]
                                        continue 
                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_5028')), 14)))
                            else:
                                if not s:
                                    if mem[_5028 + 18 len 14]:
                                        idx = idx + 1
                                        s = 0 / mem[_5028 + 18 len 14]
                                        continue 
                                else:
                                    if mem[_5028 + 50 len 14] * s / s != mem[_5028 + 50 len 14]:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if mem[_5028 + 18 len 14]:
                                        idx = idx + 1
                                        s = mem[_5028 + 50 len 14] * s / mem[_5028 + 18 len 14]
                                        continue 
                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_5028')), 14)))
                            revert
                        require stor118.length
                        mem[0] = 118
                        if address(stor118.field_0) == stakingTokenAddress:
                            _4655 = mem[64]
                            mem[64] = mem[64] + (32 * stor118.length) + 32
                            mem[_4655] = stor118.length
                            if not stor118.length:
                                idx = 0
                                t = totalSupply
                                while idx < stor118.length - 1:
                                    require idx < mem[_4655]
                                    require idx + 1 < mem[_4655]
                                    _9086 = mem[(32 * idx + 1) + _4655 + 32]
                                    mem[mem[64] + 4] = mem[(32 * idx) + _4655 + 44 len 20]
                                    mem[mem[64] + 36] = address(_9086)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_9086)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9423 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_9423] == mem[_9423 + 12 len 20]
                                    require ext_code.size(mem[_9423 + 12 len 20])
                                    staticcall mem[_9423 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10804 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_10804] == mem[_10804 + 18 len 14]
                                    require mem[_10804 + 32] == mem[_10804 + 50 len 14]
                                    require mem[_10804 + 64] == mem[_10804 + 92 len 4]
                                    require idx < mem[_4655]
                                    require idx + 1 < mem[_4655]
                                    if mem[(32 * idx + 1) + _4655 + 44 len 20] < mem[(32 * idx) + _4655 + 44 len 20]:
                                        if not t:
                                            if mem[_10804 + 50 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_10804 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_10804 + 18 len 14] * t / t != mem[_10804 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_10804 + 50 len 14]:
                                                idx = idx + 1
                                                t = mem[_10804 + 18 len 14] * t / mem[_10804 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_10804')), 14)))
                                    else:
                                        if not t:
                                            if mem[_10804 + 18 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_10804 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_10804 + 50 len 14] * t / t != mem[_10804 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_10804 + 18 len 14]:
                                                idx = idx + 1
                                                t = mem[_10804 + 50 len 14] * t / mem[_10804 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_10804')), 14)))
                                    revert
                            else:
                                mem[0] = 118
                                mem[_4655 + 32] = address(stor118.field_0)
                                idx = _4655 + 32
                                t = 0
                                while _4655 + (32 * stor118.length) > idx:
                                    mem[idx + 32] = stor118[t].field_256
                                    idx = idx + 32
                                    t = t + 1
                                    continue 
                                idx = 0
                                t = totalSupply
                                while idx < stor118.length - 1:
                                    require idx < mem[_4655]
                                    require idx + 1 < mem[_4655]
                                    _20641 = mem[(32 * idx + 1) + _4655 + 32]
                                    mem[mem[64] + 4] = mem[(32 * idx) + _4655 + 44 len 20]
                                    mem[mem[64] + 36] = address(_20641)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_20641)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21020 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_21020] == mem[_21020 + 12 len 20]
                                    require ext_code.size(mem[_21020 + 12 len 20])
                                    staticcall mem[_21020 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _22863 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_22863] == mem[_22863 + 18 len 14]
                                    require mem[_22863 + 32] == mem[_22863 + 50 len 14]
                                    require mem[_22863 + 64] == mem[_22863 + 92 len 4]
                                    require idx < mem[_4655]
                                    require idx + 1 < mem[_4655]
                                    if mem[(32 * idx + 1) + _4655 + 44 len 20] < mem[(32 * idx) + _4655 + 44 len 20]:
                                        if not t:
                                            if mem[_22863 + 50 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_22863 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_22863 + 18 len 14] * t / t != mem[_22863 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_22863 + 50 len 14]:
                                                idx = idx + 1
                                                t = mem[_22863 + 18 len 14] * t / mem[_22863 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_22863')), 14)))
                                    else:
                                        if not t:
                                            if mem[_22863 + 18 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_22863 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_22863 + 50 len 14] * t / t != mem[_22863 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_22863 + 18 len 14]:
                                                idx = idx + 1
                                                t = mem[_22863 + 50 len 14] * t / mem[_22863 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_22863')), 14)))
                                    revert
                        else:
                            require stor118.length
                            require stor118.length
                            require address(stor118.field_0) != stakingTokenAddress
                            require 0 < stor118.length
                            mem[0] = 118
                            mem[mem[64] + 4] = stakingTokenAddress
                            require ext_code.size(address(stor118.field_0))
                            staticcall address(stor118.field_0).0x70a08231 with:
                                    gas gas_remaining wei
                                   args stakingTokenAddress
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _5027 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _5121 = mem[_5027]
                            if not mem[_5027]:
                                _5542 = mem[64]
                                mem[64] = mem[64] + (32 * stor118.length) + 32
                                mem[_5542] = stor118.length
                                if not stor118.length:
                                    idx = 0
                                    t = 0
                                    while idx < stor118.length - 1:
                                        require idx < mem[_5542]
                                        require idx + 1 < mem[_5542]
                                        _9090 = mem[(32 * idx + 1) + _5542 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _5542 + 44 len 20]
                                        mem[mem[64] + 36] = address(_9090)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_9090)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9427 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9427] == mem[_9427 + 12 len 20]
                                        require ext_code.size(mem[_9427 + 12 len 20])
                                        staticcall mem[_9427 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _10810 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_10810] == mem[_10810 + 18 len 14]
                                        require mem[_10810 + 32] == mem[_10810 + 50 len 14]
                                        require mem[_10810 + 64] == mem[_10810 + 92 len 4]
                                        require idx < mem[_5542]
                                        require idx + 1 < mem[_5542]
                                        if mem[(32 * idx + 1) + _5542 + 44 len 20] < mem[(32 * idx) + _5542 + 44 len 20]:
                                            if not t:
                                                if mem[_10810 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_10810 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_10810 + 18 len 14] * t / t != mem[_10810 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_10810 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_10810 + 18 len 14] * t / mem[_10810 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_10810')), 14)))
                                        else:
                                            if not t:
                                                if mem[_10810 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_10810 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_10810 + 50 len 14] * t / t != mem[_10810 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_10810 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_10810 + 50 len 14] * t / mem[_10810 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_10810')), 14)))
                                        revert
                                else:
                                    mem[0] = 118
                                    mem[_5542 + 32] = address(stor118.field_0)
                                    idx = _5542 + 32
                                    t = 0
                                    while _5542 + (32 * stor118.length) > idx:
                                        mem[idx + 32] = stor118[t].field_256
                                        idx = idx + 32
                                        t = t + 1
                                        continue 
                                    idx = 0
                                    t = 0
                                    while idx < stor118.length - 1:
                                        require idx < mem[_5542]
                                        require idx + 1 < mem[_5542]
                                        _20645 = mem[(32 * idx + 1) + _5542 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _5542 + 44 len 20]
                                        mem[mem[64] + 36] = address(_20645)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_20645)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21024 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_21024] == mem[_21024 + 12 len 20]
                                        require ext_code.size(mem[_21024 + 12 len 20])
                                        staticcall mem[_21024 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22869 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_22869] == mem[_22869 + 18 len 14]
                                        require mem[_22869 + 32] == mem[_22869 + 50 len 14]
                                        require mem[_22869 + 64] == mem[_22869 + 92 len 4]
                                        require idx < mem[_5542]
                                        require idx + 1 < mem[_5542]
                                        if mem[(32 * idx + 1) + _5542 + 44 len 20] < mem[(32 * idx) + _5542 + 44 len 20]:
                                            if not t:
                                                if mem[_22869 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22869 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_22869 + 18 len 14] * t / t != mem[_22869 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22869 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22869 + 18 len 14] * t / mem[_22869 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_22869')), 14)))
                                        else:
                                            if not t:
                                                if mem[_22869 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22869 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_22869 + 50 len 14] * t / t != mem[_22869 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22869 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22869 + 50 len 14] * t / mem[_22869 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_22869')), 14)))
                                        revert
                            else:
                                if 2 * mem[_5027] / mem[_5027] != 2:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _5660 = mem[64]
                                mem[64] = mem[64] + (32 * stor118.length) + 32
                                mem[_5660] = stor118.length
                                if not stor118.length:
                                    idx = 0
                                    t = 2 * _5121
                                    while idx < stor118.length - 1:
                                        require idx < mem[_5660]
                                        require idx + 1 < mem[_5660]
                                        _9088 = mem[(32 * idx + 1) + _5660 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _5660 + 44 len 20]
                                        mem[mem[64] + 36] = address(_9088)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_9088)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9425 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9425] == mem[_9425 + 12 len 20]
                                        require ext_code.size(mem[_9425 + 12 len 20])
                                        staticcall mem[_9425 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _10807 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_10807] == mem[_10807 + 18 len 14]
                                        require mem[_10807 + 32] == mem[_10807 + 50 len 14]
                                        require mem[_10807 + 64] == mem[_10807 + 92 len 4]
                                        require idx < mem[_5660]
                                        require idx + 1 < mem[_5660]
                                        if mem[(32 * idx + 1) + _5660 + 44 len 20] < mem[(32 * idx) + _5660 + 44 len 20]:
                                            if not t:
                                                if mem[_10807 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_10807 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_10807 + 18 len 14] * t / t != mem[_10807 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_10807 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_10807 + 18 len 14] * t / mem[_10807 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_10807')), 14)))
                                        else:
                                            if not t:
                                                if mem[_10807 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_10807 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_10807 + 50 len 14] * t / t != mem[_10807 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_10807 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_10807 + 50 len 14] * t / mem[_10807 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_10807')), 14)))
                                        revert
                                else:
                                    mem[0] = 118
                                    mem[_5660 + 32] = address(stor118.field_0)
                                    idx = _5660 + 32
                                    t = 0
                                    while _5660 + (32 * stor118.length) > idx:
                                        mem[idx + 32] = stor118[t].field_256
                                        idx = idx + 32
                                        t = t + 1
                                        continue 
                                    idx = 0
                                    t = 2 * _5121
                                    while idx < stor118.length - 1:
                                        require idx < mem[_5660]
                                        require idx + 1 < mem[_5660]
                                        _20643 = mem[(32 * idx + 1) + _5660 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _5660 + 44 len 20]
                                        mem[mem[64] + 36] = address(_20643)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_20643)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21022 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_21022] == mem[_21022 + 12 len 20]
                                        require ext_code.size(mem[_21022 + 12 len 20])
                                        staticcall mem[_21022 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22866 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_22866] == mem[_22866 + 18 len 14]
                                        require mem[_22866 + 32] == mem[_22866 + 50 len 14]
                                        require mem[_22866 + 64] == mem[_22866 + 92 len 4]
                                        require idx < mem[_5660]
                                        require idx + 1 < mem[_5660]
                                        if mem[(32 * idx + 1) + _5660 + 44 len 20] < mem[(32 * idx) + _5660 + 44 len 20]:
                                            if not t:
                                                if mem[_22866 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22866 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_22866 + 18 len 14] * t / t != mem[_22866 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22866 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22866 + 18 len 14] * t / mem[_22866 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_22866')), 14)))
                                        else:
                                            if not t:
                                                if mem[_22866 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22866 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_22866 + 50 len 14] * t / t != mem[_22866 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22866 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22866 + 50 len 14] * t / mem[_22866 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_22866')), 14)))
                                        revert
                    else:
                        mem[ceil32(return_data.size) + 416] = address(stor119.field_256)
                        idx = ceil32(return_data.size) + 416
                        s = 1
                        while ceil32(return_data.size) + (32 * stor119.length) + 352 > idx:
                            mem[idx + 32] = stor119[s].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                        idx = 0
                        s = ext_call.return_data[0] - stor42D0 - (0 / rewardsDuration + block.timestamp + -begin + 1)
                        while idx < stor119.length - 1:
                            require idx < mem[ceil32(return_data.size) + 352]
                            require idx + 1 < mem[ceil32(return_data.size) + 352]
                            _14490 = mem[(32 * idx + 1) + ceil32(return_data.size) + 384]
                            mem[mem[64] + 4] = mem[(32 * idx) + ceil32(return_data.size) + 396 len 20]
                            mem[mem[64] + 36] = address(_14490)
                            require ext_code.size(stor117)
                            staticcall stor117.getPair(address rg1, address rg2) with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4], address(_14490)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _15294 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_15294] == mem[_15294 + 12 len 20]
                            require ext_code.size(mem[_15294 + 12 len 20])
                            staticcall mem[_15294 + 12 len 20].getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _16492 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_16492] == mem[_16492 + 18 len 14]
                            require mem[_16492 + 32] == mem[_16492 + 50 len 14]
                            require mem[_16492 + 64] == mem[_16492 + 92 len 4]
                            require idx < mem[ceil32(return_data.size) + 352]
                            require idx + 1 < mem[ceil32(return_data.size) + 352]
                            if mem[(32 * idx + 1) + ceil32(return_data.size) + 396 len 20] < mem[(32 * idx) + ceil32(return_data.size) + 396 len 20]:
                                if not s:
                                    if mem[_16492 + 50 len 14]:
                                        idx = idx + 1
                                        s = 0 / mem[_16492 + 50 len 14]
                                        continue 
                                else:
                                    if mem[_16492 + 18 len 14] * s / s != mem[_16492 + 18 len 14]:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if mem[_16492 + 50 len 14]:
                                        idx = idx + 1
                                        s = mem[_16492 + 18 len 14] * s / mem[_16492 + 50 len 14]
                                        continue 
                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_16492')), 14)))
                            else:
                                if not s:
                                    if mem[_16492 + 18 len 14]:
                                        idx = idx + 1
                                        s = 0 / mem[_16492 + 18 len 14]
                                        continue 
                                else:
                                    if mem[_16492 + 50 len 14] * s / s != mem[_16492 + 50 len 14]:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if mem[_16492 + 18 len 14]:
                                        idx = idx + 1
                                        s = mem[_16492 + 50 len 14] * s / mem[_16492 + 18 len 14]
                                        continue 
                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_16492')), 14)))
                            revert
                        require stor118.length
                        mem[0] = 118
                        if address(stor118.field_0) == stakingTokenAddress:
                            _15465 = mem[64]
                            mem[64] = mem[64] + (32 * stor118.length) + 32
                            mem[_15465] = stor118.length
                            if not stor118.length:
                                idx = 0
                                t = totalSupply
                                while idx < stor118.length - 1:
                                    require idx < mem[_15465]
                                    require idx + 1 < mem[_15465]
                                    _20635 = mem[(32 * idx + 1) + _15465 + 32]
                                    mem[mem[64] + 4] = mem[(32 * idx) + _15465 + 44 len 20]
                                    mem[mem[64] + 36] = address(_20635)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_20635)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21014 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_21014] == mem[_21014 + 12 len 20]
                                    require ext_code.size(mem[_21014 + 12 len 20])
                                    staticcall mem[_21014 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _22854 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_22854] == mem[_22854 + 18 len 14]
                                    require mem[_22854 + 32] == mem[_22854 + 50 len 14]
                                    require mem[_22854 + 64] == mem[_22854 + 92 len 4]
                                    require idx < mem[_15465]
                                    require idx + 1 < mem[_15465]
                                    if mem[(32 * idx + 1) + _15465 + 44 len 20] < mem[(32 * idx) + _15465 + 44 len 20]:
                                        if not t:
                                            if mem[_22854 + 50 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_22854 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_22854 + 18 len 14] * t / t != mem[_22854 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_22854 + 50 len 14]:
                                                idx = idx + 1
                                                t = mem[_22854 + 18 len 14] * t / mem[_22854 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_22854')), 14)))
                                    else:
                                        if not t:
                                            if mem[_22854 + 18 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_22854 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_22854 + 50 len 14] * t / t != mem[_22854 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_22854 + 18 len 14]:
                                                idx = idx + 1
                                                t = mem[_22854 + 50 len 14] * t / mem[_22854 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_22854')), 14)))
                                    revert
                                if s:
                                    if 10^18 * s / s != 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not t:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    return (10^18 * s / t)
                                if t:
                                    return (0 / t)
                                var90001 = 32
                                revert with 0, 'SafeMath: division by zero', 0
                            mem[0] = 118
                            mem[_15465 + 32] = address(stor118.field_0)
                            idx = _15465 + 32
                            t = 0
                            while _15465 + (32 * stor118.length) > idx:
                                mem[idx + 32] = stor118[t].field_256
                                idx = idx + 32
                                t = t + 1
                                continue 
                            idx = 0
                            t = totalSupply
                            while idx < stor118.length - 1:
                                require idx < mem[_15465]
                                require idx + 1 < mem[_15465]
                                _27729 = mem[(32 * idx + 1) + _15465 + 32]
                                mem[mem[64] + 4] = mem[(32 * idx) + _15465 + 44 len 20]
                                mem[mem[64] + 36] = address(_27729)
                                require ext_code.size(stor117)
                                staticcall stor117.getPair(address rg1, address rg2) with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4], address(_27729)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _27856 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_27856] == mem[_27856 + 12 len 20]
                                require ext_code.size(mem[_27856 + 12 len 20])
                                staticcall mem[_27856 + 12 len 20].getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _28469 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_28469] == mem[_28469 + 18 len 14]
                                require mem[_28469 + 32] == mem[_28469 + 50 len 14]
                                require mem[_28469 + 64] == mem[_28469 + 92 len 4]
                                require idx < mem[_15465]
                                require idx + 1 < mem[_15465]
                                if mem[(32 * idx + 1) + _15465 + 44 len 20] < mem[(32 * idx) + _15465 + 44 len 20]:
                                    if not t:
                                        if mem[_28469 + 50 len 14]:
                                            idx = idx + 1
                                            t = 0 / mem[_28469 + 50 len 14]
                                            continue 
                                    else:
                                        if mem[_28469 + 18 len 14] * t / t != mem[_28469 + 18 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_28469 + 50 len 14]:
                                            idx = idx + 1
                                            t = mem[_28469 + 18 len 14] * t / mem[_28469 + 50 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_28469')), 14)))
                                else:
                                    if not t:
                                        if mem[_28469 + 18 len 14]:
                                            idx = idx + 1
                                            t = 0 / mem[_28469 + 18 len 14]
                                            continue 
                                    else:
                                        if mem[_28469 + 50 len 14] * t / t != mem[_28469 + 50 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_28469 + 18 len 14]:
                                            idx = idx + 1
                                            t = mem[_28469 + 50 len 14] * t / mem[_28469 + 18 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_28469')), 14)))
                                revert
                        else:
                            require stor118.length
                            require stor118.length
                            require address(stor118.field_0) != stakingTokenAddress
                            require 0 < stor118.length
                            mem[0] = 118
                            mem[mem[64] + 4] = stakingTokenAddress
                            require ext_code.size(address(stor118.field_0))
                            staticcall address(stor118.field_0).0x70a08231 with:
                                    gas gas_remaining wei
                                   args stakingTokenAddress
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _16491 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _16880 = mem[_16491]
                            if not mem[_16491]:
                                _17795 = mem[64]
                                mem[64] = mem[64] + (32 * stor118.length) + 32
                                mem[_17795] = stor118.length
                                if not stor118.length:
                                    idx = 0
                                    t = 0
                                    while idx < stor118.length - 1:
                                        require idx < mem[_17795]
                                        require idx + 1 < mem[_17795]
                                        _20639 = mem[(32 * idx + 1) + _17795 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _17795 + 44 len 20]
                                        mem[mem[64] + 36] = address(_20639)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_20639)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21018 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_21018] == mem[_21018 + 12 len 20]
                                        require ext_code.size(mem[_21018 + 12 len 20])
                                        staticcall mem[_21018 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22860 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_22860] == mem[_22860 + 18 len 14]
                                        require mem[_22860 + 32] == mem[_22860 + 50 len 14]
                                        require mem[_22860 + 64] == mem[_22860 + 92 len 4]
                                        require idx < mem[_17795]
                                        require idx + 1 < mem[_17795]
                                        if mem[(32 * idx + 1) + _17795 + 44 len 20] < mem[(32 * idx) + _17795 + 44 len 20]:
                                            if not t:
                                                if mem[_22860 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22860 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_22860 + 18 len 14] * t / t != mem[_22860 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22860 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22860 + 18 len 14] * t / mem[_22860 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_22860')), 14)))
                                        else:
                                            if not t:
                                                if mem[_22860 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22860 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_22860 + 50 len 14] * t / t != mem[_22860 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22860 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22860 + 50 len 14] * t / mem[_22860 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_22860')), 14)))
                                        revert
                                    if not s:
                                        if not t:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        return (0 / t)
                                    if 10^18 * s / s != 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not t:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    return (10^18 * s / t)
                                mem[0] = 118
                                mem[_17795 + 32] = address(stor118.field_0)
                                idx = _17795 + 32
                                t = 0
                                while _17795 + (32 * stor118.length) > idx:
                                    mem[idx + 32] = stor118[t].field_256
                                    idx = idx + 32
                                    t = t + 1
                                    continue 
                                idx = 0
                                t = 0
                                while idx < stor118.length - 1:
                                    require idx < mem[_17795]
                                    require idx + 1 < mem[_17795]
                                    _27733 = mem[(32 * idx + 1) + _17795 + 32]
                                    mem[mem[64] + 4] = mem[(32 * idx) + _17795 + 44 len 20]
                                    mem[mem[64] + 36] = address(_27733)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_27733)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _27860 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_27860] == mem[_27860 + 12 len 20]
                                    require ext_code.size(mem[_27860 + 12 len 20])
                                    staticcall mem[_27860 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _28475 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_28475] == mem[_28475 + 18 len 14]
                                    require mem[_28475 + 32] == mem[_28475 + 50 len 14]
                                    require mem[_28475 + 64] == mem[_28475 + 92 len 4]
                                    require idx < mem[_17795]
                                    require idx + 1 < mem[_17795]
                                    if mem[(32 * idx + 1) + _17795 + 44 len 20] < mem[(32 * idx) + _17795 + 44 len 20]:
                                        if not t:
                                            if mem[_28475 + 50 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_28475 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_28475 + 18 len 14] * t / t != mem[_28475 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_28475 + 50 len 14]:
                                                idx = idx + 1
                                                t = mem[_28475 + 18 len 14] * t / mem[_28475 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_28475')), 14)))
                                    else:
                                        if not t:
                                            if mem[_28475 + 18 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_28475 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_28475 + 50 len 14] * t / t != mem[_28475 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_28475 + 18 len 14]:
                                                idx = idx + 1
                                                t = mem[_28475 + 50 len 14] * t / mem[_28475 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_28475')), 14)))
                                    revert
                                if s:
                                    if 10^18 * s / s != 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not t:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    return (10^18 * s / t)
                                if t:
                                    return (0 / t)
                                var109001 = 32
                                revert with 0, 'SafeMath: division by zero', 0
                            if 2 * mem[_16491] / mem[_16491] != 2:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _17904 = mem[64]
                            mem[64] = mem[64] + (32 * stor118.length) + 32
                            mem[_17904] = stor118.length
                            if not stor118.length:
                                idx = 0
                                t = 2 * _16880
                                while idx < stor118.length - 1:
                                    require idx < mem[_17904]
                                    require idx + 1 < mem[_17904]
                                    _20637 = mem[(32 * idx + 1) + _17904 + 32]
                                    mem[mem[64] + 4] = mem[(32 * idx) + _17904 + 44 len 20]
                                    mem[mem[64] + 36] = address(_20637)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_20637)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21016 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_21016] == mem[_21016 + 12 len 20]
                                    require ext_code.size(mem[_21016 + 12 len 20])
                                    staticcall mem[_21016 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _22857 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_22857] == mem[_22857 + 18 len 14]
                                    require mem[_22857 + 32] == mem[_22857 + 50 len 14]
                                    require mem[_22857 + 64] == mem[_22857 + 92 len 4]
                                    require idx < mem[_17904]
                                    require idx + 1 < mem[_17904]
                                    if mem[(32 * idx + 1) + _17904 + 44 len 20] < mem[(32 * idx) + _17904 + 44 len 20]:
                                        if not t:
                                            if mem[_22857 + 50 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_22857 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_22857 + 18 len 14] * t / t != mem[_22857 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_22857 + 50 len 14]:
                                                idx = idx + 1
                                                t = mem[_22857 + 18 len 14] * t / mem[_22857 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_22857')), 14)))
                                    else:
                                        if not t:
                                            if mem[_22857 + 18 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_22857 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_22857 + 50 len 14] * t / t != mem[_22857 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_22857 + 18 len 14]:
                                                idx = idx + 1
                                                t = mem[_22857 + 50 len 14] * t / mem[_22857 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_22857')), 14)))
                                    revert
                            else:
                                mem[0] = 118
                                mem[_17904 + 32] = address(stor118.field_0)
                                idx = _17904 + 32
                                t = 0
                                while _17904 + (32 * stor118.length) > idx:
                                    mem[idx + 32] = stor118[t].field_256
                                    idx = idx + 32
                                    t = t + 1
                                    continue 
                                idx = 0
                                t = 2 * _16880
                                while idx < stor118.length - 1:
                                    require idx < mem[_17904]
                                    require idx + 1 < mem[_17904]
                                    _27731 = mem[(32 * idx + 1) + _17904 + 32]
                                    mem[mem[64] + 4] = mem[(32 * idx) + _17904 + 44 len 20]
                                    mem[mem[64] + 36] = address(_27731)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_27731)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _27858 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_27858] == mem[_27858 + 12 len 20]
                                    require ext_code.size(mem[_27858 + 12 len 20])
                                    staticcall mem[_27858 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _28472 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_28472] == mem[_28472 + 18 len 14]
                                    require mem[_28472 + 32] == mem[_28472 + 50 len 14]
                                    require mem[_28472 + 64] == mem[_28472 + 92 len 4]
                                    require idx < mem[_17904]
                                    require idx + 1 < mem[_17904]
                                    if mem[(32 * idx + 1) + _17904 + 44 len 20] < mem[(32 * idx) + _17904 + 44 len 20]:
                                        if not t:
                                            if mem[_28472 + 50 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_28472 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_28472 + 18 len 14] * t / t != mem[_28472 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_28472 + 50 len 14]:
                                                idx = idx + 1
                                                t = mem[_28472 + 18 len 14] * t / mem[_28472 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_28472')), 14)))
                                    else:
                                        if not t:
                                            if mem[_28472 + 18 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_28472 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_28472 + 50 len 14] * t / t != mem[_28472 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_28472 + 18 len 14]:
                                                idx = idx + 1
                                                t = mem[_28472 + 50 len 14] * t / mem[_28472 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_28472')), 14)))
                                    revert
            else:
                if (8760 * 24 * 3600 * ext_call.return_data[0]) - (8760 * 24 * 3600 * stor42D0) / ext_call.return_data[0] - stor42D0 != 8760 * 24 * 3600:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not (8760 * 24 * 3600 * ext_call.return_data[0]) - (8760 * 24 * 3600 * stor42D0):
                    mem[ceil32(return_data.size) + 224] = 26
                    mem[ceil32(return_data.size) + 256] = 'SafeMath: division by zero'
                    if not rewardsDuration + block.timestamp + -begin + 1:
                        revert with 0, 'SafeMath: division by zero', 0
                    mem[ceil32(return_data.size) + 288] = 30
                    mem[ceil32(return_data.size) + 320] = 'SafeMath: subtraction overflow'
                    if 0 / rewardsDuration + block.timestamp + -begin + 1 > ext_call.return_data[0] - stor42D0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    require 0 < stor119.length
                    mem[0] = 119
                    require address(stor119.field_0) == rewardsTokenAddress
                    mem[64] = ceil32(return_data.size) + (32 * stor119.length) + 384
                    mem[ceil32(return_data.size) + 352] = stor119.length
                    if not stor119.length:
                        idx = 0
                        s = ext_call.return_data[0] - stor42D0 - (0 / rewardsDuration + block.timestamp + -begin + 1)
                        while idx < stor119.length - 1:
                            require idx < mem[ceil32(return_data.size) + 352]
                            require idx + 1 < mem[ceil32(return_data.size) + 352]
                            _4441 = mem[(32 * idx + 1) + ceil32(return_data.size) + 384]
                            mem[mem[64] + 4] = mem[(32 * idx) + ceil32(return_data.size) + 396 len 20]
                            mem[mem[64] + 36] = address(_4441)
                            require ext_code.size(stor117)
                            staticcall stor117.getPair(address rg1, address rg2) with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4], address(_4441)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4579 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_4579] == mem[_4579 + 12 len 20]
                            require ext_code.size(mem[_4579 + 12 len 20])
                            staticcall mem[_4579 + 12 len 20].getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _5016 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_5016] == mem[_5016 + 18 len 14]
                            require mem[_5016 + 32] == mem[_5016 + 50 len 14]
                            require mem[_5016 + 64] == mem[_5016 + 92 len 4]
                            require idx < mem[ceil32(return_data.size) + 352]
                            require idx + 1 < mem[ceil32(return_data.size) + 352]
                            if mem[(32 * idx + 1) + ceil32(return_data.size) + 396 len 20] < mem[(32 * idx) + ceil32(return_data.size) + 396 len 20]:
                                if not s:
                                    if mem[_5016 + 50 len 14]:
                                        idx = idx + 1
                                        s = 0 / mem[_5016 + 50 len 14]
                                        continue 
                                else:
                                    if mem[_5016 + 18 len 14] * s / s != mem[_5016 + 18 len 14]:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if mem[_5016 + 50 len 14]:
                                        idx = idx + 1
                                        s = mem[_5016 + 18 len 14] * s / mem[_5016 + 50 len 14]
                                        continue 
                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_5016')), 14)))
                            else:
                                if not s:
                                    if mem[_5016 + 18 len 14]:
                                        idx = idx + 1
                                        s = 0 / mem[_5016 + 18 len 14]
                                        continue 
                                else:
                                    if mem[_5016 + 50 len 14] * s / s != mem[_5016 + 50 len 14]:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if mem[_5016 + 18 len 14]:
                                        idx = idx + 1
                                        s = mem[_5016 + 50 len 14] * s / mem[_5016 + 18 len 14]
                                        continue 
                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_5016')), 14)))
                            revert
                        require stor118.length
                        mem[0] = 118
                        if address(stor118.field_0) == stakingTokenAddress:
                            _4649 = mem[64]
                            mem[64] = mem[64] + (32 * stor118.length) + 32
                            mem[_4649] = stor118.length
                            if not stor118.length:
                                idx = 0
                                t = totalSupply
                                while idx < stor118.length - 1:
                                    require idx < mem[_4649]
                                    require idx + 1 < mem[_4649]
                                    _9066 = mem[(32 * idx + 1) + _4649 + 32]
                                    mem[mem[64] + 4] = mem[(32 * idx) + _4649 + 44 len 20]
                                    mem[mem[64] + 36] = address(_9066)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_9066)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9403 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_9403] == mem[_9403 + 12 len 20]
                                    require ext_code.size(mem[_9403 + 12 len 20])
                                    staticcall mem[_9403 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10769 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_10769] == mem[_10769 + 18 len 14]
                                    require mem[_10769 + 32] == mem[_10769 + 50 len 14]
                                    require mem[_10769 + 64] == mem[_10769 + 92 len 4]
                                    require idx < mem[_4649]
                                    require idx + 1 < mem[_4649]
                                    if mem[(32 * idx + 1) + _4649 + 44 len 20] < mem[(32 * idx) + _4649 + 44 len 20]:
                                        if not t:
                                            if mem[_10769 + 50 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_10769 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_10769 + 18 len 14] * t / t != mem[_10769 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_10769 + 50 len 14]:
                                                idx = idx + 1
                                                t = mem[_10769 + 18 len 14] * t / mem[_10769 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_10769')), 14)))
                                    else:
                                        if not t:
                                            if mem[_10769 + 18 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_10769 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_10769 + 50 len 14] * t / t != mem[_10769 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_10769 + 18 len 14]:
                                                idx = idx + 1
                                                t = mem[_10769 + 50 len 14] * t / mem[_10769 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_10769')), 14)))
                                    revert
                            else:
                                mem[0] = 118
                                mem[_4649 + 32] = address(stor118.field_0)
                                idx = _4649 + 32
                                t = 0
                                while _4649 + (32 * stor118.length) > idx:
                                    mem[idx + 32] = stor118[t].field_256
                                    idx = idx + 32
                                    t = t + 1
                                    continue 
                                idx = 0
                                t = totalSupply
                                while idx < stor118.length - 1:
                                    require idx < mem[_4649]
                                    require idx + 1 < mem[_4649]
                                    _20611 = mem[(32 * idx + 1) + _4649 + 32]
                                    mem[mem[64] + 4] = mem[(32 * idx) + _4649 + 44 len 20]
                                    mem[mem[64] + 36] = address(_20611)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_20611)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _20990 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_20990] == mem[_20990 + 12 len 20]
                                    require ext_code.size(mem[_20990 + 12 len 20])
                                    staticcall mem[_20990 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _22818 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_22818] == mem[_22818 + 18 len 14]
                                    require mem[_22818 + 32] == mem[_22818 + 50 len 14]
                                    require mem[_22818 + 64] == mem[_22818 + 92 len 4]
                                    require idx < mem[_4649]
                                    require idx + 1 < mem[_4649]
                                    if mem[(32 * idx + 1) + _4649 + 44 len 20] < mem[(32 * idx) + _4649 + 44 len 20]:
                                        if not t:
                                            if mem[_22818 + 50 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_22818 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_22818 + 18 len 14] * t / t != mem[_22818 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_22818 + 50 len 14]:
                                                idx = idx + 1
                                                t = mem[_22818 + 18 len 14] * t / mem[_22818 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_22818')), 14)))
                                    else:
                                        if not t:
                                            if mem[_22818 + 18 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_22818 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_22818 + 50 len 14] * t / t != mem[_22818 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_22818 + 18 len 14]:
                                                idx = idx + 1
                                                t = mem[_22818 + 50 len 14] * t / mem[_22818 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_22818')), 14)))
                                    revert
                        else:
                            require stor118.length
                            require stor118.length
                            require address(stor118.field_0) != stakingTokenAddress
                            require 0 < stor118.length
                            mem[0] = 118
                            mem[mem[64] + 4] = stakingTokenAddress
                            require ext_code.size(address(stor118.field_0))
                            staticcall address(stor118.field_0).0x70a08231 with:
                                    gas gas_remaining wei
                                   args stakingTokenAddress
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _5015 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _5112 = mem[_5015]
                            if not mem[_5015]:
                                _5533 = mem[64]
                                mem[64] = mem[64] + (32 * stor118.length) + 32
                                mem[_5533] = stor118.length
                                if not stor118.length:
                                    idx = 0
                                    t = 0
                                    while idx < stor118.length - 1:
                                        require idx < mem[_5533]
                                        require idx + 1 < mem[_5533]
                                        _9070 = mem[(32 * idx + 1) + _5533 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _5533 + 44 len 20]
                                        mem[mem[64] + 36] = address(_9070)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_9070)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9407 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9407] == mem[_9407 + 12 len 20]
                                        require ext_code.size(mem[_9407 + 12 len 20])
                                        staticcall mem[_9407 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _10775 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_10775] == mem[_10775 + 18 len 14]
                                        require mem[_10775 + 32] == mem[_10775 + 50 len 14]
                                        require mem[_10775 + 64] == mem[_10775 + 92 len 4]
                                        require idx < mem[_5533]
                                        require idx + 1 < mem[_5533]
                                        if mem[(32 * idx + 1) + _5533 + 44 len 20] < mem[(32 * idx) + _5533 + 44 len 20]:
                                            if not t:
                                                if mem[_10775 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_10775 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_10775 + 18 len 14] * t / t != mem[_10775 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_10775 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_10775 + 18 len 14] * t / mem[_10775 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_10775')), 14)))
                                        else:
                                            if not t:
                                                if mem[_10775 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_10775 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_10775 + 50 len 14] * t / t != mem[_10775 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_10775 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_10775 + 50 len 14] * t / mem[_10775 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_10775')), 14)))
                                        revert
                                else:
                                    mem[0] = 118
                                    mem[_5533 + 32] = address(stor118.field_0)
                                    idx = _5533 + 32
                                    t = 0
                                    while _5533 + (32 * stor118.length) > idx:
                                        mem[idx + 32] = stor118[t].field_256
                                        idx = idx + 32
                                        t = t + 1
                                        continue 
                                    idx = 0
                                    t = 0
                                    while idx < stor118.length - 1:
                                        require idx < mem[_5533]
                                        require idx + 1 < mem[_5533]
                                        _20615 = mem[(32 * idx + 1) + _5533 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _5533 + 44 len 20]
                                        mem[mem[64] + 36] = address(_20615)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_20615)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20994 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20994] == mem[_20994 + 12 len 20]
                                        require ext_code.size(mem[_20994 + 12 len 20])
                                        staticcall mem[_20994 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22824 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_22824] == mem[_22824 + 18 len 14]
                                        require mem[_22824 + 32] == mem[_22824 + 50 len 14]
                                        require mem[_22824 + 64] == mem[_22824 + 92 len 4]
                                        require idx < mem[_5533]
                                        require idx + 1 < mem[_5533]
                                        if mem[(32 * idx + 1) + _5533 + 44 len 20] < mem[(32 * idx) + _5533 + 44 len 20]:
                                            if not t:
                                                if mem[_22824 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22824 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_22824 + 18 len 14] * t / t != mem[_22824 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22824 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22824 + 18 len 14] * t / mem[_22824 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_22824')), 14)))
                                        else:
                                            if not t:
                                                if mem[_22824 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22824 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_22824 + 50 len 14] * t / t != mem[_22824 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22824 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22824 + 50 len 14] * t / mem[_22824 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_22824')), 14)))
                                        revert
                            else:
                                if 2 * mem[_5015] / mem[_5015] != 2:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _5645 = mem[64]
                                mem[64] = mem[64] + (32 * stor118.length) + 32
                                mem[_5645] = stor118.length
                                if not stor118.length:
                                    idx = 0
                                    t = 2 * _5112
                                    while idx < stor118.length - 1:
                                        require idx < mem[_5645]
                                        require idx + 1 < mem[_5645]
                                        _9068 = mem[(32 * idx + 1) + _5645 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _5645 + 44 len 20]
                                        mem[mem[64] + 36] = address(_9068)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_9068)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9405 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9405] == mem[_9405 + 12 len 20]
                                        require ext_code.size(mem[_9405 + 12 len 20])
                                        staticcall mem[_9405 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _10772 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_10772] == mem[_10772 + 18 len 14]
                                        require mem[_10772 + 32] == mem[_10772 + 50 len 14]
                                        require mem[_10772 + 64] == mem[_10772 + 92 len 4]
                                        require idx < mem[_5645]
                                        require idx + 1 < mem[_5645]
                                        if mem[(32 * idx + 1) + _5645 + 44 len 20] < mem[(32 * idx) + _5645 + 44 len 20]:
                                            if not t:
                                                if mem[_10772 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_10772 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_10772 + 18 len 14] * t / t != mem[_10772 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_10772 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_10772 + 18 len 14] * t / mem[_10772 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_10772')), 14)))
                                        else:
                                            if not t:
                                                if mem[_10772 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_10772 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_10772 + 50 len 14] * t / t != mem[_10772 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_10772 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_10772 + 50 len 14] * t / mem[_10772 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_10772')), 14)))
                                        revert
                                else:
                                    mem[0] = 118
                                    mem[_5645 + 32] = address(stor118.field_0)
                                    idx = _5645 + 32
                                    t = 0
                                    while _5645 + (32 * stor118.length) > idx:
                                        mem[idx + 32] = stor118[t].field_256
                                        idx = idx + 32
                                        t = t + 1
                                        continue 
                                    idx = 0
                                    t = 2 * _5112
                                    while idx < stor118.length - 1:
                                        require idx < mem[_5645]
                                        require idx + 1 < mem[_5645]
                                        _20613 = mem[(32 * idx + 1) + _5645 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _5645 + 44 len 20]
                                        mem[mem[64] + 36] = address(_20613)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_20613)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20992 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20992] == mem[_20992 + 12 len 20]
                                        require ext_code.size(mem[_20992 + 12 len 20])
                                        staticcall mem[_20992 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22821 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_22821] == mem[_22821 + 18 len 14]
                                        require mem[_22821 + 32] == mem[_22821 + 50 len 14]
                                        require mem[_22821 + 64] == mem[_22821 + 92 len 4]
                                        require idx < mem[_5645]
                                        require idx + 1 < mem[_5645]
                                        if mem[(32 * idx + 1) + _5645 + 44 len 20] < mem[(32 * idx) + _5645 + 44 len 20]:
                                            if not t:
                                                if mem[_22821 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22821 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_22821 + 18 len 14] * t / t != mem[_22821 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22821 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22821 + 18 len 14] * t / mem[_22821 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_22821')), 14)))
                                        else:
                                            if not t:
                                                if mem[_22821 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22821 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_22821 + 50 len 14] * t / t != mem[_22821 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22821 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22821 + 50 len 14] * t / mem[_22821 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_22821')), 14)))
                                        revert
                    else:
                        mem[0] = 119
                        mem[ceil32(return_data.size) + 384] = address(stor119.field_0)
                        if (32 * stor119.length) + 32 <= 64:
                            idx = 0
                            s = ext_call.return_data[0] - stor42D0 - (0 / rewardsDuration + block.timestamp + -begin + 1)
                            while idx < stor119.length - 1:
                                require idx < mem[ceil32(return_data.size) + 352]
                                require idx + 1 < mem[ceil32(return_data.size) + 352]
                                _4443 = mem[(32 * idx + 1) + ceil32(return_data.size) + 384]
                                mem[mem[64] + 4] = mem[(32 * idx) + ceil32(return_data.size) + 396 len 20]
                                mem[mem[64] + 36] = address(_4443)
                                require ext_code.size(stor117)
                                staticcall stor117.getPair(address rg1, address rg2) with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4], address(_4443)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4580 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_4580] == mem[_4580 + 12 len 20]
                                require ext_code.size(mem[_4580 + 12 len 20])
                                staticcall mem[_4580 + 12 len 20].getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5020 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_5020] == mem[_5020 + 18 len 14]
                                require mem[_5020 + 32] == mem[_5020 + 50 len 14]
                                require mem[_5020 + 64] == mem[_5020 + 92 len 4]
                                require idx < mem[ceil32(return_data.size) + 352]
                                require idx + 1 < mem[ceil32(return_data.size) + 352]
                                if mem[(32 * idx + 1) + ceil32(return_data.size) + 396 len 20] < mem[(32 * idx) + ceil32(return_data.size) + 396 len 20]:
                                    if not s:
                                        if mem[_5020 + 50 len 14]:
                                            idx = idx + 1
                                            s = 0 / mem[_5020 + 50 len 14]
                                            continue 
                                    else:
                                        if mem[_5020 + 18 len 14] * s / s != mem[_5020 + 18 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_5020 + 50 len 14]:
                                            idx = idx + 1
                                            s = mem[_5020 + 18 len 14] * s / mem[_5020 + 50 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_5020')), 14)))
                                else:
                                    if not s:
                                        if mem[_5020 + 18 len 14]:
                                            idx = idx + 1
                                            s = 0 / mem[_5020 + 18 len 14]
                                            continue 
                                    else:
                                        if mem[_5020 + 50 len 14] * s / s != mem[_5020 + 50 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_5020 + 18 len 14]:
                                            idx = idx + 1
                                            s = mem[_5020 + 50 len 14] * s / mem[_5020 + 18 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_5020')), 14)))
                                revert
                            require stor118.length
                            mem[0] = 118
                            if address(stor118.field_0) == stakingTokenAddress:
                                _4651 = mem[64]
                                mem[64] = mem[64] + (32 * stor118.length) + 32
                                mem[_4651] = stor118.length
                                if not stor118.length:
                                    idx = 0
                                    t = totalSupply
                                    while idx < stor118.length - 1:
                                        require idx < mem[_4651]
                                        require idx + 1 < mem[_4651]
                                        _9073 = mem[(32 * idx + 1) + _4651 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _4651 + 44 len 20]
                                        mem[mem[64] + 36] = address(_9073)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_9073)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9410 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9410] == mem[_9410 + 12 len 20]
                                        require ext_code.size(mem[_9410 + 12 len 20])
                                        staticcall mem[_9410 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _10782 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_10782] == mem[_10782 + 18 len 14]
                                        require mem[_10782 + 32] == mem[_10782 + 50 len 14]
                                        require mem[_10782 + 64] == mem[_10782 + 92 len 4]
                                        require idx < mem[_4651]
                                        require idx + 1 < mem[_4651]
                                        if mem[(32 * idx + 1) + _4651 + 44 len 20] < mem[(32 * idx) + _4651 + 44 len 20]:
                                            if not t:
                                                if mem[_10782 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_10782 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_10782 + 18 len 14] * t / t != mem[_10782 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_10782 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_10782 + 18 len 14] * t / mem[_10782 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_10782')), 14)))
                                        else:
                                            if not t:
                                                if mem[_10782 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_10782 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_10782 + 50 len 14] * t / t != mem[_10782 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_10782 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_10782 + 50 len 14] * t / mem[_10782 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_10782')), 14)))
                                        revert
                                else:
                                    mem[0] = 118
                                    mem[_4651 + 32] = address(stor118.field_0)
                                    idx = _4651 + 32
                                    t = 0
                                    while _4651 + (32 * stor118.length) > idx:
                                        mem[idx + 32] = stor118[t].field_256
                                        idx = idx + 32
                                        t = t + 1
                                        continue 
                                    idx = 0
                                    t = totalSupply
                                    while idx < stor118.length - 1:
                                        require idx < mem[_4651]
                                        require idx + 1 < mem[_4651]
                                        _20623 = mem[(32 * idx + 1) + _4651 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _4651 + 44 len 20]
                                        mem[mem[64] + 36] = address(_20623)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_20623)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21002 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_21002] == mem[_21002 + 12 len 20]
                                        require ext_code.size(mem[_21002 + 12 len 20])
                                        staticcall mem[_21002 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22836 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_22836] == mem[_22836 + 18 len 14]
                                        require mem[_22836 + 32] == mem[_22836 + 50 len 14]
                                        require mem[_22836 + 64] == mem[_22836 + 92 len 4]
                                        require idx < mem[_4651]
                                        require idx + 1 < mem[_4651]
                                        if mem[(32 * idx + 1) + _4651 + 44 len 20] < mem[(32 * idx) + _4651 + 44 len 20]:
                                            if not t:
                                                if mem[_22836 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22836 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_22836 + 18 len 14] * t / t != mem[_22836 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22836 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22836 + 18 len 14] * t / mem[_22836 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_22836')), 14)))
                                        else:
                                            if not t:
                                                if mem[_22836 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22836 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_22836 + 50 len 14] * t / t != mem[_22836 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22836 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22836 + 50 len 14] * t / mem[_22836 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_22836')), 14)))
                                        revert
                            else:
                                require stor118.length
                                require stor118.length
                                require address(stor118.field_0) != stakingTokenAddress
                                require 0 < stor118.length
                                mem[0] = 118
                                mem[mem[64] + 4] = stakingTokenAddress
                                require ext_code.size(address(stor118.field_0))
                                staticcall address(stor118.field_0).0x70a08231 with:
                                        gas gas_remaining wei
                                       args stakingTokenAddress
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5019 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _5115 = mem[_5019]
                                if not mem[_5019]:
                                    _5536 = mem[64]
                                    mem[64] = mem[64] + (32 * stor118.length) + 32
                                    mem[_5536] = stor118.length
                                    if not stor118.length:
                                        idx = 0
                                        t = 0
                                        while idx < stor118.length - 1:
                                            require idx < mem[_5536]
                                            require idx + 1 < mem[_5536]
                                            _9077 = mem[(32 * idx + 1) + _5536 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _5536 + 44 len 20]
                                            mem[mem[64] + 36] = address(_9077)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_9077)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9414 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9414] == mem[_9414 + 12 len 20]
                                            require ext_code.size(mem[_9414 + 12 len 20])
                                            staticcall mem[_9414 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _10788 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_10788] == mem[_10788 + 18 len 14]
                                            require mem[_10788 + 32] == mem[_10788 + 50 len 14]
                                            require mem[_10788 + 64] == mem[_10788 + 92 len 4]
                                            require idx < mem[_5536]
                                            require idx + 1 < mem[_5536]
                                            if mem[(32 * idx + 1) + _5536 + 44 len 20] < mem[(32 * idx) + _5536 + 44 len 20]:
                                                if not t:
                                                    if mem[_10788 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10788 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10788 + 18 len 14] * t / t != mem[_10788 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10788 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10788 + 18 len 14] * t / mem[_10788 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_10788')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_10788 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10788 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10788 + 50 len 14] * t / t != mem[_10788 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10788 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10788 + 50 len 14] * t / mem[_10788 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_10788')), 14)))
                                            revert
                                    else:
                                        mem[0] = 118
                                        mem[_5536 + 32] = address(stor118.field_0)
                                        idx = _5536 + 32
                                        t = 0
                                        while _5536 + (32 * stor118.length) > idx:
                                            mem[idx + 32] = stor118[t].field_256
                                            idx = idx + 32
                                            t = t + 1
                                            continue 
                                        idx = 0
                                        t = 0
                                        while idx < stor118.length - 1:
                                            require idx < mem[_5536]
                                            require idx + 1 < mem[_5536]
                                            _20627 = mem[(32 * idx + 1) + _5536 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _5536 + 44 len 20]
                                            mem[mem[64] + 36] = address(_20627)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_20627)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _21006 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_21006] == mem[_21006 + 12 len 20]
                                            require ext_code.size(mem[_21006 + 12 len 20])
                                            staticcall mem[_21006 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22842 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_22842] == mem[_22842 + 18 len 14]
                                            require mem[_22842 + 32] == mem[_22842 + 50 len 14]
                                            require mem[_22842 + 64] == mem[_22842 + 92 len 4]
                                            require idx < mem[_5536]
                                            require idx + 1 < mem[_5536]
                                            if mem[(32 * idx + 1) + _5536 + 44 len 20] < mem[(32 * idx) + _5536 + 44 len 20]:
                                                if not t:
                                                    if mem[_22842 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22842 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22842 + 18 len 14] * t / t != mem[_22842 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22842 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22842 + 18 len 14] * t / mem[_22842 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_22842')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_22842 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22842 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22842 + 50 len 14] * t / t != mem[_22842 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22842 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22842 + 50 len 14] * t / mem[_22842 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_22842')), 14)))
                                            revert
                                else:
                                    if 2 * mem[_5019] / mem[_5019] != 2:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _5650 = mem[64]
                                    mem[64] = mem[64] + (32 * stor118.length) + 32
                                    mem[_5650] = stor118.length
                                    if not stor118.length:
                                        idx = 0
                                        t = 2 * _5115
                                        while idx < stor118.length - 1:
                                            require idx < mem[_5650]
                                            require idx + 1 < mem[_5650]
                                            _9075 = mem[(32 * idx + 1) + _5650 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _5650 + 44 len 20]
                                            mem[mem[64] + 36] = address(_9075)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_9075)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9412 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9412] == mem[_9412 + 12 len 20]
                                            require ext_code.size(mem[_9412 + 12 len 20])
                                            staticcall mem[_9412 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _10785 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_10785] == mem[_10785 + 18 len 14]
                                            require mem[_10785 + 32] == mem[_10785 + 50 len 14]
                                            require mem[_10785 + 64] == mem[_10785 + 92 len 4]
                                            require idx < mem[_5650]
                                            require idx + 1 < mem[_5650]
                                            if mem[(32 * idx + 1) + _5650 + 44 len 20] < mem[(32 * idx) + _5650 + 44 len 20]:
                                                if not t:
                                                    if mem[_10785 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10785 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10785 + 18 len 14] * t / t != mem[_10785 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10785 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10785 + 18 len 14] * t / mem[_10785 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_10785')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_10785 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10785 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10785 + 50 len 14] * t / t != mem[_10785 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10785 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10785 + 50 len 14] * t / mem[_10785 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_10785')), 14)))
                                            revert
                                    else:
                                        mem[0] = 118
                                        mem[_5650 + 32] = address(stor118.field_0)
                                        idx = _5650 + 32
                                        t = 0
                                        while _5650 + (32 * stor118.length) > idx:
                                            mem[idx + 32] = stor118[t].field_256
                                            idx = idx + 32
                                            t = t + 1
                                            continue 
                                        idx = 0
                                        t = 2 * _5115
                                        while idx < stor118.length - 1:
                                            require idx < mem[_5650]
                                            require idx + 1 < mem[_5650]
                                            _20625 = mem[(32 * idx + 1) + _5650 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _5650 + 44 len 20]
                                            mem[mem[64] + 36] = address(_20625)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_20625)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _21004 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_21004] == mem[_21004 + 12 len 20]
                                            require ext_code.size(mem[_21004 + 12 len 20])
                                            staticcall mem[_21004 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22839 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_22839] == mem[_22839 + 18 len 14]
                                            require mem[_22839 + 32] == mem[_22839 + 50 len 14]
                                            require mem[_22839 + 64] == mem[_22839 + 92 len 4]
                                            require idx < mem[_5650]
                                            require idx + 1 < mem[_5650]
                                            if mem[(32 * idx + 1) + _5650 + 44 len 20] < mem[(32 * idx) + _5650 + 44 len 20]:
                                                if not t:
                                                    if mem[_22839 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22839 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22839 + 18 len 14] * t / t != mem[_22839 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22839 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22839 + 18 len 14] * t / mem[_22839 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_22839')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_22839 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22839 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22839 + 50 len 14] * t / t != mem[_22839 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22839 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22839 + 50 len 14] * t / mem[_22839 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_22839')), 14)))
                                            revert
                        else:
                            mem[ceil32(return_data.size) + 416] = address(stor119.field_256)
                            idx = ceil32(return_data.size) + 416
                            s = 1
                            while ceil32(return_data.size) + (32 * stor119.length) + 352 > idx:
                                mem[idx + 32] = stor119[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            idx = 0
                            s = ext_call.return_data[0] - stor42D0 - (0 / rewardsDuration + block.timestamp + -begin + 1)
                            while idx < stor119.length - 1:
                                require idx < mem[ceil32(return_data.size) + 352]
                                require idx + 1 < mem[ceil32(return_data.size) + 352]
                                _14482 = mem[(32 * idx + 1) + ceil32(return_data.size) + 384]
                                mem[mem[64] + 4] = mem[(32 * idx) + ceil32(return_data.size) + 396 len 20]
                                mem[mem[64] + 36] = address(_14482)
                                require ext_code.size(stor117)
                                staticcall stor117.getPair(address rg1, address rg2) with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4], address(_14482)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _15287 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_15287] == mem[_15287 + 12 len 20]
                                require ext_code.size(mem[_15287 + 12 len 20])
                                staticcall mem[_15287 + 12 len 20].getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _16476 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_16476] == mem[_16476 + 18 len 14]
                                require mem[_16476 + 32] == mem[_16476 + 50 len 14]
                                require mem[_16476 + 64] == mem[_16476 + 92 len 4]
                                require idx < mem[ceil32(return_data.size) + 352]
                                require idx + 1 < mem[ceil32(return_data.size) + 352]
                                if mem[(32 * idx + 1) + ceil32(return_data.size) + 396 len 20] < mem[(32 * idx) + ceil32(return_data.size) + 396 len 20]:
                                    if not s:
                                        if mem[_16476 + 50 len 14]:
                                            idx = idx + 1
                                            s = 0 / mem[_16476 + 50 len 14]
                                            continue 
                                    else:
                                        if mem[_16476 + 18 len 14] * s / s != mem[_16476 + 18 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_16476 + 50 len 14]:
                                            idx = idx + 1
                                            s = mem[_16476 + 18 len 14] * s / mem[_16476 + 50 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_16476')), 14)))
                                else:
                                    if not s:
                                        if mem[_16476 + 18 len 14]:
                                            idx = idx + 1
                                            s = 0 / mem[_16476 + 18 len 14]
                                            continue 
                                    else:
                                        if mem[_16476 + 50 len 14] * s / s != mem[_16476 + 50 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_16476 + 18 len 14]:
                                            idx = idx + 1
                                            s = mem[_16476 + 50 len 14] * s / mem[_16476 + 18 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_16476')), 14)))
                                revert
                            require stor118.length
                            mem[0] = 118
                            if address(stor118.field_0) == stakingTokenAddress:
                                _15451 = mem[64]
                                mem[64] = mem[64] + (32 * stor118.length) + 32
                                mem[_15451] = stor118.length
                                if not stor118.length:
                                    idx = 0
                                    t = totalSupply
                                    while idx < stor118.length - 1:
                                        require idx < mem[_15451]
                                        require idx + 1 < mem[_15451]
                                        _20617 = mem[(32 * idx + 1) + _15451 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _15451 + 44 len 20]
                                        mem[mem[64] + 36] = address(_20617)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_20617)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20996 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20996] == mem[_20996 + 12 len 20]
                                        require ext_code.size(mem[_20996 + 12 len 20])
                                        staticcall mem[_20996 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22827 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_22827] == mem[_22827 + 18 len 14]
                                        require mem[_22827 + 32] == mem[_22827 + 50 len 14]
                                        require mem[_22827 + 64] == mem[_22827 + 92 len 4]
                                        require idx < mem[_15451]
                                        require idx + 1 < mem[_15451]
                                        if mem[(32 * idx + 1) + _15451 + 44 len 20] < mem[(32 * idx) + _15451 + 44 len 20]:
                                            if not t:
                                                if mem[_22827 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22827 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_22827 + 18 len 14] * t / t != mem[_22827 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22827 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22827 + 18 len 14] * t / mem[_22827 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_22827')), 14)))
                                        else:
                                            if not t:
                                                if mem[_22827 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22827 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_22827 + 50 len 14] * t / t != mem[_22827 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22827 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22827 + 50 len 14] * t / mem[_22827 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_22827')), 14)))
                                        revert
                                    if s:
                                        if 10^18 * s / s != 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not t:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        return (10^18 * s / t)
                                    if t:
                                        return (0 / t)
                                    var91001 = 32
                                    revert with 0, 'SafeMath: division by zero', 0
                                mem[0] = 118
                                mem[_15451 + 32] = address(stor118.field_0)
                                idx = _15451 + 32
                                t = 0
                                while _15451 + (32 * stor118.length) > idx:
                                    mem[idx + 32] = stor118[t].field_256
                                    idx = idx + 32
                                    t = t + 1
                                    continue 
                                idx = 0
                                t = totalSupply
                                while idx < stor118.length - 1:
                                    require idx < mem[_15451]
                                    require idx + 1 < mem[_15451]
                                    _27723 = mem[(32 * idx + 1) + _15451 + 32]
                                    mem[mem[64] + 4] = mem[(32 * idx) + _15451 + 44 len 20]
                                    mem[mem[64] + 36] = address(_27723)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_27723)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _27850 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_27850] == mem[_27850 + 12 len 20]
                                    require ext_code.size(mem[_27850 + 12 len 20])
                                    staticcall mem[_27850 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _28460 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_28460] == mem[_28460 + 18 len 14]
                                    require mem[_28460 + 32] == mem[_28460 + 50 len 14]
                                    require mem[_28460 + 64] == mem[_28460 + 92 len 4]
                                    require idx < mem[_15451]
                                    require idx + 1 < mem[_15451]
                                    if mem[(32 * idx + 1) + _15451 + 44 len 20] < mem[(32 * idx) + _15451 + 44 len 20]:
                                        if not t:
                                            if mem[_28460 + 50 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_28460 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_28460 + 18 len 14] * t / t != mem[_28460 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_28460 + 50 len 14]:
                                                idx = idx + 1
                                                t = mem[_28460 + 18 len 14] * t / mem[_28460 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_28460')), 14)))
                                    else:
                                        if not t:
                                            if mem[_28460 + 18 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_28460 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_28460 + 50 len 14] * t / t != mem[_28460 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_28460 + 18 len 14]:
                                                idx = idx + 1
                                                t = mem[_28460 + 50 len 14] * t / mem[_28460 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_28460')), 14)))
                                    revert
                            else:
                                require stor118.length
                                require stor118.length
                                require address(stor118.field_0) != stakingTokenAddress
                                require 0 < stor118.length
                                mem[0] = 118
                                mem[mem[64] + 4] = stakingTokenAddress
                                require ext_code.size(address(stor118.field_0))
                                staticcall address(stor118.field_0).0x70a08231 with:
                                        gas gas_remaining wei
                                       args stakingTokenAddress
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _16475 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _16861 = mem[_16475]
                                if not mem[_16475]:
                                    _17792 = mem[64]
                                    mem[64] = mem[64] + (32 * stor118.length) + 32
                                    mem[_17792] = stor118.length
                                    if not stor118.length:
                                        idx = 0
                                        t = 0
                                        while idx < stor118.length - 1:
                                            require idx < mem[_17792]
                                            require idx + 1 < mem[_17792]
                                            _20621 = mem[(32 * idx + 1) + _17792 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _17792 + 44 len 20]
                                            mem[mem[64] + 36] = address(_20621)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_20621)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _21000 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_21000] == mem[_21000 + 12 len 20]
                                            require ext_code.size(mem[_21000 + 12 len 20])
                                            staticcall mem[_21000 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22833 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_22833] == mem[_22833 + 18 len 14]
                                            require mem[_22833 + 32] == mem[_22833 + 50 len 14]
                                            require mem[_22833 + 64] == mem[_22833 + 92 len 4]
                                            require idx < mem[_17792]
                                            require idx + 1 < mem[_17792]
                                            if mem[(32 * idx + 1) + _17792 + 44 len 20] < mem[(32 * idx) + _17792 + 44 len 20]:
                                                if not t:
                                                    if mem[_22833 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22833 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22833 + 18 len 14] * t / t != mem[_22833 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22833 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22833 + 18 len 14] * t / mem[_22833 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_22833')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_22833 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22833 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22833 + 50 len 14] * t / t != mem[_22833 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22833 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22833 + 50 len 14] * t / mem[_22833 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_22833')), 14)))
                                            revert
                                        if not s:
                                            if not t:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            return (0 / t)
                                        if 10^18 * s / s != 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not t:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        return (10^18 * s / t)
                                    mem[0] = 118
                                    mem[_17792 + 32] = address(stor118.field_0)
                                    idx = _17792 + 32
                                    t = 0
                                    while _17792 + (32 * stor118.length) > idx:
                                        mem[idx + 32] = stor118[t].field_256
                                        idx = idx + 32
                                        t = t + 1
                                        continue 
                                    idx = 0
                                    t = 0
                                    while idx < stor118.length - 1:
                                        require idx < mem[_17792]
                                        require idx + 1 < mem[_17792]
                                        _27727 = mem[(32 * idx + 1) + _17792 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _17792 + 44 len 20]
                                        mem[mem[64] + 36] = address(_27727)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_27727)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27854 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_27854] == mem[_27854 + 12 len 20]
                                        require ext_code.size(mem[_27854 + 12 len 20])
                                        staticcall mem[_27854 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _28466 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_28466] == mem[_28466 + 18 len 14]
                                        require mem[_28466 + 32] == mem[_28466 + 50 len 14]
                                        require mem[_28466 + 64] == mem[_28466 + 92 len 4]
                                        require idx < mem[_17792]
                                        require idx + 1 < mem[_17792]
                                        if mem[(32 * idx + 1) + _17792 + 44 len 20] < mem[(32 * idx) + _17792 + 44 len 20]:
                                            if not t:
                                                if mem[_28466 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_28466 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_28466 + 18 len 14] * t / t != mem[_28466 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_28466 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_28466 + 18 len 14] * t / mem[_28466 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_28466')), 14)))
                                        else:
                                            if not t:
                                                if mem[_28466 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_28466 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_28466 + 50 len 14] * t / t != mem[_28466 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_28466 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_28466 + 50 len 14] * t / mem[_28466 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_28466')), 14)))
                                        revert
                                    if s:
                                        if 10^18 * s / s != 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not t:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        return (10^18 * s / t)
                                    if t:
                                        return (0 / t)
                                    var110001 = 32
                                    revert with 0, 'SafeMath: division by zero', 0
                                if 2 * mem[_16475] / mem[_16475] != 2:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _17893 = mem[64]
                                mem[64] = mem[64] + (32 * stor118.length) + 32
                                mem[_17893] = stor118.length
                                if not stor118.length:
                                    idx = 0
                                    t = 2 * _16861
                                    while idx < stor118.length - 1:
                                        require idx < mem[_17893]
                                        require idx + 1 < mem[_17893]
                                        _20619 = mem[(32 * idx + 1) + _17893 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _17893 + 44 len 20]
                                        mem[mem[64] + 36] = address(_20619)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_20619)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20998 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20998] == mem[_20998 + 12 len 20]
                                        require ext_code.size(mem[_20998 + 12 len 20])
                                        staticcall mem[_20998 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22830 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_22830] == mem[_22830 + 18 len 14]
                                        require mem[_22830 + 32] == mem[_22830 + 50 len 14]
                                        require mem[_22830 + 64] == mem[_22830 + 92 len 4]
                                        require idx < mem[_17893]
                                        require idx + 1 < mem[_17893]
                                        if mem[(32 * idx + 1) + _17893 + 44 len 20] < mem[(32 * idx) + _17893 + 44 len 20]:
                                            if not t:
                                                if mem[_22830 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22830 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_22830 + 18 len 14] * t / t != mem[_22830 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22830 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22830 + 18 len 14] * t / mem[_22830 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_22830')), 14)))
                                        else:
                                            if not t:
                                                if mem[_22830 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22830 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_22830 + 50 len 14] * t / t != mem[_22830 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22830 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22830 + 50 len 14] * t / mem[_22830 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_22830')), 14)))
                                        revert
                                else:
                                    mem[0] = 118
                                    mem[_17893 + 32] = address(stor118.field_0)
                                    idx = _17893 + 32
                                    t = 0
                                    while _17893 + (32 * stor118.length) > idx:
                                        mem[idx + 32] = stor118[t].field_256
                                        idx = idx + 32
                                        t = t + 1
                                        continue 
                                    idx = 0
                                    t = 2 * _16861
                                    while idx < stor118.length - 1:
                                        require idx < mem[_17893]
                                        require idx + 1 < mem[_17893]
                                        _27725 = mem[(32 * idx + 1) + _17893 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _17893 + 44 len 20]
                                        mem[mem[64] + 36] = address(_27725)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_27725)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27852 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_27852] == mem[_27852 + 12 len 20]
                                        require ext_code.size(mem[_27852 + 12 len 20])
                                        staticcall mem[_27852 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _28463 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_28463] == mem[_28463 + 18 len 14]
                                        require mem[_28463 + 32] == mem[_28463 + 50 len 14]
                                        require mem[_28463 + 64] == mem[_28463 + 92 len 4]
                                        require idx < mem[_17893]
                                        require idx + 1 < mem[_17893]
                                        if mem[(32 * idx + 1) + _17893 + 44 len 20] < mem[(32 * idx) + _17893 + 44 len 20]:
                                            if not t:
                                                if mem[_28463 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_28463 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_28463 + 18 len 14] * t / t != mem[_28463 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_28463 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_28463 + 18 len 14] * t / mem[_28463 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_28463')), 14)))
                                        else:
                                            if not t:
                                                if mem[_28463 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_28463 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_28463 + 50 len 14] * t / t != mem[_28463 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_28463 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_28463 + 50 len 14] * t / mem[_28463 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_28463')), 14)))
                                        revert
                else:
                    if (8760 * 24 * 3600 * ext_call.return_data[0] * rewardsDuration) - (8760 * 24 * 3600 * stor42D0 * rewardsDuration) + (8760 * 24 * 3600 * ext_call.return_data[0] * block.timestamp) - (8760 * 24 * 3600 * stor42D0 * block.timestamp) - (8760 * 24 * 3600 * ext_call.return_data[0] * begin) + (8760 * 24 * 3600 * stor42D0 * begin) / (8760 * 24 * 3600 * ext_call.return_data[0]) - (8760 * 24 * 3600 * stor42D0) != rewardsDuration + block.timestamp - begin:
                        revert with 0, 'SafeMath: multiplication overflow'
                    mem[ceil32(return_data.size) + 224] = 26
                    mem[ceil32(return_data.size) + 256] = 'SafeMath: division by zero'
                    if not rewardsDuration + block.timestamp + -begin + 1:
                        revert with 0, 'SafeMath: division by zero', 0
                    mem[ceil32(return_data.size) + 288] = 30
                    mem[ceil32(return_data.size) + 320] = 'SafeMath: subtraction overflow'
                    if (8760 * 24 * 3600 * ext_call.return_data[0] * rewardsDuration) - (8760 * 24 * 3600 * stor42D0 * rewardsDuration) + (8760 * 24 * 3600 * ext_call.return_data[0] * block.timestamp) - (8760 * 24 * 3600 * stor42D0 * block.timestamp) - (8760 * 24 * 3600 * ext_call.return_data[0] * begin) + (8760 * 24 * 3600 * stor42D0 * begin) / rewardsDuration + block.timestamp + -begin + 1 > ext_call.return_data[0] - stor42D0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    require 0 < stor119.length
                    mem[0] = 119
                    require address(stor119.field_0) == rewardsTokenAddress
                    mem[64] = ceil32(return_data.size) + (32 * stor119.length) + 384
                    mem[ceil32(return_data.size) + 352] = stor119.length
                    if not stor119.length:
                        idx = 0
                        s = ext_call.return_data[0] - stor42D0 - ((8760 * 24 * 3600 * ext_call.return_data[0] * rewardsDuration) - (8760 * 24 * 3600 * stor42D0 * rewardsDuration) + (8760 * 24 * 3600 * ext_call.return_data[0] * block.timestamp) - (8760 * 24 * 3600 * stor42D0 * block.timestamp) - (8760 * 24 * 3600 * ext_call.return_data[0] * begin) + (8760 * 24 * 3600 * stor42D0 * begin) / rewardsDuration + block.timestamp + -begin + 1)
                        while idx < stor119.length - 1:
                            require idx < mem[ceil32(return_data.size) + 352]
                            require idx + 1 < mem[ceil32(return_data.size) + 352]
                            _4437 = mem[(32 * idx + 1) + ceil32(return_data.size) + 384]
                            mem[mem[64] + 4] = mem[(32 * idx) + ceil32(return_data.size) + 396 len 20]
                            mem[mem[64] + 36] = address(_4437)
                            require ext_code.size(stor117)
                            staticcall stor117.getPair(address rg1, address rg2) with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4], address(_4437)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4577 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_4577] == mem[_4577 + 12 len 20]
                            require ext_code.size(mem[_4577 + 12 len 20])
                            staticcall mem[_4577 + 12 len 20].getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _5008 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_5008] == mem[_5008 + 18 len 14]
                            require mem[_5008 + 32] == mem[_5008 + 50 len 14]
                            require mem[_5008 + 64] == mem[_5008 + 92 len 4]
                            require idx < mem[ceil32(return_data.size) + 352]
                            require idx + 1 < mem[ceil32(return_data.size) + 352]
                            if mem[(32 * idx + 1) + ceil32(return_data.size) + 396 len 20] < mem[(32 * idx) + ceil32(return_data.size) + 396 len 20]:
                                if not s:
                                    if mem[_5008 + 50 len 14]:
                                        idx = idx + 1
                                        s = 0 / mem[_5008 + 50 len 14]
                                        continue 
                                else:
                                    if mem[_5008 + 18 len 14] * s / s != mem[_5008 + 18 len 14]:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if mem[_5008 + 50 len 14]:
                                        idx = idx + 1
                                        s = mem[_5008 + 18 len 14] * s / mem[_5008 + 50 len 14]
                                        continue 
                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_5008')), 14)))
                            else:
                                if not s:
                                    if mem[_5008 + 18 len 14]:
                                        idx = idx + 1
                                        s = 0 / mem[_5008 + 18 len 14]
                                        continue 
                                else:
                                    if mem[_5008 + 50 len 14] * s / s != mem[_5008 + 50 len 14]:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if mem[_5008 + 18 len 14]:
                                        idx = idx + 1
                                        s = mem[_5008 + 50 len 14] * s / mem[_5008 + 18 len 14]
                                        continue 
                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_5008')), 14)))
                            revert
                        require stor118.length
                        mem[0] = 118
                        if address(stor118.field_0) == stakingTokenAddress:
                            _4645 = mem[64]
                            mem[64] = mem[64] + (32 * stor118.length) + 32
                            mem[_4645] = stor118.length
                            if not stor118.length:
                                idx = 0
                                t = totalSupply
                                while idx < stor118.length - 1:
                                    require idx < mem[_4645]
                                    require idx + 1 < mem[_4645]
                                    _9053 = mem[(32 * idx + 1) + _4645 + 32]
                                    mem[mem[64] + 4] = mem[(32 * idx) + _4645 + 44 len 20]
                                    mem[mem[64] + 36] = address(_9053)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_9053)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9390 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_9390] == mem[_9390 + 12 len 20]
                                    require ext_code.size(mem[_9390 + 12 len 20])
                                    staticcall mem[_9390 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10747 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_10747] == mem[_10747 + 18 len 14]
                                    require mem[_10747 + 32] == mem[_10747 + 50 len 14]
                                    require mem[_10747 + 64] == mem[_10747 + 92 len 4]
                                    require idx < mem[_4645]
                                    require idx + 1 < mem[_4645]
                                    if mem[(32 * idx + 1) + _4645 + 44 len 20] < mem[(32 * idx) + _4645 + 44 len 20]:
                                        if not t:
                                            if mem[_10747 + 50 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_10747 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_10747 + 18 len 14] * t / t != mem[_10747 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_10747 + 50 len 14]:
                                                idx = idx + 1
                                                t = mem[_10747 + 18 len 14] * t / mem[_10747 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_10747')), 14)))
                                    else:
                                        if not t:
                                            if mem[_10747 + 18 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_10747 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_10747 + 50 len 14] * t / t != mem[_10747 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_10747 + 18 len 14]:
                                                idx = idx + 1
                                                t = mem[_10747 + 50 len 14] * t / mem[_10747 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_10747')), 14)))
                                    revert
                            else:
                                mem[0] = 118
                                mem[_4645 + 32] = address(stor118.field_0)
                                idx = _4645 + 32
                                t = 0
                                while _4645 + (32 * stor118.length) > idx:
                                    mem[idx + 32] = stor118[t].field_256
                                    idx = idx + 32
                                    t = t + 1
                                    continue 
                                idx = 0
                                t = totalSupply
                                while idx < stor118.length - 1:
                                    require idx < mem[_4645]
                                    require idx + 1 < mem[_4645]
                                    _20593 = mem[(32 * idx + 1) + _4645 + 32]
                                    mem[mem[64] + 4] = mem[(32 * idx) + _4645 + 44 len 20]
                                    mem[mem[64] + 36] = address(_20593)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_20593)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _20972 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_20972] == mem[_20972 + 12 len 20]
                                    require ext_code.size(mem[_20972 + 12 len 20])
                                    staticcall mem[_20972 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _22791 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_22791] == mem[_22791 + 18 len 14]
                                    require mem[_22791 + 32] == mem[_22791 + 50 len 14]
                                    require mem[_22791 + 64] == mem[_22791 + 92 len 4]
                                    require idx < mem[_4645]
                                    require idx + 1 < mem[_4645]
                                    if mem[(32 * idx + 1) + _4645 + 44 len 20] < mem[(32 * idx) + _4645 + 44 len 20]:
                                        if not t:
                                            if mem[_22791 + 50 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_22791 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_22791 + 18 len 14] * t / t != mem[_22791 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_22791 + 50 len 14]:
                                                idx = idx + 1
                                                t = mem[_22791 + 18 len 14] * t / mem[_22791 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_22791')), 14)))
                                    else:
                                        if not t:
                                            if mem[_22791 + 18 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_22791 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_22791 + 50 len 14] * t / t != mem[_22791 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_22791 + 18 len 14]:
                                                idx = idx + 1
                                                t = mem[_22791 + 50 len 14] * t / mem[_22791 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_22791')), 14)))
                                    revert
                        else:
                            require stor118.length
                            require stor118.length
                            require address(stor118.field_0) != stakingTokenAddress
                            require 0 < stor118.length
                            mem[0] = 118
                            mem[mem[64] + 4] = stakingTokenAddress
                            require ext_code.size(address(stor118.field_0))
                            staticcall address(stor118.field_0).0x70a08231 with:
                                    gas gas_remaining wei
                                   args stakingTokenAddress
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _5007 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _5106 = mem[_5007]
                            if not mem[_5007]:
                                _5527 = mem[64]
                                mem[64] = mem[64] + (32 * stor118.length) + 32
                                mem[_5527] = stor118.length
                                if not stor118.length:
                                    idx = 0
                                    t = 0
                                    while idx < stor118.length - 1:
                                        require idx < mem[_5527]
                                        require idx + 1 < mem[_5527]
                                        _9057 = mem[(32 * idx + 1) + _5527 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _5527 + 44 len 20]
                                        mem[mem[64] + 36] = address(_9057)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_9057)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9394 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9394] == mem[_9394 + 12 len 20]
                                        require ext_code.size(mem[_9394 + 12 len 20])
                                        staticcall mem[_9394 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _10753 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_10753] == mem[_10753 + 18 len 14]
                                        require mem[_10753 + 32] == mem[_10753 + 50 len 14]
                                        require mem[_10753 + 64] == mem[_10753 + 92 len 4]
                                        require idx < mem[_5527]
                                        require idx + 1 < mem[_5527]
                                        if mem[(32 * idx + 1) + _5527 + 44 len 20] < mem[(32 * idx) + _5527 + 44 len 20]:
                                            if not t:
                                                if mem[_10753 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_10753 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_10753 + 18 len 14] * t / t != mem[_10753 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_10753 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_10753 + 18 len 14] * t / mem[_10753 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_10753')), 14)))
                                        else:
                                            if not t:
                                                if mem[_10753 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_10753 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_10753 + 50 len 14] * t / t != mem[_10753 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_10753 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_10753 + 50 len 14] * t / mem[_10753 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_10753')), 14)))
                                        revert
                                else:
                                    mem[0] = 118
                                    mem[_5527 + 32] = address(stor118.field_0)
                                    idx = _5527 + 32
                                    t = 0
                                    while _5527 + (32 * stor118.length) > idx:
                                        mem[idx + 32] = stor118[t].field_256
                                        idx = idx + 32
                                        t = t + 1
                                        continue 
                                    idx = 0
                                    t = 0
                                    while idx < stor118.length - 1:
                                        require idx < mem[_5527]
                                        require idx + 1 < mem[_5527]
                                        _20597 = mem[(32 * idx + 1) + _5527 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _5527 + 44 len 20]
                                        mem[mem[64] + 36] = address(_20597)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_20597)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20976 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20976] == mem[_20976 + 12 len 20]
                                        require ext_code.size(mem[_20976 + 12 len 20])
                                        staticcall mem[_20976 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22797 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_22797] == mem[_22797 + 18 len 14]
                                        require mem[_22797 + 32] == mem[_22797 + 50 len 14]
                                        require mem[_22797 + 64] == mem[_22797 + 92 len 4]
                                        require idx < mem[_5527]
                                        require idx + 1 < mem[_5527]
                                        if mem[(32 * idx + 1) + _5527 + 44 len 20] < mem[(32 * idx) + _5527 + 44 len 20]:
                                            if not t:
                                                if mem[_22797 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22797 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_22797 + 18 len 14] * t / t != mem[_22797 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22797 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22797 + 18 len 14] * t / mem[_22797 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_22797')), 14)))
                                        else:
                                            if not t:
                                                if mem[_22797 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22797 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_22797 + 50 len 14] * t / t != mem[_22797 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22797 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22797 + 50 len 14] * t / mem[_22797 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_22797')), 14)))
                                        revert
                            else:
                                if 2 * mem[_5007] / mem[_5007] != 2:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _5635 = mem[64]
                                mem[64] = mem[64] + (32 * stor118.length) + 32
                                mem[_5635] = stor118.length
                                if not stor118.length:
                                    idx = 0
                                    t = 2 * _5106
                                    while idx < stor118.length - 1:
                                        require idx < mem[_5635]
                                        require idx + 1 < mem[_5635]
                                        _9055 = mem[(32 * idx + 1) + _5635 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _5635 + 44 len 20]
                                        mem[mem[64] + 36] = address(_9055)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_9055)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9392 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9392] == mem[_9392 + 12 len 20]
                                        require ext_code.size(mem[_9392 + 12 len 20])
                                        staticcall mem[_9392 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _10750 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_10750] == mem[_10750 + 18 len 14]
                                        require mem[_10750 + 32] == mem[_10750 + 50 len 14]
                                        require mem[_10750 + 64] == mem[_10750 + 92 len 4]
                                        require idx < mem[_5635]
                                        require idx + 1 < mem[_5635]
                                        if mem[(32 * idx + 1) + _5635 + 44 len 20] < mem[(32 * idx) + _5635 + 44 len 20]:
                                            if not t:
                                                if mem[_10750 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_10750 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_10750 + 18 len 14] * t / t != mem[_10750 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_10750 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_10750 + 18 len 14] * t / mem[_10750 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_10750')), 14)))
                                        else:
                                            if not t:
                                                if mem[_10750 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_10750 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_10750 + 50 len 14] * t / t != mem[_10750 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_10750 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_10750 + 50 len 14] * t / mem[_10750 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_10750')), 14)))
                                        revert
                                else:
                                    mem[0] = 118
                                    mem[_5635 + 32] = address(stor118.field_0)
                                    idx = _5635 + 32
                                    t = 0
                                    while _5635 + (32 * stor118.length) > idx:
                                        mem[idx + 32] = stor118[t].field_256
                                        idx = idx + 32
                                        t = t + 1
                                        continue 
                                    idx = 0
                                    t = 2 * _5106
                                    while idx < stor118.length - 1:
                                        require idx < mem[_5635]
                                        require idx + 1 < mem[_5635]
                                        _20595 = mem[(32 * idx + 1) + _5635 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _5635 + 44 len 20]
                                        mem[mem[64] + 36] = address(_20595)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_20595)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20974 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20974] == mem[_20974 + 12 len 20]
                                        require ext_code.size(mem[_20974 + 12 len 20])
                                        staticcall mem[_20974 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22794 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_22794] == mem[_22794 + 18 len 14]
                                        require mem[_22794 + 32] == mem[_22794 + 50 len 14]
                                        require mem[_22794 + 64] == mem[_22794 + 92 len 4]
                                        require idx < mem[_5635]
                                        require idx + 1 < mem[_5635]
                                        if mem[(32 * idx + 1) + _5635 + 44 len 20] < mem[(32 * idx) + _5635 + 44 len 20]:
                                            if not t:
                                                if mem[_22794 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22794 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_22794 + 18 len 14] * t / t != mem[_22794 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22794 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22794 + 18 len 14] * t / mem[_22794 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_22794')), 14)))
                                        else:
                                            if not t:
                                                if mem[_22794 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22794 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_22794 + 50 len 14] * t / t != mem[_22794 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22794 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22794 + 50 len 14] * t / mem[_22794 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_22794')), 14)))
                                        revert
                    else:
                        mem[0] = 119
                        mem[ceil32(return_data.size) + 384] = address(stor119.field_0)
                        if (32 * stor119.length) + 32 <= 64:
                            idx = 0
                            s = ext_call.return_data[0] - stor42D0 - ((8760 * 24 * 3600 * ext_call.return_data[0] * rewardsDuration) - (8760 * 24 * 3600 * stor42D0 * rewardsDuration) + (8760 * 24 * 3600 * ext_call.return_data[0] * block.timestamp) - (8760 * 24 * 3600 * stor42D0 * block.timestamp) - (8760 * 24 * 3600 * ext_call.return_data[0] * begin) + (8760 * 24 * 3600 * stor42D0 * begin) / rewardsDuration + block.timestamp + -begin + 1)
                            while idx < stor119.length - 1:
                                require idx < mem[ceil32(return_data.size) + 352]
                                require idx + 1 < mem[ceil32(return_data.size) + 352]
                                _4439 = mem[(32 * idx + 1) + ceil32(return_data.size) + 384]
                                mem[mem[64] + 4] = mem[(32 * idx) + ceil32(return_data.size) + 396 len 20]
                                mem[mem[64] + 36] = address(_4439)
                                require ext_code.size(stor117)
                                staticcall stor117.getPair(address rg1, address rg2) with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4], address(_4439)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4578 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_4578] == mem[_4578 + 12 len 20]
                                require ext_code.size(mem[_4578 + 12 len 20])
                                staticcall mem[_4578 + 12 len 20].getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5012 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_5012] == mem[_5012 + 18 len 14]
                                require mem[_5012 + 32] == mem[_5012 + 50 len 14]
                                require mem[_5012 + 64] == mem[_5012 + 92 len 4]
                                require idx < mem[ceil32(return_data.size) + 352]
                                require idx + 1 < mem[ceil32(return_data.size) + 352]
                                if mem[(32 * idx + 1) + ceil32(return_data.size) + 396 len 20] < mem[(32 * idx) + ceil32(return_data.size) + 396 len 20]:
                                    if not s:
                                        if mem[_5012 + 50 len 14]:
                                            idx = idx + 1
                                            s = 0 / mem[_5012 + 50 len 14]
                                            continue 
                                    else:
                                        if mem[_5012 + 18 len 14] * s / s != mem[_5012 + 18 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_5012 + 50 len 14]:
                                            idx = idx + 1
                                            s = mem[_5012 + 18 len 14] * s / mem[_5012 + 50 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_5012')), 14)))
                                else:
                                    if not s:
                                        if mem[_5012 + 18 len 14]:
                                            idx = idx + 1
                                            s = 0 / mem[_5012 + 18 len 14]
                                            continue 
                                    else:
                                        if mem[_5012 + 50 len 14] * s / s != mem[_5012 + 50 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_5012 + 18 len 14]:
                                            idx = idx + 1
                                            s = mem[_5012 + 50 len 14] * s / mem[_5012 + 18 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_5012')), 14)))
                                revert
                            require stor118.length
                            mem[0] = 118
                            if address(stor118.field_0) == stakingTokenAddress:
                                _4647 = mem[64]
                                mem[64] = mem[64] + (32 * stor118.length) + 32
                                mem[_4647] = stor118.length
                                if not stor118.length:
                                    idx = 0
                                    t = totalSupply
                                    while idx < stor118.length - 1:
                                        require idx < mem[_4647]
                                        require idx + 1 < mem[_4647]
                                        _9060 = mem[(32 * idx + 1) + _4647 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _4647 + 44 len 20]
                                        mem[mem[64] + 36] = address(_9060)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_9060)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9397 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9397] == mem[_9397 + 12 len 20]
                                        require ext_code.size(mem[_9397 + 12 len 20])
                                        staticcall mem[_9397 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _10760 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_10760] == mem[_10760 + 18 len 14]
                                        require mem[_10760 + 32] == mem[_10760 + 50 len 14]
                                        require mem[_10760 + 64] == mem[_10760 + 92 len 4]
                                        require idx < mem[_4647]
                                        require idx + 1 < mem[_4647]
                                        if mem[(32 * idx + 1) + _4647 + 44 len 20] < mem[(32 * idx) + _4647 + 44 len 20]:
                                            if not t:
                                                if mem[_10760 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_10760 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_10760 + 18 len 14] * t / t != mem[_10760 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_10760 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_10760 + 18 len 14] * t / mem[_10760 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_10760')), 14)))
                                        else:
                                            if not t:
                                                if mem[_10760 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_10760 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_10760 + 50 len 14] * t / t != mem[_10760 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_10760 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_10760 + 50 len 14] * t / mem[_10760 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_10760')), 14)))
                                        revert
                                else:
                                    mem[0] = 118
                                    mem[_4647 + 32] = address(stor118.field_0)
                                    idx = _4647 + 32
                                    t = 0
                                    while _4647 + (32 * stor118.length) > idx:
                                        mem[idx + 32] = stor118[t].field_256
                                        idx = idx + 32
                                        t = t + 1
                                        continue 
                                    idx = 0
                                    t = totalSupply
                                    while idx < stor118.length - 1:
                                        require idx < mem[_4647]
                                        require idx + 1 < mem[_4647]
                                        _20605 = mem[(32 * idx + 1) + _4647 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _4647 + 44 len 20]
                                        mem[mem[64] + 36] = address(_20605)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_20605)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20984 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20984] == mem[_20984 + 12 len 20]
                                        require ext_code.size(mem[_20984 + 12 len 20])
                                        staticcall mem[_20984 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22809 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_22809] == mem[_22809 + 18 len 14]
                                        require mem[_22809 + 32] == mem[_22809 + 50 len 14]
                                        require mem[_22809 + 64] == mem[_22809 + 92 len 4]
                                        require idx < mem[_4647]
                                        require idx + 1 < mem[_4647]
                                        if mem[(32 * idx + 1) + _4647 + 44 len 20] < mem[(32 * idx) + _4647 + 44 len 20]:
                                            if not t:
                                                if mem[_22809 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22809 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_22809 + 18 len 14] * t / t != mem[_22809 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22809 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22809 + 18 len 14] * t / mem[_22809 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_22809')), 14)))
                                        else:
                                            if not t:
                                                if mem[_22809 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22809 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_22809 + 50 len 14] * t / t != mem[_22809 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22809 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22809 + 50 len 14] * t / mem[_22809 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_22809')), 14)))
                                        revert
                            else:
                                require stor118.length
                                require stor118.length
                                require address(stor118.field_0) != stakingTokenAddress
                                require 0 < stor118.length
                                mem[0] = 118
                                mem[mem[64] + 4] = stakingTokenAddress
                                require ext_code.size(address(stor118.field_0))
                                staticcall address(stor118.field_0).0x70a08231 with:
                                        gas gas_remaining wei
                                       args stakingTokenAddress
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5011 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _5109 = mem[_5011]
                                if not mem[_5011]:
                                    _5530 = mem[64]
                                    mem[64] = mem[64] + (32 * stor118.length) + 32
                                    mem[_5530] = stor118.length
                                    if not stor118.length:
                                        idx = 0
                                        t = 0
                                        while idx < stor118.length - 1:
                                            require idx < mem[_5530]
                                            require idx + 1 < mem[_5530]
                                            _9064 = mem[(32 * idx + 1) + _5530 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _5530 + 44 len 20]
                                            mem[mem[64] + 36] = address(_9064)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_9064)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9401 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9401] == mem[_9401 + 12 len 20]
                                            require ext_code.size(mem[_9401 + 12 len 20])
                                            staticcall mem[_9401 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _10766 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_10766] == mem[_10766 + 18 len 14]
                                            require mem[_10766 + 32] == mem[_10766 + 50 len 14]
                                            require mem[_10766 + 64] == mem[_10766 + 92 len 4]
                                            require idx < mem[_5530]
                                            require idx + 1 < mem[_5530]
                                            if mem[(32 * idx + 1) + _5530 + 44 len 20] < mem[(32 * idx) + _5530 + 44 len 20]:
                                                if not t:
                                                    if mem[_10766 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10766 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10766 + 18 len 14] * t / t != mem[_10766 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10766 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10766 + 18 len 14] * t / mem[_10766 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_10766')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_10766 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10766 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10766 + 50 len 14] * t / t != mem[_10766 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10766 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10766 + 50 len 14] * t / mem[_10766 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_10766')), 14)))
                                            revert
                                    else:
                                        mem[0] = 118
                                        mem[_5530 + 32] = address(stor118.field_0)
                                        idx = _5530 + 32
                                        t = 0
                                        while _5530 + (32 * stor118.length) > idx:
                                            mem[idx + 32] = stor118[t].field_256
                                            idx = idx + 32
                                            t = t + 1
                                            continue 
                                        idx = 0
                                        t = 0
                                        while idx < stor118.length - 1:
                                            require idx < mem[_5530]
                                            require idx + 1 < mem[_5530]
                                            _20609 = mem[(32 * idx + 1) + _5530 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _5530 + 44 len 20]
                                            mem[mem[64] + 36] = address(_20609)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_20609)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _20988 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_20988] == mem[_20988 + 12 len 20]
                                            require ext_code.size(mem[_20988 + 12 len 20])
                                            staticcall mem[_20988 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22815 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_22815] == mem[_22815 + 18 len 14]
                                            require mem[_22815 + 32] == mem[_22815 + 50 len 14]
                                            require mem[_22815 + 64] == mem[_22815 + 92 len 4]
                                            require idx < mem[_5530]
                                            require idx + 1 < mem[_5530]
                                            if mem[(32 * idx + 1) + _5530 + 44 len 20] < mem[(32 * idx) + _5530 + 44 len 20]:
                                                if not t:
                                                    if mem[_22815 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22815 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22815 + 18 len 14] * t / t != mem[_22815 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22815 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22815 + 18 len 14] * t / mem[_22815 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_22815')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_22815 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22815 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22815 + 50 len 14] * t / t != mem[_22815 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22815 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22815 + 50 len 14] * t / mem[_22815 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_22815')), 14)))
                                            revert
                                else:
                                    if 2 * mem[_5011] / mem[_5011] != 2:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _5640 = mem[64]
                                    mem[64] = mem[64] + (32 * stor118.length) + 32
                                    mem[_5640] = stor118.length
                                    if not stor118.length:
                                        idx = 0
                                        t = 2 * _5109
                                        while idx < stor118.length - 1:
                                            require idx < mem[_5640]
                                            require idx + 1 < mem[_5640]
                                            _9062 = mem[(32 * idx + 1) + _5640 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _5640 + 44 len 20]
                                            mem[mem[64] + 36] = address(_9062)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_9062)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9399 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9399] == mem[_9399 + 12 len 20]
                                            require ext_code.size(mem[_9399 + 12 len 20])
                                            staticcall mem[_9399 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _10763 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_10763] == mem[_10763 + 18 len 14]
                                            require mem[_10763 + 32] == mem[_10763 + 50 len 14]
                                            require mem[_10763 + 64] == mem[_10763 + 92 len 4]
                                            require idx < mem[_5640]
                                            require idx + 1 < mem[_5640]
                                            if mem[(32 * idx + 1) + _5640 + 44 len 20] < mem[(32 * idx) + _5640 + 44 len 20]:
                                                if not t:
                                                    if mem[_10763 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10763 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10763 + 18 len 14] * t / t != mem[_10763 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10763 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10763 + 18 len 14] * t / mem[_10763 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_10763')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_10763 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_10763 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_10763 + 50 len 14] * t / t != mem[_10763 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_10763 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_10763 + 50 len 14] * t / mem[_10763 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_10763')), 14)))
                                            revert
                                    else:
                                        mem[0] = 118
                                        mem[_5640 + 32] = address(stor118.field_0)
                                        idx = _5640 + 32
                                        t = 0
                                        while _5640 + (32 * stor118.length) > idx:
                                            mem[idx + 32] = stor118[t].field_256
                                            idx = idx + 32
                                            t = t + 1
                                            continue 
                                        idx = 0
                                        t = 2 * _5109
                                        while idx < stor118.length - 1:
                                            require idx < mem[_5640]
                                            require idx + 1 < mem[_5640]
                                            _20607 = mem[(32 * idx + 1) + _5640 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _5640 + 44 len 20]
                                            mem[mem[64] + 36] = address(_20607)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_20607)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _20986 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_20986] == mem[_20986 + 12 len 20]
                                            require ext_code.size(mem[_20986 + 12 len 20])
                                            staticcall mem[_20986 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22812 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_22812] == mem[_22812 + 18 len 14]
                                            require mem[_22812 + 32] == mem[_22812 + 50 len 14]
                                            require mem[_22812 + 64] == mem[_22812 + 92 len 4]
                                            require idx < mem[_5640]
                                            require idx + 1 < mem[_5640]
                                            if mem[(32 * idx + 1) + _5640 + 44 len 20] < mem[(32 * idx) + _5640 + 44 len 20]:
                                                if not t:
                                                    if mem[_22812 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22812 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22812 + 18 len 14] * t / t != mem[_22812 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22812 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22812 + 18 len 14] * t / mem[_22812 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_22812')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_22812 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22812 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22812 + 50 len 14] * t / t != mem[_22812 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22812 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22812 + 50 len 14] * t / mem[_22812 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_22812')), 14)))
                                            revert
                        else:
                            mem[ceil32(return_data.size) + 416] = address(stor119.field_256)
                            idx = ceil32(return_data.size) + 416
                            s = 1
                            while ceil32(return_data.size) + (32 * stor119.length) + 352 > idx:
                                mem[idx + 32] = stor119[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            idx = 0
                            s = ext_call.return_data[0] - stor42D0 - ((8760 * 24 * 3600 * ext_call.return_data[0] * rewardsDuration) - (8760 * 24 * 3600 * stor42D0 * rewardsDuration) + (8760 * 24 * 3600 * ext_call.return_data[0] * block.timestamp) - (8760 * 24 * 3600 * stor42D0 * block.timestamp) - (8760 * 24 * 3600 * ext_call.return_data[0] * begin) + (8760 * 24 * 3600 * stor42D0 * begin) / rewardsDuration + block.timestamp + -begin + 1)
                            while idx < stor119.length - 1:
                                require idx < mem[ceil32(return_data.size) + 352]
                                require idx + 1 < mem[ceil32(return_data.size) + 352]
                                _14474 = mem[(32 * idx + 1) + ceil32(return_data.size) + 384]
                                mem[mem[64] + 4] = mem[(32 * idx) + ceil32(return_data.size) + 396 len 20]
                                mem[mem[64] + 36] = address(_14474)
                                require ext_code.size(stor117)
                                staticcall stor117.getPair(address rg1, address rg2) with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4], address(_14474)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _15280 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_15280] == mem[_15280 + 12 len 20]
                                require ext_code.size(mem[_15280 + 12 len 20])
                                staticcall mem[_15280 + 12 len 20].getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _16460 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_16460] == mem[_16460 + 18 len 14]
                                require mem[_16460 + 32] == mem[_16460 + 50 len 14]
                                require mem[_16460 + 64] == mem[_16460 + 92 len 4]
                                require idx < mem[ceil32(return_data.size) + 352]
                                require idx + 1 < mem[ceil32(return_data.size) + 352]
                                if mem[(32 * idx + 1) + ceil32(return_data.size) + 396 len 20] < mem[(32 * idx) + ceil32(return_data.size) + 396 len 20]:
                                    if not s:
                                        if mem[_16460 + 50 len 14]:
                                            idx = idx + 1
                                            s = 0 / mem[_16460 + 50 len 14]
                                            continue 
                                    else:
                                        if mem[_16460 + 18 len 14] * s / s != mem[_16460 + 18 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_16460 + 50 len 14]:
                                            idx = idx + 1
                                            s = mem[_16460 + 18 len 14] * s / mem[_16460 + 50 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 50, ('var', '_16460')), 14)))
                                else:
                                    if not s:
                                        if mem[_16460 + 18 len 14]:
                                            idx = idx + 1
                                            s = 0 / mem[_16460 + 18 len 14]
                                            continue 
                                    else:
                                        if mem[_16460 + 50 len 14] * s / s != mem[_16460 + 50 len 14]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if mem[_16460 + 18 len 14]:
                                            idx = idx + 1
                                            s = mem[_16460 + 50 len 14] * s / mem[_16460 + 18 len 14]
                                            continue 
                                    ('iszero', ('mem', ('range', ('add', 18, ('var', '_16460')), 14)))
                                revert
                            require stor118.length
                            mem[0] = 118
                            if address(stor118.field_0) == stakingTokenAddress:
                                _15437 = mem[64]
                                mem[64] = mem[64] + (32 * stor118.length) + 32
                                mem[_15437] = stor118.length
                                if not stor118.length:
                                    idx = 0
                                    t = totalSupply
                                    while idx < stor118.length - 1:
                                        require idx < mem[_15437]
                                        require idx + 1 < mem[_15437]
                                        _20599 = mem[(32 * idx + 1) + _15437 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _15437 + 44 len 20]
                                        mem[mem[64] + 36] = address(_20599)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_20599)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20978 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20978] == mem[_20978 + 12 len 20]
                                        require ext_code.size(mem[_20978 + 12 len 20])
                                        staticcall mem[_20978 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22800 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_22800] == mem[_22800 + 18 len 14]
                                        require mem[_22800 + 32] == mem[_22800 + 50 len 14]
                                        require mem[_22800 + 64] == mem[_22800 + 92 len 4]
                                        require idx < mem[_15437]
                                        require idx + 1 < mem[_15437]
                                        if mem[(32 * idx + 1) + _15437 + 44 len 20] < mem[(32 * idx) + _15437 + 44 len 20]:
                                            if not t:
                                                if mem[_22800 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22800 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_22800 + 18 len 14] * t / t != mem[_22800 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22800 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22800 + 18 len 14] * t / mem[_22800 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_22800')), 14)))
                                        else:
                                            if not t:
                                                if mem[_22800 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22800 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_22800 + 50 len 14] * t / t != mem[_22800 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22800 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22800 + 50 len 14] * t / mem[_22800 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_22800')), 14)))
                                        revert
                                    if s:
                                        if 10^18 * s / s != 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not t:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        return (10^18 * s / t)
                                    if t:
                                        return (0 / t)
                                    var92001 = 32
                                    revert with 0, 'SafeMath: division by zero', 0
                                mem[0] = 118
                                mem[_15437 + 32] = address(stor118.field_0)
                                idx = _15437 + 32
                                t = 0
                                while _15437 + (32 * stor118.length) > idx:
                                    mem[idx + 32] = stor118[t].field_256
                                    idx = idx + 32
                                    t = t + 1
                                    continue 
                                idx = 0
                                t = totalSupply
                                while idx < stor118.length - 1:
                                    require idx < mem[_15437]
                                    require idx + 1 < mem[_15437]
                                    _27717 = mem[(32 * idx + 1) + _15437 + 32]
                                    mem[mem[64] + 4] = mem[(32 * idx) + _15437 + 44 len 20]
                                    mem[mem[64] + 36] = address(_27717)
                                    require ext_code.size(stor117)
                                    staticcall stor117.getPair(address rg1, address rg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_27717)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _27844 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_27844] == mem[_27844 + 12 len 20]
                                    require ext_code.size(mem[_27844 + 12 len 20])
                                    staticcall mem[_27844 + 12 len 20].getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _28451 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_28451] == mem[_28451 + 18 len 14]
                                    require mem[_28451 + 32] == mem[_28451 + 50 len 14]
                                    require mem[_28451 + 64] == mem[_28451 + 92 len 4]
                                    require idx < mem[_15437]
                                    require idx + 1 < mem[_15437]
                                    if mem[(32 * idx + 1) + _15437 + 44 len 20] < mem[(32 * idx) + _15437 + 44 len 20]:
                                        if not t:
                                            if mem[_28451 + 50 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_28451 + 50 len 14]
                                                continue 
                                        else:
                                            if mem[_28451 + 18 len 14] * t / t != mem[_28451 + 18 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_28451 + 50 len 14]:
                                                idx = idx + 1
                                                t = mem[_28451 + 18 len 14] * t / mem[_28451 + 50 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 50, ('var', '_28451')), 14)))
                                    else:
                                        if not t:
                                            if mem[_28451 + 18 len 14]:
                                                idx = idx + 1
                                                t = 0 / mem[_28451 + 18 len 14]
                                                continue 
                                        else:
                                            if mem[_28451 + 50 len 14] * t / t != mem[_28451 + 50 len 14]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[_28451 + 18 len 14]:
                                                idx = idx + 1
                                                t = mem[_28451 + 50 len 14] * t / mem[_28451 + 18 len 14]
                                                continue 
                                        ('iszero', ('mem', ('range', ('add', 18, ('var', '_28451')), 14)))
                                    revert
                            else:
                                require stor118.length
                                require stor118.length
                                require address(stor118.field_0) != stakingTokenAddress
                                require 0 < stor118.length
                                mem[0] = 118
                                mem[mem[64] + 4] = stakingTokenAddress
                                require ext_code.size(address(stor118.field_0))
                                staticcall address(stor118.field_0).0x70a08231 with:
                                        gas gas_remaining wei
                                       args stakingTokenAddress
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _16459 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _16842 = mem[_16459]
                                if not mem[_16459]:
                                    _17789 = mem[64]
                                    mem[64] = mem[64] + (32 * stor118.length) + 32
                                    mem[_17789] = stor118.length
                                    if not stor118.length:
                                        idx = 0
                                        t = 0
                                        while idx < stor118.length - 1:
                                            require idx < mem[_17789]
                                            require idx + 1 < mem[_17789]
                                            _20603 = mem[(32 * idx + 1) + _17789 + 32]
                                            mem[mem[64] + 4] = mem[(32 * idx) + _17789 + 44 len 20]
                                            mem[mem[64] + 36] = address(_20603)
                                            require ext_code.size(stor117)
                                            staticcall stor117.getPair(address rg1, address rg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_20603)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _20982 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_20982] == mem[_20982 + 12 len 20]
                                            require ext_code.size(mem[_20982 + 12 len 20])
                                            staticcall mem[_20982 + 12 len 20].getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22806 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            require mem[_22806] == mem[_22806 + 18 len 14]
                                            require mem[_22806 + 32] == mem[_22806 + 50 len 14]
                                            require mem[_22806 + 64] == mem[_22806 + 92 len 4]
                                            require idx < mem[_17789]
                                            require idx + 1 < mem[_17789]
                                            if mem[(32 * idx + 1) + _17789 + 44 len 20] < mem[(32 * idx) + _17789 + 44 len 20]:
                                                if not t:
                                                    if mem[_22806 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22806 + 50 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22806 + 18 len 14] * t / t != mem[_22806 + 18 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22806 + 50 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22806 + 18 len 14] * t / mem[_22806 + 50 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 50, ('var', '_22806')), 14)))
                                            else:
                                                if not t:
                                                    if mem[_22806 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = 0 / mem[_22806 + 18 len 14]
                                                        continue 
                                                else:
                                                    if mem[_22806 + 50 len 14] * t / t != mem[_22806 + 50 len 14]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[_22806 + 18 len 14]:
                                                        idx = idx + 1
                                                        t = mem[_22806 + 50 len 14] * t / mem[_22806 + 18 len 14]
                                                        continue 
                                                ('iszero', ('mem', ('range', ('add', 18, ('var', '_22806')), 14)))
                                            revert
                                        if not s:
                                            if not t:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            return (0 / t)
                                        if 10^18 * s / s != 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not t:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        return (10^18 * s / t)
                                    mem[0] = 118
                                    mem[_17789 + 32] = address(stor118.field_0)
                                    idx = _17789 + 32
                                    t = 0
                                    while _17789 + (32 * stor118.length) > idx:
                                        mem[idx + 32] = stor118[t].field_256
                                        idx = idx + 32
                                        t = t + 1
                                        continue 
                                    idx = 0
                                    t = 0
                                    while idx < stor118.length - 1:
                                        require idx < mem[_17789]
                                        require idx + 1 < mem[_17789]
                                        _27721 = mem[(32 * idx + 1) + _17789 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _17789 + 44 len 20]
                                        mem[mem[64] + 36] = address(_27721)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_27721)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27848 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_27848] == mem[_27848 + 12 len 20]
                                        require ext_code.size(mem[_27848 + 12 len 20])
                                        staticcall mem[_27848 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _28457 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_28457] == mem[_28457 + 18 len 14]
                                        require mem[_28457 + 32] == mem[_28457 + 50 len 14]
                                        require mem[_28457 + 64] == mem[_28457 + 92 len 4]
                                        require idx < mem[_17789]
                                        require idx + 1 < mem[_17789]
                                        if mem[(32 * idx + 1) + _17789 + 44 len 20] < mem[(32 * idx) + _17789 + 44 len 20]:
                                            if not t:
                                                if mem[_28457 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_28457 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_28457 + 18 len 14] * t / t != mem[_28457 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_28457 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_28457 + 18 len 14] * t / mem[_28457 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_28457')), 14)))
                                        else:
                                            if not t:
                                                if mem[_28457 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_28457 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_28457 + 50 len 14] * t / t != mem[_28457 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_28457 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_28457 + 50 len 14] * t / mem[_28457 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_28457')), 14)))
                                        revert
                                    if s:
                                        if 10^18 * s / s != 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not t:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        return (10^18 * s / t)
                                    if t:
                                        return (0 / t)
                                    var111001 = 32
                                    revert with 0, 'SafeMath: division by zero', 0
                                if 2 * mem[_16459] / mem[_16459] != 2:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _17882 = mem[64]
                                mem[64] = mem[64] + (32 * stor118.length) + 32
                                mem[_17882] = stor118.length
                                if not stor118.length:
                                    idx = 0
                                    t = 2 * _16842
                                    while idx < stor118.length - 1:
                                        require idx < mem[_17882]
                                        require idx + 1 < mem[_17882]
                                        _20601 = mem[(32 * idx + 1) + _17882 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _17882 + 44 len 20]
                                        mem[mem[64] + 36] = address(_20601)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_20601)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20980 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20980] == mem[_20980 + 12 len 20]
                                        require ext_code.size(mem[_20980 + 12 len 20])
                                        staticcall mem[_20980 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22803 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_22803] == mem[_22803 + 18 len 14]
                                        require mem[_22803 + 32] == mem[_22803 + 50 len 14]
                                        require mem[_22803 + 64] == mem[_22803 + 92 len 4]
                                        require idx < mem[_17882]
                                        require idx + 1 < mem[_17882]
                                        if mem[(32 * idx + 1) + _17882 + 44 len 20] < mem[(32 * idx) + _17882 + 44 len 20]:
                                            if not t:
                                                if mem[_22803 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22803 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_22803 + 18 len 14] * t / t != mem[_22803 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22803 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22803 + 18 len 14] * t / mem[_22803 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_22803')), 14)))
                                        else:
                                            if not t:
                                                if mem[_22803 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_22803 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_22803 + 50 len 14] * t / t != mem[_22803 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_22803 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_22803 + 50 len 14] * t / mem[_22803 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_22803')), 14)))
                                        revert
                                else:
                                    mem[0] = 118
                                    mem[_17882 + 32] = address(stor118.field_0)
                                    idx = _17882 + 32
                                    t = 0
                                    while _17882 + (32 * stor118.length) > idx:
                                        mem[idx + 32] = stor118[t].field_256
                                        idx = idx + 32
                                        t = t + 1
                                        continue 
                                    idx = 0
                                    t = 2 * _16842
                                    while idx < stor118.length - 1:
                                        require idx < mem[_17882]
                                        require idx + 1 < mem[_17882]
                                        _27719 = mem[(32 * idx + 1) + _17882 + 32]
                                        mem[mem[64] + 4] = mem[(32 * idx) + _17882 + 44 len 20]
                                        mem[mem[64] + 36] = address(_27719)
                                        require ext_code.size(stor117)
                                        staticcall stor117.getPair(address rg1, address rg2) with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4], address(_27719)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _27846 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_27846] == mem[_27846 + 12 len 20]
                                        require ext_code.size(mem[_27846 + 12 len 20])
                                        staticcall mem[_27846 + 12 len 20].getReserves() with:
                                                gas gas_remaining wei
                                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _28454 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        require mem[_28454] == mem[_28454 + 18 len 14]
                                        require mem[_28454 + 32] == mem[_28454 + 50 len 14]
                                        require mem[_28454 + 64] == mem[_28454 + 92 len 4]
                                        require idx < mem[_17882]
                                        require idx + 1 < mem[_17882]
                                        if mem[(32 * idx + 1) + _17882 + 44 len 20] < mem[(32 * idx) + _17882 + 44 len 20]:
                                            if not t:
                                                if mem[_28454 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_28454 + 50 len 14]
                                                    continue 
                                            else:
                                                if mem[_28454 + 18 len 14] * t / t != mem[_28454 + 18 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_28454 + 50 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_28454 + 18 len 14] * t / mem[_28454 + 50 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 50, ('var', '_28454')), 14)))
                                        else:
                                            if not t:
                                                if mem[_28454 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = 0 / mem[_28454 + 18 len 14]
                                                    continue 
                                            else:
                                                if mem[_28454 + 50 len 14] * t / t != mem[_28454 + 50 len 14]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[_28454 + 18 len 14]:
                                                    idx = idx + 1
                                                    t = mem[_28454 + 50 len 14] * t / mem[_28454 + 18 len 14]
                                                    continue 
                                            ('iszero', ('mem', ('range', ('add', 18, ('var', '_28454')), 14)))
                                        revert
    if not s:
        if not t:
            revert with 0, 'SafeMath: division by zero', 0
        return (0 / t)
    if 10^18 * s / s != 10^18:
        revert with 0, 'SafeMath: multiplication overflow'
    if not t:
        revert with 0, 'SafeMath: division by zero', 0
    return (10^18 * s / t)
}



}

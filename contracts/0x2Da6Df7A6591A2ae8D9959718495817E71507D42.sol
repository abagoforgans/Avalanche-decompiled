contract main {




// =====================  Runtime code  =====================


#
#  - sub_480738ad(?)
#
const name = '', 0

const decimals = 18

const symbol = '', 0


address owner;
uint256 totalSupply;
mapping of uint256 balanceOf;
mapping of struct allowance;
address nodeRewardManagementAddress;
address uniswapV2RouterAddress;
address uniswapV2PairAddress;
address deadWalletAddress;
uint256 rewardsFee;
uint256 liquidityPoolFee;
uint256 devFee;
uint256 burnFee;
uint256 totalFees;
uint256 sub_c733da3b;
uint256 sub_d92c842c;
uint256 sub_3705b392;
uint256 sub_c912cc46;
uint256 sub_18b9b19a;
uint256 sub_00afb325;
uint256 swapTokensAmount;
address uniV2RouterAddress;
address stor21;
address stor22;
address sub_e8b7a2b9Address;
address distributionPoolAddress;
address devPoolAddress;
address autoLiquidityReceiverAddress;
uint256 cashoutFee;
mapping of uint8 stor28;
uint256 stor29;
uint8 stor30;
uint8 stor30; offset 8
uint256 stor30; offset 8
uint256 startTime;
uint256 interval;
mapping of uint8 stor33;
mapping of uint8 stor34;
mapping of uint256 sub_6d29ab70;
mapping of uint256 sub_6d79210f;

function sub_00afb325(?) {
    return sub_00afb325
}

function totalFees() {
    return totalFees
}

function uniswapV2Router() {
    return uniswapV2RouterAddress
}

function totalSupply() {
    return totalSupply
}

function sub_18b9b19a(?) {
    return sub_18b9b19a
}

function _isBlacklisted(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor33[arg1])
}

function rewardsFee() {
    return rewardsFee
}

function sub_3705b392(?) {
    return sub_3705b392
}

function uniswapV2Pair() {
    return uniswapV2PairAddress
}

function liquidityPoolFee() {
    return liquidityPoolFee
}

function swapTokensAmount() {
    return swapTokensAmount
}

function devFee() {
    return devFee
}

function nodeRewardManagement() {
    return nodeRewardManagementAddress
}

function sub_6d29ab70(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return sub_6d29ab70[arg1]
}

function sub_6d79210f(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return sub_6d79210f[arg1]
}

function cashoutFee() {
    return cashoutFee
}

function balanceOf(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return balanceOf[address(arg1)]
}

function startTime() {
    return startTime
}

function deadWallet() {
    return deadWalletAddress
}

function getOwner() {
    return owner
}

function owner() {
    return owner
}

function interval() {
    return interval
}

function uniV2Router() {
    return uniV2RouterAddress
}

function devPool() {
    return devPoolAddress
}

function automatedMarketMakerPairs(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor34[arg1])
}

function distributionPool() {
    return distributionPoolAddress
}

function sub_c733da3b(?) {
    return sub_c733da3b
}

function sub_c912cc46(?) {
    return sub_c912cc46
}

function autoLiquidityReceiver() {
    return autoLiquidityReceiverAddress
}

function sub_d92c842c(?) {
    return sub_d92c842c
}

function allowance(address arg1, address arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    return allowance[address(arg1)][address(arg2)].field_0
}

function sub_e8b7a2b9(?) {
    return sub_e8b7a2b9Address
}

function burnFee() {
    return burnFee
}

function shouldTakeFee(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return not bool(stor28[address(arg1)])
}

function renounceOwnership() {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function updateInterval(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    interval = arg1
}

function updateSwapTokensAmount(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    swapTokensAmount = arg1
}

function approveMax(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    allowance[msg.sender][address(arg1)].field_0 = -1
    emit Approval(-1, msg.sender, arg1);
    return 1
}

function approve(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    allowance[msg.sender][address(arg1)].field_0 = arg2
    emit Approval(arg2, msg.sender, arg1);
    return 1
}

function changeSwapLiquify(bool arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    Mask(248, 0, stor30.field_8) = Mask(248, 0, arg1)
}

function blacklistMalicious(address arg1, bool arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor33[address(arg1)] = uint8(arg2)
}

function sub_231a1ce7(?) {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    require arg2 == address(arg2)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    devPoolAddress = address(arg1)
    distributionPoolAddress = address(arg2)
}

function publiDistriRewards() {
    require ext_code.size(nodeRewardManagementAddress)
    call nodeRewardManagementAddress._distributeRewards() with:
         gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 96
}

function recoverLostAVAX() {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    call msg.sender with:
       value eth.balance(this.address) wei
         gas 2300 * is_zero(value) wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function getTotalNodesCreated() {
    require ext_code.size(nodeRewardManagementAddress)
    staticcall nodeRewardManagementAddress.0xb8527aef with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function getGasDistri() {
    require ext_code.size(nodeRewardManagementAddress)
    staticcall nodeRewardManagementAddress.gasForDistribution() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function getDistriCount() {
    require ext_code.size(nodeRewardManagementAddress)
    staticcall nodeRewardManagementAddress.lastDistributionCount() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function getTotalRewardStaked() {
    require ext_code.size(nodeRewardManagementAddress)
    staticcall nodeRewardManagementAddress.totalRewardStaked() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function transferOwnership(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function sub_c1f96b3b(?) {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    require ext_code.size(nodeRewardManagementAddress)
    call nodeRewardManagementAddress.0xea55e24e with:
         gas gas_remaining wei
        args arg1, arg2
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function getAutoDistri() {
    require ext_code.size(nodeRewardManagementAddress)
    staticcall nodeRewardManagementAddress.autoDistri() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    return bool(ext_call.return_data[0])
}

function changeGasDistri(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    require ext_code.size(nodeRewardManagementAddress)
    call nodeRewardManagementAddress._changeGasDistri(uint256 arg1) with:
         gas gas_remaining wei
        args arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function sub_a52a8678(?) {
    require calldata.size - 4 >= 32
    require arg1 == uint8(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    require ext_code.size(nodeRewardManagementAddress)
    call nodeRewardManagementAddress.0x4e09a5f6 with:
         gas gas_remaining wei
        args uint8(arg1)
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function sub_baf8879e(?) {
    require calldata.size - 4 >= 32
    require arg1 == uint8(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    require ext_code.size(nodeRewardManagementAddress)
    call nodeRewardManagementAddress.0x58e1cd45 with:
         gas gas_remaining wei
        args uint8(arg1)
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function sub_ada1a6a8(?) {
    require calldata.size - 4 >= 32
    require arg1 == uint8(arg1)
    require ext_code.size(nodeRewardManagementAddress)
    staticcall nodeRewardManagementAddress.0x9d3c20ba with:
            gas gas_remaining wei
           args msg.sender, uint8(arg1)
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function changeAutoDistri(bool arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    require ext_code.size(nodeRewardManagementAddress)
    call nodeRewardManagementAddress._changeAutoDistri(bool arg1) with:
         gas gas_remaining wei
        args arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function getNodeNumberOf(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    require ext_code.size(nodeRewardManagementAddress)
    staticcall nodeRewardManagementAddress._getNodeNumberOf(address arg1) with:
            gas gas_remaining wei
           args arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function sub_4d2e5119(?) {
    require calldata.size - 4 >= 32
    require arg1 == uint8(arg1)
    require ext_code.size(nodeRewardManagementAddress)
    staticcall nodeRewardManagementAddress.0x3add38de with:
            gas gas_remaining wei
           args arg1 << 248, balanceOf[address(msg.sender)]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function getCirculatingSupply() {
    if balanceOf[stor21] > totalSupply:
        revert with 0, 'SafeMath: subtraction overflow', 0
    if totalSupply < balanceOf[stor21]:
        revert with 0, 17
    if balanceOf[stor22] > totalSupply - balanceOf[stor21]:
        revert with 0, 'SafeMath: subtraction overflow', 0
    if totalSupply - balanceOf[stor21] < balanceOf[stor22]:
        revert with 0, 17
    return (totalSupply - balanceOf[stor21] - balanceOf[stor22])
}

function sub_9922b4c9(?) {
    require calldata.size - 4 >= 224
    require arg1 == uint8(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    require ext_code.size(nodeRewardManagementAddress)
    call nodeRewardManagementAddress.0x9867ae29 with:
         gas gas_remaining wei
        args 0, 0, arg2, arg3, arg4, arg5, arg6, arg7
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function distributeRewards() {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    require ext_code.size(nodeRewardManagementAddress)
    call nodeRewardManagementAddress._distributeRewards() with:
         gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 96
    return ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64]
}

function sub_149d5660(?) {
    require ext_code.size(nodeRewardManagementAddress)
    staticcall nodeRewardManagementAddress.0x7c942fa6 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 64
    require 191 < return_data.size + 160
    if not bool(ceil32(return_data.size) + 224 <= test266151307()):
        revert with 0, 65
    require 64 <= return_data.size
    return ext_call.return_data[0 len 64]
}

function sub_466f6311(?) {
    if balanceOf[address(msg.sender)] > !sub_6d29ab70[msg.sender]:
        revert with 0, 17
    require ext_code.size(nodeRewardManagementAddress)
    staticcall nodeRewardManagementAddress.0x6591f30a with:
            gas gas_remaining wei
           args msg.sender, balanceOf[address(msg.sender)] + sub_6d29ab70[msg.sender]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function getRewardAmountOf(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    require ext_code.size(nodeRewardManagementAddress)
    staticcall nodeRewardManagementAddress._getRewardAmountOf(address arg1) with:
            gas gas_remaining wei
           args arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function sub_5d7e9c2a(?) {
    require calldata.size - 4 >= 224
    require arg1 == uint8(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if arg3 and 10^18 > -1 / arg3:
        revert with 0, 17
    if arg5 and 10^18 > -1 / arg5:
        revert with 0, 17
    require ext_code.size(nodeRewardManagementAddress)
    call nodeRewardManagementAddress.0x9867ae29 with:
         gas gas_remaining wei
        args 0, 0, arg2, 10^18 * arg3, arg4, 10^18 * arg5, arg6, arg7
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function transfer(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer to the zero address'
    if stor33[address(msg.sender)]:
        revert with 0, 'Blacklisted address'
    if stor33[address(arg1)]:
        revert with 0, 'Blacklisted address'
    emit Transfer(arg2, msg.sender, arg1);
    return 1
}

function sub_9725cd5b(?) {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not this.address:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'
    if not owner:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer to the zero address'
    if stor33[address(this.address)]:
        revert with 0, 'Blacklisted address'
    if stor33[stor0]:
        revert with 0, 'Blacklisted address'
    emit Transfer(balanceOf[address(this.address)], this.address, owner);
}

function updateFees(uint256 arg1, uint256 arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6) {
    require calldata.size - 4 >= 192
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    burnFee = arg1
    rewardsFee = arg4
    liquidityPoolFee = arg2
    devFee = arg3
    cashoutFee = arg5
    stor29 = arg6
    if arg4 > !arg2:
        revert with 0, 17
    if arg4 + arg2 < arg4:
        revert with 0, 'SafeMath: addition overflow'
    if arg4 + arg2 > !arg3:
        revert with 0, 17
    if arg3 < 0:
        revert with 0, 'SafeMath: addition overflow'
    if arg4 + arg2 + arg3 > !arg1:
        revert with 0, 17
    if arg1 < 0:
        revert with 0, 'SafeMath: addition overflow'
    totalFees = arg4 + arg2 + arg3 + arg1
}

function getRewardAmount() {
    if not msg.sender:
        revert with 0, 'SENDER CAN'T BE ZERO'
    require ext_code.size(nodeRewardManagementAddress)
    staticcall nodeRewardManagementAddress._isNodeOwner(address arg1) with:
            gas gas_remaining wei
           args msg.sender
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if not ext_call.return_data[0]:
        revert with 0, 'NO NODE OWNER'
    require ext_code.size(nodeRewardManagementAddress)
    staticcall nodeRewardManagementAddress._getRewardAmountOf(address arg1) with:
            gas gas_remaining wei
           args msg.sender
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function transferFrom(address arg1, address arg2, uint256 arg3) {
    require calldata.size - 4 >= 96
    require arg1 == arg1
    require arg2 == arg2
    if -1 == allowance[address(arg1)][msg.sender].field_0:
        if not arg1:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'
        if not arg2:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer to the zero address'
    else:
        if arg3 > allowance[address(arg1)][address(msg.sender)].field_0:
            revert with 0, 'Insufficient Allowance', 0
        if allowance[address(arg1)][address(msg.sender)].field_0 < arg3:
            revert with 0, 17
        allowance[address(arg1)][msg.sender].field_0 = allowance[address(arg1)][address(msg.sender)].field_0 - arg3
        if not arg1:
            revert with 0, 'ERC20: transfer from the zero address'
        if not arg2:
            revert with 0, 'ERC20: transfer to the zero address'
    ('bool', ('param', 'arg2'))
    if stor33[address(arg1)]:
        revert with 0, 'Blacklisted address'
    if stor33[address(arg2)]:
        revert with 0, 'Blacklisted address'
    emit Transfer(arg3, arg1, arg2);
    return 1
}

function swapTokensForEth(uint256 arg1) {
    require calldata.size - 4 >= 32
    mem[128] = this.address
    require ext_code.size(uniswapV2RouterAddress)
    staticcall uniswapV2RouterAddress.WAVAX() with:
            gas gas_remaining wei
    mem[192] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    mem[160] = ext_call.return_data[12 len 20]
    allowance[msg.sender][stor20].field_0 = arg1
    emit Approval(arg1, msg.sender, uniV2RouterAddress);
    mem[ceil32(return_data.size) + 192] = 0x762b156200000000000000000000000000000000000000000000000000000000
    mem[ceil32(return_data.size) + 196] = arg1
    idx = 0
    s = ceil32(return_data.size) + 388
    t = 128
    while idx < 2:
        mem[s] = mem[t + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ext_code.size(uniswapV2RouterAddress)
    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
         gas gas_remaining wei
        args arg1, 0, 160, address(this.address), block.timestamp, 2, mem[ceil32(return_data.size) + 388 len 64]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function sub_0406c49c(?) {
    require calldata.size - 4 >= 64
    require cd[4] <= test266151307()
    require calldata.size > cd[4] + 35
    if ('cd', 4).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 4).length) + 97 < 96 or ceil32(32 * ('cd', 4).length) + 97 > test266151307():
        revert with 0, 65
    mem[96] = ('cd', 4).length
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    s = cd[4] + 36
    t = 128
    idx = 0
    while idx < ('cd', 4).length:
        require cd[s] == uint8(cd[s])
        mem[t] = cd[s]
        s = s + 32
        t = t + 32
        idx = idx + 1
        continue 
    require cd[36] == address(cd[36])
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    idx = 0
    while idx < ('cd', 4).length:
        if idx >= mem[96]:
            revert with 0, 50
        _18 = mem[(32 * idx) + 128]
        mem[ceil32(32 * ('cd', 4).length) + 97] = 0x37696eec00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * ('cd', 4).length) + 101] = address(cd[36])
        mem[ceil32(32 * ('cd', 4).length) + 133] = uint8(_18)
        require ext_code.size(nodeRewardManagementAddress)
        call nodeRewardManagementAddress.0x37696eec with:
             gas gas_remaining wei
            args address(cd[36]), uint8(_18)
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
}

function takeBuyFee(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if not arg2:
        if not arg1:
            revert with 0, 'ERC20: transfer from the zero address'
        if not sub_e8b7a2b9Address:
            revert with 0, 'ERC20: transfer to the zero address'
        if stor33[address(arg1)]:
            revert with 0, 'Blacklisted address'
        if stor33[stor23]:
            revert with 0, 'Blacklisted address'
        emit Transfer(0, arg1, sub_e8b7a2b9Address);
        if 0 > arg2:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg2 < 0:
            revert with 0, 17
        return arg2
    if arg2 and sub_3705b392 > -1 / arg2:
        revert with 0, 17
    if not arg2:
        revert with 0, 18
    if arg2 * sub_3705b392 / arg2 != sub_3705b392:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
    if not arg1:
        revert with 0, 'ERC20: transfer from the zero address'
    if not sub_e8b7a2b9Address:
        revert with 0, 'ERC20: transfer to the zero address'
    if stor33[address(arg1)]:
        revert with 0, 'Blacklisted address'
    if stor33[stor23]:
        revert with 0, 'Blacklisted address'
    emit Transfer((arg2 * sub_3705b392 / 100), arg1, sub_e8b7a2b9Address);
    if arg2 * sub_3705b392 / 100 > arg2:
        revert with 0, 'SafeMath: subtraction overflow', 0
    if arg2 < arg2 * sub_3705b392 / 100:
        revert with 0, 17
    return (arg2 - (arg2 * sub_3705b392 / 100))
}

function takeSellFee(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if not arg2:
        if not arg1:
            revert with 0, 'ERC20: transfer from the zero address'
        if not sub_e8b7a2b9Address:
            revert with 0, 'ERC20: transfer to the zero address'
        if stor33[address(arg1)]:
            revert with 0, 'Blacklisted address'
        if stor33[stor23]:
            revert with 0, 'Blacklisted address'
        emit Transfer(0, arg1, sub_e8b7a2b9Address);
        if 0 > arg2:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg2 < 0:
            revert with 0, 17
        return arg2
    if arg2 and sub_00afb325 > -1 / arg2:
        revert with 0, 17
    if not arg2:
        revert with 0, 18
    if arg2 * sub_00afb325 / arg2 != sub_00afb325:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
    if not arg1:
        revert with 0, 'ERC20: transfer from the zero address'
    if not sub_e8b7a2b9Address:
        revert with 0, 'ERC20: transfer to the zero address'
    if stor33[address(arg1)]:
        revert with 0, 'Blacklisted address'
    if stor33[stor23]:
        revert with 0, 'Blacklisted address'
    emit Transfer((arg2 * sub_00afb325 / 100), arg1, sub_e8b7a2b9Address);
    if arg2 * sub_00afb325 / 100 > arg2:
        revert with 0, 'SafeMath: subtraction overflow', 0
    if arg2 < arg2 * sub_00afb325 / 100:
        revert with 0, 17
    return (arg2 - (arg2 * sub_00afb325 / 100))
}

function types() {
    mem[96] = 0xb2e853e300000000000000000000000000000000000000000000000000000000
    require ext_code.size(nodeRewardManagementAddress)
    staticcall nodeRewardManagementAddress.0xb2e853e3 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[96 len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = ceil32(return_data.size) + 96
    require return_data.size >= 32
    _4 = mem[96]
    require mem[96] <= test266151307()
    require return_data.size + 96 > mem[96] + 127
    _5 = mem[mem[96] + 96]
    if mem[mem[96] + 96] > test266151307():
        revert with 0, 65
    if ceil32(32 * mem[mem[96] + 96]) + 1 < 0 or ceil32(return_data.size) + ceil32(32 * mem[mem[96] + 96]) + 97 > test266151307():
        revert with 0, 65
    mem[64] = ceil32(return_data.size) + ceil32(32 * mem[mem[96] + 96]) + 97
    mem[ceil32(return_data.size) + 96] = _5
    require _4 + (32 * _5) + 32 <= return_data.size
    s = _4 + 128
    t = ceil32(return_data.size) + 128
    idx = 0
    while idx < _5:
        require mem[s] == mem[s + 31 len 1]
        mem[t] = mem[s]
        s = s + 32
        t = t + 32
        idx = idx + 1
        continue 
    _13 = mem[64]
    mem[mem[64]] = 32
    mem[mem[64] + 32] = _5
    idx = 0
    s = mem[64] + 64
    t = ceil32(return_data.size) + 128
    while idx < _5:
        mem[s] = mem[t + 31 len 1]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    return memory
      from mem[64]
       len _13 + (32 * _5) + -mem[64] + 64
}

function swapAndLiquify(uint256 arg1) {
    require calldata.size - 4 >= 32
    if arg1 / 2 > arg1:
        revert with 0, 'SafeMath: subtraction overflow', 0
    if arg1 < arg1 / 2:
        revert with 0, 17
    mem[256] = this.address
    require ext_code.size(uniswapV2RouterAddress)
    staticcall uniswapV2RouterAddress.WAVAX() with:
            gas gas_remaining wei
    mem[320] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    mem[288] = ext_call.return_data[12 len 20]
    allowance[msg.sender][stor20].field_0 = arg1 / 2
    allowance[msg.sender][stor20].field_255 = 0
    emit Approval((arg1 / 2), msg.sender, uniV2RouterAddress);
    mem[ceil32(return_data.size) + 320] = 0x762b156200000000000000000000000000000000000000000000000000000000
    mem[ceil32(return_data.size) + 324] = arg1 / 2
    idx = 0
    s = ceil32(return_data.size) + 516
    t = 256
    while idx < 2:
        mem[s] = mem[t + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ext_code.size(uniswapV2RouterAddress)
    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
         gas gas_remaining wei
        args Mask(255, 1, arg1), 0, 160, address(this.address), block.timestamp, 2, mem[ceil32(return_data.size) + 516 len 64]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    if eth.balance(this.address) > eth.balance(this.address):
        revert with 0, 'SafeMath: subtraction overflow', 0
    if eth.balance(this.address) < eth.balance(this.address):
        revert with 0, 17
    allowance[msg.sender][stor20].field_0 = arg1 - (arg1 / 2)
    emit Approval((arg1 - (arg1 / 2)), msg.sender, uniV2RouterAddress);
    require ext_code.size(uniswapV2RouterAddress)
    call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
         gas gas_remaining wei
        args this.address, arg1 - (arg1 / 2), 0, 0, 0, block.timestamp
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 96
    emit SwapAndLiquify(Mask(255, 1, arg1), 0, arg1 - (arg1 / 2));
}

function cashoutAll() {
    require not stor33[msg.sender]
    mem[100] = msg.sender
    require ext_code.size(nodeRewardManagementAddress)
    staticcall nodeRewardManagementAddress._getRewardAmountOf(address arg1) with:
            gas gas_remaining wei
           args msg.sender
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] > 0
    if not uint8(stor30.field_8):
        if not distributionPoolAddress:
            revert with 0, 'ERC20: transfer from the zero address'
        if not msg.sender:
            revert with 0, 'ERC20: transfer to the zero address'
        if stor33[stor24]:
            revert with 0, 'Blacklisted address'
        if stor33[address(msg.sender)]:
            revert with 0, 'Blacklisted address'
        emit Transfer(ext_call.return_data[0], distributionPoolAddress, msg.sender);
    else:
        if not cashoutFee:
            if ext_call.return_data[0] < 0:
                revert with 0, 17
            if not distributionPoolAddress:
                revert with 0, 'ERC20: transfer from the zero address'
            if not msg.sender:
                revert with 0, 'ERC20: transfer to the zero address'
            if stor33[stor24]:
                revert with 0, 'Blacklisted address'
            if stor33[address(msg.sender)]:
                revert with 0, 'Blacklisted address'
            emit Transfer(ext_call.return_data[0], distributionPoolAddress, msg.sender);
        else:
            if not ext_call.return_data[0]:
                mem[ceil32(return_data.size) + 96] = 26
                mem[ceil32(return_data.size) + 128] = 'SafeMath: division by zero'
                mem[ceil32(return_data.size) + 160] = 2
                mem[ceil32(return_data.size) + 192] = this.address
                require ext_code.size(uniswapV2RouterAddress)
                staticcall uniswapV2RouterAddress.WAVAX() with:
                        gas gas_remaining wei
                mem[ceil32(return_data.size) + 256] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = (2 * ceil32(return_data.size)) + 256
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                mem[ceil32(return_data.size) + 224] = ext_call.return_data[12 len 20]
                mem[0] = uniV2RouterAddress
                mem[32] = sha3(msg.sender, 3)
                allowance[msg.sender][stor20].field_0 = 0
                mem[(2 * ceil32(return_data.size)) + 256] = 0
                emit Approval(mem[(2 * ceil32(return_data.size)) + 256 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                mem[(2 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                mem[(2 * ceil32(return_data.size)) + 260] = 0
                mem[(2 * ceil32(return_data.size)) + 292] = 0
                mem[(2 * ceil32(return_data.size)) + 324] = 160
                mem[(2 * ceil32(return_data.size)) + 420] = 2
                idx = 0
                s = (2 * ceil32(return_data.size)) + 452
                t = ceil32(return_data.size) + 192
                while idx < mem[ceil32(return_data.size) + 160]:
                    mem[s] = mem[t + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[(2 * ceil32(return_data.size)) + 356] = this.address
                mem[(2 * ceil32(return_data.size)) + 388] = block.timestamp
                require ext_code.size(uniswapV2RouterAddress)
                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 512]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if eth.balance(this.address) > eth.balance(this.address):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if eth.balance(this.address) < eth.balance(this.address):
                    revert with 0, 17
                call devPoolAddress with:
                     gas 30000 wei
                if ext_call.return_data[0] < 0:
                    revert with 0, 17
                if not distributionPoolAddress:
                    revert with 0, 'ERC20: transfer from the zero address'
                if not msg.sender:
                    revert with 0, 'ERC20: transfer to the zero address'
                if stor33[stor24]:
                    revert with 0, 'Blacklisted address'
                if stor33[address(msg.sender)]:
                    revert with 0, 'Blacklisted address'
                emit Transfer(ext_call.return_data[0], distributionPoolAddress, msg.sender);
            else:
                if ext_call.return_data[0] and cashoutFee > -1 / ext_call.return_data[0]:
                    revert with 0, 17
                if not ext_call.return_data[0]:
                    revert with 0, 18
                if ext_call.return_data[0] * cashoutFee / ext_call.return_data[0] != cashoutFee:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[ceil32(return_data.size) + 96] = 26
                mem[ceil32(return_data.size) + 128] = 'SafeMath: division by zero'
                mem[ceil32(return_data.size) + 160] = 2
                mem[ceil32(return_data.size) + 192] = this.address
                require ext_code.size(uniswapV2RouterAddress)
                staticcall uniswapV2RouterAddress.WAVAX() with:
                        gas gas_remaining wei
                mem[ceil32(return_data.size) + 256] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = (2 * ceil32(return_data.size)) + 256
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                mem[ceil32(return_data.size) + 224] = ext_call.return_data[12 len 20]
                mem[0] = uniV2RouterAddress
                mem[32] = sha3(msg.sender, 3)
                allowance[msg.sender][stor20].field_0 = ext_call.return_data[0] * cashoutFee / 100
                mem[(2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0] * cashoutFee / 100
                emit Approval(mem[(2 * ceil32(return_data.size)) + 256 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                mem[(2 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                mem[(2 * ceil32(return_data.size)) + 260] = ext_call.return_data[0] * cashoutFee / 100
                mem[(2 * ceil32(return_data.size)) + 292] = 0
                mem[(2 * ceil32(return_data.size)) + 324] = 160
                mem[(2 * ceil32(return_data.size)) + 420] = 2
                idx = 0
                s = (2 * ceil32(return_data.size)) + 452
                t = ceil32(return_data.size) + 192
                while idx < mem[ceil32(return_data.size) + 160]:
                    mem[s] = mem[t + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[(2 * ceil32(return_data.size)) + 356] = this.address
                mem[(2 * ceil32(return_data.size)) + 388] = block.timestamp
                require ext_code.size(uniswapV2RouterAddress)
                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 512]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if eth.balance(this.address) > eth.balance(this.address):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if eth.balance(this.address) < eth.balance(this.address):
                    revert with 0, 17
                call devPoolAddress with:
                     gas 30000 wei
                if ext_call.return_data[0] < ext_call.return_data[0] * cashoutFee / 100:
                    revert with 0, 17
                if not distributionPoolAddress:
                    revert with 0, 'ERC20: transfer from the zero address'
                if not msg.sender:
                    revert with 0, 'ERC20: transfer to the zero address'
                if stor33[stor24]:
                    revert with 0, 'Blacklisted address'
                if stor33[address(msg.sender)]:
                    revert with 0, 'Blacklisted address'
                emit Transfer((ext_call.return_data[0] - (ext_call.return_data[0] * cashoutFee / 100)), distributionPoolAddress, msg.sender);
    require ext_code.size(nodeRewardManagementAddress)
    call nodeRewardManagementAddress._cashoutAllNodesReward(address arg1) with:
         gas gas_remaining wei
        args msg.sender
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
}

function _fallback() payable {
    if calldata.size < 4:
        require not calldata.size
    else:
        if unknown_0x77c0ef1d(?????) <= uint32(call.func_hash) >> 224:
            if unknown_0xb96392c1(?????) > uint32(call.func_hash) >> 224:
                if unknown_0x9725cd5b(?????) > uint32(call.func_hash) >> 224:
                    if unknown_0x893d20e8(?????) <= uint32(call.func_hash) >> 224:
                        if unknown_0x893d20e8(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            return owner
                        if unknown_0x8da5cb5b(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            return owner
                        if unknown_0x947a36fb(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            return interval
                        if unknown_0x958c2e52(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            return uniV2RouterAddress
                        require unknown_0x95d89b41(?????) == uint32(call.func_hash) >> 224
                        require not msg.value
                        return '', 0
                    if uint32(call.func_hash) >> 224 != unknown_0x77c0ef1d(?????):
                        if unknown_0x78e97925(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            return startTime
                        if unknown_0x823349b3(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            require ext_code.size(nodeRewardManagementAddress)
                            staticcall nodeRewardManagementAddress.0xb8527aef with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            return ext_call.return_data[0]
                        if unknown_0x85141a77(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            return deadWalletAddress
                        require unknown_0x8743ef6d(?????) == uint32(call.func_hash) >> 224
                        require not msg.value
                        require ext_code.size(nodeRewardManagementAddress)
                        call nodeRewardManagementAddress._distributeRewards() with:
                             gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 96
                    require not msg.value
                    require calldata.size - 4 >= 64
                    require cd[4] == address(cd[4])
                    if not cd[36]:
                        if not address(cd[4]):
                            revert with 0, 'ERC20: transfer from the zero address'
                        if not sub_e8b7a2b9Address:
                            revert with 0, 'ERC20: transfer to the zero address'
                        if stor33[address(cd[4])]:
                            revert with 0, 'Blacklisted address'
                        if stor33[stor23]:
                            revert with 0, 'Blacklisted address'
                        emit Transfer(0, address(cd[4]), sub_e8b7a2b9Address);
                        if 0 > cd[36]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if cd[36] < 0:
                            revert with 0, 17
                        return cd[36]
                    if cd[36] and sub_3705b392 > -1 / cd[36]:
                        revert with 0, 17
                    if not cd[36]:
                        revert with 0, 18
                    if cd[36] * sub_3705b392 / cd[36] != sub_3705b392:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not address(cd[4]):
                        revert with 0, 'ERC20: transfer from the zero address'
                    if not sub_e8b7a2b9Address:
                        revert with 0, 'ERC20: transfer to the zero address'
                    if stor33[address(cd[4])]:
                        revert with 0, 'Blacklisted address'
                    if stor33[stor23]:
                        revert with 0, 'Blacklisted address'
                    emit Transfer((cd[36] * sub_3705b392 / 100), address(cd[4]), sub_e8b7a2b9Address);
                    if cd[36] * sub_3705b392 / 100 > cd[36]:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if cd[36] < cd[36] * sub_3705b392 / 100:
                        revert with 0, 17
                    return (cd[36] - (cd[36] * sub_3705b392 / 100))
                if unknown_0xa9059cbb(?????) > uint32(call.func_hash) >> 224:
                    if unknown_0x9725cd5b(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        if owner != msg.sender:
                            revert with 0, 'Ownable: caller is not the owner'
                        if not this.address:
                            revert with 0, 'ERC20: transfer from the zero address'
                        if not owner:
                            revert with 0, 'ERC20: transfer to the zero address'
                        if stor33[address(this.address)]:
                            revert with 0, 'Blacklisted address'
                        if stor33[stor0]:
                            revert with 0, 'Blacklisted address'
                        emit Transfer(balanceOf[address(this.address)], this.address, owner);
                    else:
                        if unknown_0x9922b4c9(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            require calldata.size - 4 >= 224
                            require cd[4] == uint8(cd[4])
                            if owner != msg.sender:
                                revert with 0, 'Ownable: caller is not the owner'
                            require ext_code.size(nodeRewardManagementAddress)
                            call nodeRewardManagementAddress.0x9867ae29 with:
                                 gas gas_remaining wei
                                args 0, 0, cd[36], cd[68], cd[100], cd[132], cd[164], cd[196]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                        else:
                            if uint32(call.func_hash) >> 224 != unknown_0x992c58e4(?????):
                                if uint32(call.func_hash) >> 224 != unknown_0xa52a8678(?????):
                                    require unknown_0xa647c9ff(?????) == uint32(call.func_hash) >> 224
                                    require not msg.value
                                    if owner != msg.sender:
                                        revert with 0, 'Ownable: caller is not the owner'
                                    call msg.sender with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                else:
                                    require not msg.value
                                    require calldata.size - 4 >= 32
                                    require cd[4] == uint8(cd[4])
                                    if owner != msg.sender:
                                        revert with 0, 'Ownable: caller is not the owner'
                                    require ext_code.size(nodeRewardManagementAddress)
                                    call nodeRewardManagementAddress.0x4e09a5f6 with:
                                         gas gas_remaining wei
                                        args uint8(cd[4])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            else:
                                require not msg.value
                                require calldata.size - 4 >= 192
                                if owner != msg.sender:
                                    revert with 0, 'Ownable: caller is not the owner'
                                burnFee = cd[4]
                                rewardsFee = cd[100]
                                liquidityPoolFee = cd[36]
                                devFee = cd[68]
                                cashoutFee = cd[132]
                                stor29 = cd[164]
                                if cd[100] > !cd[36]:
                                    revert with 0, 17
                                if cd[100] + cd[36] < cd[100]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if cd[100] + cd[36] > !cd[68]:
                                    revert with 0, 17
                                if cd[68] < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if cd[100] + cd[36] + cd[68] > !cd[4]:
                                    revert with 0, 17
                                if cd[4] < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees = cd[100] + cd[36] + cd[68] + cd[4]
                else:
                    if unknown_0xa9059cbb(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        require calldata.size - 4 >= 64
                        require cd[4] == address(cd[4])
                        if not msg.sender:
                            revert with 0, 'ERC20: transfer from the zero address'
                        if not address(cd[4]):
                            revert with 0, 'ERC20: transfer to the zero address'
                        if stor33[address(msg.sender)]:
                            revert with 0, 'Blacklisted address'
                        if stor33[address(cd[4])]:
                            revert with 0, 'Blacklisted address'
                        emit Transfer(cd[36], msg.sender, address(cd[4]));
                        return 1
                    if unknown_0xada1a6a8(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        require calldata.size - 4 >= 32
                        require cd[4] == uint8(cd[4])
                        require ext_code.size(nodeRewardManagementAddress)
                        staticcall nodeRewardManagementAddress.0x9d3c20ba with:
                                gas gas_remaining wei
                               args msg.sender, uint8(cd[4])
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        return ext_call.return_data[0]
                    if uint32(call.func_hash) >> 224 != unknown_0xb28805f4(?????):
                        if unknown_0xb5838a27(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            return devPoolAddress
                        require unknown_0xb62496f5(?????) == uint32(call.func_hash) >> 224
                        require not msg.value
                        require calldata.size - 4 >= 32
                        require cd[4] == address(cd[4])
                        return bool(stor34[cd[4]])
                    require not msg.value
                    require calldata.size - 4 >= 32
                    mem[160] = this.address
                    require ext_code.size(uniswapV2RouterAddress)
                    staticcall uniswapV2RouterAddress.WAVAX() with:
                            gas gas_remaining wei
                    mem[224] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    mem[192] = ext_call.return_data[12 len 20]
                    allowance[msg.sender][stor20].field_0 = cd[4]
                    emit Approval(cd[4], msg.sender, uniV2RouterAddress);
                    mem[ceil32(return_data.size) + 224] = 0x762b156200000000000000000000000000000000000000000000000000000000
                    mem[ceil32(return_data.size) + 228] = cd[4]
                    idx = 0
                    s = ceil32(return_data.size) + 420
                    t = 160
                    while idx < 2:
                        mem[s] = mem[t + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    require ext_code.size(uniswapV2RouterAddress)
                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args cd[4], 0, 160, address(this.address), block.timestamp, 2, mem[ceil32(return_data.size) + 420 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
            if unknown_0xd8929342(?????) <= uint32(call.func_hash) >> 224:
                if unknown_0xe8b7a2b9(?????) > uint32(call.func_hash) >> 224:
                    if unknown_0xd8929342(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        require calldata.size - 4 >= 64
                        require cd[4] == address(cd[4])
                        require cd[36] == bool(cd[36])
                        if owner != msg.sender:
                            revert with 0, 'Ownable: caller is not the owner'
                        stor33[address(cd[4])] = uint8(bool(cd[36]))
                    if unknown_0xd92c842c(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        return sub_d92c842c
                    if unknown_0xda41b333(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        require ext_code.size(nodeRewardManagementAddress)
                        staticcall nodeRewardManagementAddress.lastDistributionCount() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        return ext_call.return_data[0]
                    if unknown_0xdd62ed3e(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        require calldata.size - 4 >= 64
                        require cd[4] == address(cd[4])
                        require cd[36] == address(cd[36])
                        return allowance[address(cd[4])][address(cd[36])].field_0
                    require unknown_0xe7c44c69(?????) == uint32(call.func_hash) >> 224
                    require not msg.value
                    require calldata.size - 4 >= 32
                    require cd[4] == address(cd[4])
                    return not bool(stor28[address(cd[4])])
                if unknown_0xe8b7a2b9(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    return sub_e8b7a2b9Address
                if unknown_0xf2fde38b(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    require calldata.size - 4 >= 32
                    require cd[4] == address(cd[4])
                    if owner != msg.sender:
                        revert with 0, 'Ownable: caller is not the owner'
                    if not address(cd[4]):
                        revert with 0, 'Ownable: new owner is the zero address'
                    emit OwnershipTransferred(owner, address(cd[4]));
                    owner = address(cd[4])
                if unknown_0xf74c9934(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    require calldata.size - 4 >= 32
                    require cd[4] == address(cd[4])
                    require ext_code.size(nodeRewardManagementAddress)
                    staticcall nodeRewardManagementAddress._getNodeNumberOf(address arg1) with:
                            gas gas_remaining wei
                           args address(cd[4])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if unknown_0xf7b9f943(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    require ext_code.size(nodeRewardManagementAddress)
                    staticcall nodeRewardManagementAddress.gasForDistribution() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if uint32(call.func_hash) >> 224 != unknown_0xf9afc763(?????):
                    require unknown_0xfce589d8(?????) == uint32(call.func_hash) >> 224
                    require not msg.value
                    return burnFee
                require not msg.value
                require ext_code.size(nodeRewardManagementAddress)
                staticcall nodeRewardManagementAddress.autoDistri() with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                return bool(ext_call.return_data[0])
            if unknown_0xc912cc46(?????) > uint32(call.func_hash) >> 224:
                if unknown_0xb96392c1(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    require calldata.size - 4 >= 32
                    require cd[4] == address(cd[4])
                    if owner != msg.sender:
                        revert with 0, 'Ownable: caller is not the owner'
                    require ext_code.size(nodeRewardManagementAddress)
                    staticcall nodeRewardManagementAddress._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args address(cd[4])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if unknown_0xbaf8879e(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    require calldata.size - 4 >= 32
                    require cd[4] == uint8(cd[4])
                    if owner != msg.sender:
                        revert with 0, 'Ownable: caller is not the owner'
                    require ext_code.size(nodeRewardManagementAddress)
                    call nodeRewardManagementAddress.0x58e1cd45 with:
                         gas gas_remaining wei
                        args uint8(cd[4])
                else:
                    if uint32(call.func_hash) >> 224 != unknown_0xc1f96b3b(?????):
                        if unknown_0xc5ca7d6d(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            return distributionPoolAddress
                        require unknown_0xc733da3b(?????) == uint32(call.func_hash) >> 224
                        require not msg.value
                        return sub_c733da3b
                    require not msg.value
                    require calldata.size - 4 >= 64
                    if owner != msg.sender:
                        revert with 0, 'Ownable: caller is not the owner'
                    require ext_code.size(nodeRewardManagementAddress)
                    call nodeRewardManagementAddress.0xea55e24e with:
                         gas gas_remaining wei
                        args cd[4], cd[36]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
            if unknown_0xc912cc46(?????) == uint32(call.func_hash) >> 224:
                require not msg.value
                return sub_c912cc46
            if unknown_0xca33e64c(?????) == uint32(call.func_hash) >> 224:
                require not msg.value
                return autoLiquidityReceiverAddress
            if uint32(call.func_hash) >> 224 != unknown_0xccbff979(?????):
                if unknown_0xd0f07926(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    require calldata.size - 4 >= 32
                    if owner != msg.sender:
                        revert with 0, 'Ownable: caller is not the owner'
                    interval = cd[4]
                else:
                    require unknown_0xd0f77474(?????) == uint32(call.func_hash) >> 224
                    require not msg.value
                    require calldata.size - 4 >= 32
                    require cd[4] == bool(cd[4])
                    if owner != msg.sender:
                        revert with 0, 'Ownable: caller is not the owner'
                    require ext_code.size(nodeRewardManagementAddress)
                    call nodeRewardManagementAddress._changeAutoDistri(bool arg1) with:
                         gas gas_remaining wei
                        args bool(cd[4])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
            require not msg.value
            mem[128] = 0xb2e853e300000000000000000000000000000000000000000000000000000000
            require ext_code.size(nodeRewardManagementAddress)
            staticcall nodeRewardManagementAddress.0xb2e853e3 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[128 len return_data.size] = ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _124 = mem[128]
            require mem[128] <= test266151307()
            require return_data.size + 128 > mem[128] + 159
            _178 = mem[mem[128] + 128]
            if mem[mem[128] + 128] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[mem[128] + 128]) + 1 < 0 or ceil32(return_data.size) + ceil32(32 * mem[mem[128] + 128]) + 129 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(return_data.size) + ceil32(32 * mem[mem[128] + 128]) + 129
            mem[ceil32(return_data.size) + 128] = mem[mem[128] + 128]
            require _124 + (32 * _178) + 32 <= return_data.size
            s = _124 + 160
            t = ceil32(return_data.size) + 160
            idx = 0
            while idx < _178:
                require mem[s] == mem[s + 31 len 1]
                mem[t] = mem[s]
                s = s + 32
                t = t + 32
                idx = idx + 1
                continue 
            _4005 = mem[64]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _178
            idx = 0
            s = mem[64] + 64
            t = ceil32(return_data.size) + 160
            while idx < _178:
                mem[s] = mem[t + 31 len 1]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            return memory
              from mem[64]
               len _4005 + (32 * _178) + -mem[64] + 64
        if unknown_0x480738ad(?????) > uint32(call.func_hash) >> 224:
            if unknown_0x18160ddd(?????) <= uint32(call.func_hash) >> 224:
                if unknown_0x2b112e49(?????) <= uint32(call.func_hash) >> 224:
                    if unknown_0x2b112e49(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        if balanceOf[stor21] > totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if totalSupply < balanceOf[stor21]:
                            revert with 0, 17
                        if balanceOf[stor22] > totalSupply - balanceOf[stor21]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if totalSupply - balanceOf[stor21] < balanceOf[stor22]:
                            revert with 0, 17
                        return (totalSupply - balanceOf[stor21] - balanceOf[stor22])
                    if unknown_0x2bb14e1d(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        return rewardsFee
                    if unknown_0x313ce567(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        return 18
                    if unknown_0x3705b392(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        return sub_3705b392
                    require unknown_0x466f6311(?????) == uint32(call.func_hash) >> 224
                    require not msg.value
                    if balanceOf[address(msg.sender)] > !sub_6d29ab70[msg.sender]:
                        revert with 0, 17
                    require ext_code.size(nodeRewardManagementAddress)
                    staticcall nodeRewardManagementAddress.0x6591f30a with:
                            gas gas_remaining wei
                           args msg.sender, balanceOf[address(msg.sender)] + sub_6d29ab70[msg.sender]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if unknown_0x18160ddd(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    return totalSupply
                if unknown_0x18b9b19a(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    return sub_18b9b19a
                if unknown_0x1cdd3be3(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    require calldata.size - 4 >= 32
                    require cd[4] == address(cd[4])
                    return bool(stor33[cd[4]])
                if unknown_0x231a1ce7(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    require calldata.size - 4 >= 64
                    require cd[4] == address(cd[4])
                    require cd[36] == address(cd[36])
                    if owner != msg.sender:
                        revert with 0, 'Ownable: caller is not the owner'
                    devPoolAddress = address(cd[4])
                    distributionPoolAddress = address(cd[36])
                require unknown_0x23b872dd(?????) == uint32(call.func_hash) >> 224
                require not msg.value
                require calldata.size - 4 >= 96
                require cd[4] == address(cd[4])
                require cd[36] == address(cd[36])
                if allowance[address(cd[4])][msg.sender].field_0 != -1:
                    if cd[68] > allowance[address(cd[4])][address(msg.sender)].field_0:
                        revert with 0, 'Insufficient Allowance', 0
                    if allowance[address(cd[4])][address(msg.sender)].field_0 < cd[68]:
                        revert with 0, 17
                    allowance[address(cd[4])][msg.sender].field_0 = allowance[address(cd[4])][address(msg.sender)].field_0 - cd[68]
                if not address(cd[4]):
                    revert with 0, 'ERC20: transfer from the zero address'
                if not address(cd[36]):
                    revert with 0, 'ERC20: transfer to the zero address'
                if stor33[address(cd[4])]:
                    revert with 0, 'Blacklisted address'
                if stor33[address(cd[36])]:
                    revert with 0, 'Blacklisted address'
                emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                return 1
            if unknown_0x13114a9d(?????) > uint32(call.func_hash) >> 224:
                if unknown_0x00afb325(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    return sub_00afb325
                if unknown_0x0406c49c(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    require calldata.size - 4 >= 64
                    require cd[4] <= test266151307()
                    require calldata.size > cd[4] + 35
                    if ('cd', 4).length > test266151307():
                        revert with 0, 65
                    if ceil32(32 * ('cd', 4).length) + 129 < 128 or ceil32(32 * ('cd', 4).length) + 129 > test266151307():
                        revert with 0, 65
                    mem[128] = ('cd', 4).length
                    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
                    s = cd[4] + 36
                    t = 160
                    idx = 0
                    while idx < ('cd', 4).length:
                        require cd[s] == uint8(cd[s])
                        mem[t] = cd[s]
                        s = s + 32
                        t = t + 32
                        idx = idx + 1
                        continue 
                    require cd[36] == address(cd[36])
                    if owner != msg.sender:
                        revert with 0, 'Ownable: caller is not the owner'
                    idx = 0
                    while idx < ('cd', 4).length:
                        if idx >= mem[128]:
                            revert with 0, 50
                        _9348 = mem[(32 * idx) + 160]
                        mem[ceil32(32 * ('cd', 4).length) + 129] = 0x37696eec00000000000000000000000000000000000000000000000000000000
                        mem[ceil32(32 * ('cd', 4).length) + 133] = address(cd[36])
                        mem[ceil32(32 * ('cd', 4).length) + 165] = uint8(_9348)
                        require ext_code.size(nodeRewardManagementAddress)
                        call nodeRewardManagementAddress.0x37696eec with:
                             gas gas_remaining wei
                            args address(cd[36]), uint8(_9348)
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                if name() == uint32(call.func_hash) >> 224:
                    require not msg.value
                    return '', 0
                if approve(address arg1, uint256 arg2) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    require calldata.size - 4 >= 64
                    require cd[4] == address(cd[4])
                    allowance[msg.sender][address(cd[4])].field_0 = cd[36]
                    emit Approval(cd[36], msg.sender, address(cd[4]));
                    return 1
                require getRewardAmount() == uint32(call.func_hash) >> 224
                require not msg.value
                if not msg.sender:
                    revert with 0, 'SENDER CAN'T BE ZERO'
                require ext_code.size(nodeRewardManagementAddress)
                staticcall nodeRewardManagementAddress._isNodeOwner(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                if not ext_call.return_data[0]:
                    revert with 0, 'NO NODE OWNER'
                require ext_code.size(nodeRewardManagementAddress)
                staticcall nodeRewardManagementAddress._getRewardAmountOf(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                return ext_call.return_data[0]
            if unknown_0x13114a9d(?????) == uint32(call.func_hash) >> 224:
                require not msg.value
                return totalFees
            if unknown_0x144236d3(?????) == uint32(call.func_hash) >> 224:
                require not msg.value
                require calldata.size - 4 >= 64
                require cd[4] == address(cd[4])
                if not cd[36]:
                    if not address(cd[4]):
                        revert with 0, 'ERC20: transfer from the zero address'
                    if not sub_e8b7a2b9Address:
                        revert with 0, 'ERC20: transfer to the zero address'
                    if stor33[address(cd[4])]:
                        revert with 0, 'Blacklisted address'
                    if stor33[stor23]:
                        revert with 0, 'Blacklisted address'
                    emit Transfer(0, address(cd[4]), sub_e8b7a2b9Address);
                    if 0 > cd[36]:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if cd[36] < 0:
                        revert with 0, 17
                    return cd[36]
                if cd[36] and sub_00afb325 > -1 / cd[36]:
                    revert with 0, 17
                if not cd[36]:
                    revert with 0, 18
                if cd[36] * sub_00afb325 / cd[36] != sub_00afb325:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not address(cd[4]):
                    revert with 0, 'ERC20: transfer from the zero address'
                if not sub_e8b7a2b9Address:
                    revert with 0, 'ERC20: transfer to the zero address'
                if stor33[address(cd[4])]:
                    revert with 0, 'Blacklisted address'
                if stor33[stor23]:
                    revert with 0, 'Blacklisted address'
                emit Transfer((cd[36] * sub_00afb325 / 100), address(cd[4]), sub_e8b7a2b9Address);
                if cd[36] * sub_00afb325 / 100 > cd[36]:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if cd[36] < cd[36] * sub_00afb325 / 100:
                    revert with 0, 17
                return (cd[36] - (cd[36] * sub_00afb325 / 100))
            if unknown_0x149d5660(?????) == uint32(call.func_hash) >> 224:
                require not msg.value
                require ext_code.size(nodeRewardManagementAddress)
                staticcall nodeRewardManagementAddress.0x7c942fa6 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 64
                require 223 < return_data.size + 192
                if not bool(ceil32(return_data.size) + 256 <= test266151307()):
                    revert with 0, 65
                require 64 <= return_data.size
                return ext_call.return_data[0 len 64]
            if unknown_0x1694505e(?????) == uint32(call.func_hash) >> 224:
                require not msg.value
                return uniswapV2RouterAddress
            require unknown_0x173865ad(?????) == uint32(call.func_hash) >> 224
            require not msg.value
            require calldata.size - 4 >= 32
            if cd[4] / 2 > cd[4]:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if cd[4] < cd[4] / 2:
                revert with 0, 17
            mem[288] = this.address
            require ext_code.size(uniswapV2RouterAddress)
            staticcall uniswapV2RouterAddress.WAVAX() with:
                    gas gas_remaining wei
            mem[352] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            mem[320] = ext_call.return_data[12 len 20]
            allowance[msg.sender][stor20].field_0 = cd[4] / 2
            allowance[msg.sender][stor20].field_255 = 0
            emit Approval((cd[4] / 2), msg.sender, uniV2RouterAddress);
            mem[ceil32(return_data.size) + 352] = 0x762b156200000000000000000000000000000000000000000000000000000000
            mem[ceil32(return_data.size) + 356] = cd[4] / 2
            idx = 0
            s = ceil32(return_data.size) + 548
            t = 288
            while idx < 2:
                mem[s] = mem[t + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            require ext_code.size(uniswapV2RouterAddress)
            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args Mask(255, 1, cd[4]), 0, 160, address(this.address), block.timestamp, 2, mem[ceil32(return_data.size) + 548 len 64]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if eth.balance(this.address) > eth.balance(this.address):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if eth.balance(this.address) < eth.balance(this.address):
                revert with 0, 17
            allowance[msg.sender][stor20].field_0 = cd[4] - (cd[4] / 2)
            emit Approval((cd[4] - (cd[4] / 2)), msg.sender, uniV2RouterAddress);
            require ext_code.size(uniswapV2RouterAddress)
            call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                 gas gas_remaining wei
                args this.address, cd[4] - (cd[4] / 2), 0, 0, 0, block.timestamp
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 96
            emit SwapAndLiquify(Mask(255, 1, cd[4]), 0, cd[4] - (cd[4] / 2));
        else:
            if unknown_0x5f1c3182(?????) <= uint32(call.func_hash) >> 224:
                if unknown_0x6d79210f(?????) > uint32(call.func_hash) >> 224:
                    if unknown_0x5f1c3182(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        return swapTokensAmount
                    if unknown_0x6770474b(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        require calldata.size - 4 >= 32
                        if owner != msg.sender:
                            revert with 0, 'Ownable: caller is not the owner'
                        swapTokensAmount = cd[4]
                    if unknown_0x6827e764(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        return devFee
                    if unknown_0x697e2f8e(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        return nodeRewardManagementAddress
                    require unknown_0x6d29ab70(?????) == uint32(call.func_hash) >> 224
                    require not msg.value
                    require calldata.size - 4 >= 32
                    require cd[4] == address(cd[4])
                    return sub_6d29ab70[cd[4]]
                if unknown_0x6d79210f(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    require calldata.size - 4 >= 32
                    require cd[4] == address(cd[4])
                    return sub_6d79210f[cd[4]]
                if unknown_0x6d9ae0be(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    return cashoutFee
                if unknown_0x6f4a2cd0(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    if owner != msg.sender:
                        revert with 0, 'Ownable: caller is not the owner'
                    require ext_code.size(nodeRewardManagementAddress)
                    call nodeRewardManagementAddress._distributeRewards() with:
                         gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 96
                    return ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64]
                if unknown_0x70a08231(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    require calldata.size - 4 >= 32
                    require cd[4] == address(cd[4])
                    return balanceOf[address(cd[4])]
                require unknown_0x715018a6(?????) == uint32(call.func_hash) >> 224
                require not msg.value
                if owner != msg.sender:
                    revert with 0, 'Ownable: caller is not the owner'
                emit OwnershipTransferred(owner, 0);
                owner = 0
            else:
                if unknown_0x54f12f1f(?????) <= uint32(call.func_hash) >> 224:
                    if unknown_0x54f12f1f(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        return liquidityPoolFee
                    if unknown_0x571ac8b0(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        require calldata.size - 4 >= 32
                        require cd[4] == address(cd[4])
                        allowance[msg.sender][address(cd[4])].field_0 = -1
                        emit Approval(-1, msg.sender, address(cd[4]));
                        return 1
                    if unknown_0x583bd7a6(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        require calldata.size - 4 >= 32
                        require cd[4] == bool(cd[4])
                        if owner != msg.sender:
                            revert with 0, 'Ownable: caller is not the owner'
                        Mask(248, 0, stor30.field_8) = Mask(248, 0, bool(cd[4]))
                    else:
                        if unknown_0x59640ed9(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            require calldata.size - 4 >= 32
                            if owner != msg.sender:
                                revert with 0, 'Ownable: caller is not the owner'
                            require ext_code.size(nodeRewardManagementAddress)
                            call nodeRewardManagementAddress._changeGasDistri(uint256 arg1) with:
                                 gas gas_remaining wei
                                args cd[4]
                        else:
                            require unknown_0x5d7e9c2a(?????) == uint32(call.func_hash) >> 224
                            require not msg.value
                            require calldata.size - 4 >= 224
                            require cd[4] == uint8(cd[4])
                            if owner != msg.sender:
                                revert with 0, 'Ownable: caller is not the owner'
                            if cd[68] and 10^18 > -1 / cd[68]:
                                revert with 0, 17
                            if cd[132] and 10^18 > -1 / cd[132]:
                                revert with 0, 17
                            require ext_code.size(nodeRewardManagementAddress)
                            call nodeRewardManagementAddress.0x9867ae29 with:
                                 gas gas_remaining wei
                                args 0, 0, cd[36], 10^18 * cd[68], cd[100], 10^18 * cd[132], cd[164], cd[196]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                else:
                    if uint32(call.func_hash) >> 224 != unknown_0x480738ad(?????):
                        if unknown_0x49bd5a5e(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            return uniswapV2PairAddress
                        if unknown_0x4d2e5119(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            require calldata.size - 4 >= 32
                            require cd[4] == uint8(cd[4])
                            require ext_code.size(nodeRewardManagementAddress)
                            staticcall nodeRewardManagementAddress.0x3add38de with:
                                    gas gas_remaining wei
                                   args cd[4] << 248, balanceOf[address(msg.sender)]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            return ext_call.return_data[0]
                        if unknown_0x4dc9b819(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            require ext_code.size(nodeRewardManagementAddress)
                            staticcall nodeRewardManagementAddress.totalRewardStaked() with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            return ext_call.return_data[0]
                        require unknown_0x54557973(?????) == uint32(call.func_hash) >> 224
                        require not msg.value
                        require not stor33[msg.sender]
                        mem[132] = msg.sender
                        require ext_code.size(nodeRewardManagementAddress)
                        staticcall nodeRewardManagementAddress._getRewardAmountOf(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[128] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] > 0
                        if not uint8(stor30.field_8):
                            if not distributionPoolAddress:
                                revert with 0, 'ERC20: transfer from the zero address'
                            if not msg.sender:
                                revert with 0, 'ERC20: transfer to the zero address'
                            if stor33[stor24]:
                                revert with 0, 'Blacklisted address'
                            if stor33[address(msg.sender)]:
                                revert with 0, 'Blacklisted address'
                            emit Transfer(ext_call.return_data[0], distributionPoolAddress, msg.sender);
                        else:
                            if not cashoutFee:
                                if ext_call.return_data[0] < 0:
                                    revert with 0, 17
                                if not distributionPoolAddress:
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                if stor33[stor24]:
                                    revert with 0, 'Blacklisted address'
                                if stor33[address(msg.sender)]:
                                    revert with 0, 'Blacklisted address'
                                emit Transfer(ext_call.return_data[0], distributionPoolAddress, msg.sender);
                            else:
                                if not ext_call.return_data[0]:
                                    mem[ceil32(return_data.size) + 128] = 26
                                    mem[ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                    mem[ceil32(return_data.size) + 192] = 2
                                    mem[ceil32(return_data.size) + 224] = this.address
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                            gas gas_remaining wei
                                    mem[ceil32(return_data.size) + 288] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = (2 * ceil32(return_data.size)) + 288
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    mem[ceil32(return_data.size) + 256] = ext_call.return_data[12 len 20]
                                    mem[0] = uniV2RouterAddress
                                    mem[32] = sha3(msg.sender, 3)
                                    allowance[msg.sender][stor20].field_0 = 0
                                    mem[(2 * ceil32(return_data.size)) + 288] = 0
                                    emit Approval(mem[(2 * ceil32(return_data.size)) + 288 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                    mem[(2 * ceil32(return_data.size)) + 288] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[(2 * ceil32(return_data.size)) + 292] = 0
                                    mem[(2 * ceil32(return_data.size)) + 324] = 0
                                    mem[(2 * ceil32(return_data.size)) + 356] = 160
                                    mem[(2 * ceil32(return_data.size)) + 452] = 2
                                    idx = 0
                                    s = (2 * ceil32(return_data.size)) + 484
                                    t = ceil32(return_data.size) + 224
                                    while idx < mem[ceil32(return_data.size) + 192]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(2 * ceil32(return_data.size)) + 388] = this.address
                                    mem[(2 * ceil32(return_data.size)) + 420] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 544]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    call devPoolAddress with:
                                         gas 30000 wei
                                    if ext_call.return_data[0] < 0:
                                        revert with 0, 17
                                    if not distributionPoolAddress:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if stor33[stor24]:
                                        revert with 0, 'Blacklisted address'
                                    if stor33[address(msg.sender)]:
                                        revert with 0, 'Blacklisted address'
                                    emit Transfer(ext_call.return_data[0], distributionPoolAddress, msg.sender);
                                else:
                                    if ext_call.return_data[0] and cashoutFee > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    if not ext_call.return_data[0]:
                                        revert with 0, 18
                                    if ext_call.return_data[0] * cashoutFee / ext_call.return_data[0] != cashoutFee:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[ceil32(return_data.size) + 128] = 26
                                    mem[ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                    mem[ceil32(return_data.size) + 192] = 2
                                    mem[ceil32(return_data.size) + 224] = this.address
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                            gas gas_remaining wei
                                    mem[ceil32(return_data.size) + 288] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = (2 * ceil32(return_data.size)) + 288
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    mem[ceil32(return_data.size) + 256] = ext_call.return_data[12 len 20]
                                    mem[0] = uniV2RouterAddress
                                    mem[32] = sha3(msg.sender, 3)
                                    allowance[msg.sender][stor20].field_0 = ext_call.return_data[0] * cashoutFee / 100
                                    mem[(2 * ceil32(return_data.size)) + 288] = ext_call.return_data[0] * cashoutFee / 100
                                    emit Approval(mem[(2 * ceil32(return_data.size)) + 288 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                    mem[(2 * ceil32(return_data.size)) + 288] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[(2 * ceil32(return_data.size)) + 292] = ext_call.return_data[0] * cashoutFee / 100
                                    mem[(2 * ceil32(return_data.size)) + 324] = 0
                                    mem[(2 * ceil32(return_data.size)) + 356] = 160
                                    mem[(2 * ceil32(return_data.size)) + 452] = 2
                                    idx = 0
                                    s = (2 * ceil32(return_data.size)) + 484
                                    t = ceil32(return_data.size) + 224
                                    while idx < mem[ceil32(return_data.size) + 192]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(2 * ceil32(return_data.size)) + 388] = this.address
                                    mem[(2 * ceil32(return_data.size)) + 420] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 544]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    call devPoolAddress with:
                                         gas 30000 wei
                                    if ext_call.return_data[0] < ext_call.return_data[0] * cashoutFee / 100:
                                        revert with 0, 17
                                    if not distributionPoolAddress:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if stor33[stor24]:
                                        revert with 0, 'Blacklisted address'
                                    if stor33[address(msg.sender)]:
                                        revert with 0, 'Blacklisted address'
                                    emit Transfer((ext_call.return_data[0] - (ext_call.return_data[0] * cashoutFee / 100)), distributionPoolAddress, msg.sender);
                        require ext_code.size(nodeRewardManagementAddress)
                        call nodeRewardManagementAddress._cashoutAllNodesReward(address arg1) with:
                             gas gas_remaining wei
                            args msg.sender
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                    else:
                        require not msg.value
                        require calldata.size - 4 >= 32
                        require cd[4] == uint8(cd[4])
                        require not stor33[msg.sender]
                        require devPoolAddress != msg.sender
                        require distributionPoolAddress != msg.sender
                        mem[132] = uint8(cd[4])
                        require ext_code.size(nodeRewardManagementAddress)
                        staticcall nodeRewardManagementAddress.0xd04375ed with:
                                gas gas_remaining wei
                               args uint8(cd[4])
                        mem[128] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require balanceOf[address(msg.sender)] >= ext_call.return_data[0]
                        if balanceOf[address(this.address)] < swapTokensAmount:
                            if not msg.sender:
                                revert with 0, 'ERC20: transfer from the zero address'
                            if not this.address:
                                revert with 0, 'ERC20: transfer to the zero address'
                            if stor33[address(msg.sender)]:
                                revert with 0, 'Blacklisted address'
                            if stor33[address(this.address)]:
                                revert with 0, 'Blacklisted address'
                            emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                            require ext_code.size(nodeRewardManagementAddress)
                            call nodeRewardManagementAddress.0x37696eec with:
                                 gas gas_remaining wei
                                args msg.sender, uint8(cd[4])
                        else:
                            if not uint8(stor30.field_8):
                                if not msg.sender:
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if not this.address:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                if stor33[address(msg.sender)]:
                                    revert with 0, 'Blacklisted address'
                                if stor33[address(this.address)]:
                                    revert with 0, 'Blacklisted address'
                                emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                require ext_code.size(nodeRewardManagementAddress)
                                call nodeRewardManagementAddress.0x37696eec with:
                                     gas gas_remaining wei
                                    args msg.sender, uint8(cd[4])
                            else:
                                if uint8(stor30.field_0):
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not this.address:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if stor33[address(msg.sender)]:
                                        revert with 0, 'Blacklisted address'
                                    if stor33[address(this.address)]:
                                        revert with 0, 'Blacklisted address'
                                    emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                    require ext_code.size(nodeRewardManagementAddress)
                                    call nodeRewardManagementAddress.0x37696eec with:
                                         gas gas_remaining wei
                                        args msg.sender, uint8(cd[4])
                                else:
                                    if owner == msg.sender:
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not this.address:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if stor33[address(msg.sender)]:
                                            revert with 0, 'Blacklisted address'
                                        if stor33[address(this.address)]:
                                            revert with 0, 'Blacklisted address'
                                        emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                        require ext_code.size(nodeRewardManagementAddress)
                                        call nodeRewardManagementAddress.0x37696eec with:
                                             gas gas_remaining wei
                                            args msg.sender, uint8(cd[4])
                                    else:
                                        if uniswapV2PairAddress == msg.sender:
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not this.address:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if stor33[address(msg.sender)]:
                                                revert with 0, 'Blacklisted address'
                                            if stor33[address(this.address)]:
                                                revert with 0, 'Blacklisted address'
                                            emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                            require ext_code.size(nodeRewardManagementAddress)
                                            call nodeRewardManagementAddress.0x37696eec with:
                                                 gas gas_remaining wei
                                                args msg.sender, uint8(cd[4])
                                        else:
                                            uint8(stor30.field_0) = 1
                                            if not swapTokensAmount:
                                                mem[ceil32(return_data.size) + 128] = 26
                                                mem[ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                                if swapTokensAmount:
                                                    if swapTokensAmount and burnFee > -1 / swapTokensAmount:
                                                        revert with 0, 17
                                                    if not swapTokensAmount:
                                                        revert with 0, 18
                                                    if swapTokensAmount * burnFee / swapTokensAmount != burnFee:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    mem[ceil32(return_data.size) + 192] = 26
                                                    mem[ceil32(return_data.size) + 224] = 'SafeMath: division by zero'
                                                    if not this.address:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not deadWalletAddress:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if stor33[address(this.address)]:
                                                        revert with 0, 'Blacklisted address'
                                                    if stor33[stor7]:
                                                        revert with 0, 'Blacklisted address'
                                                    emit Transfer((swapTokensAmount * burnFee / 100), this.address, deadWalletAddress);
                                                    if not swapTokensAmount:
                                                        mem[ceil32(return_data.size) + 256] = 26
                                                        mem[ceil32(return_data.size) + 288] = 'SafeMath: division by zero'
                                                        mem[ceil32(return_data.size) + 320] = 26
                                                        mem[ceil32(return_data.size) + 352] = 'SafeMath: division by zero'
                                                        mem[ceil32(return_data.size) + 384] = 30
                                                        mem[ceil32(return_data.size) + 416] = 'SafeMath: subtraction overflow'
                                                        if not this.address:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not distributionPoolAddress:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        if stor33[address(this.address)]:
                                                            revert with 0, 'Blacklisted address'
                                                        if stor33[stor24]:
                                                            revert with 0, 'Blacklisted address'
                                                        emit Transfer(0, this.address, distributionPoolAddress);
                                                        if not swapTokensAmount:
                                                            mem[ceil32(return_data.size) + 448] = 26
                                                            mem[ceil32(return_data.size) + 480] = 'SafeMath: division by zero'
                                                            mem[ceil32(return_data.size) + 512] = 2
                                                            mem[ceil32(return_data.size) + 544] = this.address
                                                            require ext_code.size(uniswapV2RouterAddress)
                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                    gas gas_remaining wei
                                                            mem[ceil32(return_data.size) + 608] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (2 * ceil32(return_data.size)) + 608
                                                            require return_data.size >= 32
                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                            mem[ceil32(return_data.size) + 576] = ext_call.return_data[12 len 20]
                                                            mem[0] = uniV2RouterAddress
                                                            mem[32] = sha3(msg.sender, 3)
                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                            mem[(2 * ceil32(return_data.size)) + 608] = balanceOf[address(this.address)]
                                                            emit Approval(mem[(2 * ceil32(return_data.size)) + 608 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                            mem[(2 * ceil32(return_data.size)) + 608] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                            mem[(2 * ceil32(return_data.size)) + 612] = balanceOf[address(this.address)]
                                                            mem[(2 * ceil32(return_data.size)) + 644] = 0
                                                            mem[(2 * ceil32(return_data.size)) + 676] = 160
                                                            mem[(2 * ceil32(return_data.size)) + 772] = 2
                                                            idx = 0
                                                            s = (2 * ceil32(return_data.size)) + 804
                                                            t = ceil32(return_data.size) + 544
                                                            while idx < mem[ceil32(return_data.size) + 512]:
                                                                mem[s] = mem[t + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(2 * ceil32(return_data.size)) + 708] = this.address
                                                            mem[(2 * ceil32(return_data.size)) + 740] = block.timestamp
                                                            require ext_code.size(uniswapV2RouterAddress)
                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 864]
                                                        else:
                                                            if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                revert with 0, 17
                                                            if not swapTokensAmount:
                                                                revert with 0, 18
                                                            if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[ceil32(return_data.size) + 448] = 26
                                                            mem[ceil32(return_data.size) + 480] = 'SafeMath: division by zero'
                                                            if not swapTokensAmount * liquidityPoolFee / 100:
                                                                mem[ceil32(return_data.size) + 512] = 2
                                                                mem[ceil32(return_data.size) + 544] = this.address
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                        gas gas_remaining wei
                                                                mem[ceil32(return_data.size) + 608] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (2 * ceil32(return_data.size)) + 608
                                                                require return_data.size >= 32
                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                mem[ceil32(return_data.size) + 576] = ext_call.return_data[12 len 20]
                                                                mem[0] = uniV2RouterAddress
                                                                mem[32] = sha3(msg.sender, 3)
                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                mem[(2 * ceil32(return_data.size)) + 608] = balanceOf[address(this.address)]
                                                                emit Approval(mem[(2 * ceil32(return_data.size)) + 608 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                mem[(2 * ceil32(return_data.size)) + 608] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                mem[(2 * ceil32(return_data.size)) + 612] = balanceOf[address(this.address)]
                                                                mem[(2 * ceil32(return_data.size)) + 644] = 0
                                                                mem[(2 * ceil32(return_data.size)) + 676] = 160
                                                                mem[(2 * ceil32(return_data.size)) + 772] = 2
                                                                idx = 0
                                                                s = (2 * ceil32(return_data.size)) + 804
                                                                t = ceil32(return_data.size) + 544
                                                                while idx < mem[ceil32(return_data.size) + 512]:
                                                                    mem[s] = mem[t + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(2 * ceil32(return_data.size)) + 708] = this.address
                                                                mem[(2 * ceil32(return_data.size)) + 740] = block.timestamp
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 864]
                                                            else:
                                                                mem[ceil32(return_data.size) + 512] = 26
                                                                mem[ceil32(return_data.size) + 544] = 'SafeMath: division by zero'
                                                                mem[ceil32(return_data.size) + 576] = 30
                                                                mem[ceil32(return_data.size) + 608] = 'SafeMath: subtraction overflow'
                                                                if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                    revert with 0, 17
                                                                mem[ceil32(return_data.size) + 640] = 2
                                                                mem[ceil32(return_data.size) + 672] = this.address
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                        gas gas_remaining wei
                                                                mem[ceil32(return_data.size) + 736] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (2 * ceil32(return_data.size)) + 736
                                                                require return_data.size >= 32
                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                mem[ceil32(return_data.size) + 704] = ext_call.return_data[12 len 20]
                                                                mem[0] = uniV2RouterAddress
                                                                mem[32] = sha3(msg.sender, 3)
                                                                allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                allowance[msg.sender][stor20].field_255 = 0
                                                                mem[(2 * ceil32(return_data.size)) + 736] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                emit Approval(mem[(2 * ceil32(return_data.size)) + 736 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                mem[(2 * ceil32(return_data.size)) + 736] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                mem[(2 * ceil32(return_data.size)) + 740] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                mem[(2 * ceil32(return_data.size)) + 772] = 0
                                                                mem[(2 * ceil32(return_data.size)) + 804] = 160
                                                                mem[(2 * ceil32(return_data.size)) + 900] = 2
                                                                idx = 0
                                                                s = (2 * ceil32(return_data.size)) + 932
                                                                t = ceil32(return_data.size) + 672
                                                                while idx < mem[ceil32(return_data.size) + 640]:
                                                                    mem[s] = mem[t + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(2 * ceil32(return_data.size)) + 836] = this.address
                                                                mem[(2 * ceil32(return_data.size)) + 868] = block.timestamp
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 992]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _4051 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_4051] = 30
                                                                mem[_4051 + 32] = 'SafeMath: subtraction overflow'
                                                                if eth.balance(this.address) > eth.balance(this.address):
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                if eth.balance(this.address) < eth.balance(this.address):
                                                                    revert with 0, 17
                                                                mem[0] = uniV2RouterAddress
                                                                mem[32] = sha3(msg.sender, 3)
                                                                allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                mem[mem[64] + 68] = 0
                                                                mem[mem[64] + 100] = 0
                                                                mem[mem[64] + 132] = 0
                                                                mem[mem[64] + 164] = block.timestamp
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                     gas gas_remaining wei
                                                                    args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 96
                                                                mem[mem[64] + 32] = 0
                                                                mem[mem[64] + 64] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                mem[0] = this.address
                                                                mem[32] = 2
                                                                _4856 = mem[64]
                                                                mem[mem[64]] = 2
                                                                mem[64] = mem[64] + 96
                                                                mem[_4856 + 32 len 64] = call.data[calldata.size len 64]
                                                                if 0 >= mem[_4856]:
                                                                    revert with 0, 50
                                                                mem[_4856 + 32] = this.address
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                        gas gas_remaining wei
                                                                mem[_4856 + 96] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _4856 + ceil32(return_data.size) + 96
                                                                require return_data.size >= 32
                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                if 1 >= mem[_4856]:
                                                                    revert with 0, 50
                                                                mem[_4856 + 64] = ext_call.return_data[12 len 20]
                                                                mem[0] = uniV2RouterAddress
                                                                mem[32] = sha3(msg.sender, 3)
                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                mem[_4856 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                mem[_4856 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                mem[_4856 + ceil32(return_data.size) + 132] = 0
                                                                mem[_4856 + ceil32(return_data.size) + 164] = 160
                                                                mem[_4856 + ceil32(return_data.size) + 260] = mem[_4856]
                                                                idx = 0
                                                                s = _4856 + ceil32(return_data.size) + 292
                                                                t = _4856 + 32
                                                                while idx < mem[_4856]:
                                                                    mem[s] = mem[t + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[_4856 + ceil32(return_data.size) + 196] = this.address
                                                                mem[_4856 + ceil32(return_data.size) + 228] = block.timestamp
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len _4856 + ceil32(return_data.size) + (32 * mem[_4856]) + -mem[64] + 288]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        uint8(stor30.field_0) = 0
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not this.address:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        if stor33[address(msg.sender)]:
                                                            revert with 0, 'Blacklisted address'
                                                        if stor33[address(this.address)]:
                                                            revert with 0, 'Blacklisted address'
                                                        emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                        require ext_code.size(nodeRewardManagementAddress)
                                                        call nodeRewardManagementAddress.0x37696eec with:
                                                             gas gas_remaining wei
                                                            args msg.sender, uint8(cd[4])
                                                    else:
                                                        if swapTokensAmount and rewardsFee > -1 / swapTokensAmount:
                                                            revert with 0, 17
                                                        if not swapTokensAmount:
                                                            revert with 0, 18
                                                        if swapTokensAmount * rewardsFee / swapTokensAmount != rewardsFee:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[ceil32(return_data.size) + 256] = 26
                                                        mem[ceil32(return_data.size) + 288] = 'SafeMath: division by zero'
                                                        if not swapTokensAmount * rewardsFee / 100:
                                                            mem[ceil32(return_data.size) + 320] = 26
                                                            mem[ceil32(return_data.size) + 352] = 'SafeMath: division by zero'
                                                            mem[ceil32(return_data.size) + 384] = 30
                                                            mem[ceil32(return_data.size) + 416] = 'SafeMath: subtraction overflow'
                                                            if 0 > swapTokensAmount * rewardsFee / 100:
                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                            if swapTokensAmount * rewardsFee / 100 < 0:
                                                                revert with 0, 17
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not distributionPoolAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            if stor33[address(this.address)]:
                                                                revert with 0, 'Blacklisted address'
                                                            if stor33[stor24]:
                                                                revert with 0, 'Blacklisted address'
                                                            emit Transfer((swapTokensAmount * rewardsFee / 100), this.address, distributionPoolAddress);
                                                            if not swapTokensAmount:
                                                                mem[ceil32(return_data.size) + 448] = 26
                                                                mem[ceil32(return_data.size) + 480] = 'SafeMath: division by zero'
                                                                mem[ceil32(return_data.size) + 512] = 2
                                                                mem[ceil32(return_data.size) + 544] = this.address
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                        gas gas_remaining wei
                                                                mem[ceil32(return_data.size) + 608] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (2 * ceil32(return_data.size)) + 608
                                                                require return_data.size >= 32
                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                mem[ceil32(return_data.size) + 576] = ext_call.return_data[12 len 20]
                                                                mem[0] = uniV2RouterAddress
                                                                mem[32] = sha3(msg.sender, 3)
                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                mem[(2 * ceil32(return_data.size)) + 608] = balanceOf[address(this.address)]
                                                                emit Approval(mem[(2 * ceil32(return_data.size)) + 608 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                mem[(2 * ceil32(return_data.size)) + 608] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                mem[(2 * ceil32(return_data.size)) + 612] = balanceOf[address(this.address)]
                                                                mem[(2 * ceil32(return_data.size)) + 644] = 0
                                                                mem[(2 * ceil32(return_data.size)) + 676] = 160
                                                                mem[(2 * ceil32(return_data.size)) + 772] = 2
                                                                idx = 0
                                                                s = (2 * ceil32(return_data.size)) + 804
                                                                t = ceil32(return_data.size) + 544
                                                                while idx < mem[ceil32(return_data.size) + 512]:
                                                                    mem[s] = mem[t + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(2 * ceil32(return_data.size)) + 708] = this.address
                                                                mem[(2 * ceil32(return_data.size)) + 740] = block.timestamp
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 864]
                                                            else:
                                                                if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                    revert with 0, 17
                                                                if not swapTokensAmount:
                                                                    revert with 0, 18
                                                                if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                mem[ceil32(return_data.size) + 448] = 26
                                                                mem[ceil32(return_data.size) + 480] = 'SafeMath: division by zero'
                                                                if not swapTokensAmount * liquidityPoolFee / 100:
                                                                    mem[ceil32(return_data.size) + 512] = 2
                                                                    mem[ceil32(return_data.size) + 544] = this.address
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                            gas gas_remaining wei
                                                                    mem[ceil32(return_data.size) + 608] = ext_call.return_data[0]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = (2 * ceil32(return_data.size)) + 608
                                                                    require return_data.size >= 32
                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                    mem[ceil32(return_data.size) + 576] = ext_call.return_data[12 len 20]
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                    mem[(2 * ceil32(return_data.size)) + 608] = balanceOf[address(this.address)]
                                                                    emit Approval(mem[(2 * ceil32(return_data.size)) + 608 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                    mem[(2 * ceil32(return_data.size)) + 608] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                    mem[(2 * ceil32(return_data.size)) + 612] = balanceOf[address(this.address)]
                                                                    mem[(2 * ceil32(return_data.size)) + 644] = 0
                                                                    mem[(2 * ceil32(return_data.size)) + 676] = 160
                                                                    mem[(2 * ceil32(return_data.size)) + 772] = 2
                                                                    idx = 0
                                                                    s = (2 * ceil32(return_data.size)) + 804
                                                                    t = ceil32(return_data.size) + 544
                                                                    while idx < mem[ceil32(return_data.size) + 512]:
                                                                        mem[s] = mem[t + 12 len 20]
                                                                        idx = idx + 1
                                                                        s = s + 32
                                                                        t = t + 32
                                                                        continue 
                                                                    mem[(2 * ceil32(return_data.size)) + 708] = this.address
                                                                    mem[(2 * ceil32(return_data.size)) + 740] = block.timestamp
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 864]
                                                                else:
                                                                    mem[ceil32(return_data.size) + 512] = 26
                                                                    mem[ceil32(return_data.size) + 544] = 'SafeMath: division by zero'
                                                                    mem[ceil32(return_data.size) + 576] = 30
                                                                    mem[ceil32(return_data.size) + 608] = 'SafeMath: subtraction overflow'
                                                                    if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                        revert with 0, 17
                                                                    mem[ceil32(return_data.size) + 640] = 2
                                                                    mem[ceil32(return_data.size) + 672] = this.address
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                            gas gas_remaining wei
                                                                    mem[ceil32(return_data.size) + 736] = ext_call.return_data[0]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = (2 * ceil32(return_data.size)) + 736
                                                                    require return_data.size >= 32
                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                    mem[ceil32(return_data.size) + 704] = ext_call.return_data[12 len 20]
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                    allowance[msg.sender][stor20].field_255 = 0
                                                                    mem[(2 * ceil32(return_data.size)) + 736] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                    emit Approval(mem[(2 * ceil32(return_data.size)) + 736 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                    mem[(2 * ceil32(return_data.size)) + 736] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                    mem[(2 * ceil32(return_data.size)) + 740] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                    mem[(2 * ceil32(return_data.size)) + 772] = 0
                                                                    mem[(2 * ceil32(return_data.size)) + 804] = 160
                                                                    mem[(2 * ceil32(return_data.size)) + 900] = 2
                                                                    idx = 0
                                                                    s = (2 * ceil32(return_data.size)) + 932
                                                                    t = ceil32(return_data.size) + 672
                                                                    while idx < mem[ceil32(return_data.size) + 640]:
                                                                        mem[s] = mem[t + 12 len 20]
                                                                        idx = idx + 1
                                                                        s = s + 32
                                                                        t = t + 32
                                                                        continue 
                                                                    mem[(2 * ceil32(return_data.size)) + 836] = this.address
                                                                    mem[(2 * ceil32(return_data.size)) + 868] = block.timestamp
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 992]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _4050 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_4050] = 30
                                                                    mem[_4050 + 32] = 'SafeMath: subtraction overflow'
                                                                    if eth.balance(this.address) > eth.balance(this.address):
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if eth.balance(this.address) < eth.balance(this.address):
                                                                        revert with 0, 17
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                    emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                    mem[mem[64] + 68] = 0
                                                                    mem[mem[64] + 100] = 0
                                                                    mem[mem[64] + 132] = 0
                                                                    mem[mem[64] + 164] = block.timestamp
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                         gas gas_remaining wei
                                                                        args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 96
                                                                    mem[mem[64] + 32] = 0
                                                                    mem[mem[64] + 64] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                    emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                    mem[0] = this.address
                                                                    mem[32] = 2
                                                                    _4854 = mem[64]
                                                                    mem[mem[64]] = 2
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_4854 + 32 len 64] = call.data[calldata.size len 64]
                                                                    if 0 >= mem[_4854]:
                                                                        revert with 0, 50
                                                                    mem[_4854 + 32] = this.address
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                            gas gas_remaining wei
                                                                    mem[_4854 + 96] = ext_call.return_data[0]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _4854 + ceil32(return_data.size) + 96
                                                                    require return_data.size >= 32
                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                    if 1 >= mem[_4854]:
                                                                        revert with 0, 50
                                                                    mem[_4854 + 64] = ext_call.return_data[12 len 20]
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                    emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                    mem[_4854 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                    mem[_4854 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                    mem[_4854 + ceil32(return_data.size) + 132] = 0
                                                                    mem[_4854 + ceil32(return_data.size) + 164] = 160
                                                                    mem[_4854 + ceil32(return_data.size) + 260] = mem[_4854]
                                                                    idx = 0
                                                                    s = _4854 + ceil32(return_data.size) + 292
                                                                    t = _4854 + 32
                                                                    while idx < mem[_4854]:
                                                                        mem[s] = mem[t + 12 len 20]
                                                                        idx = idx + 1
                                                                        s = s + 32
                                                                        t = t + 32
                                                                        continue 
                                                                    mem[_4854 + ceil32(return_data.size) + 196] = this.address
                                                                    mem[_4854 + ceil32(return_data.size) + 228] = block.timestamp
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _4854 + ceil32(return_data.size) + (32 * mem[_4854]) + -mem[64] + 288]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            uint8(stor30.field_0) = 0
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            if stor33[address(msg.sender)]:
                                                                revert with 0, 'Blacklisted address'
                                                            if stor33[address(this.address)]:
                                                                revert with 0, 'Blacklisted address'
                                                            emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                            require ext_code.size(nodeRewardManagementAddress)
                                                            call nodeRewardManagementAddress.0x37696eec with:
                                                                 gas gas_remaining wei
                                                                args msg.sender, uint8(cd[4])
                                                        else:
                                                            if swapTokensAmount * rewardsFee / 100 and stor29 > -1 / swapTokensAmount * rewardsFee / 100:
                                                                revert with 0, 17
                                                            if not swapTokensAmount * rewardsFee / 100:
                                                                revert with 0, 18
                                                            if swapTokensAmount * rewardsFee / 100 * stor29 / swapTokensAmount * rewardsFee / 100 != stor29:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[ceil32(return_data.size) + 320] = 26
                                                            mem[ceil32(return_data.size) + 352] = 'SafeMath: division by zero'
                                                            if not swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                mem[ceil32(return_data.size) + 384] = 30
                                                                mem[ceil32(return_data.size) + 416] = 'SafeMath: subtraction overflow'
                                                                if swapTokensAmount * rewardsFee / 100 * stor29 / 100 > swapTokensAmount * rewardsFee / 100:
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                if swapTokensAmount * rewardsFee / 100 < swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                    revert with 0, 17
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not distributionPoolAddress:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                if stor33[address(this.address)]:
                                                                    revert with 0, 'Blacklisted address'
                                                                if stor33[stor24]:
                                                                    revert with 0, 'Blacklisted address'
                                                                emit Transfer(((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)), this.address, distributionPoolAddress);
                                                                if not swapTokensAmount:
                                                                    mem[ceil32(return_data.size) + 448] = 26
                                                                    mem[ceil32(return_data.size) + 480] = 'SafeMath: division by zero'
                                                                    mem[ceil32(return_data.size) + 512] = 2
                                                                    mem[ceil32(return_data.size) + 544] = this.address
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                            gas gas_remaining wei
                                                                    mem[ceil32(return_data.size) + 608] = ext_call.return_data[0]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = (2 * ceil32(return_data.size)) + 608
                                                                    require return_data.size >= 32
                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                    mem[ceil32(return_data.size) + 576] = ext_call.return_data[12 len 20]
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                    mem[(2 * ceil32(return_data.size)) + 608] = balanceOf[address(this.address)]
                                                                    emit Approval(mem[(2 * ceil32(return_data.size)) + 608 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                    mem[(2 * ceil32(return_data.size)) + 608] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                    mem[(2 * ceil32(return_data.size)) + 612] = balanceOf[address(this.address)]
                                                                    mem[(2 * ceil32(return_data.size)) + 644] = 0
                                                                    mem[(2 * ceil32(return_data.size)) + 676] = 160
                                                                    mem[(2 * ceil32(return_data.size)) + 772] = 2
                                                                    idx = 0
                                                                    s = (2 * ceil32(return_data.size)) + 804
                                                                    t = ceil32(return_data.size) + 544
                                                                    while idx < mem[ceil32(return_data.size) + 512]:
                                                                        mem[s] = mem[t + 12 len 20]
                                                                        idx = idx + 1
                                                                        s = s + 32
                                                                        t = t + 32
                                                                        continue 
                                                                    mem[(2 * ceil32(return_data.size)) + 708] = this.address
                                                                    mem[(2 * ceil32(return_data.size)) + 740] = block.timestamp
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 864]
                                                                else:
                                                                    if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                        revert with 0, 17
                                                                    if not swapTokensAmount:
                                                                        revert with 0, 18
                                                                    if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                                    mem[ceil32(return_data.size) + 448] = 26
                                                                    mem[ceil32(return_data.size) + 480] = 'SafeMath: division by zero'
                                                                    if not swapTokensAmount * liquidityPoolFee / 100:
                                                                        mem[ceil32(return_data.size) + 512] = 2
                                                                        mem[ceil32(return_data.size) + 544] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[ceil32(return_data.size) + 608] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = (2 * ceil32(return_data.size)) + 608
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        mem[ceil32(return_data.size) + 576] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        mem[(2 * ceil32(return_data.size)) + 608] = balanceOf[address(this.address)]
                                                                        emit Approval(mem[(2 * ceil32(return_data.size)) + 608 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                        mem[(2 * ceil32(return_data.size)) + 608] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[(2 * ceil32(return_data.size)) + 612] = balanceOf[address(this.address)]
                                                                        mem[(2 * ceil32(return_data.size)) + 644] = 0
                                                                        mem[(2 * ceil32(return_data.size)) + 676] = 160
                                                                        mem[(2 * ceil32(return_data.size)) + 772] = 2
                                                                        idx = 0
                                                                        s = (2 * ceil32(return_data.size)) + 804
                                                                        t = ceil32(return_data.size) + 544
                                                                        while idx < mem[ceil32(return_data.size) + 512]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[(2 * ceil32(return_data.size)) + 708] = this.address
                                                                        mem[(2 * ceil32(return_data.size)) + 740] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                             gas gas_remaining wei
                                                                            args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 864]
                                                                    else:
                                                                        mem[ceil32(return_data.size) + 512] = 26
                                                                        mem[ceil32(return_data.size) + 544] = 'SafeMath: division by zero'
                                                                        mem[ceil32(return_data.size) + 576] = 30
                                                                        mem[ceil32(return_data.size) + 608] = 'SafeMath: subtraction overflow'
                                                                        if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                            revert with 0, 17
                                                                        mem[ceil32(return_data.size) + 640] = 2
                                                                        mem[ceil32(return_data.size) + 672] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[ceil32(return_data.size) + 736] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = (2 * ceil32(return_data.size)) + 736
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        mem[ceil32(return_data.size) + 704] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                        allowance[msg.sender][stor20].field_255 = 0
                                                                        mem[(2 * ceil32(return_data.size)) + 736] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                        emit Approval(mem[(2 * ceil32(return_data.size)) + 736 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                        mem[(2 * ceil32(return_data.size)) + 736] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[(2 * ceil32(return_data.size)) + 740] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                        mem[(2 * ceil32(return_data.size)) + 772] = 0
                                                                        mem[(2 * ceil32(return_data.size)) + 804] = 160
                                                                        mem[(2 * ceil32(return_data.size)) + 900] = 2
                                                                        idx = 0
                                                                        s = (2 * ceil32(return_data.size)) + 932
                                                                        t = ceil32(return_data.size) + 672
                                                                        while idx < mem[ceil32(return_data.size) + 640]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[(2 * ceil32(return_data.size)) + 836] = this.address
                                                                        mem[(2 * ceil32(return_data.size)) + 868] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                             gas gas_remaining wei
                                                                            args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 992]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        _4048 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_4048] = 30
                                                                        mem[_4048 + 32] = 'SafeMath: subtraction overflow'
                                                                        if eth.balance(this.address) > eth.balance(this.address):
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if eth.balance(this.address) < eth.balance(this.address):
                                                                            revert with 0, 17
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                        emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                        mem[mem[64] + 68] = 0
                                                                        mem[mem[64] + 100] = 0
                                                                        mem[mem[64] + 132] = 0
                                                                        mem[mem[64] + 164] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                             gas gas_remaining wei
                                                                            args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                                        require return_data.size >= 96
                                                                        mem[mem[64] + 32] = 0
                                                                        mem[mem[64] + 64] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                        emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                        mem[0] = this.address
                                                                        mem[32] = 2
                                                                        _4848 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_4848 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_4848]:
                                                                            revert with 0, 50
                                                                        mem[_4848 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_4848 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _4848 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_4848]:
                                                                            revert with 0, 50
                                                                        mem[_4848 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                        mem[_4848 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_4848 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                        mem[_4848 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_4848 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_4848 + ceil32(return_data.size) + 260] = mem[_4848]
                                                                        idx = 0
                                                                        s = _4848 + ceil32(return_data.size) + 292
                                                                        t = _4848 + 32
                                                                        while idx < mem[_4848]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                             gas gas_remaining wei
                                                                            args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_4848 + ceil32(return_data.size) + 260 len (32 * mem[_4848]) + 32]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                uint8(stor30.field_0) = 0
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                if stor33[address(msg.sender)]:
                                                                    revert with 0, 'Blacklisted address'
                                                                if stor33[address(this.address)]:
                                                                    revert with 0, 'Blacklisted address'
                                                                emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                require ext_code.size(nodeRewardManagementAddress)
                                                                call nodeRewardManagementAddress.0x37696eec with:
                                                                     gas gas_remaining wei
                                                                    args msg.sender, uint8(cd[4])
                                                            else:
                                                                mem[ceil32(return_data.size) + 384] = 2
                                                                mem[ceil32(return_data.size) + 416] = this.address
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                        gas gas_remaining wei
                                                                mem[ceil32(return_data.size) + 480] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (2 * ceil32(return_data.size)) + 480
                                                                require return_data.size >= 32
                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                mem[ceil32(return_data.size) + 448] = ext_call.return_data[12 len 20]
                                                                mem[0] = uniV2RouterAddress
                                                                mem[32] = sha3(msg.sender, 3)
                                                                allowance[msg.sender][stor20].field_0 = swapTokensAmount * rewardsFee / 100 * stor29 / 100
                                                                mem[(2 * ceil32(return_data.size)) + 480] = swapTokensAmount * rewardsFee / 100 * stor29 / 100
                                                                emit Approval(mem[(2 * ceil32(return_data.size)) + 480 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                mem[(2 * ceil32(return_data.size)) + 480] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                mem[(2 * ceil32(return_data.size)) + 484] = swapTokensAmount * rewardsFee / 100 * stor29 / 100
                                                                mem[(2 * ceil32(return_data.size)) + 516] = 0
                                                                mem[(2 * ceil32(return_data.size)) + 548] = 160
                                                                mem[(2 * ceil32(return_data.size)) + 644] = 2
                                                                idx = 0
                                                                s = (2 * ceil32(return_data.size)) + 676
                                                                t = ceil32(return_data.size) + 416
                                                                while idx < mem[ceil32(return_data.size) + 384]:
                                                                    mem[s] = mem[t + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(2 * ceil32(return_data.size)) + 580] = this.address
                                                                mem[(2 * ceil32(return_data.size)) + 612] = block.timestamp
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 736]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _4049 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_4049] = 30
                                                                mem[_4049 + 32] = 'SafeMath: subtraction overflow'
                                                                if eth.balance(this.address) > eth.balance(this.address):
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                if eth.balance(this.address) < eth.balance(this.address):
                                                                    revert with 0, 17
                                                                call distributionPoolAddress with:
                                                                     gas 30000 wei
                                                                if not return_data.size:
                                                                    _4580 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_4580] = 30
                                                                    mem[_4580 + 32] = 'SafeMath: subtraction overflow'
                                                                    if swapTokensAmount * rewardsFee / 100 * stor29 / 100 > swapTokensAmount * rewardsFee / 100:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if swapTokensAmount * rewardsFee / 100 < swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                        revert with 0, 17
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not distributionPoolAddress:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    if stor33[address(this.address)]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    mem[0] = distributionPoolAddress
                                                                    mem[32] = 33
                                                                    if stor33[stor24]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    emit Transfer(((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)), this.address, distributionPoolAddress);
                                                                    if not swapTokensAmount:
                                                                        _5023 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_5023] = 26
                                                                        mem[_5023 + 32] = 'SafeMath: division by zero'
                                                                        mem[0] = this.address
                                                                        mem[32] = 2
                                                                        _5194 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_5194 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_5194]:
                                                                            revert with 0, 50
                                                                        mem[_5194 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_5194 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _5194 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_5194]:
                                                                            revert with 0, 50
                                                                        mem[_5194 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                        mem[_5194 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_5194 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                        mem[_5194 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_5194 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_5194 + ceil32(return_data.size) + 260] = mem[_5194]
                                                                        idx = 0
                                                                        s = _5194 + ceil32(return_data.size) + 292
                                                                        t = _5194 + 32
                                                                        while idx < mem[_5194]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[_5194 + ceil32(return_data.size) + 196] = this.address
                                                                        mem[_5194 + ceil32(return_data.size) + 228] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                             gas gas_remaining wei
                                                                            args mem[mem[64] + 4 len _5194 + ceil32(return_data.size) + (32 * mem[_5194]) + -mem[64] + 288]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        uint8(stor30.field_0) = 0
                                                                        if not msg.sender:
                                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                                        if not this.address:
                                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                                        if stor33[address(msg.sender)]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        if stor33[address(this.address)]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                        require ext_code.size(nodeRewardManagementAddress)
                                                                        call nodeRewardManagementAddress.0x37696eec with:
                                                                             gas gas_remaining wei
                                                                            args msg.sender, uint8(cd[4])
                                                                    else:
                                                                        if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                            revert with 0, 17
                                                                        if not swapTokensAmount:
                                                                            revert with 0, 18
                                                                        if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                                        _5137 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_5137] = 26
                                                                        mem[_5137 + 32] = 'SafeMath: division by zero'
                                                                        if not swapTokensAmount * liquidityPoolFee / 100:
                                                                            mem[0] = this.address
                                                                            mem[32] = 2
                                                                            _5328 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_5328 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_5328]:
                                                                                revert with 0, 50
                                                                            mem[_5328 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_5328 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _5328 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_5328]:
                                                                                revert with 0, 50
                                                                            mem[_5328 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_5328 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_5328 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                            mem[_5328 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_5328 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_5328 + ceil32(return_data.size) + 260] = mem[_5328]
                                                                            idx = 0
                                                                            s = _5328 + ceil32(return_data.size) + 292
                                                                            t = _5328 + 32
                                                                            while idx < mem[_5328]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            mem[_5328 + ceil32(return_data.size) + 196] = this.address
                                                                            mem[_5328 + ceil32(return_data.size) + 228] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                 gas gas_remaining wei
                                                                                args mem[mem[64] + 4 len _5328 + ceil32(return_data.size) + (32 * mem[_5328]) + -mem[64] + 288]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            uint8(stor30.field_0) = 0
                                                                            if not msg.sender:
                                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                                            if not this.address:
                                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                                            if stor33[address(msg.sender)]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            if stor33[address(this.address)]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                            require ext_code.size(nodeRewardManagementAddress)
                                                                            call nodeRewardManagementAddress.0x37696eec with:
                                                                                 gas gas_remaining wei
                                                                                args msg.sender, uint8(cd[4])
                                                                        else:
                                                                            _5283 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_5283] = 26
                                                                            mem[_5283 + 32] = 'SafeMath: division by zero'
                                                                            _5522 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_5522] = 30
                                                                            mem[_5522 + 32] = 'SafeMath: subtraction overflow'
                                                                            if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                revert with 0, 17
                                                                            _5671 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_5671 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_5671]:
                                                                                revert with 0, 50
                                                                            mem[_5671 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_5671 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _5671 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_5671]:
                                                                                revert with 0, 50
                                                                            mem[_5671 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                            allowance[msg.sender][stor20].field_255 = 0
                                                                            emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                            mem[_5671 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_5671 + ceil32(return_data.size) + 100] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                            mem[_5671 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_5671 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_5671 + ceil32(return_data.size) + 260] = mem[_5671]
                                                                            idx = 0
                                                                            s = _5671 + ceil32(return_data.size) + 292
                                                                            t = _5671 + 32
                                                                            while idx < mem[_5671]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                 gas gas_remaining wei
                                                                                args Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_5671 + ceil32(return_data.size) + 260 len (32 * mem[_5671]) + 32]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[_5671 + ceil32(return_data.size) + 96] = 30
                                                                            mem[_5671 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                                                            if eth.balance(this.address) > eth.balance(this.address):
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if eth.balance(this.address) < eth.balance(this.address):
                                                                                revert with 0, 17
                                                                            allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                            emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                            mem[_5671 + ceil32(return_data.size) + 228] = 0
                                                                            mem[_5671 + ceil32(return_data.size) + 260] = 0
                                                                            mem[_5671 + ceil32(return_data.size) + 292] = 0
                                                                            mem[_5671 + ceil32(return_data.size) + 324] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                 gas gas_remaining wei
                                                                                args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                            mem[_5671 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            require return_data.size >= 96
                                                                            emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                            mem[_5671 + (2 * ceil32(return_data.size)) + 160] = 2
                                                                            mem[_5671 + (2 * ceil32(return_data.size)) + 192] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_5671 + (2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _5671 + (4 * ceil32(return_data.size)) + 256
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            mem[_5671 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_5671 + (4 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_5671 + (4 * ceil32(return_data.size)) + 260] = balanceOf[address(this.address)]
                                                                            mem[_5671 + (4 * ceil32(return_data.size)) + 292] = 0
                                                                            mem[_5671 + (4 * ceil32(return_data.size)) + 324] = 160
                                                                            mem[_5671 + (4 * ceil32(return_data.size)) + 420] = 2
                                                                            idx = 0
                                                                            s = _5671 + (4 * ceil32(return_data.size)) + 452
                                                                            t = _5671 + (2 * ceil32(return_data.size)) + 192
                                                                            while idx < mem[_5671 + (2 * ceil32(return_data.size)) + 160]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            mem[_5671 + (4 * ceil32(return_data.size)) + 356] = this.address
                                                                            mem[_5671 + (4 * ceil32(return_data.size)) + 388] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                 gas gas_remaining wei
                                                                                args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_5671 + (4 * ceil32(return_data.size)) + 420 len (32 * mem[_5671 + (2 * ceil32(return_data.size)) + 160]) + 32]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            uint8(stor30.field_0) = 0
                                                                            if not msg.sender:
                                                                                mem[_5671 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[_5671 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                                mem[_5671 + (4 * ceil32(return_data.size)) + 292] = 37
                                                                                mem[_5671 + (4 * ceil32(return_data.size)) + 324] = 'ERC20: transfer from the zero ad'
                                                                                mem[_5671 + (4 * ceil32(return_data.size)) + 356] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                                revert with memory
                                                                                  from _5671 + (4 * ceil32(return_data.size)) + 256
                                                                                   len (5 * ceil32(return_data.size)) + 132
                                                                            if not this.address:
                                                                                mem[_5671 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[_5671 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                                mem[_5671 + (4 * ceil32(return_data.size)) + 292] = 35
                                                                                mem[_5671 + (4 * ceil32(return_data.size)) + 324] = 'ERC20: transfer to the zero addr'
                                                                                mem[_5671 + (4 * ceil32(return_data.size)) + 356] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                                revert with memory
                                                                                  from _5671 + (4 * ceil32(return_data.size)) + 256
                                                                                   len (5 * ceil32(return_data.size)) + 132
                                                                            if stor33[address(msg.sender)]:
                                                                                mem[_5671 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[_5671 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                                mem[_5671 + (4 * ceil32(return_data.size)) + 292] = 19
                                                                                mem[_5671 + (4 * ceil32(return_data.size)) + 324] = 'Blacklisted address' << 104
                                                                                revert with memory
                                                                                  from _5671 + (4 * ceil32(return_data.size)) + 256
                                                                                   len (5 * ceil32(return_data.size)) + 100
                                                                            if stor33[address(this.address)]:
                                                                                mem[_5671 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[_5671 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                                mem[_5671 + (4 * ceil32(return_data.size)) + 292] = 19
                                                                                mem[_5671 + (4 * ceil32(return_data.size)) + 324] = 'Blacklisted address' << 104
                                                                                revert with memory
                                                                                  from _5671 + (4 * ceil32(return_data.size)) + 256
                                                                                   len (5 * ceil32(return_data.size)) + 100
                                                                            emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                            mem[_5671 + (4 * ceil32(return_data.size)) + 260] = msg.sender
                                                                            mem[_5671 + (4 * ceil32(return_data.size)) + 292] = uint8(cd[4])
                                                                            require ext_code.size(nodeRewardManagementAddress)
                                                                            call nodeRewardManagementAddress.0x37696eec with:
                                                                                 gas gas_remaining wei
                                                                                args mem[_5671 + (4 * ceil32(return_data.size)) + 260 len (5 * ceil32(return_data.size)) + 64]
                                                                else:
                                                                    _4491 = mem[64]
                                                                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                                                                    mem[_4491] = return_data.size
                                                                    mem[_4491 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    _4581 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_4581] = 30
                                                                    mem[_4581 + 32] = 'SafeMath: subtraction overflow'
                                                                    if swapTokensAmount * rewardsFee / 100 * stor29 / 100 > swapTokensAmount * rewardsFee / 100:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if swapTokensAmount * rewardsFee / 100 < swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                        revert with 0, 17
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not distributionPoolAddress:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    if stor33[address(this.address)]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    mem[0] = distributionPoolAddress
                                                                    mem[32] = 33
                                                                    if stor33[stor24]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    emit Transfer(((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)), this.address, distributionPoolAddress);
                                                                    if not swapTokensAmount:
                                                                        _5024 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_5024] = 26
                                                                        mem[_5024 + 32] = 'SafeMath: division by zero'
                                                                        mem[0] = this.address
                                                                        mem[32] = 2
                                                                        _5196 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_5196 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_5196]:
                                                                            revert with 0, 50
                                                                        mem[_5196 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_5196 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _5196 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_5196]:
                                                                            revert with 0, 50
                                                                        mem[_5196 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                        mem[_5196 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_5196 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                        mem[_5196 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_5196 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_5196 + ceil32(return_data.size) + 260] = mem[_5196]
                                                                        idx = 0
                                                                        s = _5196 + ceil32(return_data.size) + 292
                                                                        t = _5196 + 32
                                                                        while idx < mem[_5196]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                             gas gas_remaining wei
                                                                            args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_5196 + ceil32(return_data.size) + 260 len (32 * mem[_5196]) + 32]
                                                                    else:
                                                                        if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                            revert with 0, 17
                                                                        if not swapTokensAmount:
                                                                            revert with 0, 18
                                                                        if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                                        _5138 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_5138] = 26
                                                                        mem[_5138 + 32] = 'SafeMath: division by zero'
                                                                        if not swapTokensAmount * liquidityPoolFee / 100:
                                                                            mem[0] = this.address
                                                                            mem[32] = 2
                                                                            _5330 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_5330 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_5330]:
                                                                                revert with 0, 50
                                                                            mem[_5330 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_5330 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _5330 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_5330]:
                                                                                revert with 0, 50
                                                                            mem[_5330 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_5330 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_5330 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                            mem[_5330 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_5330 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_5330 + ceil32(return_data.size) + 260] = mem[_5330]
                                                                            idx = 0
                                                                            s = _5330 + ceil32(return_data.size) + 292
                                                                            t = _5330 + 32
                                                                            while idx < mem[_5330]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                 gas gas_remaining wei
                                                                                args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_5330 + ceil32(return_data.size) + 260 len (32 * mem[_5330]) + 32]
                                                                        else:
                                                                            _5285 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_5285] = 26
                                                                            mem[_5285 + 32] = 'SafeMath: division by zero'
                                                                            _5523 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_5523] = 30
                                                                            mem[_5523 + 32] = 'SafeMath: subtraction overflow'
                                                                            if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                revert with 0, 17
                                                                            _5675 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_5675 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_5675]:
                                                                                revert with 0, 50
                                                                            mem[_5675 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_5675 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _5675 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_5675]:
                                                                                revert with 0, 50
                                                                            mem[_5675 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                            allowance[msg.sender][stor20].field_255 = 0
                                                                            emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                            mem[_5675 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_5675 + ceil32(return_data.size) + 100] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                            mem[_5675 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_5675 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_5675 + ceil32(return_data.size) + 260] = mem[_5675]
                                                                            idx = 0
                                                                            s = _5675 + ceil32(return_data.size) + 292
                                                                            t = _5675 + 32
                                                                            while idx < mem[_5675]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                 gas gas_remaining wei
                                                                                args Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_5675 + ceil32(return_data.size) + 260 len (32 * mem[_5675]) + 32]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[_5675 + ceil32(return_data.size) + 96] = 30
                                                                            mem[_5675 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                                                            if eth.balance(this.address) > eth.balance(this.address):
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if eth.balance(this.address) < eth.balance(this.address):
                                                                                revert with 0, 17
                                                                            allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                            emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                            mem[_5675 + ceil32(return_data.size) + 228] = 0
                                                                            mem[_5675 + ceil32(return_data.size) + 260] = 0
                                                                            mem[_5675 + ceil32(return_data.size) + 292] = 0
                                                                            mem[_5675 + ceil32(return_data.size) + 324] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                 gas gas_remaining wei
                                                                                args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                            mem[_5675 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            require return_data.size >= 96
                                                                            emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                            mem[_5675 + (2 * ceil32(return_data.size)) + 160] = 2
                                                                            mem[_5675 + (2 * ceil32(return_data.size)) + 192] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_5675 + (2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _5675 + (4 * ceil32(return_data.size)) + 256
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            mem[_5675 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_5675 + (4 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_5675 + (4 * ceil32(return_data.size)) + 260] = balanceOf[address(this.address)]
                                                                            mem[_5675 + (4 * ceil32(return_data.size)) + 292] = 0
                                                                            mem[_5675 + (4 * ceil32(return_data.size)) + 324] = 160
                                                                            mem[_5675 + (4 * ceil32(return_data.size)) + 420] = 2
                                                                            idx = 0
                                                                            s = _5675 + (4 * ceil32(return_data.size)) + 452
                                                                            t = _5675 + (2 * ceil32(return_data.size)) + 192
                                                                            while idx < mem[_5675 + (2 * ceil32(return_data.size)) + 160]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            mem[_5675 + (4 * ceil32(return_data.size)) + 356] = this.address
                                                                            mem[_5675 + (4 * ceil32(return_data.size)) + 388] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                 gas gas_remaining wei
                                                                                args mem[mem[64] + 4 len _5675 + (4 * ceil32(return_data.size)) + (32 * mem[_5675 + (2 * ceil32(return_data.size)) + 160]) + -mem[64] + 448]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    uint8(stor30.field_0) = 0
                                                                    if not msg.sender:
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    if stor33[address(msg.sender)]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    if stor33[address(this.address)]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                    require ext_code.size(nodeRewardManagementAddress)
                                                                    call nodeRewardManagementAddress.0x37696eec with:
                                                                         gas gas_remaining wei
                                                                        args msg.sender, uint8(cd[4])
                                                else:
                                                    mem[ceil32(return_data.size) + 192] = 26
                                                    mem[ceil32(return_data.size) + 224] = 'SafeMath: division by zero'
                                                    if not this.address:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not deadWalletAddress:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if stor33[address(this.address)]:
                                                        revert with 0, 'Blacklisted address'
                                                    if stor33[stor7]:
                                                        revert with 0, 'Blacklisted address'
                                                    emit Transfer(0, this.address, deadWalletAddress);
                                                    if not swapTokensAmount:
                                                        mem[ceil32(return_data.size) + 256] = 26
                                                        mem[ceil32(return_data.size) + 288] = 'SafeMath: division by zero'
                                                        mem[ceil32(return_data.size) + 320] = 26
                                                        mem[ceil32(return_data.size) + 352] = 'SafeMath: division by zero'
                                                        mem[ceil32(return_data.size) + 384] = 30
                                                        mem[ceil32(return_data.size) + 416] = 'SafeMath: subtraction overflow'
                                                        if not this.address:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not distributionPoolAddress:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        if stor33[address(this.address)]:
                                                            revert with 0, 'Blacklisted address'
                                                        if stor33[stor24]:
                                                            revert with 0, 'Blacklisted address'
                                                        emit Transfer(0, this.address, distributionPoolAddress);
                                                        if not swapTokensAmount:
                                                            mem[ceil32(return_data.size) + 448] = 26
                                                            mem[ceil32(return_data.size) + 480] = 'SafeMath: division by zero'
                                                            mem[ceil32(return_data.size) + 512] = 2
                                                            mem[ceil32(return_data.size) + 544] = this.address
                                                            require ext_code.size(uniswapV2RouterAddress)
                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                    gas gas_remaining wei
                                                            mem[ceil32(return_data.size) + 608] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            mem[64] = (2 * ceil32(return_data.size)) + 608
                                                            require return_data.size >= 32
                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                            mem[ceil32(return_data.size) + 576] = ext_call.return_data[12 len 20]
                                                            mem[0] = uniV2RouterAddress
                                                            mem[32] = sha3(msg.sender, 3)
                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                            mem[(2 * ceil32(return_data.size)) + 608] = balanceOf[address(this.address)]
                                                            emit Approval(mem[(2 * ceil32(return_data.size)) + 608 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                            mem[(2 * ceil32(return_data.size)) + 608] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                            mem[(2 * ceil32(return_data.size)) + 612] = balanceOf[address(this.address)]
                                                            mem[(2 * ceil32(return_data.size)) + 644] = 0
                                                            mem[(2 * ceil32(return_data.size)) + 676] = 160
                                                            mem[(2 * ceil32(return_data.size)) + 772] = 2
                                                            idx = 0
                                                            s = (2 * ceil32(return_data.size)) + 804
                                                            t = ceil32(return_data.size) + 544
                                                            while idx < mem[ceil32(return_data.size) + 512]:
                                                                mem[s] = mem[t + 12 len 20]
                                                                idx = idx + 1
                                                                s = s + 32
                                                                t = t + 32
                                                                continue 
                                                            mem[(2 * ceil32(return_data.size)) + 708] = this.address
                                                            mem[(2 * ceil32(return_data.size)) + 740] = block.timestamp
                                                            require ext_code.size(uniswapV2RouterAddress)
                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                 gas gas_remaining wei
                                                                args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 864]
                                                        else:
                                                            if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                revert with 0, 17
                                                            if not swapTokensAmount:
                                                                revert with 0, 18
                                                            if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[ceil32(return_data.size) + 448] = 26
                                                            mem[ceil32(return_data.size) + 480] = 'SafeMath: division by zero'
                                                            if not swapTokensAmount * liquidityPoolFee / 100:
                                                                mem[ceil32(return_data.size) + 512] = 2
                                                                mem[ceil32(return_data.size) + 544] = this.address
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                        gas gas_remaining wei
                                                                mem[ceil32(return_data.size) + 608] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (2 * ceil32(return_data.size)) + 608
                                                                require return_data.size >= 32
                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                mem[ceil32(return_data.size) + 576] = ext_call.return_data[12 len 20]
                                                                mem[0] = uniV2RouterAddress
                                                                mem[32] = sha3(msg.sender, 3)
                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                mem[(2 * ceil32(return_data.size)) + 608] = balanceOf[address(this.address)]
                                                                emit Approval(mem[(2 * ceil32(return_data.size)) + 608 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                mem[(2 * ceil32(return_data.size)) + 608] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                mem[(2 * ceil32(return_data.size)) + 612] = balanceOf[address(this.address)]
                                                                mem[(2 * ceil32(return_data.size)) + 644] = 0
                                                                mem[(2 * ceil32(return_data.size)) + 676] = 160
                                                                mem[(2 * ceil32(return_data.size)) + 772] = 2
                                                                idx = 0
                                                                s = (2 * ceil32(return_data.size)) + 804
                                                                t = ceil32(return_data.size) + 544
                                                                while idx < mem[ceil32(return_data.size) + 512]:
                                                                    mem[s] = mem[t + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(2 * ceil32(return_data.size)) + 708] = this.address
                                                                mem[(2 * ceil32(return_data.size)) + 740] = block.timestamp
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 864]
                                                            else:
                                                                mem[ceil32(return_data.size) + 512] = 26
                                                                mem[ceil32(return_data.size) + 544] = 'SafeMath: division by zero'
                                                                mem[ceil32(return_data.size) + 576] = 30
                                                                mem[ceil32(return_data.size) + 608] = 'SafeMath: subtraction overflow'
                                                                if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                    revert with 0, 17
                                                                mem[ceil32(return_data.size) + 640] = 2
                                                                mem[ceil32(return_data.size) + 672] = this.address
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                        gas gas_remaining wei
                                                                mem[ceil32(return_data.size) + 736] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (2 * ceil32(return_data.size)) + 736
                                                                require return_data.size >= 32
                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                mem[ceil32(return_data.size) + 704] = ext_call.return_data[12 len 20]
                                                                mem[0] = uniV2RouterAddress
                                                                mem[32] = sha3(msg.sender, 3)
                                                                allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                allowance[msg.sender][stor20].field_255 = 0
                                                                mem[(2 * ceil32(return_data.size)) + 736] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                emit Approval(mem[(2 * ceil32(return_data.size)) + 736 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                mem[(2 * ceil32(return_data.size)) + 736] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                mem[(2 * ceil32(return_data.size)) + 740] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                mem[(2 * ceil32(return_data.size)) + 772] = 0
                                                                mem[(2 * ceil32(return_data.size)) + 804] = 160
                                                                mem[(2 * ceil32(return_data.size)) + 900] = 2
                                                                idx = 0
                                                                s = (2 * ceil32(return_data.size)) + 932
                                                                t = ceil32(return_data.size) + 672
                                                                while idx < mem[ceil32(return_data.size) + 640]:
                                                                    mem[s] = mem[t + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(2 * ceil32(return_data.size)) + 836] = this.address
                                                                mem[(2 * ceil32(return_data.size)) + 868] = block.timestamp
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 992]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _4055 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_4055] = 30
                                                                mem[_4055 + 32] = 'SafeMath: subtraction overflow'
                                                                if eth.balance(this.address) > eth.balance(this.address):
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                if eth.balance(this.address) < eth.balance(this.address):
                                                                    revert with 0, 17
                                                                mem[0] = uniV2RouterAddress
                                                                mem[32] = sha3(msg.sender, 3)
                                                                allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                mem[mem[64] + 68] = 0
                                                                mem[mem[64] + 100] = 0
                                                                mem[mem[64] + 132] = 0
                                                                mem[mem[64] + 164] = block.timestamp
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                     gas gas_remaining wei
                                                                    args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 96
                                                                mem[mem[64] + 32] = 0
                                                                mem[mem[64] + 64] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                mem[0] = this.address
                                                                mem[32] = 2
                                                                _4866 = mem[64]
                                                                mem[mem[64]] = 2
                                                                mem[64] = mem[64] + 96
                                                                mem[_4866 + 32 len 64] = call.data[calldata.size len 64]
                                                                if 0 >= mem[_4866]:
                                                                    revert with 0, 50
                                                                mem[_4866 + 32] = this.address
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                        gas gas_remaining wei
                                                                mem[_4866 + 96] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[64] = _4866 + ceil32(return_data.size) + 96
                                                                require return_data.size >= 32
                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                if 1 >= mem[_4866]:
                                                                    revert with 0, 50
                                                                mem[_4866 + 64] = ext_call.return_data[12 len 20]
                                                                mem[0] = uniV2RouterAddress
                                                                mem[32] = sha3(msg.sender, 3)
                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                mem[_4866 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                mem[_4866 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                mem[_4866 + ceil32(return_data.size) + 132] = 0
                                                                mem[_4866 + ceil32(return_data.size) + 164] = 160
                                                                mem[_4866 + ceil32(return_data.size) + 260] = mem[_4866]
                                                                idx = 0
                                                                s = _4866 + ceil32(return_data.size) + 292
                                                                t = _4866 + 32
                                                                while idx < mem[_4866]:
                                                                    mem[s] = mem[t + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                     gas gas_remaining wei
                                                                    args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_4866 + ceil32(return_data.size) + 260 len (32 * mem[_4866]) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        uint8(stor30.field_0) = 0
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not this.address:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        if stor33[address(msg.sender)]:
                                                            revert with 0, 'Blacklisted address'
                                                        if stor33[address(this.address)]:
                                                            revert with 0, 'Blacklisted address'
                                                        emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                        require ext_code.size(nodeRewardManagementAddress)
                                                        call nodeRewardManagementAddress.0x37696eec with:
                                                             gas gas_remaining wei
                                                            args msg.sender, uint8(cd[4])
                                                    else:
                                                        if swapTokensAmount and rewardsFee > -1 / swapTokensAmount:
                                                            revert with 0, 17
                                                        if not swapTokensAmount:
                                                            revert with 0, 18
                                                        if swapTokensAmount * rewardsFee / swapTokensAmount != rewardsFee:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[ceil32(return_data.size) + 256] = 26
                                                        mem[ceil32(return_data.size) + 288] = 'SafeMath: division by zero'
                                                        if not swapTokensAmount * rewardsFee / 100:
                                                            mem[ceil32(return_data.size) + 320] = 26
                                                            mem[ceil32(return_data.size) + 352] = 'SafeMath: division by zero'
                                                            mem[ceil32(return_data.size) + 384] = 30
                                                            mem[ceil32(return_data.size) + 416] = 'SafeMath: subtraction overflow'
                                                            if 0 > swapTokensAmount * rewardsFee / 100:
                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                            if swapTokensAmount * rewardsFee / 100 < 0:
                                                                revert with 0, 17
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not distributionPoolAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            if stor33[address(this.address)]:
                                                                revert with 0, 'Blacklisted address'
                                                            if stor33[stor24]:
                                                                revert with 0, 'Blacklisted address'
                                                            emit Transfer((swapTokensAmount * rewardsFee / 100), this.address, distributionPoolAddress);
                                                            if not swapTokensAmount:
                                                                mem[ceil32(return_data.size) + 448] = 26
                                                                mem[ceil32(return_data.size) + 480] = 'SafeMath: division by zero'
                                                                mem[ceil32(return_data.size) + 512] = 2
                                                                mem[ceil32(return_data.size) + 544] = this.address
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                        gas gas_remaining wei
                                                                mem[ceil32(return_data.size) + 608] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (2 * ceil32(return_data.size)) + 608
                                                                require return_data.size >= 32
                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                mem[ceil32(return_data.size) + 576] = ext_call.return_data[12 len 20]
                                                                mem[0] = uniV2RouterAddress
                                                                mem[32] = sha3(msg.sender, 3)
                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                mem[(2 * ceil32(return_data.size)) + 608] = balanceOf[address(this.address)]
                                                                emit Approval(mem[(2 * ceil32(return_data.size)) + 608 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                mem[(2 * ceil32(return_data.size)) + 608] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                mem[(2 * ceil32(return_data.size)) + 612] = balanceOf[address(this.address)]
                                                                mem[(2 * ceil32(return_data.size)) + 644] = 0
                                                                mem[(2 * ceil32(return_data.size)) + 676] = 160
                                                                mem[(2 * ceil32(return_data.size)) + 772] = 2
                                                                idx = 0
                                                                s = (2 * ceil32(return_data.size)) + 804
                                                                t = ceil32(return_data.size) + 544
                                                                while idx < mem[ceil32(return_data.size) + 512]:
                                                                    mem[s] = mem[t + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(2 * ceil32(return_data.size)) + 708] = this.address
                                                                mem[(2 * ceil32(return_data.size)) + 740] = block.timestamp
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 864]
                                                            else:
                                                                if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                    revert with 0, 17
                                                                if not swapTokensAmount:
                                                                    revert with 0, 18
                                                                if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                mem[ceil32(return_data.size) + 448] = 26
                                                                mem[ceil32(return_data.size) + 480] = 'SafeMath: division by zero'
                                                                if not swapTokensAmount * liquidityPoolFee / 100:
                                                                    mem[ceil32(return_data.size) + 512] = 2
                                                                    mem[ceil32(return_data.size) + 544] = this.address
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                            gas gas_remaining wei
                                                                    mem[ceil32(return_data.size) + 608] = ext_call.return_data[0]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = (2 * ceil32(return_data.size)) + 608
                                                                    require return_data.size >= 32
                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                    mem[ceil32(return_data.size) + 576] = ext_call.return_data[12 len 20]
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                    mem[(2 * ceil32(return_data.size)) + 608] = balanceOf[address(this.address)]
                                                                    emit Approval(mem[(2 * ceil32(return_data.size)) + 608 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                    mem[(2 * ceil32(return_data.size)) + 608] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                    mem[(2 * ceil32(return_data.size)) + 612] = balanceOf[address(this.address)]
                                                                    mem[(2 * ceil32(return_data.size)) + 644] = 0
                                                                    mem[(2 * ceil32(return_data.size)) + 676] = 160
                                                                    mem[(2 * ceil32(return_data.size)) + 772] = 2
                                                                    idx = 0
                                                                    s = (2 * ceil32(return_data.size)) + 804
                                                                    t = ceil32(return_data.size) + 544
                                                                    while idx < mem[ceil32(return_data.size) + 512]:
                                                                        mem[s] = mem[t + 12 len 20]
                                                                        idx = idx + 1
                                                                        s = s + 32
                                                                        t = t + 32
                                                                        continue 
                                                                    mem[(2 * ceil32(return_data.size)) + 708] = this.address
                                                                    mem[(2 * ceil32(return_data.size)) + 740] = block.timestamp
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 864]
                                                                else:
                                                                    mem[ceil32(return_data.size) + 512] = 26
                                                                    mem[ceil32(return_data.size) + 544] = 'SafeMath: division by zero'
                                                                    mem[ceil32(return_data.size) + 576] = 30
                                                                    mem[ceil32(return_data.size) + 608] = 'SafeMath: subtraction overflow'
                                                                    if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                        revert with 0, 17
                                                                    mem[ceil32(return_data.size) + 640] = 2
                                                                    mem[ceil32(return_data.size) + 672] = this.address
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                            gas gas_remaining wei
                                                                    mem[ceil32(return_data.size) + 736] = ext_call.return_data[0]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = (2 * ceil32(return_data.size)) + 736
                                                                    require return_data.size >= 32
                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                    mem[ceil32(return_data.size) + 704] = ext_call.return_data[12 len 20]
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                    allowance[msg.sender][stor20].field_255 = 0
                                                                    mem[(2 * ceil32(return_data.size)) + 736] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                    emit Approval(mem[(2 * ceil32(return_data.size)) + 736 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                    mem[(2 * ceil32(return_data.size)) + 736] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                    mem[(2 * ceil32(return_data.size)) + 740] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                    mem[(2 * ceil32(return_data.size)) + 772] = 0
                                                                    mem[(2 * ceil32(return_data.size)) + 804] = 160
                                                                    mem[(2 * ceil32(return_data.size)) + 900] = 2
                                                                    idx = 0
                                                                    s = (2 * ceil32(return_data.size)) + 932
                                                                    t = ceil32(return_data.size) + 672
                                                                    while idx < mem[ceil32(return_data.size) + 640]:
                                                                        mem[s] = mem[t + 12 len 20]
                                                                        idx = idx + 1
                                                                        s = s + 32
                                                                        t = t + 32
                                                                        continue 
                                                                    mem[(2 * ceil32(return_data.size)) + 836] = this.address
                                                                    mem[(2 * ceil32(return_data.size)) + 868] = block.timestamp
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 992]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _4054 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_4054] = 30
                                                                    mem[_4054 + 32] = 'SafeMath: subtraction overflow'
                                                                    if eth.balance(this.address) > eth.balance(this.address):
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if eth.balance(this.address) < eth.balance(this.address):
                                                                        revert with 0, 17
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                    emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                    mem[mem[64] + 68] = 0
                                                                    mem[mem[64] + 100] = 0
                                                                    mem[mem[64] + 132] = 0
                                                                    mem[mem[64] + 164] = block.timestamp
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                         gas gas_remaining wei
                                                                        args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 96
                                                                    mem[mem[64] + 32] = 0
                                                                    mem[mem[64] + 64] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                    emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                    mem[0] = this.address
                                                                    mem[32] = 2
                                                                    _4864 = mem[64]
                                                                    mem[mem[64]] = 2
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_4864 + 32 len 64] = call.data[calldata.size len 64]
                                                                    if 0 >= mem[_4864]:
                                                                        revert with 0, 50
                                                                    mem[_4864 + 32] = this.address
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                            gas gas_remaining wei
                                                                    mem[_4864 + 96] = ext_call.return_data[0]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _4864 + ceil32(return_data.size) + 96
                                                                    require return_data.size >= 32
                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                    if 1 >= mem[_4864]:
                                                                        revert with 0, 50
                                                                    mem[_4864 + 64] = ext_call.return_data[12 len 20]
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                    emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                    mem[_4864 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                    mem[_4864 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                    mem[_4864 + ceil32(return_data.size) + 132] = 0
                                                                    mem[_4864 + ceil32(return_data.size) + 164] = 160
                                                                    mem[_4864 + ceil32(return_data.size) + 260] = mem[_4864]
                                                                    idx = 0
                                                                    s = _4864 + ceil32(return_data.size) + 292
                                                                    t = _4864 + 32
                                                                    while idx < mem[_4864]:
                                                                        mem[s] = mem[t + 12 len 20]
                                                                        idx = idx + 1
                                                                        s = s + 32
                                                                        t = t + 32
                                                                        continue 
                                                                    mem[_4864 + ceil32(return_data.size) + 196] = this.address
                                                                    mem[_4864 + ceil32(return_data.size) + 228] = block.timestamp
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _4864 + ceil32(return_data.size) + (32 * mem[_4864]) + -mem[64] + 288]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            uint8(stor30.field_0) = 0
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            if stor33[address(msg.sender)]:
                                                                revert with 0, 'Blacklisted address'
                                                            if stor33[address(this.address)]:
                                                                revert with 0, 'Blacklisted address'
                                                            emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                            require ext_code.size(nodeRewardManagementAddress)
                                                            call nodeRewardManagementAddress.0x37696eec with:
                                                                 gas gas_remaining wei
                                                                args msg.sender, uint8(cd[4])
                                                        else:
                                                            if swapTokensAmount * rewardsFee / 100 and stor29 > -1 / swapTokensAmount * rewardsFee / 100:
                                                                revert with 0, 17
                                                            if not swapTokensAmount * rewardsFee / 100:
                                                                revert with 0, 18
                                                            if swapTokensAmount * rewardsFee / 100 * stor29 / swapTokensAmount * rewardsFee / 100 != stor29:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[ceil32(return_data.size) + 320] = 26
                                                            mem[ceil32(return_data.size) + 352] = 'SafeMath: division by zero'
                                                            if not swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                mem[ceil32(return_data.size) + 384] = 30
                                                                mem[ceil32(return_data.size) + 416] = 'SafeMath: subtraction overflow'
                                                                if swapTokensAmount * rewardsFee / 100 * stor29 / 100 > swapTokensAmount * rewardsFee / 100:
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                if swapTokensAmount * rewardsFee / 100 < swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                    revert with 0, 17
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not distributionPoolAddress:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                if stor33[address(this.address)]:
                                                                    revert with 0, 'Blacklisted address'
                                                                if stor33[stor24]:
                                                                    revert with 0, 'Blacklisted address'
                                                                emit Transfer(((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)), this.address, distributionPoolAddress);
                                                                if not swapTokensAmount:
                                                                    mem[ceil32(return_data.size) + 448] = 26
                                                                    mem[ceil32(return_data.size) + 480] = 'SafeMath: division by zero'
                                                                    mem[ceil32(return_data.size) + 512] = 2
                                                                    mem[ceil32(return_data.size) + 544] = this.address
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                            gas gas_remaining wei
                                                                    mem[ceil32(return_data.size) + 608] = ext_call.return_data[0]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = (2 * ceil32(return_data.size)) + 608
                                                                    require return_data.size >= 32
                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                    mem[ceil32(return_data.size) + 576] = ext_call.return_data[12 len 20]
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                    mem[(2 * ceil32(return_data.size)) + 608] = balanceOf[address(this.address)]
                                                                    emit Approval(mem[(2 * ceil32(return_data.size)) + 608 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                    mem[(2 * ceil32(return_data.size)) + 608] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                    mem[(2 * ceil32(return_data.size)) + 612] = balanceOf[address(this.address)]
                                                                    mem[(2 * ceil32(return_data.size)) + 644] = 0
                                                                    mem[(2 * ceil32(return_data.size)) + 676] = 160
                                                                    mem[(2 * ceil32(return_data.size)) + 772] = 2
                                                                    idx = 0
                                                                    s = (2 * ceil32(return_data.size)) + 804
                                                                    t = ceil32(return_data.size) + 544
                                                                    while idx < mem[ceil32(return_data.size) + 512]:
                                                                        mem[s] = mem[t + 12 len 20]
                                                                        idx = idx + 1
                                                                        s = s + 32
                                                                        t = t + 32
                                                                        continue 
                                                                    mem[(2 * ceil32(return_data.size)) + 708] = this.address
                                                                    mem[(2 * ceil32(return_data.size)) + 740] = block.timestamp
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 864]
                                                                else:
                                                                    if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                        revert with 0, 17
                                                                    if not swapTokensAmount:
                                                                        revert with 0, 18
                                                                    if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                                    mem[ceil32(return_data.size) + 448] = 26
                                                                    mem[ceil32(return_data.size) + 480] = 'SafeMath: division by zero'
                                                                    if not swapTokensAmount * liquidityPoolFee / 100:
                                                                        mem[ceil32(return_data.size) + 512] = 2
                                                                        mem[ceil32(return_data.size) + 544] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[ceil32(return_data.size) + 608] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = (2 * ceil32(return_data.size)) + 608
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        mem[ceil32(return_data.size) + 576] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        mem[(2 * ceil32(return_data.size)) + 608] = balanceOf[address(this.address)]
                                                                        emit Approval(mem[(2 * ceil32(return_data.size)) + 608 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                        mem[(2 * ceil32(return_data.size)) + 608] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[(2 * ceil32(return_data.size)) + 612] = balanceOf[address(this.address)]
                                                                        mem[(2 * ceil32(return_data.size)) + 644] = 0
                                                                        mem[(2 * ceil32(return_data.size)) + 676] = 160
                                                                        mem[(2 * ceil32(return_data.size)) + 772] = 2
                                                                        idx = 0
                                                                        s = (2 * ceil32(return_data.size)) + 804
                                                                        t = ceil32(return_data.size) + 544
                                                                        while idx < mem[ceil32(return_data.size) + 512]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[(2 * ceil32(return_data.size)) + 708] = this.address
                                                                        mem[(2 * ceil32(return_data.size)) + 740] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                             gas gas_remaining wei
                                                                            args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 864]
                                                                    else:
                                                                        mem[ceil32(return_data.size) + 512] = 26
                                                                        mem[ceil32(return_data.size) + 544] = 'SafeMath: division by zero'
                                                                        mem[ceil32(return_data.size) + 576] = 30
                                                                        mem[ceil32(return_data.size) + 608] = 'SafeMath: subtraction overflow'
                                                                        if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                            revert with 0, 17
                                                                        mem[ceil32(return_data.size) + 640] = 2
                                                                        mem[ceil32(return_data.size) + 672] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[ceil32(return_data.size) + 736] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = (2 * ceil32(return_data.size)) + 736
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        mem[ceil32(return_data.size) + 704] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                        allowance[msg.sender][stor20].field_255 = 0
                                                                        mem[(2 * ceil32(return_data.size)) + 736] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                        emit Approval(mem[(2 * ceil32(return_data.size)) + 736 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                        mem[(2 * ceil32(return_data.size)) + 736] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[(2 * ceil32(return_data.size)) + 740] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                        mem[(2 * ceil32(return_data.size)) + 772] = 0
                                                                        mem[(2 * ceil32(return_data.size)) + 804] = 160
                                                                        mem[(2 * ceil32(return_data.size)) + 900] = 2
                                                                        idx = 0
                                                                        s = (2 * ceil32(return_data.size)) + 932
                                                                        t = ceil32(return_data.size) + 672
                                                                        while idx < mem[ceil32(return_data.size) + 640]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[(2 * ceil32(return_data.size)) + 836] = this.address
                                                                        mem[(2 * ceil32(return_data.size)) + 868] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                             gas gas_remaining wei
                                                                            args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 992]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        _4052 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_4052] = 30
                                                                        mem[_4052 + 32] = 'SafeMath: subtraction overflow'
                                                                        if eth.balance(this.address) > eth.balance(this.address):
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if eth.balance(this.address) < eth.balance(this.address):
                                                                            revert with 0, 17
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                        emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                        mem[mem[64] + 68] = 0
                                                                        mem[mem[64] + 100] = 0
                                                                        mem[mem[64] + 132] = 0
                                                                        mem[mem[64] + 164] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                             gas gas_remaining wei
                                                                            args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                                        require return_data.size >= 96
                                                                        mem[mem[64] + 32] = 0
                                                                        mem[mem[64] + 64] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                        emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                        mem[0] = this.address
                                                                        mem[32] = 2
                                                                        _4858 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_4858 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_4858]:
                                                                            revert with 0, 50
                                                                        mem[_4858 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_4858 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _4858 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_4858]:
                                                                            revert with 0, 50
                                                                        mem[_4858 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                        mem[_4858 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_4858 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                        mem[_4858 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_4858 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_4858 + ceil32(return_data.size) + 260] = mem[_4858]
                                                                        idx = 0
                                                                        s = _4858 + ceil32(return_data.size) + 292
                                                                        t = _4858 + 32
                                                                        while idx < mem[_4858]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[_4858 + ceil32(return_data.size) + 196] = this.address
                                                                        mem[_4858 + ceil32(return_data.size) + 228] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                             gas gas_remaining wei
                                                                            args mem[mem[64] + 4 len _4858 + ceil32(return_data.size) + (32 * mem[_4858]) + -mem[64] + 288]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                uint8(stor30.field_0) = 0
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                if stor33[address(msg.sender)]:
                                                                    revert with 0, 'Blacklisted address'
                                                                if stor33[address(this.address)]:
                                                                    revert with 0, 'Blacklisted address'
                                                                emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                require ext_code.size(nodeRewardManagementAddress)
                                                                call nodeRewardManagementAddress.0x37696eec with:
                                                                     gas gas_remaining wei
                                                                    args msg.sender, uint8(cd[4])
                                                            else:
                                                                mem[ceil32(return_data.size) + 384] = 2
                                                                mem[ceil32(return_data.size) + 416] = this.address
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                        gas gas_remaining wei
                                                                mem[ceil32(return_data.size) + 480] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (2 * ceil32(return_data.size)) + 480
                                                                require return_data.size >= 32
                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                mem[ceil32(return_data.size) + 448] = ext_call.return_data[12 len 20]
                                                                mem[0] = uniV2RouterAddress
                                                                mem[32] = sha3(msg.sender, 3)
                                                                allowance[msg.sender][stor20].field_0 = swapTokensAmount * rewardsFee / 100 * stor29 / 100
                                                                mem[(2 * ceil32(return_data.size)) + 480] = swapTokensAmount * rewardsFee / 100 * stor29 / 100
                                                                emit Approval(mem[(2 * ceil32(return_data.size)) + 480 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                mem[(2 * ceil32(return_data.size)) + 480] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                mem[(2 * ceil32(return_data.size)) + 484] = swapTokensAmount * rewardsFee / 100 * stor29 / 100
                                                                mem[(2 * ceil32(return_data.size)) + 516] = 0
                                                                mem[(2 * ceil32(return_data.size)) + 548] = 160
                                                                mem[(2 * ceil32(return_data.size)) + 644] = 2
                                                                idx = 0
                                                                s = (2 * ceil32(return_data.size)) + 676
                                                                t = ceil32(return_data.size) + 416
                                                                while idx < mem[ceil32(return_data.size) + 384]:
                                                                    mem[s] = mem[t + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(2 * ceil32(return_data.size)) + 580] = this.address
                                                                mem[(2 * ceil32(return_data.size)) + 612] = block.timestamp
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 736]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _4053 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_4053] = 30
                                                                mem[_4053 + 32] = 'SafeMath: subtraction overflow'
                                                                if eth.balance(this.address) > eth.balance(this.address):
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                if eth.balance(this.address) < eth.balance(this.address):
                                                                    revert with 0, 17
                                                                call distributionPoolAddress with:
                                                                     gas 30000 wei
                                                                if not return_data.size:
                                                                    _4582 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_4582] = 30
                                                                    mem[_4582 + 32] = 'SafeMath: subtraction overflow'
                                                                    if swapTokensAmount * rewardsFee / 100 * stor29 / 100 > swapTokensAmount * rewardsFee / 100:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if swapTokensAmount * rewardsFee / 100 < swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                        revert with 0, 17
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not distributionPoolAddress:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    if stor33[address(this.address)]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    mem[0] = distributionPoolAddress
                                                                    mem[32] = 33
                                                                    if stor33[stor24]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    emit Transfer(((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)), this.address, distributionPoolAddress);
                                                                    if not swapTokensAmount:
                                                                        _5028 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_5028] = 26
                                                                        mem[_5028 + 32] = 'SafeMath: division by zero'
                                                                        mem[0] = this.address
                                                                        mem[32] = 2
                                                                        _5198 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_5198 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_5198]:
                                                                            revert with 0, 50
                                                                        mem[_5198 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_5198 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _5198 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_5198]:
                                                                            revert with 0, 50
                                                                        mem[_5198 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                        mem[_5198 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_5198 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                        mem[_5198 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_5198 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_5198 + ceil32(return_data.size) + 260] = mem[_5198]
                                                                        idx = 0
                                                                        s = _5198 + ceil32(return_data.size) + 292
                                                                        t = _5198 + 32
                                                                        while idx < mem[_5198]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                             gas gas_remaining wei
                                                                            args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_5198 + ceil32(return_data.size) + 260 len (32 * mem[_5198]) + 32]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        uint8(stor30.field_0) = 0
                                                                        if not msg.sender:
                                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                                        if not this.address:
                                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                                        if stor33[address(msg.sender)]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        if stor33[address(this.address)]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                        require ext_code.size(nodeRewardManagementAddress)
                                                                        call nodeRewardManagementAddress.0x37696eec with:
                                                                             gas gas_remaining wei
                                                                            args msg.sender, uint8(cd[4])
                                                                    else:
                                                                        if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                            revert with 0, 17
                                                                        if not swapTokensAmount:
                                                                            revert with 0, 18
                                                                        if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                                        _5142 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_5142] = 26
                                                                        mem[_5142 + 32] = 'SafeMath: division by zero'
                                                                        if not swapTokensAmount * liquidityPoolFee / 100:
                                                                            mem[0] = this.address
                                                                            mem[32] = 2
                                                                            _5338 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_5338 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_5338]:
                                                                                revert with 0, 50
                                                                            mem[_5338 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_5338 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _5338 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_5338]:
                                                                                revert with 0, 50
                                                                            mem[_5338 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_5338 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_5338 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                            mem[_5338 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_5338 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_5338 + ceil32(return_data.size) + 260] = mem[_5338]
                                                                            idx = 0
                                                                            s = _5338 + ceil32(return_data.size) + 292
                                                                            t = _5338 + 32
                                                                            while idx < mem[_5338]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                 gas gas_remaining wei
                                                                                args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_5338 + ceil32(return_data.size) + 260 len (32 * mem[_5338]) + 32]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            uint8(stor30.field_0) = 0
                                                                            if not msg.sender:
                                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                                            if not this.address:
                                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                                            if stor33[address(msg.sender)]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            if stor33[address(this.address)]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                            require ext_code.size(nodeRewardManagementAddress)
                                                                            call nodeRewardManagementAddress.0x37696eec with:
                                                                                 gas gas_remaining wei
                                                                                args msg.sender, uint8(cd[4])
                                                                        else:
                                                                            _5296 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_5296] = 26
                                                                            mem[_5296 + 32] = 'SafeMath: division by zero'
                                                                            _5524 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_5524] = 30
                                                                            mem[_5524 + 32] = 'SafeMath: subtraction overflow'
                                                                            if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                revert with 0, 17
                                                                            _5679 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_5679 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_5679]:
                                                                                revert with 0, 50
                                                                            mem[_5679 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_5679 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _5679 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_5679]:
                                                                                revert with 0, 50
                                                                            mem[_5679 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                            allowance[msg.sender][stor20].field_255 = 0
                                                                            emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                            mem[_5679 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_5679 + ceil32(return_data.size) + 100] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                            mem[_5679 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_5679 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_5679 + ceil32(return_data.size) + 260] = mem[_5679]
                                                                            idx = 0
                                                                            s = _5679 + ceil32(return_data.size) + 292
                                                                            t = _5679 + 32
                                                                            while idx < mem[_5679]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                 gas gas_remaining wei
                                                                                args Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_5679 + ceil32(return_data.size) + 260 len (32 * mem[_5679]) + 32]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[_5679 + ceil32(return_data.size) + 96] = 30
                                                                            mem[_5679 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                                                            if eth.balance(this.address) > eth.balance(this.address):
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if eth.balance(this.address) < eth.balance(this.address):
                                                                                revert with 0, 17
                                                                            allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                            emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                            mem[_5679 + ceil32(return_data.size) + 228] = 0
                                                                            mem[_5679 + ceil32(return_data.size) + 260] = 0
                                                                            mem[_5679 + ceil32(return_data.size) + 292] = 0
                                                                            mem[_5679 + ceil32(return_data.size) + 324] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                 gas gas_remaining wei
                                                                                args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                            mem[_5679 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            require return_data.size >= 96
                                                                            emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                            mem[_5679 + (2 * ceil32(return_data.size)) + 160] = 2
                                                                            mem[_5679 + (2 * ceil32(return_data.size)) + 192] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_5679 + (2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _5679 + (4 * ceil32(return_data.size)) + 256
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            mem[_5679 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_5679 + (4 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_5679 + (4 * ceil32(return_data.size)) + 260] = balanceOf[address(this.address)]
                                                                            mem[_5679 + (4 * ceil32(return_data.size)) + 292] = 0
                                                                            mem[_5679 + (4 * ceil32(return_data.size)) + 324] = 160
                                                                            mem[_5679 + (4 * ceil32(return_data.size)) + 420] = 2
                                                                            idx = 0
                                                                            s = _5679 + (4 * ceil32(return_data.size)) + 452
                                                                            t = _5679 + (2 * ceil32(return_data.size)) + 192
                                                                            while idx < mem[_5679 + (2 * ceil32(return_data.size)) + 160]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            mem[_5679 + (4 * ceil32(return_data.size)) + 356] = this.address
                                                                            mem[_5679 + (4 * ceil32(return_data.size)) + 388] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                 gas gas_remaining wei
                                                                                args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_5679 + (4 * ceil32(return_data.size)) + 420 len (32 * mem[_5679 + (2 * ceil32(return_data.size)) + 160]) + 32]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            uint8(stor30.field_0) = 0
                                                                            if not msg.sender:
                                                                                mem[_5679 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[_5679 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                                mem[_5679 + (4 * ceil32(return_data.size)) + 292] = 37
                                                                                mem[_5679 + (4 * ceil32(return_data.size)) + 324] = 'ERC20: transfer from the zero ad'
                                                                                mem[_5679 + (4 * ceil32(return_data.size)) + 356] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                                revert with memory
                                                                                  from _5679 + (4 * ceil32(return_data.size)) + 256
                                                                                   len (5 * ceil32(return_data.size)) + 132
                                                                            if not this.address:
                                                                                mem[_5679 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[_5679 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                                mem[_5679 + (4 * ceil32(return_data.size)) + 292] = 35
                                                                                mem[_5679 + (4 * ceil32(return_data.size)) + 324] = 'ERC20: transfer to the zero addr'
                                                                                mem[_5679 + (4 * ceil32(return_data.size)) + 356] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                                revert with memory
                                                                                  from _5679 + (4 * ceil32(return_data.size)) + 256
                                                                                   len (5 * ceil32(return_data.size)) + 132
                                                                            if stor33[address(msg.sender)]:
                                                                                mem[_5679 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[_5679 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                                mem[_5679 + (4 * ceil32(return_data.size)) + 292] = 19
                                                                                mem[_5679 + (4 * ceil32(return_data.size)) + 324] = 'Blacklisted address' << 104
                                                                                revert with memory
                                                                                  from _5679 + (4 * ceil32(return_data.size)) + 256
                                                                                   len (5 * ceil32(return_data.size)) + 100
                                                                            if stor33[address(this.address)]:
                                                                                mem[_5679 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[_5679 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                                mem[_5679 + (4 * ceil32(return_data.size)) + 292] = 19
                                                                                mem[_5679 + (4 * ceil32(return_data.size)) + 324] = 'Blacklisted address' << 104
                                                                                revert with memory
                                                                                  from _5679 + (4 * ceil32(return_data.size)) + 256
                                                                                   len (5 * ceil32(return_data.size)) + 100
                                                                            emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                            mem[_5679 + (4 * ceil32(return_data.size)) + 260] = msg.sender
                                                                            mem[_5679 + (4 * ceil32(return_data.size)) + 292] = uint8(cd[4])
                                                                            require ext_code.size(nodeRewardManagementAddress)
                                                                            call nodeRewardManagementAddress.0x37696eec with:
                                                                                 gas gas_remaining wei
                                                                                args mem[_5679 + (4 * ceil32(return_data.size)) + 260 len (5 * ceil32(return_data.size)) + 64]
                                                                else:
                                                                    _4508 = mem[64]
                                                                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                                                                    mem[_4508] = return_data.size
                                                                    mem[_4508 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                    _4583 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_4583] = 30
                                                                    mem[_4583 + 32] = 'SafeMath: subtraction overflow'
                                                                    if swapTokensAmount * rewardsFee / 100 * stor29 / 100 > swapTokensAmount * rewardsFee / 100:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if swapTokensAmount * rewardsFee / 100 < swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                        revert with 0, 17
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not distributionPoolAddress:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    if stor33[address(this.address)]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    mem[0] = distributionPoolAddress
                                                                    mem[32] = 33
                                                                    if stor33[stor24]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    emit Transfer(((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)), this.address, distributionPoolAddress);
                                                                    if not swapTokensAmount:
                                                                        _5029 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_5029] = 26
                                                                        mem[_5029 + 32] = 'SafeMath: division by zero'
                                                                        mem[0] = this.address
                                                                        mem[32] = 2
                                                                        _5200 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_5200 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_5200]:
                                                                            revert with 0, 50
                                                                        mem[_5200 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_5200 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _5200 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_5200]:
                                                                            revert with 0, 50
                                                                        mem[_5200 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                        mem[_5200 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_5200 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                        mem[_5200 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_5200 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_5200 + ceil32(return_data.size) + 260] = mem[_5200]
                                                                        idx = 0
                                                                        s = _5200 + ceil32(return_data.size) + 292
                                                                        t = _5200 + 32
                                                                        while idx < mem[_5200]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[_5200 + ceil32(return_data.size) + 196] = this.address
                                                                        mem[_5200 + ceil32(return_data.size) + 228] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                             gas gas_remaining wei
                                                                            args mem[mem[64] + 4 len _5200 + ceil32(return_data.size) + (32 * mem[_5200]) + -mem[64] + 288]
                                                                    else:
                                                                        if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                            revert with 0, 17
                                                                        if not swapTokensAmount:
                                                                            revert with 0, 18
                                                                        if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                                        _5143 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_5143] = 26
                                                                        mem[_5143 + 32] = 'SafeMath: division by zero'
                                                                        if not swapTokensAmount * liquidityPoolFee / 100:
                                                                            mem[0] = this.address
                                                                            mem[32] = 2
                                                                            _5340 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_5340 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_5340]:
                                                                                revert with 0, 50
                                                                            mem[_5340 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_5340 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _5340 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_5340]:
                                                                                revert with 0, 50
                                                                            mem[_5340 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_5340 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_5340 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                            mem[_5340 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_5340 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_5340 + ceil32(return_data.size) + 260] = mem[_5340]
                                                                            idx = 0
                                                                            s = _5340 + ceil32(return_data.size) + 292
                                                                            t = _5340 + 32
                                                                            while idx < mem[_5340]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            mem[_5340 + ceil32(return_data.size) + 196] = this.address
                                                                            mem[_5340 + ceil32(return_data.size) + 228] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                 gas gas_remaining wei
                                                                                args mem[mem[64] + 4 len _5340 + ceil32(return_data.size) + (32 * mem[_5340]) + -mem[64] + 288]
                                                                        else:
                                                                            _5298 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_5298] = 26
                                                                            mem[_5298 + 32] = 'SafeMath: division by zero'
                                                                            _5525 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_5525] = 30
                                                                            mem[_5525 + 32] = 'SafeMath: subtraction overflow'
                                                                            if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                revert with 0, 17
                                                                            _5683 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_5683 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_5683]:
                                                                                revert with 0, 50
                                                                            mem[_5683 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_5683 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _5683 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_5683]:
                                                                                revert with 0, 50
                                                                            mem[_5683 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                            allowance[msg.sender][stor20].field_255 = 0
                                                                            emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                            mem[_5683 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_5683 + ceil32(return_data.size) + 100] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                            mem[_5683 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_5683 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_5683 + ceil32(return_data.size) + 260] = mem[_5683]
                                                                            idx = 0
                                                                            s = _5683 + ceil32(return_data.size) + 292
                                                                            t = _5683 + 32
                                                                            while idx < mem[_5683]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            mem[_5683 + ceil32(return_data.size) + 196] = this.address
                                                                            mem[_5683 + ceil32(return_data.size) + 228] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                 gas gas_remaining wei
                                                                                args mem[mem[64] + 4 len _5683 + ceil32(return_data.size) + (32 * mem[_5683]) + -mem[64] + 288]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            _9564 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_9564] = 30
                                                                            mem[_9564 + 32] = 'SafeMath: subtraction overflow'
                                                                            if eth.balance(this.address) > eth.balance(this.address):
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if eth.balance(this.address) < eth.balance(this.address):
                                                                                revert with 0, 17
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                            emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                            mem[mem[64] + 68] = 0
                                                                            mem[mem[64] + 100] = 0
                                                                            mem[mem[64] + 132] = 0
                                                                            mem[mem[64] + 164] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                 gas gas_remaining wei
                                                                                args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                                            require return_data.size >= 96
                                                                            mem[mem[64] + 32] = 0
                                                                            mem[mem[64] + 64] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                            emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                            mem[0] = this.address
                                                                            mem[32] = 2
                                                                            _10819 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_10819 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_10819]:
                                                                                revert with 0, 50
                                                                            mem[_10819 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_10819 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _10819 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_10819]:
                                                                                revert with 0, 50
                                                                            mem[_10819 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_10819 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_10819 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                            mem[_10819 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_10819 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_10819 + ceil32(return_data.size) + 260] = mem[_10819]
                                                                            idx = 0
                                                                            s = _10819 + ceil32(return_data.size) + 292
                                                                            t = _10819 + 32
                                                                            while idx < mem[_10819]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            mem[_10819 + ceil32(return_data.size) + 196] = this.address
                                                                            mem[_10819 + ceil32(return_data.size) + 228] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                 gas gas_remaining wei
                                                                                args mem[mem[64] + 4 len _10819 + ceil32(return_data.size) + (32 * mem[_10819]) + -mem[64] + 288]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    uint8(stor30.field_0) = 0
                                                                    if not msg.sender:
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    if stor33[address(msg.sender)]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    if stor33[address(this.address)]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                    require ext_code.size(nodeRewardManagementAddress)
                                                                    call nodeRewardManagementAddress.0x37696eec with:
                                                                         gas gas_remaining wei
                                                                        args msg.sender, uint8(cd[4])
                                            else:
                                                if swapTokensAmount and devFee > -1 / swapTokensAmount:
                                                    revert with 0, 17
                                                if not swapTokensAmount:
                                                    revert with 0, 18
                                                if swapTokensAmount * devFee / swapTokensAmount != devFee:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                mem[ceil32(return_data.size) + 128] = 26
                                                mem[ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                                if not swapTokensAmount * devFee / 100:
                                                    if swapTokensAmount:
                                                        if swapTokensAmount and burnFee > -1 / swapTokensAmount:
                                                            revert with 0, 17
                                                        if not swapTokensAmount:
                                                            revert with 0, 18
                                                        if swapTokensAmount * burnFee / swapTokensAmount != burnFee:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[ceil32(return_data.size) + 192] = 26
                                                        mem[ceil32(return_data.size) + 224] = 'SafeMath: division by zero'
                                                        if not this.address:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not deadWalletAddress:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        if stor33[address(this.address)]:
                                                            revert with 0, 'Blacklisted address'
                                                        if stor33[stor7]:
                                                            revert with 0, 'Blacklisted address'
                                                        emit Transfer((swapTokensAmount * burnFee / 100), this.address, deadWalletAddress);
                                                        if not swapTokensAmount:
                                                            mem[ceil32(return_data.size) + 256] = 26
                                                            mem[ceil32(return_data.size) + 288] = 'SafeMath: division by zero'
                                                            mem[ceil32(return_data.size) + 320] = 26
                                                            mem[ceil32(return_data.size) + 352] = 'SafeMath: division by zero'
                                                            mem[ceil32(return_data.size) + 384] = 30
                                                            mem[ceil32(return_data.size) + 416] = 'SafeMath: subtraction overflow'
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not distributionPoolAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            if stor33[address(this.address)]:
                                                                revert with 0, 'Blacklisted address'
                                                            if stor33[stor24]:
                                                                revert with 0, 'Blacklisted address'
                                                            emit Transfer(0, this.address, distributionPoolAddress);
                                                            if not swapTokensAmount:
                                                                mem[ceil32(return_data.size) + 448] = 26
                                                                mem[ceil32(return_data.size) + 480] = 'SafeMath: division by zero'
                                                                mem[ceil32(return_data.size) + 512] = 2
                                                                mem[ceil32(return_data.size) + 544] = this.address
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                        gas gas_remaining wei
                                                                mem[ceil32(return_data.size) + 608] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (2 * ceil32(return_data.size)) + 608
                                                                require return_data.size >= 32
                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                mem[ceil32(return_data.size) + 576] = ext_call.return_data[12 len 20]
                                                                mem[0] = uniV2RouterAddress
                                                                mem[32] = sha3(msg.sender, 3)
                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                mem[(2 * ceil32(return_data.size)) + 608] = balanceOf[address(this.address)]
                                                                emit Approval(mem[(2 * ceil32(return_data.size)) + 608 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                mem[(2 * ceil32(return_data.size)) + 608] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                mem[(2 * ceil32(return_data.size)) + 612] = balanceOf[address(this.address)]
                                                                mem[(2 * ceil32(return_data.size)) + 644] = 0
                                                                mem[(2 * ceil32(return_data.size)) + 676] = 160
                                                                mem[(2 * ceil32(return_data.size)) + 772] = 2
                                                                idx = 0
                                                                s = (2 * ceil32(return_data.size)) + 804
                                                                t = ceil32(return_data.size) + 544
                                                                while idx < mem[ceil32(return_data.size) + 512]:
                                                                    mem[s] = mem[t + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(2 * ceil32(return_data.size)) + 708] = this.address
                                                                mem[(2 * ceil32(return_data.size)) + 740] = block.timestamp
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 864]
                                                            else:
                                                                if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                    revert with 0, 17
                                                                if not swapTokensAmount:
                                                                    revert with 0, 18
                                                                if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                mem[ceil32(return_data.size) + 448] = 26
                                                                mem[ceil32(return_data.size) + 480] = 'SafeMath: division by zero'
                                                                if not swapTokensAmount * liquidityPoolFee / 100:
                                                                    mem[ceil32(return_data.size) + 512] = 2
                                                                    mem[ceil32(return_data.size) + 544] = this.address
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                            gas gas_remaining wei
                                                                    mem[ceil32(return_data.size) + 608] = ext_call.return_data[0]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = (2 * ceil32(return_data.size)) + 608
                                                                    require return_data.size >= 32
                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                    mem[ceil32(return_data.size) + 576] = ext_call.return_data[12 len 20]
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                    mem[(2 * ceil32(return_data.size)) + 608] = balanceOf[address(this.address)]
                                                                    emit Approval(mem[(2 * ceil32(return_data.size)) + 608 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                    mem[(2 * ceil32(return_data.size)) + 608] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                    mem[(2 * ceil32(return_data.size)) + 612] = balanceOf[address(this.address)]
                                                                    mem[(2 * ceil32(return_data.size)) + 644] = 0
                                                                    mem[(2 * ceil32(return_data.size)) + 676] = 160
                                                                    mem[(2 * ceil32(return_data.size)) + 772] = 2
                                                                    idx = 0
                                                                    s = (2 * ceil32(return_data.size)) + 804
                                                                    t = ceil32(return_data.size) + 544
                                                                    while idx < mem[ceil32(return_data.size) + 512]:
                                                                        mem[s] = mem[t + 12 len 20]
                                                                        idx = idx + 1
                                                                        s = s + 32
                                                                        t = t + 32
                                                                        continue 
                                                                    mem[(2 * ceil32(return_data.size)) + 708] = this.address
                                                                    mem[(2 * ceil32(return_data.size)) + 740] = block.timestamp
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 864]
                                                                else:
                                                                    mem[ceil32(return_data.size) + 512] = 26
                                                                    mem[ceil32(return_data.size) + 544] = 'SafeMath: division by zero'
                                                                    mem[ceil32(return_data.size) + 576] = 30
                                                                    mem[ceil32(return_data.size) + 608] = 'SafeMath: subtraction overflow'
                                                                    if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                        revert with 0, 17
                                                                    mem[ceil32(return_data.size) + 640] = 2
                                                                    mem[ceil32(return_data.size) + 672] = this.address
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                            gas gas_remaining wei
                                                                    mem[ceil32(return_data.size) + 736] = ext_call.return_data[0]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = (2 * ceil32(return_data.size)) + 736
                                                                    require return_data.size >= 32
                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                    mem[ceil32(return_data.size) + 704] = ext_call.return_data[12 len 20]
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                    allowance[msg.sender][stor20].field_255 = 0
                                                                    mem[(2 * ceil32(return_data.size)) + 736] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                    emit Approval(mem[(2 * ceil32(return_data.size)) + 736 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                    mem[(2 * ceil32(return_data.size)) + 736] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                    mem[(2 * ceil32(return_data.size)) + 740] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                    mem[(2 * ceil32(return_data.size)) + 772] = 0
                                                                    mem[(2 * ceil32(return_data.size)) + 804] = 160
                                                                    mem[(2 * ceil32(return_data.size)) + 900] = 2
                                                                    idx = 0
                                                                    s = (2 * ceil32(return_data.size)) + 932
                                                                    t = ceil32(return_data.size) + 672
                                                                    while idx < mem[ceil32(return_data.size) + 640]:
                                                                        mem[s] = mem[t + 12 len 20]
                                                                        idx = idx + 1
                                                                        s = s + 32
                                                                        t = t + 32
                                                                        continue 
                                                                    mem[(2 * ceil32(return_data.size)) + 836] = this.address
                                                                    mem[(2 * ceil32(return_data.size)) + 868] = block.timestamp
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 992]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _4042 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_4042] = 30
                                                                    mem[_4042 + 32] = 'SafeMath: subtraction overflow'
                                                                    if eth.balance(this.address) > eth.balance(this.address):
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if eth.balance(this.address) < eth.balance(this.address):
                                                                        revert with 0, 17
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                    emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                    mem[mem[64] + 68] = 0
                                                                    mem[mem[64] + 100] = 0
                                                                    mem[mem[64] + 132] = 0
                                                                    mem[mem[64] + 164] = block.timestamp
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                         gas gas_remaining wei
                                                                        args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 96
                                                                    mem[mem[64] + 32] = 0
                                                                    mem[mem[64] + 64] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                    emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                    mem[0] = this.address
                                                                    mem[32] = 2
                                                                    _4836 = mem[64]
                                                                    mem[mem[64]] = 2
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_4836 + 32 len 64] = call.data[calldata.size len 64]
                                                                    if 0 >= mem[_4836]:
                                                                        revert with 0, 50
                                                                    mem[_4836 + 32] = this.address
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                            gas gas_remaining wei
                                                                    mem[_4836 + 96] = ext_call.return_data[0]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _4836 + ceil32(return_data.size) + 96
                                                                    require return_data.size >= 32
                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                    if 1 >= mem[_4836]:
                                                                        revert with 0, 50
                                                                    mem[_4836 + 64] = ext_call.return_data[12 len 20]
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                    emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                    mem[_4836 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                    mem[_4836 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                    mem[_4836 + ceil32(return_data.size) + 132] = 0
                                                                    mem[_4836 + ceil32(return_data.size) + 164] = 160
                                                                    mem[_4836 + ceil32(return_data.size) + 260] = mem[_4836]
                                                                    idx = 0
                                                                    s = _4836 + ceil32(return_data.size) + 292
                                                                    t = _4836 + 32
                                                                    while idx < mem[_4836]:
                                                                        mem[s] = mem[t + 12 len 20]
                                                                        idx = idx + 1
                                                                        s = s + 32
                                                                        t = t + 32
                                                                        continue 
                                                                    mem[_4836 + ceil32(return_data.size) + 196] = this.address
                                                                    mem[_4836 + ceil32(return_data.size) + 228] = block.timestamp
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _4836 + ceil32(return_data.size) + (32 * mem[_4836]) + -mem[64] + 288]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            uint8(stor30.field_0) = 0
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            if stor33[address(msg.sender)]:
                                                                revert with 0, 'Blacklisted address'
                                                            if stor33[address(this.address)]:
                                                                revert with 0, 'Blacklisted address'
                                                            emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                            require ext_code.size(nodeRewardManagementAddress)
                                                            call nodeRewardManagementAddress.0x37696eec with:
                                                                 gas gas_remaining wei
                                                                args msg.sender, uint8(cd[4])
                                                        else:
                                                            if swapTokensAmount and rewardsFee > -1 / swapTokensAmount:
                                                                revert with 0, 17
                                                            if not swapTokensAmount:
                                                                revert with 0, 18
                                                            if swapTokensAmount * rewardsFee / swapTokensAmount != rewardsFee:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[ceil32(return_data.size) + 256] = 26
                                                            mem[ceil32(return_data.size) + 288] = 'SafeMath: division by zero'
                                                            if not swapTokensAmount * rewardsFee / 100:
                                                                mem[ceil32(return_data.size) + 320] = 26
                                                                mem[ceil32(return_data.size) + 352] = 'SafeMath: division by zero'
                                                                mem[ceil32(return_data.size) + 384] = 30
                                                                mem[ceil32(return_data.size) + 416] = 'SafeMath: subtraction overflow'
                                                                if 0 > swapTokensAmount * rewardsFee / 100:
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                if swapTokensAmount * rewardsFee / 100 < 0:
                                                                    revert with 0, 17
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not distributionPoolAddress:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                if stor33[address(this.address)]:
                                                                    revert with 0, 'Blacklisted address'
                                                                if stor33[stor24]:
                                                                    revert with 0, 'Blacklisted address'
                                                                emit Transfer((swapTokensAmount * rewardsFee / 100), this.address, distributionPoolAddress);
                                                                if not swapTokensAmount:
                                                                    mem[ceil32(return_data.size) + 448] = 26
                                                                    mem[ceil32(return_data.size) + 480] = 'SafeMath: division by zero'
                                                                    mem[ceil32(return_data.size) + 512] = 2
                                                                    mem[ceil32(return_data.size) + 544] = this.address
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                            gas gas_remaining wei
                                                                    mem[ceil32(return_data.size) + 608] = ext_call.return_data[0]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = (2 * ceil32(return_data.size)) + 608
                                                                    require return_data.size >= 32
                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                    mem[ceil32(return_data.size) + 576] = ext_call.return_data[12 len 20]
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                    mem[(2 * ceil32(return_data.size)) + 608] = balanceOf[address(this.address)]
                                                                    emit Approval(mem[(2 * ceil32(return_data.size)) + 608 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                    mem[(2 * ceil32(return_data.size)) + 608] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                    mem[(2 * ceil32(return_data.size)) + 612] = balanceOf[address(this.address)]
                                                                    mem[(2 * ceil32(return_data.size)) + 644] = 0
                                                                    mem[(2 * ceil32(return_data.size)) + 676] = 160
                                                                    mem[(2 * ceil32(return_data.size)) + 772] = 2
                                                                    idx = 0
                                                                    s = (2 * ceil32(return_data.size)) + 804
                                                                    t = ceil32(return_data.size) + 544
                                                                    while idx < mem[ceil32(return_data.size) + 512]:
                                                                        mem[s] = mem[t + 12 len 20]
                                                                        idx = idx + 1
                                                                        s = s + 32
                                                                        t = t + 32
                                                                        continue 
                                                                    mem[(2 * ceil32(return_data.size)) + 708] = this.address
                                                                    mem[(2 * ceil32(return_data.size)) + 740] = block.timestamp
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 864]
                                                                else:
                                                                    if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                        revert with 0, 17
                                                                    if not swapTokensAmount:
                                                                        revert with 0, 18
                                                                    if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                                    mem[ceil32(return_data.size) + 448] = 26
                                                                    mem[ceil32(return_data.size) + 480] = 'SafeMath: division by zero'
                                                                    if not swapTokensAmount * liquidityPoolFee / 100:
                                                                        mem[ceil32(return_data.size) + 512] = 2
                                                                        mem[ceil32(return_data.size) + 544] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[ceil32(return_data.size) + 608] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = (2 * ceil32(return_data.size)) + 608
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        mem[ceil32(return_data.size) + 576] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        mem[(2 * ceil32(return_data.size)) + 608] = balanceOf[address(this.address)]
                                                                        emit Approval(mem[(2 * ceil32(return_data.size)) + 608 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                        mem[(2 * ceil32(return_data.size)) + 608] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[(2 * ceil32(return_data.size)) + 612] = balanceOf[address(this.address)]
                                                                        mem[(2 * ceil32(return_data.size)) + 644] = 0
                                                                        mem[(2 * ceil32(return_data.size)) + 676] = 160
                                                                        mem[(2 * ceil32(return_data.size)) + 772] = 2
                                                                        idx = 0
                                                                        s = (2 * ceil32(return_data.size)) + 804
                                                                        t = ceil32(return_data.size) + 544
                                                                        while idx < mem[ceil32(return_data.size) + 512]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[(2 * ceil32(return_data.size)) + 708] = this.address
                                                                        mem[(2 * ceil32(return_data.size)) + 740] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                             gas gas_remaining wei
                                                                            args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 864]
                                                                    else:
                                                                        mem[ceil32(return_data.size) + 512] = 26
                                                                        mem[ceil32(return_data.size) + 544] = 'SafeMath: division by zero'
                                                                        mem[ceil32(return_data.size) + 576] = 30
                                                                        mem[ceil32(return_data.size) + 608] = 'SafeMath: subtraction overflow'
                                                                        if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                            revert with 0, 17
                                                                        mem[ceil32(return_data.size) + 640] = 2
                                                                        mem[ceil32(return_data.size) + 672] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[ceil32(return_data.size) + 736] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = (2 * ceil32(return_data.size)) + 736
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        mem[ceil32(return_data.size) + 704] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                        allowance[msg.sender][stor20].field_255 = 0
                                                                        mem[(2 * ceil32(return_data.size)) + 736] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                        emit Approval(mem[(2 * ceil32(return_data.size)) + 736 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                        mem[(2 * ceil32(return_data.size)) + 736] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[(2 * ceil32(return_data.size)) + 740] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                        mem[(2 * ceil32(return_data.size)) + 772] = 0
                                                                        mem[(2 * ceil32(return_data.size)) + 804] = 160
                                                                        mem[(2 * ceil32(return_data.size)) + 900] = 2
                                                                        idx = 0
                                                                        s = (2 * ceil32(return_data.size)) + 932
                                                                        t = ceil32(return_data.size) + 672
                                                                        while idx < mem[ceil32(return_data.size) + 640]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[(2 * ceil32(return_data.size)) + 836] = this.address
                                                                        mem[(2 * ceil32(return_data.size)) + 868] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                             gas gas_remaining wei
                                                                            args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 992]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        _4041 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_4041] = 30
                                                                        mem[_4041 + 32] = 'SafeMath: subtraction overflow'
                                                                        if eth.balance(this.address) > eth.balance(this.address):
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if eth.balance(this.address) < eth.balance(this.address):
                                                                            revert with 0, 17
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                        emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                        mem[mem[64] + 68] = 0
                                                                        mem[mem[64] + 100] = 0
                                                                        mem[mem[64] + 132] = 0
                                                                        mem[mem[64] + 164] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                             gas gas_remaining wei
                                                                            args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                                        require return_data.size >= 96
                                                                        mem[mem[64] + 32] = 0
                                                                        mem[mem[64] + 64] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                        emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                        mem[0] = this.address
                                                                        mem[32] = 2
                                                                        _4834 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_4834 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_4834]:
                                                                            revert with 0, 50
                                                                        mem[_4834 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_4834 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _4834 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_4834]:
                                                                            revert with 0, 50
                                                                        mem[_4834 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                        mem[_4834 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_4834 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                        mem[_4834 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_4834 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_4834 + ceil32(return_data.size) + 260] = mem[_4834]
                                                                        idx = 0
                                                                        s = _4834 + ceil32(return_data.size) + 292
                                                                        t = _4834 + 32
                                                                        while idx < mem[_4834]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                             gas gas_remaining wei
                                                                            args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_4834 + ceil32(return_data.size) + 260 len (32 * mem[_4834]) + 32]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                uint8(stor30.field_0) = 0
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                if stor33[address(msg.sender)]:
                                                                    revert with 0, 'Blacklisted address'
                                                                if stor33[address(this.address)]:
                                                                    revert with 0, 'Blacklisted address'
                                                                emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                require ext_code.size(nodeRewardManagementAddress)
                                                                call nodeRewardManagementAddress.0x37696eec with:
                                                                     gas gas_remaining wei
                                                                    args msg.sender, uint8(cd[4])
                                                            else:
                                                                if swapTokensAmount * rewardsFee / 100 and stor29 > -1 / swapTokensAmount * rewardsFee / 100:
                                                                    revert with 0, 17
                                                                if not swapTokensAmount * rewardsFee / 100:
                                                                    revert with 0, 18
                                                                if swapTokensAmount * rewardsFee / 100 * stor29 / swapTokensAmount * rewardsFee / 100 != stor29:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                mem[ceil32(return_data.size) + 320] = 26
                                                                mem[ceil32(return_data.size) + 352] = 'SafeMath: division by zero'
                                                                if not swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                    mem[ceil32(return_data.size) + 384] = 30
                                                                    mem[ceil32(return_data.size) + 416] = 'SafeMath: subtraction overflow'
                                                                    if swapTokensAmount * rewardsFee / 100 * stor29 / 100 > swapTokensAmount * rewardsFee / 100:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if swapTokensAmount * rewardsFee / 100 < swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                        revert with 0, 17
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not distributionPoolAddress:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    if stor33[address(this.address)]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    if stor33[stor24]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    emit Transfer(((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)), this.address, distributionPoolAddress);
                                                                    if not swapTokensAmount:
                                                                        mem[ceil32(return_data.size) + 448] = 26
                                                                        mem[ceil32(return_data.size) + 480] = 'SafeMath: division by zero'
                                                                        mem[ceil32(return_data.size) + 512] = 2
                                                                        mem[ceil32(return_data.size) + 544] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[ceil32(return_data.size) + 608] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = (2 * ceil32(return_data.size)) + 608
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        mem[ceil32(return_data.size) + 576] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        mem[(2 * ceil32(return_data.size)) + 608] = balanceOf[address(this.address)]
                                                                        emit Approval(mem[(2 * ceil32(return_data.size)) + 608 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                        mem[(2 * ceil32(return_data.size)) + 608] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[(2 * ceil32(return_data.size)) + 612] = balanceOf[address(this.address)]
                                                                        mem[(2 * ceil32(return_data.size)) + 644] = 0
                                                                        mem[(2 * ceil32(return_data.size)) + 676] = 160
                                                                        mem[(2 * ceil32(return_data.size)) + 772] = 2
                                                                        idx = 0
                                                                        s = (2 * ceil32(return_data.size)) + 804
                                                                        t = ceil32(return_data.size) + 544
                                                                        while idx < mem[ceil32(return_data.size) + 512]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[(2 * ceil32(return_data.size)) + 708] = this.address
                                                                        mem[(2 * ceil32(return_data.size)) + 740] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                             gas gas_remaining wei
                                                                            args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 864]
                                                                    else:
                                                                        if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                            revert with 0, 17
                                                                        if not swapTokensAmount:
                                                                            revert with 0, 18
                                                                        if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                                        mem[ceil32(return_data.size) + 448] = 26
                                                                        mem[ceil32(return_data.size) + 480] = 'SafeMath: division by zero'
                                                                        if not swapTokensAmount * liquidityPoolFee / 100:
                                                                            mem[ceil32(return_data.size) + 512] = 2
                                                                            mem[ceil32(return_data.size) + 544] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[ceil32(return_data.size) + 608] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = (2 * ceil32(return_data.size)) + 608
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            mem[ceil32(return_data.size) + 576] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            mem[(2 * ceil32(return_data.size)) + 608] = balanceOf[address(this.address)]
                                                                            emit Approval(mem[(2 * ceil32(return_data.size)) + 608 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                            mem[(2 * ceil32(return_data.size)) + 608] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[(2 * ceil32(return_data.size)) + 612] = balanceOf[address(this.address)]
                                                                            mem[(2 * ceil32(return_data.size)) + 644] = 0
                                                                            mem[(2 * ceil32(return_data.size)) + 676] = 160
                                                                            mem[(2 * ceil32(return_data.size)) + 772] = 2
                                                                            idx = 0
                                                                            s = (2 * ceil32(return_data.size)) + 804
                                                                            t = ceil32(return_data.size) + 544
                                                                            while idx < mem[ceil32(return_data.size) + 512]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            mem[(2 * ceil32(return_data.size)) + 708] = this.address
                                                                            mem[(2 * ceil32(return_data.size)) + 740] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                 gas gas_remaining wei
                                                                                args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 864]
                                                                        else:
                                                                            mem[ceil32(return_data.size) + 512] = 26
                                                                            mem[ceil32(return_data.size) + 544] = 'SafeMath: division by zero'
                                                                            mem[ceil32(return_data.size) + 576] = 30
                                                                            mem[ceil32(return_data.size) + 608] = 'SafeMath: subtraction overflow'
                                                                            if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                revert with 0, 17
                                                                            mem[ceil32(return_data.size) + 640] = 2
                                                                            mem[ceil32(return_data.size) + 672] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[ceil32(return_data.size) + 736] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = (2 * ceil32(return_data.size)) + 736
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            mem[ceil32(return_data.size) + 704] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                            allowance[msg.sender][stor20].field_255 = 0
                                                                            mem[(2 * ceil32(return_data.size)) + 736] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                            emit Approval(mem[(2 * ceil32(return_data.size)) + 736 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                            mem[(2 * ceil32(return_data.size)) + 736] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[(2 * ceil32(return_data.size)) + 740] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                            mem[(2 * ceil32(return_data.size)) + 772] = 0
                                                                            mem[(2 * ceil32(return_data.size)) + 804] = 160
                                                                            mem[(2 * ceil32(return_data.size)) + 900] = 2
                                                                            idx = 0
                                                                            s = (2 * ceil32(return_data.size)) + 932
                                                                            t = ceil32(return_data.size) + 672
                                                                            while idx < mem[ceil32(return_data.size) + 640]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            mem[(2 * ceil32(return_data.size)) + 836] = this.address
                                                                            mem[(2 * ceil32(return_data.size)) + 868] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                 gas gas_remaining wei
                                                                                args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 992]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            _4039 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_4039] = 30
                                                                            mem[_4039 + 32] = 'SafeMath: subtraction overflow'
                                                                            if eth.balance(this.address) > eth.balance(this.address):
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if eth.balance(this.address) < eth.balance(this.address):
                                                                                revert with 0, 17
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                            emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                            mem[mem[64] + 68] = 0
                                                                            mem[mem[64] + 100] = 0
                                                                            mem[mem[64] + 132] = 0
                                                                            mem[mem[64] + 164] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                 gas gas_remaining wei
                                                                                args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                                            require return_data.size >= 96
                                                                            mem[mem[64] + 32] = 0
                                                                            mem[mem[64] + 64] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                            emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                            mem[0] = this.address
                                                                            mem[32] = 2
                                                                            _4828 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_4828 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_4828]:
                                                                                revert with 0, 50
                                                                            mem[_4828 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_4828 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _4828 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_4828]:
                                                                                revert with 0, 50
                                                                            mem[_4828 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_4828 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_4828 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                            mem[_4828 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_4828 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_4828 + ceil32(return_data.size) + 260] = mem[_4828]
                                                                            idx = 0
                                                                            s = _4828 + ceil32(return_data.size) + 292
                                                                            t = _4828 + 32
                                                                            while idx < mem[_4828]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            mem[_4828 + ceil32(return_data.size) + 196] = this.address
                                                                            mem[_4828 + ceil32(return_data.size) + 228] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                 gas gas_remaining wei
                                                                                args mem[mem[64] + 4 len _4828 + ceil32(return_data.size) + (32 * mem[_4828]) + -mem[64] + 288]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    uint8(stor30.field_0) = 0
                                                                    if not msg.sender:
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    if stor33[address(msg.sender)]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    if stor33[address(this.address)]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                    require ext_code.size(nodeRewardManagementAddress)
                                                                    call nodeRewardManagementAddress.0x37696eec with:
                                                                         gas gas_remaining wei
                                                                        args msg.sender, uint8(cd[4])
                                                                else:
                                                                    mem[ceil32(return_data.size) + 384] = 2
                                                                    mem[ceil32(return_data.size) + 416] = this.address
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                            gas gas_remaining wei
                                                                    mem[ceil32(return_data.size) + 480] = ext_call.return_data[0]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = (2 * ceil32(return_data.size)) + 480
                                                                    require return_data.size >= 32
                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                    mem[ceil32(return_data.size) + 448] = ext_call.return_data[12 len 20]
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = swapTokensAmount * rewardsFee / 100 * stor29 / 100
                                                                    mem[(2 * ceil32(return_data.size)) + 480] = swapTokensAmount * rewardsFee / 100 * stor29 / 100
                                                                    emit Approval(mem[(2 * ceil32(return_data.size)) + 480 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                    mem[(2 * ceil32(return_data.size)) + 480] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                    mem[(2 * ceil32(return_data.size)) + 484] = swapTokensAmount * rewardsFee / 100 * stor29 / 100
                                                                    mem[(2 * ceil32(return_data.size)) + 516] = 0
                                                                    mem[(2 * ceil32(return_data.size)) + 548] = 160
                                                                    mem[(2 * ceil32(return_data.size)) + 644] = 2
                                                                    idx = 0
                                                                    s = (2 * ceil32(return_data.size)) + 676
                                                                    t = ceil32(return_data.size) + 416
                                                                    while idx < mem[ceil32(return_data.size) + 384]:
                                                                        mem[s] = mem[t + 12 len 20]
                                                                        idx = idx + 1
                                                                        s = s + 32
                                                                        t = t + 32
                                                                        continue 
                                                                    mem[(2 * ceil32(return_data.size)) + 580] = this.address
                                                                    mem[(2 * ceil32(return_data.size)) + 612] = block.timestamp
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 736]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _4040 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_4040] = 30
                                                                    mem[_4040 + 32] = 'SafeMath: subtraction overflow'
                                                                    if eth.balance(this.address) > eth.balance(this.address):
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if eth.balance(this.address) < eth.balance(this.address):
                                                                        revert with 0, 17
                                                                    call distributionPoolAddress with:
                                                                         gas 30000 wei
                                                                    if not return_data.size:
                                                                        _4576 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_4576] = 30
                                                                        mem[_4576 + 32] = 'SafeMath: subtraction overflow'
                                                                        if swapTokensAmount * rewardsFee / 100 * stor29 / 100 > swapTokensAmount * rewardsFee / 100:
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if swapTokensAmount * rewardsFee / 100 < swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                            revert with 0, 17
                                                                        if not this.address:
                                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                                        if not distributionPoolAddress:
                                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                                        if stor33[address(this.address)]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        mem[0] = distributionPoolAddress
                                                                        mem[32] = 33
                                                                        if stor33[stor24]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        emit Transfer(((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)), this.address, distributionPoolAddress);
                                                                        if not swapTokensAmount:
                                                                            _5007 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_5007] = 26
                                                                            mem[_5007 + 32] = 'SafeMath: division by zero'
                                                                            mem[0] = this.address
                                                                            mem[32] = 2
                                                                            _5186 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_5186 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_5186]:
                                                                                revert with 0, 50
                                                                            mem[_5186 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_5186 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _5186 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_5186]:
                                                                                revert with 0, 50
                                                                            mem[_5186 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_5186 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_5186 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                            mem[_5186 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_5186 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_5186 + ceil32(return_data.size) + 260] = mem[_5186]
                                                                            idx = 0
                                                                            s = _5186 + ceil32(return_data.size) + 292
                                                                            t = _5186 + 32
                                                                            while idx < mem[_5186]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                 gas gas_remaining wei
                                                                                args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_5186 + ceil32(return_data.size) + 260 len (32 * mem[_5186]) + 32]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            uint8(stor30.field_0) = 0
                                                                            if not msg.sender:
                                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                                            if not this.address:
                                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                                            if stor33[address(msg.sender)]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            if stor33[address(this.address)]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                            require ext_code.size(nodeRewardManagementAddress)
                                                                            call nodeRewardManagementAddress.0x37696eec with:
                                                                                 gas gas_remaining wei
                                                                                args msg.sender, uint8(cd[4])
                                                                        else:
                                                                            if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                                revert with 0, 17
                                                                            if not swapTokensAmount:
                                                                                revert with 0, 18
                                                                            if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                                            _5127 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_5127] = 26
                                                                            mem[_5127 + 32] = 'SafeMath: division by zero'
                                                                            if not swapTokensAmount * liquidityPoolFee / 100:
                                                                                mem[0] = this.address
                                                                                mem[32] = 2
                                                                                _5308 = mem[64]
                                                                                mem[mem[64]] = 2
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_5308 + 32 len 64] = call.data[calldata.size len 64]
                                                                                if 0 >= mem[_5308]:
                                                                                    revert with 0, 50
                                                                                mem[_5308 + 32] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_5308 + 96] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _5308 + ceil32(return_data.size) + 96
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                if 1 >= mem[_5308]:
                                                                                    revert with 0, 50
                                                                                mem[_5308 + 64] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                mem[_5308 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_5308 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                                mem[_5308 + ceil32(return_data.size) + 132] = 0
                                                                                mem[_5308 + ceil32(return_data.size) + 164] = 160
                                                                                mem[_5308 + ceil32(return_data.size) + 260] = mem[_5308]
                                                                                idx = 0
                                                                                s = _5308 + ceil32(return_data.size) + 292
                                                                                t = _5308 + 32
                                                                                while idx < mem[_5308]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                     gas gas_remaining wei
                                                                                    args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_5308 + ceil32(return_data.size) + 260 len (32 * mem[_5308]) + 32]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                uint8(stor30.field_0) = 0
                                                                                if not msg.sender:
                                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                                if not this.address:
                                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                                if stor33[address(msg.sender)]:
                                                                                    revert with 0, 'Blacklisted address'
                                                                                if stor33[address(this.address)]:
                                                                                    revert with 0, 'Blacklisted address'
                                                                                emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                                require ext_code.size(nodeRewardManagementAddress)
                                                                                call nodeRewardManagementAddress.0x37696eec with:
                                                                                     gas gas_remaining wei
                                                                                    args msg.sender, uint8(cd[4])
                                                                            else:
                                                                                _5253 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_5253] = 26
                                                                                mem[_5253 + 32] = 'SafeMath: division by zero'
                                                                                _5518 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_5518] = 30
                                                                                mem[_5518 + 32] = 'SafeMath: subtraction overflow'
                                                                                if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                    revert with 0, 17
                                                                                _5653 = mem[64]
                                                                                mem[mem[64]] = 2
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_5653 + 32 len 64] = call.data[calldata.size len 64]
                                                                                if 0 >= mem[_5653]:
                                                                                    revert with 0, 50
                                                                                mem[_5653 + 32] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_5653 + 96] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _5653 + ceil32(return_data.size) + 96
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                if 1 >= mem[_5653]:
                                                                                    revert with 0, 50
                                                                                mem[_5653 + 64] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                allowance[msg.sender][stor20].field_255 = 0
                                                                                emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                                mem[_5653 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_5653 + ceil32(return_data.size) + 100] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                mem[_5653 + ceil32(return_data.size) + 132] = 0
                                                                                mem[_5653 + ceil32(return_data.size) + 164] = 160
                                                                                mem[_5653 + ceil32(return_data.size) + 260] = mem[_5653]
                                                                                idx = 0
                                                                                s = _5653 + ceil32(return_data.size) + 292
                                                                                t = _5653 + 32
                                                                                while idx < mem[_5653]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                     gas gas_remaining wei
                                                                                    args Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_5653 + ceil32(return_data.size) + 260 len (32 * mem[_5653]) + 32]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[_5653 + ceil32(return_data.size) + 96] = 30
                                                                                mem[_5653 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                                                                if eth.balance(this.address) > eth.balance(this.address):
                                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                if eth.balance(this.address) < eth.balance(this.address):
                                                                                    revert with 0, 17
                                                                                allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                                mem[_5653 + ceil32(return_data.size) + 228] = 0
                                                                                mem[_5653 + ceil32(return_data.size) + 260] = 0
                                                                                mem[_5653 + ceil32(return_data.size) + 292] = 0
                                                                                mem[_5653 + ceil32(return_data.size) + 324] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                     gas gas_remaining wei
                                                                                    args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                                mem[_5653 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                require return_data.size >= 96
                                                                                emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                                mem[_5653 + (2 * ceil32(return_data.size)) + 160] = 2
                                                                                mem[_5653 + (2 * ceil32(return_data.size)) + 192] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_5653 + (2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _5653 + (4 * ceil32(return_data.size)) + 256
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                mem[_5653 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                mem[_5653 + (4 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_5653 + (4 * ceil32(return_data.size)) + 260] = balanceOf[address(this.address)]
                                                                                mem[_5653 + (4 * ceil32(return_data.size)) + 292] = 0
                                                                                mem[_5653 + (4 * ceil32(return_data.size)) + 324] = 160
                                                                                mem[_5653 + (4 * ceil32(return_data.size)) + 420] = 2
                                                                                idx = 0
                                                                                s = _5653 + (4 * ceil32(return_data.size)) + 452
                                                                                t = _5653 + (2 * ceil32(return_data.size)) + 192
                                                                                while idx < mem[_5653 + (2 * ceil32(return_data.size)) + 160]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                mem[_5653 + (4 * ceil32(return_data.size)) + 356] = this.address
                                                                                mem[_5653 + (4 * ceil32(return_data.size)) + 388] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                     gas gas_remaining wei
                                                                                    args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_5653 + (4 * ceil32(return_data.size)) + 420 len (32 * mem[_5653 + (2 * ceil32(return_data.size)) + 160]) + 32]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                uint8(stor30.field_0) = 0
                                                                                if not msg.sender:
                                                                                    mem[_5653 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[_5653 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                                    mem[_5653 + (4 * ceil32(return_data.size)) + 292] = 37
                                                                                    mem[_5653 + (4 * ceil32(return_data.size)) + 324] = 'ERC20: transfer from the zero ad'
                                                                                    mem[_5653 + (4 * ceil32(return_data.size)) + 356] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                                    revert with memory
                                                                                      from _5653 + (4 * ceil32(return_data.size)) + 256
                                                                                       len (5 * ceil32(return_data.size)) + 132
                                                                                if not this.address:
                                                                                    mem[_5653 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[_5653 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                                    mem[_5653 + (4 * ceil32(return_data.size)) + 292] = 35
                                                                                    mem[_5653 + (4 * ceil32(return_data.size)) + 324] = 'ERC20: transfer to the zero addr'
                                                                                    mem[_5653 + (4 * ceil32(return_data.size)) + 356] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                                    revert with memory
                                                                                      from _5653 + (4 * ceil32(return_data.size)) + 256
                                                                                       len (5 * ceil32(return_data.size)) + 132
                                                                                if stor33[address(msg.sender)]:
                                                                                    mem[_5653 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[_5653 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                                    mem[_5653 + (4 * ceil32(return_data.size)) + 292] = 19
                                                                                    mem[_5653 + (4 * ceil32(return_data.size)) + 324] = 'Blacklisted address' << 104
                                                                                    revert with memory
                                                                                      from _5653 + (4 * ceil32(return_data.size)) + 256
                                                                                       len (5 * ceil32(return_data.size)) + 100
                                                                                if stor33[address(this.address)]:
                                                                                    mem[_5653 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[_5653 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                                    mem[_5653 + (4 * ceil32(return_data.size)) + 292] = 19
                                                                                    mem[_5653 + (4 * ceil32(return_data.size)) + 324] = 'Blacklisted address' << 104
                                                                                    revert with memory
                                                                                      from _5653 + (4 * ceil32(return_data.size)) + 256
                                                                                       len (5 * ceil32(return_data.size)) + 100
                                                                                emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                                mem[_5653 + (4 * ceil32(return_data.size)) + 260] = msg.sender
                                                                                mem[_5653 + (4 * ceil32(return_data.size)) + 292] = uint8(cd[4])
                                                                                require ext_code.size(nodeRewardManagementAddress)
                                                                                call nodeRewardManagementAddress.0x37696eec with:
                                                                                     gas gas_remaining wei
                                                                                    args mem[_5653 + (4 * ceil32(return_data.size)) + 260 len (5 * ceil32(return_data.size)) + 64]
                                                                    else:
                                                                        _4455 = mem[64]
                                                                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                                                                        mem[_4455] = return_data.size
                                                                        mem[_4455 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                        _4577 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_4577] = 30
                                                                        mem[_4577 + 32] = 'SafeMath: subtraction overflow'
                                                                        if swapTokensAmount * rewardsFee / 100 * stor29 / 100 > swapTokensAmount * rewardsFee / 100:
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if swapTokensAmount * rewardsFee / 100 < swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                            revert with 0, 17
                                                                        if not this.address:
                                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                                        if not distributionPoolAddress:
                                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                                        if stor33[address(this.address)]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        mem[0] = distributionPoolAddress
                                                                        mem[32] = 33
                                                                        if stor33[stor24]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        emit Transfer(((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)), this.address, distributionPoolAddress);
                                                                        if not swapTokensAmount:
                                                                            _5008 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_5008] = 26
                                                                            mem[_5008 + 32] = 'SafeMath: division by zero'
                                                                            mem[0] = this.address
                                                                            mem[32] = 2
                                                                            _5188 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_5188 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_5188]:
                                                                                revert with 0, 50
                                                                            mem[_5188 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_5188 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _5188 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_5188]:
                                                                                revert with 0, 50
                                                                            mem[_5188 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_5188 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_5188 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                            mem[_5188 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_5188 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_5188 + ceil32(return_data.size) + 260] = mem[_5188]
                                                                            idx = 0
                                                                            s = _5188 + ceil32(return_data.size) + 292
                                                                            t = _5188 + 32
                                                                            while idx < mem[_5188]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            mem[_5188 + ceil32(return_data.size) + 196] = this.address
                                                                            mem[_5188 + ceil32(return_data.size) + 228] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                 gas gas_remaining wei
                                                                                args mem[mem[64] + 4 len _5188 + ceil32(return_data.size) + (32 * mem[_5188]) + -mem[64] + 288]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            uint8(stor30.field_0) = 0
                                                                            if not msg.sender:
                                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                                            if not this.address:
                                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                                            if stor33[address(msg.sender)]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            if stor33[address(this.address)]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                            require ext_code.size(nodeRewardManagementAddress)
                                                                            call nodeRewardManagementAddress.0x37696eec with:
                                                                                 gas gas_remaining wei
                                                                                args msg.sender, uint8(cd[4])
                                                                        else:
                                                                            if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                                revert with 0, 17
                                                                            if not swapTokensAmount:
                                                                                revert with 0, 18
                                                                            if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                                            _5128 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_5128] = 26
                                                                            mem[_5128 + 32] = 'SafeMath: division by zero'
                                                                            if not swapTokensAmount * liquidityPoolFee / 100:
                                                                                mem[0] = this.address
                                                                                mem[32] = 2
                                                                                _5310 = mem[64]
                                                                                mem[mem[64]] = 2
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_5310 + 32 len 64] = call.data[calldata.size len 64]
                                                                                if 0 >= mem[_5310]:
                                                                                    revert with 0, 50
                                                                                mem[_5310 + 32] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_5310 + 96] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _5310 + ceil32(return_data.size) + 96
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                if 1 >= mem[_5310]:
                                                                                    revert with 0, 50
                                                                                mem[_5310 + 64] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                mem[_5310 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_5310 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                                mem[_5310 + ceil32(return_data.size) + 132] = 0
                                                                                mem[_5310 + ceil32(return_data.size) + 164] = 160
                                                                                mem[_5310 + ceil32(return_data.size) + 260] = mem[_5310]
                                                                                idx = 0
                                                                                s = _5310 + ceil32(return_data.size) + 292
                                                                                t = _5310 + 32
                                                                                while idx < mem[_5310]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                mem[_5310 + ceil32(return_data.size) + 196] = this.address
                                                                                mem[_5310 + ceil32(return_data.size) + 228] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                     gas gas_remaining wei
                                                                                    args mem[mem[64] + 4 len _5310 + ceil32(return_data.size) + (32 * mem[_5310]) + -mem[64] + 288]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                uint8(stor30.field_0) = 0
                                                                                if not msg.sender:
                                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                                if not this.address:
                                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                                if stor33[address(msg.sender)]:
                                                                                    revert with 0, 'Blacklisted address'
                                                                                if stor33[address(this.address)]:
                                                                                    revert with 0, 'Blacklisted address'
                                                                                emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                                require ext_code.size(nodeRewardManagementAddress)
                                                                                call nodeRewardManagementAddress.0x37696eec with:
                                                                                     gas gas_remaining wei
                                                                                    args msg.sender, uint8(cd[4])
                                                                            else:
                                                                                _5255 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_5255] = 26
                                                                                mem[_5255 + 32] = 'SafeMath: division by zero'
                                                                                _5519 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_5519] = 30
                                                                                mem[_5519 + 32] = 'SafeMath: subtraction overflow'
                                                                                if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                    revert with 0, 17
                                                                                _5657 = mem[64]
                                                                                mem[mem[64]] = 2
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_5657 + 32 len 64] = call.data[calldata.size len 64]
                                                                                if 0 >= mem[_5657]:
                                                                                    revert with 0, 50
                                                                                mem[_5657 + 32] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_5657 + 96] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _5657 + ceil32(return_data.size) + 96
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                if 1 >= mem[_5657]:
                                                                                    revert with 0, 50
                                                                                mem[_5657 + 64] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                allowance[msg.sender][stor20].field_255 = 0
                                                                                emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                                mem[_5657 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_5657 + ceil32(return_data.size) + 100] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                mem[_5657 + ceil32(return_data.size) + 132] = 0
                                                                                mem[_5657 + ceil32(return_data.size) + 164] = 160
                                                                                mem[_5657 + ceil32(return_data.size) + 260] = mem[_5657]
                                                                                idx = 0
                                                                                s = _5657 + ceil32(return_data.size) + 292
                                                                                t = _5657 + 32
                                                                                while idx < mem[_5657]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                     gas gas_remaining wei
                                                                                    args Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_5657 + ceil32(return_data.size) + 260 len (32 * mem[_5657]) + 32]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[_5657 + ceil32(return_data.size) + 96] = 30
                                                                                mem[_5657 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                                                                if eth.balance(this.address) > eth.balance(this.address):
                                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                if eth.balance(this.address) < eth.balance(this.address):
                                                                                    revert with 0, 17
                                                                                allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                                mem[_5657 + ceil32(return_data.size) + 228] = 0
                                                                                mem[_5657 + ceil32(return_data.size) + 260] = 0
                                                                                mem[_5657 + ceil32(return_data.size) + 292] = 0
                                                                                mem[_5657 + ceil32(return_data.size) + 324] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                     gas gas_remaining wei
                                                                                    args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                                mem[_5657 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                require return_data.size >= 96
                                                                                emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                                mem[_5657 + (2 * ceil32(return_data.size)) + 160] = 2
                                                                                mem[_5657 + (2 * ceil32(return_data.size)) + 192] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_5657 + (2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _5657 + (4 * ceil32(return_data.size)) + 256
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                mem[_5657 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                mem[_5657 + (4 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_5657 + (4 * ceil32(return_data.size)) + 260] = balanceOf[address(this.address)]
                                                                                mem[_5657 + (4 * ceil32(return_data.size)) + 292] = 0
                                                                                mem[_5657 + (4 * ceil32(return_data.size)) + 324] = 160
                                                                                mem[_5657 + (4 * ceil32(return_data.size)) + 420] = 2
                                                                                idx = 0
                                                                                s = _5657 + (4 * ceil32(return_data.size)) + 452
                                                                                t = _5657 + (2 * ceil32(return_data.size)) + 192
                                                                                while idx < mem[_5657 + (2 * ceil32(return_data.size)) + 160]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                mem[_5657 + (4 * ceil32(return_data.size)) + 356] = this.address
                                                                                mem[_5657 + (4 * ceil32(return_data.size)) + 388] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                     gas gas_remaining wei
                                                                                    args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_5657 + (4 * ceil32(return_data.size)) + 420 len (32 * mem[_5657 + (2 * ceil32(return_data.size)) + 160]) + 32]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                uint8(stor30.field_0) = 0
                                                                                if not msg.sender:
                                                                                    mem[_5657 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[_5657 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                                    mem[_5657 + (4 * ceil32(return_data.size)) + 292] = 37
                                                                                    mem[_5657 + (4 * ceil32(return_data.size)) + 324] = 'ERC20: transfer from the zero ad'
                                                                                    mem[_5657 + (4 * ceil32(return_data.size)) + 356] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                                    revert with memory
                                                                                      from _5657 + (4 * ceil32(return_data.size)) + 256
                                                                                       len (5 * ceil32(return_data.size)) + 132
                                                                                if not this.address:
                                                                                    mem[_5657 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[_5657 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                                    mem[_5657 + (4 * ceil32(return_data.size)) + 292] = 35
                                                                                    mem[_5657 + (4 * ceil32(return_data.size)) + 324] = 'ERC20: transfer to the zero addr'
                                                                                    mem[_5657 + (4 * ceil32(return_data.size)) + 356] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                                    revert with memory
                                                                                      from _5657 + (4 * ceil32(return_data.size)) + 256
                                                                                       len (5 * ceil32(return_data.size)) + 132
                                                                                if stor33[address(msg.sender)]:
                                                                                    mem[_5657 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[_5657 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                                    mem[_5657 + (4 * ceil32(return_data.size)) + 292] = 19
                                                                                    mem[_5657 + (4 * ceil32(return_data.size)) + 324] = 'Blacklisted address' << 104
                                                                                    revert with memory
                                                                                      from _5657 + (4 * ceil32(return_data.size)) + 256
                                                                                       len (5 * ceil32(return_data.size)) + 100
                                                                                if stor33[address(this.address)]:
                                                                                    mem[_5657 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[_5657 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                                    mem[_5657 + (4 * ceil32(return_data.size)) + 292] = 19
                                                                                    mem[_5657 + (4 * ceil32(return_data.size)) + 324] = 'Blacklisted address' << 104
                                                                                    revert with memory
                                                                                      from _5657 + (4 * ceil32(return_data.size)) + 256
                                                                                       len (5 * ceil32(return_data.size)) + 100
                                                                                emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                                mem[_5657 + (4 * ceil32(return_data.size)) + 260] = msg.sender
                                                                                mem[_5657 + (4 * ceil32(return_data.size)) + 292] = uint8(cd[4])
                                                                                require ext_code.size(nodeRewardManagementAddress)
                                                                                call nodeRewardManagementAddress.0x37696eec with:
                                                                                     gas gas_remaining wei
                                                                                    args mem[_5657 + (4 * ceil32(return_data.size)) + 260 len (5 * ceil32(return_data.size)) + 64]
                                                    else:
                                                        mem[ceil32(return_data.size) + 192] = 26
                                                        mem[ceil32(return_data.size) + 224] = 'SafeMath: division by zero'
                                                        if not this.address:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not deadWalletAddress:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        if stor33[address(this.address)]:
                                                            revert with 0, 'Blacklisted address'
                                                        if stor33[stor7]:
                                                            revert with 0, 'Blacklisted address'
                                                        emit Transfer(0, this.address, deadWalletAddress);
                                                        if not swapTokensAmount:
                                                            mem[ceil32(return_data.size) + 256] = 26
                                                            mem[ceil32(return_data.size) + 288] = 'SafeMath: division by zero'
                                                            mem[ceil32(return_data.size) + 320] = 26
                                                            mem[ceil32(return_data.size) + 352] = 'SafeMath: division by zero'
                                                            mem[ceil32(return_data.size) + 384] = 30
                                                            mem[ceil32(return_data.size) + 416] = 'SafeMath: subtraction overflow'
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not distributionPoolAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            if stor33[address(this.address)]:
                                                                revert with 0, 'Blacklisted address'
                                                            if stor33[stor24]:
                                                                revert with 0, 'Blacklisted address'
                                                            emit Transfer(0, this.address, distributionPoolAddress);
                                                            if not swapTokensAmount:
                                                                mem[ceil32(return_data.size) + 448] = 26
                                                                mem[ceil32(return_data.size) + 480] = 'SafeMath: division by zero'
                                                                mem[ceil32(return_data.size) + 512] = 2
                                                                mem[ceil32(return_data.size) + 544] = this.address
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                        gas gas_remaining wei
                                                                mem[ceil32(return_data.size) + 608] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                mem[64] = (2 * ceil32(return_data.size)) + 608
                                                                require return_data.size >= 32
                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                mem[ceil32(return_data.size) + 576] = ext_call.return_data[12 len 20]
                                                                mem[0] = uniV2RouterAddress
                                                                mem[32] = sha3(msg.sender, 3)
                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                mem[(2 * ceil32(return_data.size)) + 608] = balanceOf[address(this.address)]
                                                                emit Approval(mem[(2 * ceil32(return_data.size)) + 608 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                mem[(2 * ceil32(return_data.size)) + 608] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                mem[(2 * ceil32(return_data.size)) + 612] = balanceOf[address(this.address)]
                                                                mem[(2 * ceil32(return_data.size)) + 644] = 0
                                                                mem[(2 * ceil32(return_data.size)) + 676] = 160
                                                                mem[(2 * ceil32(return_data.size)) + 772] = 2
                                                                idx = 0
                                                                s = (2 * ceil32(return_data.size)) + 804
                                                                t = ceil32(return_data.size) + 544
                                                                while idx < mem[ceil32(return_data.size) + 512]:
                                                                    mem[s] = mem[t + 12 len 20]
                                                                    idx = idx + 1
                                                                    s = s + 32
                                                                    t = t + 32
                                                                    continue 
                                                                mem[(2 * ceil32(return_data.size)) + 708] = this.address
                                                                mem[(2 * ceil32(return_data.size)) + 740] = block.timestamp
                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                     gas gas_remaining wei
                                                                    args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 864]
                                                            else:
                                                                if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                    revert with 0, 17
                                                                if not swapTokensAmount:
                                                                    revert with 0, 18
                                                                if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                mem[ceil32(return_data.size) + 448] = 26
                                                                mem[ceil32(return_data.size) + 480] = 'SafeMath: division by zero'
                                                                if not swapTokensAmount * liquidityPoolFee / 100:
                                                                    mem[ceil32(return_data.size) + 512] = 2
                                                                    mem[ceil32(return_data.size) + 544] = this.address
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                            gas gas_remaining wei
                                                                    mem[ceil32(return_data.size) + 608] = ext_call.return_data[0]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = (2 * ceil32(return_data.size)) + 608
                                                                    require return_data.size >= 32
                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                    mem[ceil32(return_data.size) + 576] = ext_call.return_data[12 len 20]
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                    mem[(2 * ceil32(return_data.size)) + 608] = balanceOf[address(this.address)]
                                                                    emit Approval(mem[(2 * ceil32(return_data.size)) + 608 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                    mem[(2 * ceil32(return_data.size)) + 608] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                    mem[(2 * ceil32(return_data.size)) + 612] = balanceOf[address(this.address)]
                                                                    mem[(2 * ceil32(return_data.size)) + 644] = 0
                                                                    mem[(2 * ceil32(return_data.size)) + 676] = 160
                                                                    mem[(2 * ceil32(return_data.size)) + 772] = 2
                                                                    idx = 0
                                                                    s = (2 * ceil32(return_data.size)) + 804
                                                                    t = ceil32(return_data.size) + 544
                                                                    while idx < mem[ceil32(return_data.size) + 512]:
                                                                        mem[s] = mem[t + 12 len 20]
                                                                        idx = idx + 1
                                                                        s = s + 32
                                                                        t = t + 32
                                                                        continue 
                                                                    mem[(2 * ceil32(return_data.size)) + 708] = this.address
                                                                    mem[(2 * ceil32(return_data.size)) + 740] = block.timestamp
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 864]
                                                                else:
                                                                    mem[ceil32(return_data.size) + 512] = 26
                                                                    mem[ceil32(return_data.size) + 544] = 'SafeMath: division by zero'
                                                                    mem[ceil32(return_data.size) + 576] = 30
                                                                    mem[ceil32(return_data.size) + 608] = 'SafeMath: subtraction overflow'
                                                                    if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                        revert with 0, 17
                                                                    mem[ceil32(return_data.size) + 640] = 2
                                                                    mem[ceil32(return_data.size) + 672] = this.address
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                            gas gas_remaining wei
                                                                    mem[ceil32(return_data.size) + 736] = ext_call.return_data[0]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = (2 * ceil32(return_data.size)) + 736
                                                                    require return_data.size >= 32
                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                    mem[ceil32(return_data.size) + 704] = ext_call.return_data[12 len 20]
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                    allowance[msg.sender][stor20].field_255 = 0
                                                                    mem[(2 * ceil32(return_data.size)) + 736] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                    emit Approval(mem[(2 * ceil32(return_data.size)) + 736 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                    mem[(2 * ceil32(return_data.size)) + 736] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                    mem[(2 * ceil32(return_data.size)) + 740] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                    mem[(2 * ceil32(return_data.size)) + 772] = 0
                                                                    mem[(2 * ceil32(return_data.size)) + 804] = 160
                                                                    mem[(2 * ceil32(return_data.size)) + 900] = 2
                                                                    idx = 0
                                                                    s = (2 * ceil32(return_data.size)) + 932
                                                                    t = ceil32(return_data.size) + 672
                                                                    while idx < mem[ceil32(return_data.size) + 640]:
                                                                        mem[s] = mem[t + 12 len 20]
                                                                        idx = idx + 1
                                                                        s = s + 32
                                                                        t = t + 32
                                                                        continue 
                                                                    mem[(2 * ceil32(return_data.size)) + 836] = this.address
                                                                    mem[(2 * ceil32(return_data.size)) + 868] = block.timestamp
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 992]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _4046 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_4046] = 30
                                                                    mem[_4046 + 32] = 'SafeMath: subtraction overflow'
                                                                    if eth.balance(this.address) > eth.balance(this.address):
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if eth.balance(this.address) < eth.balance(this.address):
                                                                        revert with 0, 17
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                    emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                    mem[mem[64] + 68] = 0
                                                                    mem[mem[64] + 100] = 0
                                                                    mem[mem[64] + 132] = 0
                                                                    mem[mem[64] + 164] = block.timestamp
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                         gas gas_remaining wei
                                                                        args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 96
                                                                    mem[mem[64] + 32] = 0
                                                                    mem[mem[64] + 64] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                    emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                    mem[0] = this.address
                                                                    mem[32] = 2
                                                                    _4846 = mem[64]
                                                                    mem[mem[64]] = 2
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_4846 + 32 len 64] = call.data[calldata.size len 64]
                                                                    if 0 >= mem[_4846]:
                                                                        revert with 0, 50
                                                                    mem[_4846 + 32] = this.address
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                            gas gas_remaining wei
                                                                    mem[_4846 + 96] = ext_call.return_data[0]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _4846 + ceil32(return_data.size) + 96
                                                                    require return_data.size >= 32
                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                    if 1 >= mem[_4846]:
                                                                        revert with 0, 50
                                                                    mem[_4846 + 64] = ext_call.return_data[12 len 20]
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                    emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                    mem[_4846 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                    mem[_4846 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                    mem[_4846 + ceil32(return_data.size) + 132] = 0
                                                                    mem[_4846 + ceil32(return_data.size) + 164] = 160
                                                                    mem[_4846 + ceil32(return_data.size) + 260] = mem[_4846]
                                                                    idx = 0
                                                                    s = _4846 + ceil32(return_data.size) + 292
                                                                    t = _4846 + 32
                                                                    while idx < mem[_4846]:
                                                                        mem[s] = mem[t + 12 len 20]
                                                                        idx = idx + 1
                                                                        s = s + 32
                                                                        t = t + 32
                                                                        continue 
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                         gas gas_remaining wei
                                                                        args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_4846 + ceil32(return_data.size) + 260 len (32 * mem[_4846]) + 32]
                                                        else:
                                                            if swapTokensAmount and rewardsFee > -1 / swapTokensAmount:
                                                                revert with 0, 17
                                                            if not swapTokensAmount:
                                                                revert with 0, 18
                                                            if swapTokensAmount * rewardsFee / swapTokensAmount != rewardsFee:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[ceil32(return_data.size) + 256] = 26
                                                            mem[ceil32(return_data.size) + 288] = 'SafeMath: division by zero'
                                                            if not swapTokensAmount * rewardsFee / 100:
                                                                mem[ceil32(return_data.size) + 320] = 26
                                                                mem[ceil32(return_data.size) + 352] = 'SafeMath: division by zero'
                                                                mem[ceil32(return_data.size) + 384] = 30
                                                                mem[ceil32(return_data.size) + 416] = 'SafeMath: subtraction overflow'
                                                                if 0 > swapTokensAmount * rewardsFee / 100:
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                if swapTokensAmount * rewardsFee / 100 < 0:
                                                                    revert with 0, 17
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not distributionPoolAddress:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                if stor33[address(this.address)]:
                                                                    revert with 0, 'Blacklisted address'
                                                                if stor33[stor24]:
                                                                    revert with 0, 'Blacklisted address'
                                                                emit Transfer((swapTokensAmount * rewardsFee / 100), this.address, distributionPoolAddress);
                                                                if not swapTokensAmount:
                                                                    mem[ceil32(return_data.size) + 448] = 26
                                                                    mem[ceil32(return_data.size) + 480] = 'SafeMath: division by zero'
                                                                    mem[ceil32(return_data.size) + 512] = 2
                                                                    mem[ceil32(return_data.size) + 544] = this.address
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                            gas gas_remaining wei
                                                                    mem[ceil32(return_data.size) + 608] = ext_call.return_data[0]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = (2 * ceil32(return_data.size)) + 608
                                                                    require return_data.size >= 32
                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                    mem[ceil32(return_data.size) + 576] = ext_call.return_data[12 len 20]
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                    mem[(2 * ceil32(return_data.size)) + 608] = balanceOf[address(this.address)]
                                                                    emit Approval(mem[(2 * ceil32(return_data.size)) + 608 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                    mem[(2 * ceil32(return_data.size)) + 608] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                    mem[(2 * ceil32(return_data.size)) + 612] = balanceOf[address(this.address)]
                                                                    mem[(2 * ceil32(return_data.size)) + 644] = 0
                                                                    mem[(2 * ceil32(return_data.size)) + 676] = 160
                                                                    mem[(2 * ceil32(return_data.size)) + 772] = 2
                                                                    idx = 0
                                                                    s = (2 * ceil32(return_data.size)) + 804
                                                                    t = ceil32(return_data.size) + 544
                                                                    while idx < mem[ceil32(return_data.size) + 512]:
                                                                        mem[s] = mem[t + 12 len 20]
                                                                        idx = idx + 1
                                                                        s = s + 32
                                                                        t = t + 32
                                                                        continue 
                                                                    mem[(2 * ceil32(return_data.size)) + 708] = this.address
                                                                    mem[(2 * ceil32(return_data.size)) + 740] = block.timestamp
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 864]
                                                                else:
                                                                    if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                        revert with 0, 17
                                                                    if not swapTokensAmount:
                                                                        revert with 0, 18
                                                                    if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                                    mem[ceil32(return_data.size) + 448] = 26
                                                                    mem[ceil32(return_data.size) + 480] = 'SafeMath: division by zero'
                                                                    if not swapTokensAmount * liquidityPoolFee / 100:
                                                                        mem[ceil32(return_data.size) + 512] = 2
                                                                        mem[ceil32(return_data.size) + 544] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[ceil32(return_data.size) + 608] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = (2 * ceil32(return_data.size)) + 608
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        mem[ceil32(return_data.size) + 576] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        mem[(2 * ceil32(return_data.size)) + 608] = balanceOf[address(this.address)]
                                                                        emit Approval(mem[(2 * ceil32(return_data.size)) + 608 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                        mem[(2 * ceil32(return_data.size)) + 608] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[(2 * ceil32(return_data.size)) + 612] = balanceOf[address(this.address)]
                                                                        mem[(2 * ceil32(return_data.size)) + 644] = 0
                                                                        mem[(2 * ceil32(return_data.size)) + 676] = 160
                                                                        mem[(2 * ceil32(return_data.size)) + 772] = 2
                                                                        idx = 0
                                                                        s = (2 * ceil32(return_data.size)) + 804
                                                                        t = ceil32(return_data.size) + 544
                                                                        while idx < mem[ceil32(return_data.size) + 512]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[(2 * ceil32(return_data.size)) + 708] = this.address
                                                                        mem[(2 * ceil32(return_data.size)) + 740] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                             gas gas_remaining wei
                                                                            args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 864]
                                                                    else:
                                                                        mem[ceil32(return_data.size) + 512] = 26
                                                                        mem[ceil32(return_data.size) + 544] = 'SafeMath: division by zero'
                                                                        mem[ceil32(return_data.size) + 576] = 30
                                                                        mem[ceil32(return_data.size) + 608] = 'SafeMath: subtraction overflow'
                                                                        if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                            revert with 0, 17
                                                                        mem[ceil32(return_data.size) + 640] = 2
                                                                        mem[ceil32(return_data.size) + 672] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[ceil32(return_data.size) + 736] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = (2 * ceil32(return_data.size)) + 736
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        mem[ceil32(return_data.size) + 704] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                        allowance[msg.sender][stor20].field_255 = 0
                                                                        mem[(2 * ceil32(return_data.size)) + 736] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                        emit Approval(mem[(2 * ceil32(return_data.size)) + 736 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                        mem[(2 * ceil32(return_data.size)) + 736] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[(2 * ceil32(return_data.size)) + 740] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                        mem[(2 * ceil32(return_data.size)) + 772] = 0
                                                                        mem[(2 * ceil32(return_data.size)) + 804] = 160
                                                                        mem[(2 * ceil32(return_data.size)) + 900] = 2
                                                                        idx = 0
                                                                        s = (2 * ceil32(return_data.size)) + 932
                                                                        t = ceil32(return_data.size) + 672
                                                                        while idx < mem[ceil32(return_data.size) + 640]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[(2 * ceil32(return_data.size)) + 836] = this.address
                                                                        mem[(2 * ceil32(return_data.size)) + 868] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                             gas gas_remaining wei
                                                                            args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 992]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        _4045 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_4045] = 30
                                                                        mem[_4045 + 32] = 'SafeMath: subtraction overflow'
                                                                        if eth.balance(this.address) > eth.balance(this.address):
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if eth.balance(this.address) < eth.balance(this.address):
                                                                            revert with 0, 17
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                        emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                        mem[mem[64] + 68] = 0
                                                                        mem[mem[64] + 100] = 0
                                                                        mem[mem[64] + 132] = 0
                                                                        mem[mem[64] + 164] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                             gas gas_remaining wei
                                                                            args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                                        require return_data.size >= 96
                                                                        mem[mem[64] + 32] = 0
                                                                        mem[mem[64] + 64] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                        emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                        mem[0] = this.address
                                                                        mem[32] = 2
                                                                        _4844 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_4844 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_4844]:
                                                                            revert with 0, 50
                                                                        mem[_4844 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_4844 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _4844 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_4844]:
                                                                            revert with 0, 50
                                                                        mem[_4844 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                        mem[_4844 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_4844 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                        mem[_4844 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_4844 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_4844 + ceil32(return_data.size) + 260] = mem[_4844]
                                                                        idx = 0
                                                                        s = _4844 + ceil32(return_data.size) + 292
                                                                        t = _4844 + 32
                                                                        while idx < mem[_4844]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                             gas gas_remaining wei
                                                                            args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_4844 + ceil32(return_data.size) + 260 len (32 * mem[_4844]) + 32]
                                                            else:
                                                                if swapTokensAmount * rewardsFee / 100 and stor29 > -1 / swapTokensAmount * rewardsFee / 100:
                                                                    revert with 0, 17
                                                                if not swapTokensAmount * rewardsFee / 100:
                                                                    revert with 0, 18
                                                                if swapTokensAmount * rewardsFee / 100 * stor29 / swapTokensAmount * rewardsFee / 100 != stor29:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                mem[ceil32(return_data.size) + 320] = 26
                                                                mem[ceil32(return_data.size) + 352] = 'SafeMath: division by zero'
                                                                if not swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                    mem[ceil32(return_data.size) + 384] = 30
                                                                    mem[ceil32(return_data.size) + 416] = 'SafeMath: subtraction overflow'
                                                                    if swapTokensAmount * rewardsFee / 100 * stor29 / 100 > swapTokensAmount * rewardsFee / 100:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if swapTokensAmount * rewardsFee / 100 < swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                        revert with 0, 17
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not distributionPoolAddress:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    if stor33[address(this.address)]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    if stor33[stor24]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    emit Transfer(((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)), this.address, distributionPoolAddress);
                                                                    if not swapTokensAmount:
                                                                        mem[ceil32(return_data.size) + 448] = 26
                                                                        mem[ceil32(return_data.size) + 480] = 'SafeMath: division by zero'
                                                                        mem[ceil32(return_data.size) + 512] = 2
                                                                        mem[ceil32(return_data.size) + 544] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[ceil32(return_data.size) + 608] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = (2 * ceil32(return_data.size)) + 608
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        mem[ceil32(return_data.size) + 576] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        mem[(2 * ceil32(return_data.size)) + 608] = balanceOf[address(this.address)]
                                                                        emit Approval(mem[(2 * ceil32(return_data.size)) + 608 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                        mem[(2 * ceil32(return_data.size)) + 608] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[(2 * ceil32(return_data.size)) + 612] = balanceOf[address(this.address)]
                                                                        mem[(2 * ceil32(return_data.size)) + 644] = 0
                                                                        mem[(2 * ceil32(return_data.size)) + 676] = 160
                                                                        mem[(2 * ceil32(return_data.size)) + 772] = 2
                                                                        idx = 0
                                                                        s = (2 * ceil32(return_data.size)) + 804
                                                                        t = ceil32(return_data.size) + 544
                                                                        while idx < mem[ceil32(return_data.size) + 512]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[(2 * ceil32(return_data.size)) + 708] = this.address
                                                                        mem[(2 * ceil32(return_data.size)) + 740] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                             gas gas_remaining wei
                                                                            args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 864]
                                                                    else:
                                                                        if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                            revert with 0, 17
                                                                        if not swapTokensAmount:
                                                                            revert with 0, 18
                                                                        if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                                        mem[ceil32(return_data.size) + 448] = 26
                                                                        mem[ceil32(return_data.size) + 480] = 'SafeMath: division by zero'
                                                                        if not swapTokensAmount * liquidityPoolFee / 100:
                                                                            mem[ceil32(return_data.size) + 512] = 2
                                                                            mem[ceil32(return_data.size) + 544] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[ceil32(return_data.size) + 608] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = (2 * ceil32(return_data.size)) + 608
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            mem[ceil32(return_data.size) + 576] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            mem[(2 * ceil32(return_data.size)) + 608] = balanceOf[address(this.address)]
                                                                            emit Approval(mem[(2 * ceil32(return_data.size)) + 608 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                            mem[(2 * ceil32(return_data.size)) + 608] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[(2 * ceil32(return_data.size)) + 612] = balanceOf[address(this.address)]
                                                                            mem[(2 * ceil32(return_data.size)) + 644] = 0
                                                                            mem[(2 * ceil32(return_data.size)) + 676] = 160
                                                                            mem[(2 * ceil32(return_data.size)) + 772] = 2
                                                                            idx = 0
                                                                            s = (2 * ceil32(return_data.size)) + 804
                                                                            t = ceil32(return_data.size) + 544
                                                                            while idx < mem[ceil32(return_data.size) + 512]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            mem[(2 * ceil32(return_data.size)) + 708] = this.address
                                                                            mem[(2 * ceil32(return_data.size)) + 740] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                 gas gas_remaining wei
                                                                                args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 864]
                                                                        else:
                                                                            mem[ceil32(return_data.size) + 512] = 26
                                                                            mem[ceil32(return_data.size) + 544] = 'SafeMath: division by zero'
                                                                            mem[ceil32(return_data.size) + 576] = 30
                                                                            mem[ceil32(return_data.size) + 608] = 'SafeMath: subtraction overflow'
                                                                            if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                revert with 0, 17
                                                                            mem[ceil32(return_data.size) + 640] = 2
                                                                            mem[ceil32(return_data.size) + 672] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[ceil32(return_data.size) + 736] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = (2 * ceil32(return_data.size)) + 736
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            mem[ceil32(return_data.size) + 704] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                            allowance[msg.sender][stor20].field_255 = 0
                                                                            mem[(2 * ceil32(return_data.size)) + 736] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                            emit Approval(mem[(2 * ceil32(return_data.size)) + 736 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                            mem[(2 * ceil32(return_data.size)) + 736] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[(2 * ceil32(return_data.size)) + 740] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                            mem[(2 * ceil32(return_data.size)) + 772] = 0
                                                                            mem[(2 * ceil32(return_data.size)) + 804] = 160
                                                                            mem[(2 * ceil32(return_data.size)) + 900] = 2
                                                                            idx = 0
                                                                            s = (2 * ceil32(return_data.size)) + 932
                                                                            t = ceil32(return_data.size) + 672
                                                                            while idx < mem[ceil32(return_data.size) + 640]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            mem[(2 * ceil32(return_data.size)) + 836] = this.address
                                                                            mem[(2 * ceil32(return_data.size)) + 868] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                 gas gas_remaining wei
                                                                                args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 992]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            _4043 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_4043] = 30
                                                                            mem[_4043 + 32] = 'SafeMath: subtraction overflow'
                                                                            if eth.balance(this.address) > eth.balance(this.address):
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if eth.balance(this.address) < eth.balance(this.address):
                                                                                revert with 0, 17
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                            emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                            mem[mem[64] + 68] = 0
                                                                            mem[mem[64] + 100] = 0
                                                                            mem[mem[64] + 132] = 0
                                                                            mem[mem[64] + 164] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                 gas gas_remaining wei
                                                                                args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                                            require return_data.size >= 96
                                                                            mem[mem[64] + 32] = 0
                                                                            mem[mem[64] + 64] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                            emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                            mem[0] = this.address
                                                                            mem[32] = 2
                                                                            _4838 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_4838 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_4838]:
                                                                                revert with 0, 50
                                                                            mem[_4838 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_4838 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _4838 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_4838]:
                                                                                revert with 0, 50
                                                                            mem[_4838 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_4838 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_4838 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                            mem[_4838 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_4838 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_4838 + ceil32(return_data.size) + 260] = mem[_4838]
                                                                            idx = 0
                                                                            s = _4838 + ceil32(return_data.size) + 292
                                                                            t = _4838 + 32
                                                                            while idx < mem[_4838]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                 gas gas_remaining wei
                                                                                args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_4838 + ceil32(return_data.size) + 260 len (32 * mem[_4838]) + 32]
                                                                else:
                                                                    mem[ceil32(return_data.size) + 384] = 2
                                                                    mem[ceil32(return_data.size) + 416] = this.address
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                            gas gas_remaining wei
                                                                    mem[ceil32(return_data.size) + 480] = ext_call.return_data[0]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = (2 * ceil32(return_data.size)) + 480
                                                                    require return_data.size >= 32
                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                    mem[ceil32(return_data.size) + 448] = ext_call.return_data[12 len 20]
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = swapTokensAmount * rewardsFee / 100 * stor29 / 100
                                                                    mem[(2 * ceil32(return_data.size)) + 480] = swapTokensAmount * rewardsFee / 100 * stor29 / 100
                                                                    emit Approval(mem[(2 * ceil32(return_data.size)) + 480 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                                    mem[(2 * ceil32(return_data.size)) + 480] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                    mem[(2 * ceil32(return_data.size)) + 484] = swapTokensAmount * rewardsFee / 100 * stor29 / 100
                                                                    mem[(2 * ceil32(return_data.size)) + 516] = 0
                                                                    mem[(2 * ceil32(return_data.size)) + 548] = 160
                                                                    mem[(2 * ceil32(return_data.size)) + 644] = 2
                                                                    idx = 0
                                                                    s = (2 * ceil32(return_data.size)) + 676
                                                                    t = ceil32(return_data.size) + 416
                                                                    while idx < mem[ceil32(return_data.size) + 384]:
                                                                        mem[s] = mem[t + 12 len 20]
                                                                        idx = idx + 1
                                                                        s = s + 32
                                                                        t = t + 32
                                                                        continue 
                                                                    mem[(2 * ceil32(return_data.size)) + 580] = this.address
                                                                    mem[(2 * ceil32(return_data.size)) + 612] = block.timestamp
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 736]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _4044 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_4044] = 30
                                                                    mem[_4044 + 32] = 'SafeMath: subtraction overflow'
                                                                    if eth.balance(this.address) > eth.balance(this.address):
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if eth.balance(this.address) < eth.balance(this.address):
                                                                        revert with 0, 17
                                                                    call distributionPoolAddress with:
                                                                         gas 30000 wei
                                                                    if return_data.size:
                                                                        _4472 = mem[64]
                                                                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                                                                        mem[_4472] = return_data.size
                                                                        mem[_4472 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                        _4579 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_4579] = 30
                                                                        mem[_4579 + 32] = 'SafeMath: subtraction overflow'
                                                                        if swapTokensAmount * rewardsFee / 100 * stor29 / 100 > swapTokensAmount * rewardsFee / 100:
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if swapTokensAmount * rewardsFee / 100 < swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                            revert with 0, 17
                                                                        if not this.address:
                                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                                        if not distributionPoolAddress:
                                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                                        if stor33[address(this.address)]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        mem[0] = distributionPoolAddress
                                                                        mem[32] = 33
                                                                        if stor33[stor24]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        emit Transfer(((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)), this.address, distributionPoolAddress);
                                                                        if not swapTokensAmount:
                                                                            _5013 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_5013] = 26
                                                                            mem[_5013 + 32] = 'SafeMath: division by zero'
                                                                            mem[0] = this.address
                                                                            mem[32] = 2
                                                                            _5192 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_5192 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_5192]:
                                                                                revert with 0, 50
                                                                            mem[_5192 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_5192 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _5192 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_5192]:
                                                                                revert with 0, 50
                                                                            mem[_5192 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_5192 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_5192 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                            mem[_5192 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_5192 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_5192 + ceil32(return_data.size) + 260] = mem[_5192]
                                                                            idx = 0
                                                                            s = _5192 + ceil32(return_data.size) + 292
                                                                            t = _5192 + 32
                                                                            while idx < mem[_5192]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            mem[_5192 + ceil32(return_data.size) + 196] = this.address
                                                                            mem[_5192 + ceil32(return_data.size) + 228] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                 gas gas_remaining wei
                                                                                args mem[mem[64] + 4 len _5192 + ceil32(return_data.size) + (32 * mem[_5192]) + -mem[64] + 288]
                                                                        else:
                                                                            if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                                revert with 0, 17
                                                                            if not swapTokensAmount:
                                                                                revert with 0, 18
                                                                            if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                                            _5133 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_5133] = 26
                                                                            mem[_5133 + 32] = 'SafeMath: division by zero'
                                                                            if not swapTokensAmount * liquidityPoolFee / 100:
                                                                                mem[0] = this.address
                                                                                mem[32] = 2
                                                                                _5320 = mem[64]
                                                                                mem[mem[64]] = 2
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_5320 + 32 len 64] = call.data[calldata.size len 64]
                                                                                if 0 >= mem[_5320]:
                                                                                    revert with 0, 50
                                                                                mem[_5320 + 32] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_5320 + 96] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _5320 + ceil32(return_data.size) + 96
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                if 1 >= mem[_5320]:
                                                                                    revert with 0, 50
                                                                                mem[_5320 + 64] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                mem[_5320 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_5320 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                                mem[_5320 + ceil32(return_data.size) + 132] = 0
                                                                                mem[_5320 + ceil32(return_data.size) + 164] = 160
                                                                                mem[_5320 + ceil32(return_data.size) + 260] = mem[_5320]
                                                                                idx = 0
                                                                                s = _5320 + ceil32(return_data.size) + 292
                                                                                t = _5320 + 32
                                                                                while idx < mem[_5320]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                     gas gas_remaining wei
                                                                                    args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_5320 + ceil32(return_data.size) + 260 len (32 * mem[_5320]) + 32]
                                                                            else:
                                                                                _5268 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_5268] = 26
                                                                                mem[_5268 + 32] = 'SafeMath: division by zero'
                                                                                _5521 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_5521] = 30
                                                                                mem[_5521 + 32] = 'SafeMath: subtraction overflow'
                                                                                if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                    revert with 0, 17
                                                                                _5665 = mem[64]
                                                                                mem[mem[64]] = 2
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_5665 + 32 len 64] = call.data[calldata.size len 64]
                                                                                if 0 >= mem[_5665]:
                                                                                    revert with 0, 50
                                                                                mem[_5665 + 32] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_5665 + 96] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _5665 + ceil32(return_data.size) + 96
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                if 1 >= mem[_5665]:
                                                                                    revert with 0, 50
                                                                                mem[_5665 + 64] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                allowance[msg.sender][stor20].field_255 = 0
                                                                                emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                                mem[_5665 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_5665 + ceil32(return_data.size) + 100] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                mem[_5665 + ceil32(return_data.size) + 132] = 0
                                                                                mem[_5665 + ceil32(return_data.size) + 164] = 160
                                                                                mem[_5665 + ceil32(return_data.size) + 260] = mem[_5665]
                                                                                idx = 0
                                                                                s = _5665 + ceil32(return_data.size) + 292
                                                                                t = _5665 + 32
                                                                                while idx < mem[_5665]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                     gas gas_remaining wei
                                                                                    args Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_5665 + ceil32(return_data.size) + 260 len (32 * mem[_5665]) + 32]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[_5665 + ceil32(return_data.size) + 96] = 30
                                                                                mem[_5665 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                                                                if eth.balance(this.address) > eth.balance(this.address):
                                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                if eth.balance(this.address) < eth.balance(this.address):
                                                                                    revert with 0, 17
                                                                                allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                                mem[_5665 + ceil32(return_data.size) + 228] = 0
                                                                                mem[_5665 + ceil32(return_data.size) + 260] = 0
                                                                                mem[_5665 + ceil32(return_data.size) + 292] = 0
                                                                                mem[_5665 + ceil32(return_data.size) + 324] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                     gas gas_remaining wei
                                                                                    args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                                mem[_5665 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                require return_data.size >= 96
                                                                                emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                                mem[_5665 + (2 * ceil32(return_data.size)) + 160] = 2
                                                                                mem[_5665 + (2 * ceil32(return_data.size)) + 192] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_5665 + (2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _5665 + (4 * ceil32(return_data.size)) + 256
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                mem[_5665 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                mem[_5665 + (4 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_5665 + (4 * ceil32(return_data.size)) + 260] = balanceOf[address(this.address)]
                                                                                mem[_5665 + (4 * ceil32(return_data.size)) + 292] = 0
                                                                                mem[_5665 + (4 * ceil32(return_data.size)) + 324] = 160
                                                                                mem[_5665 + (4 * ceil32(return_data.size)) + 420] = 2
                                                                                idx = 0
                                                                                s = _5665 + (4 * ceil32(return_data.size)) + 452
                                                                                t = _5665 + (2 * ceil32(return_data.size)) + 192
                                                                                while idx < mem[_5665 + (2 * ceil32(return_data.size)) + 160]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                mem[_5665 + (4 * ceil32(return_data.size)) + 356] = this.address
                                                                                mem[_5665 + (4 * ceil32(return_data.size)) + 388] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                     gas gas_remaining wei
                                                                                    args mem[mem[64] + 4 len _5665 + (4 * ceil32(return_data.size)) + (32 * mem[_5665 + (2 * ceil32(return_data.size)) + 160]) + -mem[64] + 448]
                                                                    else:
                                                                        _4578 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_4578] = 30
                                                                        mem[_4578 + 32] = 'SafeMath: subtraction overflow'
                                                                        if swapTokensAmount * rewardsFee / 100 * stor29 / 100 > swapTokensAmount * rewardsFee / 100:
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if swapTokensAmount * rewardsFee / 100 < swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                            revert with 0, 17
                                                                        if not this.address:
                                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                                        if not distributionPoolAddress:
                                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                                        if stor33[address(this.address)]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        mem[0] = distributionPoolAddress
                                                                        mem[32] = 33
                                                                        if stor33[stor24]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        emit Transfer(((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)), this.address, distributionPoolAddress);
                                                                        if not swapTokensAmount:
                                                                            _5012 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_5012] = 26
                                                                            mem[_5012 + 32] = 'SafeMath: division by zero'
                                                                            mem[0] = this.address
                                                                            mem[32] = 2
                                                                            _5190 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_5190 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_5190]:
                                                                                revert with 0, 50
                                                                            mem[_5190 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_5190 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _5190 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_5190]:
                                                                                revert with 0, 50
                                                                            mem[_5190 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_5190 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_5190 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                            mem[_5190 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_5190 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_5190 + ceil32(return_data.size) + 260] = mem[_5190]
                                                                            idx = 0
                                                                            s = _5190 + ceil32(return_data.size) + 292
                                                                            t = _5190 + 32
                                                                            while idx < mem[_5190]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            mem[_5190 + ceil32(return_data.size) + 196] = this.address
                                                                            mem[_5190 + ceil32(return_data.size) + 228] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                 gas gas_remaining wei
                                                                                args mem[mem[64] + 4 len _5190 + ceil32(return_data.size) + (32 * mem[_5190]) + -mem[64] + 288]
                                                                        else:
                                                                            if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                                revert with 0, 17
                                                                            if not swapTokensAmount:
                                                                                revert with 0, 18
                                                                            if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                                            _5132 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_5132] = 26
                                                                            mem[_5132 + 32] = 'SafeMath: division by zero'
                                                                            if not swapTokensAmount * liquidityPoolFee / 100:
                                                                                mem[0] = this.address
                                                                                mem[32] = 2
                                                                                _5318 = mem[64]
                                                                                mem[mem[64]] = 2
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_5318 + 32 len 64] = call.data[calldata.size len 64]
                                                                                if 0 >= mem[_5318]:
                                                                                    revert with 0, 50
                                                                                mem[_5318 + 32] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_5318 + 96] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _5318 + ceil32(return_data.size) + 96
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                if 1 >= mem[_5318]:
                                                                                    revert with 0, 50
                                                                                mem[_5318 + 64] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                mem[_5318 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_5318 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                                mem[_5318 + ceil32(return_data.size) + 132] = 0
                                                                                mem[_5318 + ceil32(return_data.size) + 164] = 160
                                                                                mem[_5318 + ceil32(return_data.size) + 260] = mem[_5318]
                                                                                idx = 0
                                                                                s = _5318 + ceil32(return_data.size) + 292
                                                                                t = _5318 + 32
                                                                                while idx < mem[_5318]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                     gas gas_remaining wei
                                                                                    args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_5318 + ceil32(return_data.size) + 260 len (32 * mem[_5318]) + 32]
                                                                            else:
                                                                                _5266 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_5266] = 26
                                                                                mem[_5266 + 32] = 'SafeMath: division by zero'
                                                                                _5520 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_5520] = 30
                                                                                mem[_5520 + 32] = 'SafeMath: subtraction overflow'
                                                                                if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                    revert with 0, 17
                                                                                _5661 = mem[64]
                                                                                mem[mem[64]] = 2
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_5661 + 32 len 64] = call.data[calldata.size len 64]
                                                                                if 0 >= mem[_5661]:
                                                                                    revert with 0, 50
                                                                                mem[_5661 + 32] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_5661 + 96] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _5661 + ceil32(return_data.size) + 96
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                if 1 >= mem[_5661]:
                                                                                    revert with 0, 50
                                                                                mem[_5661 + 64] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                allowance[msg.sender][stor20].field_255 = 0
                                                                                emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                                mem[_5661 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_5661 + ceil32(return_data.size) + 100] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                mem[_5661 + ceil32(return_data.size) + 132] = 0
                                                                                mem[_5661 + ceil32(return_data.size) + 164] = 160
                                                                                mem[_5661 + ceil32(return_data.size) + 260] = mem[_5661]
                                                                                idx = 0
                                                                                s = _5661 + ceil32(return_data.size) + 292
                                                                                t = _5661 + 32
                                                                                while idx < mem[_5661]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                mem[_5661 + ceil32(return_data.size) + 196] = this.address
                                                                                mem[_5661 + ceil32(return_data.size) + 228] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                     gas gas_remaining wei
                                                                                    args mem[mem[64] + 4 len _5661 + ceil32(return_data.size) + (32 * mem[_5661]) + -mem[64] + 288]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                _9543 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_9543] = 30
                                                                                mem[_9543 + 32] = 'SafeMath: subtraction overflow'
                                                                                if eth.balance(this.address) > eth.balance(this.address):
                                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                if eth.balance(this.address) < eth.balance(this.address):
                                                                                    revert with 0, 17
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                                mem[mem[64] + 68] = 0
                                                                                mem[mem[64] + 100] = 0
                                                                                mem[mem[64] + 132] = 0
                                                                                mem[mem[64] + 164] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                     gas gas_remaining wei
                                                                                    args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                                require return_data.size >= 96
                                                                                mem[mem[64] + 32] = 0
                                                                                mem[mem[64] + 64] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                                mem[0] = this.address
                                                                                mem[32] = 2
                                                                                _10769 = mem[64]
                                                                                mem[mem[64]] = 2
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_10769 + 32 len 64] = call.data[calldata.size len 64]
                                                                                if 0 >= mem[_10769]:
                                                                                    revert with 0, 50
                                                                                mem[_10769 + 32] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_10769 + 96] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _10769 + ceil32(return_data.size) + 96
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                if 1 >= mem[_10769]:
                                                                                    revert with 0, 50
                                                                                mem[_10769 + 64] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                mem[_10769 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_10769 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                                mem[_10769 + ceil32(return_data.size) + 132] = 0
                                                                                mem[_10769 + ceil32(return_data.size) + 164] = 160
                                                                                mem[_10769 + ceil32(return_data.size) + 260] = mem[_10769]
                                                                                idx = 0
                                                                                s = _10769 + ceil32(return_data.size) + 292
                                                                                t = _10769 + 32
                                                                                while idx < mem[_10769]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                     gas gas_remaining wei
                                                                                    args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_10769 + ceil32(return_data.size) + 260 len (32 * mem[_10769]) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        uint8(stor30.field_0) = 0
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not this.address:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        if stor33[address(msg.sender)]:
                                                            revert with 0, 'Blacklisted address'
                                                        if stor33[address(this.address)]:
                                                            revert with 0, 'Blacklisted address'
                                                        emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                        require ext_code.size(nodeRewardManagementAddress)
                                                        call nodeRewardManagementAddress.0x37696eec with:
                                                             gas gas_remaining wei
                                                            args msg.sender, uint8(cd[4])
                                                else:
                                                    mem[ceil32(return_data.size) + 192] = 2
                                                    mem[ceil32(return_data.size) + 224] = this.address
                                                    require ext_code.size(uniswapV2RouterAddress)
                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[ceil32(return_data.size) + 288] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (2 * ceil32(return_data.size)) + 288
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    mem[ceil32(return_data.size) + 256] = ext_call.return_data[12 len 20]
                                                    mem[0] = uniV2RouterAddress
                                                    mem[32] = sha3(msg.sender, 3)
                                                    allowance[msg.sender][stor20].field_0 = swapTokensAmount * devFee / 100
                                                    mem[(2 * ceil32(return_data.size)) + 288] = swapTokensAmount * devFee / 100
                                                    emit Approval(mem[(2 * ceil32(return_data.size)) + 288 len ceil32(return_data.size) + 32], msg.sender, uniV2RouterAddress);
                                                    mem[(2 * ceil32(return_data.size)) + 288] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                    mem[(2 * ceil32(return_data.size)) + 292] = swapTokensAmount * devFee / 100
                                                    mem[(2 * ceil32(return_data.size)) + 324] = 0
                                                    mem[(2 * ceil32(return_data.size)) + 356] = 160
                                                    mem[(2 * ceil32(return_data.size)) + 452] = 2
                                                    idx = 0
                                                    s = (2 * ceil32(return_data.size)) + 484
                                                    t = ceil32(return_data.size) + 224
                                                    while idx < mem[ceil32(return_data.size) + 192]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[(2 * ceil32(return_data.size)) + 388] = this.address
                                                    mem[(2 * ceil32(return_data.size)) + 420] = block.timestamp
                                                    require ext_code.size(uniswapV2RouterAddress)
                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 544]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _4047 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_4047] = 30
                                                    mem[_4047 + 32] = 'SafeMath: subtraction overflow'
                                                    if eth.balance(this.address) > eth.balance(this.address):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if eth.balance(this.address) < eth.balance(this.address):
                                                        revert with 0, 17
                                                    call devPoolAddress with:
                                                         gas 30000 wei
                                                    if not return_data.size:
                                                        if swapTokensAmount:
                                                            if swapTokensAmount and burnFee > -1 / swapTokensAmount:
                                                                revert with 0, 17
                                                            if not swapTokensAmount:
                                                                revert with 0, 18
                                                            if swapTokensAmount * burnFee / swapTokensAmount != burnFee:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _4806 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_4806] = 26
                                                            mem[_4806 + 32] = 'SafeMath: division by zero'
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not deadWalletAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            if stor33[address(this.address)]:
                                                                revert with 0, 'Blacklisted address'
                                                            mem[0] = deadWalletAddress
                                                            mem[32] = 33
                                                            if stor33[stor7]:
                                                                revert with 0, 'Blacklisted address'
                                                            emit Transfer((swapTokensAmount * burnFee / 100), this.address, deadWalletAddress);
                                                            if not swapTokensAmount:
                                                                _5182 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_5182] = 26
                                                                mem[_5182 + 32] = 'SafeMath: division by zero'
                                                                _5490 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_5490] = 26
                                                                mem[_5490 + 32] = 'SafeMath: division by zero'
                                                                _5640 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_5640] = 30
                                                                mem[_5640 + 32] = 'SafeMath: subtraction overflow'
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not distributionPoolAddress:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                if stor33[address(this.address)]:
                                                                    revert with 0, 'Blacklisted address'
                                                                mem[0] = distributionPoolAddress
                                                                mem[32] = 33
                                                                if stor33[stor24]:
                                                                    revert with 0, 'Blacklisted address'
                                                                emit Transfer(0, this.address, distributionPoolAddress);
                                                                if not swapTokensAmount:
                                                                    _6233 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_6233] = 26
                                                                    mem[_6233 + 32] = 'SafeMath: division by zero'
                                                                    mem[0] = this.address
                                                                    mem[32] = 2
                                                                    _6384 = mem[64]
                                                                    mem[mem[64]] = 2
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_6384 + 32 len 64] = call.data[calldata.size len 64]
                                                                    if 0 >= mem[_6384]:
                                                                        revert with 0, 50
                                                                    mem[_6384 + 32] = this.address
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                            gas gas_remaining wei
                                                                    mem[_6384 + 96] = ext_call.return_data[0]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _6384 + ceil32(return_data.size) + 96
                                                                    require return_data.size >= 32
                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                    if 1 >= mem[_6384]:
                                                                        revert with 0, 50
                                                                    mem[_6384 + 64] = ext_call.return_data[12 len 20]
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                    emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                    mem[_6384 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                    mem[_6384 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                    mem[_6384 + ceil32(return_data.size) + 132] = 0
                                                                    mem[_6384 + ceil32(return_data.size) + 164] = 160
                                                                    mem[_6384 + ceil32(return_data.size) + 260] = mem[_6384]
                                                                    idx = 0
                                                                    s = _6384 + ceil32(return_data.size) + 292
                                                                    t = _6384 + 32
                                                                    while idx < mem[_6384]:
                                                                        mem[s] = mem[t + 12 len 20]
                                                                        idx = idx + 1
                                                                        s = s + 32
                                                                        t = t + 32
                                                                        continue 
                                                                    mem[_6384 + ceil32(return_data.size) + 196] = this.address
                                                                    mem[_6384 + ceil32(return_data.size) + 228] = block.timestamp
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _6384 + ceil32(return_data.size) + (32 * mem[_6384]) + -mem[64] + 288]
                                                                else:
                                                                    if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                        revert with 0, 17
                                                                    if not swapTokensAmount:
                                                                        revert with 0, 18
                                                                    if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                                    _6321 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_6321] = 26
                                                                    mem[_6321 + 32] = 'SafeMath: division by zero'
                                                                    if not swapTokensAmount * liquidityPoolFee / 100:
                                                                        mem[0] = this.address
                                                                        mem[32] = 2
                                                                        _6526 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_6526 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_6526]:
                                                                            revert with 0, 50
                                                                        mem[_6526 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_6526 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _6526 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_6526]:
                                                                            revert with 0, 50
                                                                        mem[_6526 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                        mem[_6526 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_6526 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                        mem[_6526 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_6526 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_6526 + ceil32(return_data.size) + 260] = mem[_6526]
                                                                        idx = 0
                                                                        s = _6526 + ceil32(return_data.size) + 292
                                                                        t = _6526 + 32
                                                                        while idx < mem[_6526]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                             gas gas_remaining wei
                                                                            args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_6526 + ceil32(return_data.size) + 260 len (32 * mem[_6526]) + 32]
                                                                    else:
                                                                        _6495 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_6495] = 26
                                                                        mem[_6495 + 32] = 'SafeMath: division by zero'
                                                                        _6732 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_6732] = 30
                                                                        mem[_6732 + 32] = 'SafeMath: subtraction overflow'
                                                                        if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                            revert with 0, 17
                                                                        _6994 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_6994 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_6994]:
                                                                            revert with 0, 50
                                                                        mem[_6994 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_6994 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _6994 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_6994]:
                                                                            revert with 0, 50
                                                                        mem[_6994 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                        allowance[msg.sender][stor20].field_255 = 0
                                                                        emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                        mem[_6994 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_6994 + ceil32(return_data.size) + 100] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                        mem[_6994 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_6994 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_6994 + ceil32(return_data.size) + 260] = mem[_6994]
                                                                        idx = 0
                                                                        s = _6994 + ceil32(return_data.size) + 292
                                                                        t = _6994 + 32
                                                                        while idx < mem[_6994]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[_6994 + ceil32(return_data.size) + 196] = this.address
                                                                        mem[_6994 + ceil32(return_data.size) + 228] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                             gas gas_remaining wei
                                                                            args mem[mem[64] + 4 len _6994 + ceil32(return_data.size) + (32 * mem[_6994]) + -mem[64] + 288]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        _9548 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_9548] = 30
                                                                        mem[_9548 + 32] = 'SafeMath: subtraction overflow'
                                                                        if eth.balance(this.address) > eth.balance(this.address):
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if eth.balance(this.address) < eth.balance(this.address):
                                                                            revert with 0, 17
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                        emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                        mem[mem[64] + 68] = 0
                                                                        mem[mem[64] + 100] = 0
                                                                        mem[mem[64] + 132] = 0
                                                                        mem[mem[64] + 164] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                             gas gas_remaining wei
                                                                            args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                                        require return_data.size >= 96
                                                                        mem[mem[64] + 32] = 0
                                                                        mem[mem[64] + 64] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                        emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                        mem[0] = this.address
                                                                        mem[32] = 2
                                                                        _10781 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_10781 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_10781]:
                                                                            revert with 0, 50
                                                                        mem[_10781 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_10781 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _10781 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_10781]:
                                                                            revert with 0, 50
                                                                        mem[_10781 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                        mem[_10781 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_10781 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                        mem[_10781 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_10781 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_10781 + ceil32(return_data.size) + 260] = mem[_10781]
                                                                        idx = 0
                                                                        s = _10781 + ceil32(return_data.size) + 292
                                                                        t = _10781 + 32
                                                                        while idx < mem[_10781]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                             gas gas_remaining wei
                                                                            args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_10781 + ceil32(return_data.size) + 260 len (32 * mem[_10781]) + 32]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                uint8(stor30.field_0) = 0
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                if stor33[address(msg.sender)]:
                                                                    revert with 0, 'Blacklisted address'
                                                                if stor33[address(this.address)]:
                                                                    revert with 0, 'Blacklisted address'
                                                                emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                require ext_code.size(nodeRewardManagementAddress)
                                                                call nodeRewardManagementAddress.0x37696eec with:
                                                                     gas gas_remaining wei
                                                                    args msg.sender, uint8(cd[4])
                                                            else:
                                                                if swapTokensAmount and rewardsFee > -1 / swapTokensAmount:
                                                                    revert with 0, 17
                                                                if not swapTokensAmount:
                                                                    revert with 0, 18
                                                                if swapTokensAmount * rewardsFee / swapTokensAmount != rewardsFee:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                _5276 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_5276] = 26
                                                                mem[_5276 + 32] = 'SafeMath: division by zero'
                                                                if not swapTokensAmount * rewardsFee / 100:
                                                                    _5588 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_5588] = 26
                                                                    mem[_5588 + 32] = 'SafeMath: division by zero'
                                                                    _5792 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_5792] = 30
                                                                    mem[_5792 + 32] = 'SafeMath: subtraction overflow'
                                                                    if 0 > swapTokensAmount * rewardsFee / 100:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if swapTokensAmount * rewardsFee / 100 < 0:
                                                                        revert with 0, 17
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not distributionPoolAddress:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    if stor33[address(this.address)]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    mem[0] = distributionPoolAddress
                                                                    mem[32] = 33
                                                                    if stor33[stor24]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    emit Transfer((swapTokensAmount * rewardsFee / 100), this.address, distributionPoolAddress);
                                                                    if not swapTokensAmount:
                                                                        _6320 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_6320] = 26
                                                                        mem[_6320 + 32] = 'SafeMath: division by zero'
                                                                        mem[0] = this.address
                                                                        mem[32] = 2
                                                                        _6524 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_6524 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_6524]:
                                                                            revert with 0, 50
                                                                        mem[_6524 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_6524 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _6524 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_6524]:
                                                                            revert with 0, 50
                                                                        mem[_6524 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                        mem[_6524 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_6524 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                        mem[_6524 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_6524 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_6524 + ceil32(return_data.size) + 260] = mem[_6524]
                                                                        idx = 0
                                                                        s = _6524 + ceil32(return_data.size) + 292
                                                                        t = _6524 + 32
                                                                        while idx < mem[_6524]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[_6524 + ceil32(return_data.size) + 196] = this.address
                                                                        mem[_6524 + ceil32(return_data.size) + 228] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                             gas gas_remaining wei
                                                                            args mem[mem[64] + 4 len _6524 + ceil32(return_data.size) + (32 * mem[_6524]) + -mem[64] + 288]
                                                                    else:
                                                                        if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                            revert with 0, 17
                                                                        if not swapTokensAmount:
                                                                            revert with 0, 18
                                                                        if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                                        _6419 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_6419] = 26
                                                                        mem[_6419 + 32] = 'SafeMath: division by zero'
                                                                        if not swapTokensAmount * liquidityPoolFee / 100:
                                                                            mem[0] = this.address
                                                                            mem[32] = 2
                                                                            _6698 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_6698 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_6698]:
                                                                                revert with 0, 50
                                                                            mem[_6698 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_6698 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _6698 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_6698]:
                                                                                revert with 0, 50
                                                                            mem[_6698 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_6698 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_6698 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                            mem[_6698 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_6698 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_6698 + ceil32(return_data.size) + 260] = mem[_6698]
                                                                            idx = 0
                                                                            s = _6698 + ceil32(return_data.size) + 292
                                                                            t = _6698 + 32
                                                                            while idx < mem[_6698]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                 gas gas_remaining wei
                                                                                args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_6698 + ceil32(return_data.size) + 260 len (32 * mem[_6698]) + 32]
                                                                        else:
                                                                            _6651 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_6651] = 26
                                                                            mem[_6651 + 32] = 'SafeMath: division by zero'
                                                                            _6930 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_6930] = 30
                                                                            mem[_6930 + 32] = 'SafeMath: subtraction overflow'
                                                                            if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                revert with 0, 17
                                                                            _7260 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_7260 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_7260]:
                                                                                revert with 0, 50
                                                                            mem[_7260 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_7260 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _7260 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_7260]:
                                                                                revert with 0, 50
                                                                            mem[_7260 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                            allowance[msg.sender][stor20].field_255 = 0
                                                                            emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                            mem[_7260 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_7260 + ceil32(return_data.size) + 100] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                            mem[_7260 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_7260 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_7260 + ceil32(return_data.size) + 260] = mem[_7260]
                                                                            idx = 0
                                                                            s = _7260 + ceil32(return_data.size) + 292
                                                                            t = _7260 + 32
                                                                            while idx < mem[_7260]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            mem[_7260 + ceil32(return_data.size) + 196] = this.address
                                                                            mem[_7260 + ceil32(return_data.size) + 228] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                 gas gas_remaining wei
                                                                                args mem[mem[64] + 4 len _7260 + ceil32(return_data.size) + (32 * mem[_7260]) + -mem[64] + 288]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            _9547 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_9547] = 30
                                                                            mem[_9547 + 32] = 'SafeMath: subtraction overflow'
                                                                            if eth.balance(this.address) > eth.balance(this.address):
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if eth.balance(this.address) < eth.balance(this.address):
                                                                                revert with 0, 17
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                            emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                            mem[mem[64] + 68] = 0
                                                                            mem[mem[64] + 100] = 0
                                                                            mem[mem[64] + 132] = 0
                                                                            mem[mem[64] + 164] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                 gas gas_remaining wei
                                                                                args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                                            require return_data.size >= 96
                                                                            mem[mem[64] + 32] = 0
                                                                            mem[mem[64] + 64] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                            emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                            mem[0] = this.address
                                                                            mem[32] = 2
                                                                            _10779 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_10779 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_10779]:
                                                                                revert with 0, 50
                                                                            mem[_10779 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_10779 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _10779 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_10779]:
                                                                                revert with 0, 50
                                                                            mem[_10779 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_10779 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_10779 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                            mem[_10779 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_10779 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_10779 + ceil32(return_data.size) + 260] = mem[_10779]
                                                                            idx = 0
                                                                            s = _10779 + ceil32(return_data.size) + 292
                                                                            t = _10779 + 32
                                                                            while idx < mem[_10779]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                 gas gas_remaining wei
                                                                                args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_10779 + ceil32(return_data.size) + 260 len (32 * mem[_10779]) + 32]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    uint8(stor30.field_0) = 0
                                                                    if not msg.sender:
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    if stor33[address(msg.sender)]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    if stor33[address(this.address)]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                    require ext_code.size(nodeRewardManagementAddress)
                                                                    call nodeRewardManagementAddress.0x37696eec with:
                                                                         gas gas_remaining wei
                                                                        args msg.sender, uint8(cd[4])
                                                                else:
                                                                    if swapTokensAmount * rewardsFee / 100 and stor29 > -1 / swapTokensAmount * rewardsFee / 100:
                                                                        revert with 0, 17
                                                                    if not swapTokensAmount * rewardsFee / 100:
                                                                        revert with 0, 18
                                                                    if swapTokensAmount * rewardsFee / 100 * stor29 / swapTokensAmount * rewardsFee / 100 != stor29:
                                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                                    _5710 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_5710] = 26
                                                                    mem[_5710 + 32] = 'SafeMath: division by zero'
                                                                    if not swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                        _5994 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_5994] = 30
                                                                        mem[_5994 + 32] = 'SafeMath: subtraction overflow'
                                                                        if swapTokensAmount * rewardsFee / 100 * stor29 / 100 > swapTokensAmount * rewardsFee / 100:
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if swapTokensAmount * rewardsFee / 100 < swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                            revert with 0, 17
                                                                        if not this.address:
                                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                                        if not distributionPoolAddress:
                                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                                        if stor33[address(this.address)]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        mem[0] = distributionPoolAddress
                                                                        mem[32] = 33
                                                                        if stor33[stor24]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        emit Transfer(((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)), this.address, distributionPoolAddress);
                                                                        if not swapTokensAmount:
                                                                            _6418 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_6418] = 26
                                                                            mem[_6418 + 32] = 'SafeMath: division by zero'
                                                                            mem[0] = this.address
                                                                            mem[32] = 2
                                                                            _6694 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_6694 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_6694]:
                                                                                revert with 0, 50
                                                                            mem[_6694 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_6694 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _6694 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_6694]:
                                                                                revert with 0, 50
                                                                            mem[_6694 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_6694 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_6694 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                            mem[_6694 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_6694 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_6694 + ceil32(return_data.size) + 260] = mem[_6694]
                                                                            idx = 0
                                                                            s = _6694 + ceil32(return_data.size) + 292
                                                                            t = _6694 + 32
                                                                            while idx < mem[_6694]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                 gas gas_remaining wei
                                                                                args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_6694 + ceil32(return_data.size) + 260 len (32 * mem[_6694]) + 32]
                                                                        else:
                                                                            if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                                revert with 0, 17
                                                                            if not swapTokensAmount:
                                                                                revert with 0, 18
                                                                            if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                                            _6552 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_6552] = 26
                                                                            mem[_6552 + 32] = 'SafeMath: division by zero'
                                                                            if not swapTokensAmount * liquidityPoolFee / 100:
                                                                                mem[0] = this.address
                                                                                mem[32] = 2
                                                                                _6890 = mem[64]
                                                                                mem[mem[64]] = 2
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_6890 + 32 len 64] = call.data[calldata.size len 64]
                                                                                if 0 >= mem[_6890]:
                                                                                    revert with 0, 50
                                                                                mem[_6890 + 32] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_6890 + 96] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _6890 + ceil32(return_data.size) + 96
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                if 1 >= mem[_6890]:
                                                                                    revert with 0, 50
                                                                                mem[_6890 + 64] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                mem[_6890 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_6890 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                                mem[_6890 + ceil32(return_data.size) + 132] = 0
                                                                                mem[_6890 + ceil32(return_data.size) + 164] = 160
                                                                                mem[_6890 + ceil32(return_data.size) + 260] = mem[_6890]
                                                                                idx = 0
                                                                                s = _6890 + ceil32(return_data.size) + 292
                                                                                t = _6890 + 32
                                                                                while idx < mem[_6890]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                mem[_6890 + ceil32(return_data.size) + 196] = this.address
                                                                                mem[_6890 + ceil32(return_data.size) + 228] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                     gas gas_remaining wei
                                                                                    args mem[mem[64] + 4 len _6890 + ceil32(return_data.size) + (32 * mem[_6890]) + -mem[64] + 288]
                                                                            else:
                                                                                _6840 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_6840] = 26
                                                                                mem[_6840 + 32] = 'SafeMath: division by zero'
                                                                                _7162 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_7162] = 30
                                                                                mem[_7162 + 32] = 'SafeMath: subtraction overflow'
                                                                                if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                    revert with 0, 17
                                                                                _7501 = mem[64]
                                                                                mem[mem[64]] = 2
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_7501 + 32 len 64] = call.data[calldata.size len 64]
                                                                                if 0 >= mem[_7501]:
                                                                                    revert with 0, 50
                                                                                mem[_7501 + 32] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_7501 + 96] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _7501 + ceil32(return_data.size) + 96
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                if 1 >= mem[_7501]:
                                                                                    revert with 0, 50
                                                                                mem[_7501 + 64] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                allowance[msg.sender][stor20].field_255 = 0
                                                                                emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                                mem[_7501 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_7501 + ceil32(return_data.size) + 100] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                mem[_7501 + ceil32(return_data.size) + 132] = 0
                                                                                mem[_7501 + ceil32(return_data.size) + 164] = 160
                                                                                mem[_7501 + ceil32(return_data.size) + 260] = mem[_7501]
                                                                                idx = 0
                                                                                s = _7501 + ceil32(return_data.size) + 292
                                                                                t = _7501 + 32
                                                                                while idx < mem[_7501]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                mem[_7501 + ceil32(return_data.size) + 196] = this.address
                                                                                mem[_7501 + ceil32(return_data.size) + 228] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                     gas gas_remaining wei
                                                                                    args mem[mem[64] + 4 len _7501 + ceil32(return_data.size) + (32 * mem[_7501]) + -mem[64] + 288]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                _9545 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_9545] = 30
                                                                                mem[_9545 + 32] = 'SafeMath: subtraction overflow'
                                                                                if eth.balance(this.address) > eth.balance(this.address):
                                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                if eth.balance(this.address) < eth.balance(this.address):
                                                                                    revert with 0, 17
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                                mem[mem[64] + 68] = 0
                                                                                mem[mem[64] + 100] = 0
                                                                                mem[mem[64] + 132] = 0
                                                                                mem[mem[64] + 164] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                     gas gas_remaining wei
                                                                                    args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                                require return_data.size >= 96
                                                                                mem[mem[64] + 32] = 0
                                                                                mem[mem[64] + 64] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                                mem[0] = this.address
                                                                                mem[32] = 2
                                                                                _10773 = mem[64]
                                                                                mem[mem[64]] = 2
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_10773 + 32 len 64] = call.data[calldata.size len 64]
                                                                                if 0 >= mem[_10773]:
                                                                                    revert with 0, 50
                                                                                mem[_10773 + 32] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_10773 + 96] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _10773 + ceil32(return_data.size) + 96
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                if 1 >= mem[_10773]:
                                                                                    revert with 0, 50
                                                                                mem[_10773 + 64] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                mem[_10773 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_10773 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                                mem[_10773 + ceil32(return_data.size) + 132] = 0
                                                                                mem[_10773 + ceil32(return_data.size) + 164] = 160
                                                                                mem[_10773 + ceil32(return_data.size) + 260] = mem[_10773]
                                                                                idx = 0
                                                                                s = _10773 + ceil32(return_data.size) + 292
                                                                                t = _10773 + 32
                                                                                while idx < mem[_10773]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                mem[_10773 + ceil32(return_data.size) + 196] = this.address
                                                                                mem[_10773 + ceil32(return_data.size) + 228] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                     gas gas_remaining wei
                                                                                    args mem[mem[64] + 4 len _10773 + ceil32(return_data.size) + (32 * mem[_10773]) + -mem[64] + 288]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        uint8(stor30.field_0) = 0
                                                                        if not msg.sender:
                                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                                        if not this.address:
                                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                                        if stor33[address(msg.sender)]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        if stor33[address(this.address)]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                        require ext_code.size(nodeRewardManagementAddress)
                                                                        call nodeRewardManagementAddress.0x37696eec with:
                                                                             gas gas_remaining wei
                                                                            args msg.sender, uint8(cd[4])
                                                                    else:
                                                                        _6030 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_6030 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_6030]:
                                                                            revert with 0, 50
                                                                        mem[_6030 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_6030 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _6030 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_6030]:
                                                                            revert with 0, 50
                                                                        mem[_6030 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = swapTokensAmount * rewardsFee / 100 * stor29 / 100
                                                                        emit Approval((swapTokensAmount * rewardsFee / 100 * stor29 / 100), msg.sender, uniV2RouterAddress);
                                                                        mem[_6030 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_6030 + ceil32(return_data.size) + 100] = swapTokensAmount * rewardsFee / 100 * stor29 / 100
                                                                        mem[_6030 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_6030 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_6030 + ceil32(return_data.size) + 260] = mem[_6030]
                                                                        idx = 0
                                                                        s = _6030 + ceil32(return_data.size) + 292
                                                                        t = _6030 + 32
                                                                        while idx < mem[_6030]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[_6030 + ceil32(return_data.size) + 196] = this.address
                                                                        mem[_6030 + ceil32(return_data.size) + 228] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                             gas gas_remaining wei
                                                                            args swapTokensAmount * rewardsFee / 100 * stor29 / 100, 0, 160, address(this.address), block.timestamp, mem[_6030 + ceil32(return_data.size) + 260 len (32 * mem[_6030]) + 32]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[_6030 + ceil32(return_data.size) + 96] = 30
                                                                        mem[_6030 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                                                        if eth.balance(this.address) > eth.balance(this.address):
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if eth.balance(this.address) < eth.balance(this.address):
                                                                            revert with 0, 17
                                                                        call distributionPoolAddress with:
                                                                             gas 30000 wei
                                                                        if not return_data.size:
                                                                            mem[_6030 + ceil32(return_data.size) + 160] = 30
                                                                            mem[_6030 + ceil32(return_data.size) + 192] = 'SafeMath: subtraction overflow'
                                                                            if swapTokensAmount * rewardsFee / 100 * stor29 / 100 > swapTokensAmount * rewardsFee / 100:
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if swapTokensAmount * rewardsFee / 100 < swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                                revert with 0, 17
                                                                            if not this.address:
                                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                                            if not distributionPoolAddress:
                                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                                            if stor33[address(this.address)]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            if stor33[stor24]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            emit Transfer(((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)), this.address, distributionPoolAddress);
                                                                            if not swapTokensAmount:
                                                                                mem[_6030 + ceil32(return_data.size) + 288] = 2
                                                                                mem[_6030 + ceil32(return_data.size) + 320] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_6030 + ceil32(return_data.size) + 384] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _6030 + (2 * ceil32(return_data.size)) + 384
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                mem[_6030 + ceil32(return_data.size) + 352] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                mem[_6030 + (2 * ceil32(return_data.size)) + 384] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_6030 + (2 * ceil32(return_data.size)) + 388] = balanceOf[address(this.address)]
                                                                                mem[_6030 + (2 * ceil32(return_data.size)) + 420] = 0
                                                                                mem[_6030 + (2 * ceil32(return_data.size)) + 452] = 160
                                                                                mem[_6030 + (2 * ceil32(return_data.size)) + 548] = 2
                                                                                idx = 0
                                                                                s = _6030 + (2 * ceil32(return_data.size)) + 580
                                                                                t = _6030 + ceil32(return_data.size) + 320
                                                                                while idx < mem[_6030 + ceil32(return_data.size) + 288]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                mem[_6030 + (2 * ceil32(return_data.size)) + 484] = this.address
                                                                                mem[_6030 + (2 * ceil32(return_data.size)) + 516] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                     gas gas_remaining wei
                                                                                    args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_6030 + (2 * ceil32(return_data.size)) + 548 len (32 * mem[_6030 + ceil32(return_data.size) + 288]) + 32]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                uint8(stor30.field_0) = 0
                                                                                if not msg.sender:
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + 384] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + 388] = 32
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + 420] = 37
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + 452] = 'ERC20: transfer from the zero ad'
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + 484] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                                    revert with memory
                                                                                      from _6030 + (2 * ceil32(return_data.size)) + 384
                                                                                       len ceil32(return_data.size) + 132
                                                                                if not this.address:
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + 384] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + 388] = 32
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + 420] = 35
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + 452] = 'ERC20: transfer to the zero addr'
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + 484] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                                    revert with memory
                                                                                      from _6030 + (2 * ceil32(return_data.size)) + 384
                                                                                       len ceil32(return_data.size) + 132
                                                                                if stor33[address(msg.sender)]:
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + 384] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + 388] = 32
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + 420] = 19
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + 452] = 'Blacklisted address' << 104
                                                                                    revert with memory
                                                                                      from _6030 + (2 * ceil32(return_data.size)) + 384
                                                                                       len ceil32(return_data.size) + 100
                                                                                if stor33[address(this.address)]:
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + 384] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + 388] = 32
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + 420] = 19
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + 452] = 'Blacklisted address' << 104
                                                                                    revert with memory
                                                                                      from _6030 + (2 * ceil32(return_data.size)) + 384
                                                                                       len ceil32(return_data.size) + 100
                                                                                emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                                mem[_6030 + (2 * ceil32(return_data.size)) + 388] = msg.sender
                                                                                mem[_6030 + (2 * ceil32(return_data.size)) + 420] = uint8(cd[4])
                                                                                require ext_code.size(nodeRewardManagementAddress)
                                                                                call nodeRewardManagementAddress.0x37696eec with:
                                                                                     gas gas_remaining wei
                                                                                    args mem[_6030 + (2 * ceil32(return_data.size)) + 388 len ceil32(return_data.size) + 64]
                                                                            else:
                                                                                if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                                    revert with 0, 17
                                                                                if not swapTokensAmount:
                                                                                    revert with 0, 18
                                                                                if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                                mem[_6030 + ceil32(return_data.size) + 224] = 26
                                                                                mem[_6030 + ceil32(return_data.size) + 256] = 'SafeMath: division by zero'
                                                                                if not swapTokensAmount * liquidityPoolFee / 100:
                                                                                    mem[_6030 + ceil32(return_data.size) + 288] = 2
                                                                                    mem[_6030 + ceil32(return_data.size) + 320] = this.address
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                            gas gas_remaining wei
                                                                                    mem[_6030 + ceil32(return_data.size) + 384] = ext_call.return_data[0]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = _6030 + (2 * ceil32(return_data.size)) + 384
                                                                                    require return_data.size >= 32
                                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                    mem[_6030 + ceil32(return_data.size) + 352] = ext_call.return_data[12 len 20]
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                    emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + 384] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + 388] = balanceOf[address(this.address)]
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + 420] = 0
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + 452] = 160
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + 548] = 2
                                                                                    idx = 0
                                                                                    s = _6030 + (2 * ceil32(return_data.size)) + 580
                                                                                    t = _6030 + ceil32(return_data.size) + 320
                                                                                    while idx < mem[_6030 + ceil32(return_data.size) + 288]:
                                                                                        mem[s] = mem[t + 12 len 20]
                                                                                        idx = idx + 1
                                                                                        s = s + 32
                                                                                        t = t + 32
                                                                                        continue 
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + 484] = this.address
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + 516] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                         gas gas_remaining wei
                                                                                        args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_6030 + (2 * ceil32(return_data.size)) + 548 len (32 * mem[_6030 + ceil32(return_data.size) + 288]) + 32]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    uint8(stor30.field_0) = 0
                                                                                    if not msg.sender:
                                                                                        mem[_6030 + (2 * ceil32(return_data.size)) + 384] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[_6030 + (2 * ceil32(return_data.size)) + 388] = 32
                                                                                        mem[_6030 + (2 * ceil32(return_data.size)) + 420] = 37
                                                                                        mem[_6030 + (2 * ceil32(return_data.size)) + 452] = 'ERC20: transfer from the zero ad'
                                                                                        mem[_6030 + (2 * ceil32(return_data.size)) + 484] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                                        revert with memory
                                                                                          from _6030 + (2 * ceil32(return_data.size)) + 384
                                                                                           len ceil32(return_data.size) + 132
                                                                                    if not this.address:
                                                                                        mem[_6030 + (2 * ceil32(return_data.size)) + 384] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[_6030 + (2 * ceil32(return_data.size)) + 388] = 32
                                                                                        mem[_6030 + (2 * ceil32(return_data.size)) + 420] = 35
                                                                                        mem[_6030 + (2 * ceil32(return_data.size)) + 452] = 'ERC20: transfer to the zero addr'
                                                                                        mem[_6030 + (2 * ceil32(return_data.size)) + 484] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                                        revert with memory
                                                                                          from _6030 + (2 * ceil32(return_data.size)) + 384
                                                                                           len ceil32(return_data.size) + 132
                                                                                    if stor33[address(msg.sender)]:
                                                                                        mem[_6030 + (2 * ceil32(return_data.size)) + 384] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[_6030 + (2 * ceil32(return_data.size)) + 388] = 32
                                                                                        mem[_6030 + (2 * ceil32(return_data.size)) + 420] = 19
                                                                                        mem[_6030 + (2 * ceil32(return_data.size)) + 452] = 'Blacklisted address' << 104
                                                                                        revert with memory
                                                                                          from _6030 + (2 * ceil32(return_data.size)) + 384
                                                                                           len ceil32(return_data.size) + 100
                                                                                    if stor33[address(this.address)]:
                                                                                        mem[_6030 + (2 * ceil32(return_data.size)) + 384] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[_6030 + (2 * ceil32(return_data.size)) + 388] = 32
                                                                                        mem[_6030 + (2 * ceil32(return_data.size)) + 420] = 19
                                                                                        mem[_6030 + (2 * ceil32(return_data.size)) + 452] = 'Blacklisted address' << 104
                                                                                        revert with memory
                                                                                          from _6030 + (2 * ceil32(return_data.size)) + 384
                                                                                           len ceil32(return_data.size) + 100
                                                                                    emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + 388] = msg.sender
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + 420] = uint8(cd[4])
                                                                                    require ext_code.size(nodeRewardManagementAddress)
                                                                                    call nodeRewardManagementAddress.0x37696eec with:
                                                                                         gas gas_remaining wei
                                                                                        args mem[_6030 + (2 * ceil32(return_data.size)) + 388 len ceil32(return_data.size) + 64]
                                                                                else:
                                                                                    mem[_6030 + ceil32(return_data.size) + 288] = 26
                                                                                    mem[_6030 + ceil32(return_data.size) + 320] = 'SafeMath: division by zero'
                                                                                    mem[_6030 + ceil32(return_data.size) + 352] = 30
                                                                                    mem[_6030 + ceil32(return_data.size) + 384] = 'SafeMath: subtraction overflow'
                                                                                    if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                    if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                        revert with 0, 17
                                                                                    mem[_6030 + ceil32(return_data.size) + 416] = 2
                                                                                    mem[_6030 + ceil32(return_data.size) + 448] = this.address
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                            gas gas_remaining wei
                                                                                    mem[_6030 + ceil32(return_data.size) + 512] = ext_call.return_data[0]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = _6030 + (2 * ceil32(return_data.size)) + 512
                                                                                    require return_data.size >= 32
                                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                    mem[_6030 + ceil32(return_data.size) + 480] = ext_call.return_data[12 len 20]
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                    allowance[msg.sender][stor20].field_255 = 0
                                                                                    emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + 512] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + 516] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + 548] = 0
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + 580] = 160
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + 676] = 2
                                                                                    idx = 0
                                                                                    s = _6030 + (2 * ceil32(return_data.size)) + 708
                                                                                    t = _6030 + ceil32(return_data.size) + 448
                                                                                    while idx < mem[_6030 + ceil32(return_data.size) + 416]:
                                                                                        mem[s] = mem[t + 12 len 20]
                                                                                        idx = idx + 1
                                                                                        s = s + 32
                                                                                        t = t + 32
                                                                                        continue 
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + 612] = this.address
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + 644] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                         gas gas_remaining wei
                                                                                        args Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_6030 + (2 * ceil32(return_data.size)) + 676 len (32 * mem[_6030 + ceil32(return_data.size) + 416]) + 32]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + 512] = 30
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + 544] = 'SafeMath: subtraction overflow'
                                                                                    if eth.balance(this.address) > eth.balance(this.address):
                                                                                        mem[_6030 + (2 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[_6030 + (2 * ceil32(return_data.size)) + 580] = 32
                                                                                        mem[_6030 + (2 * ceil32(return_data.size)) + 612] = 30
                                                                                        mem[_6030 + (2 * ceil32(return_data.size)) + 644] = 'SafeMath: subtraction overflow'
                                                                                        mem[_6030 + (2 * ceil32(return_data.size)) + 674] = 0
                                                                                        revert with memory
                                                                                          from _6030 + (2 * ceil32(return_data.size)) + 576
                                                                                           len ceil32(return_data.size) + 100
                                                                                    if eth.balance(this.address) < eth.balance(this.address):
                                                                                        revert with 0, 17
                                                                                    allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                    emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + 580] = this.address
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + 612] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + 644] = 0
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + 676] = 0
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + 708] = 0
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + 740] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                         gas gas_remaining wei
                                                                                        args mem[_6030 + (2 * ceil32(return_data.size)) + 580 len ceil32(return_data.size) + 192]
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + 576 len 96] = ext_call.return_data[0 len 96]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    require return_data.size >= 96
                                                                                    mem[_6030 + (4 * ceil32(return_data.size)) + 576] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                    mem[_6030 + (4 * ceil32(return_data.size)) + 608] = 0
                                                                                    mem[_6030 + (4 * ceil32(return_data.size)) + 640] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                    emit SwapAndLiquify(uint256 arg1, uint256 arg2, uint256 arg3):
                                                                                                        mem[_6030 + (4 * ceil32(return_data.size)) + 576 len (5 * ceil32(return_data.size)) + 96],
                                                                                    mem[_6030 + (4 * ceil32(return_data.size)) + 576] = 2
                                                                                    mem[_6030 + (4 * ceil32(return_data.size)) + 608] = this.address
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                            gas gas_remaining wei
                                                                                    mem[_6030 + (4 * ceil32(return_data.size)) + 672] = ext_call.return_data[0]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = _6030 + (6 * ceil32(return_data.size)) + 672
                                                                                    require return_data.size >= 32
                                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                    mem[_6030 + (4 * ceil32(return_data.size)) + 640] = ext_call.return_data[12 len 20]
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                    emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                    mem[_6030 + (6 * ceil32(return_data.size)) + 672] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                    mem[_6030 + (6 * ceil32(return_data.size)) + 676] = balanceOf[address(this.address)]
                                                                                    mem[_6030 + (6 * ceil32(return_data.size)) + 708] = 0
                                                                                    mem[_6030 + (6 * ceil32(return_data.size)) + 740] = 160
                                                                                    mem[_6030 + (6 * ceil32(return_data.size)) + 836] = 2
                                                                                    idx = 0
                                                                                    s = _6030 + (6 * ceil32(return_data.size)) + 868
                                                                                    t = _6030 + (4 * ceil32(return_data.size)) + 608
                                                                                    while idx < mem[_6030 + (4 * ceil32(return_data.size)) + 576]:
                                                                                        mem[s] = mem[t + 12 len 20]
                                                                                        idx = idx + 1
                                                                                        s = s + 32
                                                                                        t = t + 32
                                                                                        continue 
                                                                                    mem[_6030 + (6 * ceil32(return_data.size)) + 772] = this.address
                                                                                    mem[_6030 + (6 * ceil32(return_data.size)) + 804] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                         gas gas_remaining wei
                                                                                        args mem[mem[64] + 4 len _6030 + (6 * ceil32(return_data.size)) + (32 * mem[_6030 + (4 * ceil32(return_data.size)) + 576]) + -mem[64] + 864]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    uint8(stor30.field_0) = 0
                                                                                    if not msg.sender:
                                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                                    if not this.address:
                                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                                    if stor33[address(msg.sender)]:
                                                                                        revert with 0, 'Blacklisted address'
                                                                                    if stor33[address(this.address)]:
                                                                                        revert with 0, 'Blacklisted address'
                                                                                    emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                                    require ext_code.size(nodeRewardManagementAddress)
                                                                                    call nodeRewardManagementAddress.0x37696eec with:
                                                                                         gas gas_remaining wei
                                                                                        args msg.sender, uint8(cd[4])
                                                                        else:
                                                                            mem[_6030 + ceil32(return_data.size) + 160] = return_data.size
                                                                            mem[_6030 + ceil32(return_data.size) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                            mem[_6030 + ceil32(return_data.size) + ceil32(return_data.size) + 161] = 30
                                                                            mem[_6030 + ceil32(return_data.size) + ceil32(return_data.size) + 193] = 'SafeMath: subtraction overflow'
                                                                            if swapTokensAmount * rewardsFee / 100 * stor29 / 100 > swapTokensAmount * rewardsFee / 100:
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if swapTokensAmount * rewardsFee / 100 < swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                                revert with 0, 17
                                                                            if not this.address:
                                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                                            if not distributionPoolAddress:
                                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                                            if stor33[address(this.address)]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            if stor33[stor24]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            emit Transfer(((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)), this.address, distributionPoolAddress);
                                                                            if not swapTokensAmount:
                                                                                mem[_6030 + ceil32(return_data.size) + ceil32(return_data.size) + 289] = 2
                                                                                mem[_6030 + ceil32(return_data.size) + ceil32(return_data.size) + 321] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_6030 + ceil32(return_data.size) + ceil32(return_data.size) + 385] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 385
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                mem[_6030 + ceil32(return_data.size) + ceil32(return_data.size) + 353] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                mem[_6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 385] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 389] = balanceOf[address(this.address)]
                                                                                mem[_6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 421] = 0
                                                                                mem[_6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 453] = 160
                                                                                mem[_6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 549] = 2
                                                                                idx = 0
                                                                                s = _6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 581
                                                                                t = _6030 + ceil32(return_data.size) + ceil32(return_data.size) + 321
                                                                                while idx < mem[_6030 + ceil32(return_data.size) + ceil32(return_data.size) + 289]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                mem[_6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 485] = this.address
                                                                                mem[_6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 517] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                     gas gas_remaining wei
                                                                                    args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 549 len (32 * mem[_6030 + ceil32(return_data.size) + ceil32(return_data.size) + 289]) + 32]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                uint8(stor30.field_0) = 0
                                                                                if not msg.sender:
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 385] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 389] = 32
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 421] = 37
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 453] = 'ERC20: transfer from the zero ad'
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 485] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                                    revert with memory
                                                                                      from _6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 385
                                                                                       len ceil32(return_data.size) + 132
                                                                                if not this.address:
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 385] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 389] = 32
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 421] = 35
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 453] = 'ERC20: transfer to the zero addr'
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 485] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                                    revert with memory
                                                                                      from _6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 385
                                                                                       len ceil32(return_data.size) + 132
                                                                                if stor33[address(msg.sender)]:
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 385] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 389] = 32
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 421] = 19
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 453] = 'Blacklisted address' << 104
                                                                                    revert with memory
                                                                                      from _6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 385
                                                                                       len ceil32(return_data.size) + 100
                                                                                if stor33[address(this.address)]:
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 385] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 389] = 32
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 421] = 19
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 453] = 'Blacklisted address' << 104
                                                                                    revert with memory
                                                                                      from _6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 385
                                                                                       len ceil32(return_data.size) + 100
                                                                                emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                                mem[_6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 389] = msg.sender
                                                                                mem[_6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 421] = uint8(cd[4])
                                                                                require ext_code.size(nodeRewardManagementAddress)
                                                                                call nodeRewardManagementAddress.0x37696eec with:
                                                                                     gas gas_remaining wei
                                                                                    args mem[_6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 389 len ceil32(return_data.size) + 64]
                                                                            else:
                                                                                if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                                    revert with 0, 17
                                                                                if not swapTokensAmount:
                                                                                    revert with 0, 18
                                                                                if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                                mem[_6030 + ceil32(return_data.size) + ceil32(return_data.size) + 225] = 26
                                                                                mem[_6030 + ceil32(return_data.size) + ceil32(return_data.size) + 257] = 'SafeMath: division by zero'
                                                                                if not swapTokensAmount * liquidityPoolFee / 100:
                                                                                    mem[_6030 + ceil32(return_data.size) + ceil32(return_data.size) + 289] = 2
                                                                                    mem[_6030 + ceil32(return_data.size) + ceil32(return_data.size) + 321] = this.address
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                            gas gas_remaining wei
                                                                                    mem[_6030 + ceil32(return_data.size) + ceil32(return_data.size) + 385] = ext_call.return_data[0]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = _6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 385
                                                                                    require return_data.size >= 32
                                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                    mem[_6030 + ceil32(return_data.size) + ceil32(return_data.size) + 353] = ext_call.return_data[12 len 20]
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                    emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 385] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 389] = balanceOf[address(this.address)]
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 421] = 0
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 453] = 160
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 549] = 2
                                                                                    idx = 0
                                                                                    s = _6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 581
                                                                                    t = _6030 + ceil32(return_data.size) + ceil32(return_data.size) + 321
                                                                                    while idx < mem[_6030 + ceil32(return_data.size) + ceil32(return_data.size) + 289]:
                                                                                        mem[s] = mem[t + 12 len 20]
                                                                                        idx = idx + 1
                                                                                        s = s + 32
                                                                                        t = t + 32
                                                                                        continue 
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 485] = this.address
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 517] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                         gas gas_remaining wei
                                                                                        args mem[mem[64] + 4 len _6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * mem[_6030 + ceil32(return_data.size) + ceil32(return_data.size) + 289]) + -mem[64] + 577]
                                                                                else:
                                                                                    mem[_6030 + ceil32(return_data.size) + ceil32(return_data.size) + 289] = 26
                                                                                    mem[_6030 + ceil32(return_data.size) + ceil32(return_data.size) + 321] = 'SafeMath: division by zero'
                                                                                    mem[_6030 + ceil32(return_data.size) + ceil32(return_data.size) + 353] = 30
                                                                                    mem[_6030 + ceil32(return_data.size) + ceil32(return_data.size) + 385] = 'SafeMath: subtraction overflow'
                                                                                    if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                    if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                        revert with 0, 17
                                                                                    mem[_6030 + ceil32(return_data.size) + ceil32(return_data.size) + 417] = 2
                                                                                    mem[_6030 + ceil32(return_data.size) + ceil32(return_data.size) + 449] = this.address
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                            gas gas_remaining wei
                                                                                    mem[_6030 + ceil32(return_data.size) + ceil32(return_data.size) + 513] = ext_call.return_data[0]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = _6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 513
                                                                                    require return_data.size >= 32
                                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                    mem[_6030 + ceil32(return_data.size) + ceil32(return_data.size) + 481] = ext_call.return_data[12 len 20]
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                    allowance[msg.sender][stor20].field_255 = 0
                                                                                    emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 513] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 517] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 549] = 0
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 581] = 160
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 677] = 2
                                                                                    idx = 0
                                                                                    s = _6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 709
                                                                                    t = _6030 + ceil32(return_data.size) + ceil32(return_data.size) + 449
                                                                                    while idx < mem[_6030 + ceil32(return_data.size) + ceil32(return_data.size) + 417]:
                                                                                        mem[s] = mem[t + 12 len 20]
                                                                                        idx = idx + 1
                                                                                        s = s + 32
                                                                                        t = t + 32
                                                                                        continue 
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 613] = this.address
                                                                                    mem[_6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 645] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                         gas gas_remaining wei
                                                                                        args mem[mem[64] + 4 len _6030 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * mem[_6030 + ceil32(return_data.size) + ceil32(return_data.size) + 417]) + -mem[64] + 705]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    _12690 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_12690] = 30
                                                                                    mem[_12690 + 32] = 'SafeMath: subtraction overflow'
                                                                                    if eth.balance(this.address) > eth.balance(this.address):
                                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                    if eth.balance(this.address) < eth.balance(this.address):
                                                                                        revert with 0, 17
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                    emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                                    mem[mem[64] + 68] = 0
                                                                                    mem[mem[64] + 100] = 0
                                                                                    mem[mem[64] + 132] = 0
                                                                                    mem[mem[64] + 164] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                         gas gas_remaining wei
                                                                                        args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    mem[mem[64] + 32] = 0
                                                                                    mem[mem[64] + 64] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                    emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                                    mem[0] = this.address
                                                                                    mem[32] = 2
                                                                                    _13347 = mem[64]
                                                                                    mem[mem[64]] = 2
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_13347 + 32 len 64] = call.data[calldata.size len 64]
                                                                                    if 0 >= mem[_13347]:
                                                                                        revert with 0, 50
                                                                                    mem[_13347 + 32] = this.address
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                            gas gas_remaining wei
                                                                                    mem[_13347 + 96] = ext_call.return_data[0]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = _13347 + ceil32(return_data.size) + 96
                                                                                    require return_data.size >= 32
                                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                    if 1 >= mem[_13347]:
                                                                                        revert with 0, 50
                                                                                    mem[_13347 + 64] = ext_call.return_data[12 len 20]
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                    emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                    mem[_13347 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                    mem[_13347 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                                    mem[_13347 + ceil32(return_data.size) + 132] = 0
                                                                                    mem[_13347 + ceil32(return_data.size) + 164] = 160
                                                                                    mem[_13347 + ceil32(return_data.size) + 260] = mem[_13347]
                                                                                    idx = 0
                                                                                    s = _13347 + ceil32(return_data.size) + 292
                                                                                    t = _13347 + 32
                                                                                    while idx < mem[_13347]:
                                                                                        mem[s] = mem[t + 12 len 20]
                                                                                        idx = idx + 1
                                                                                        s = s + 32
                                                                                        t = t + 32
                                                                                        continue 
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                         gas gas_remaining wei
                                                                                        args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_13347 + ceil32(return_data.size) + 260 len (32 * mem[_13347]) + 32]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                uint8(stor30.field_0) = 0
                                                                                if not msg.sender:
                                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                                if not this.address:
                                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                                if stor33[address(msg.sender)]:
                                                                                    revert with 0, 'Blacklisted address'
                                                                                if stor33[address(this.address)]:
                                                                                    revert with 0, 'Blacklisted address'
                                                                                emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                                require ext_code.size(nodeRewardManagementAddress)
                                                                                call nodeRewardManagementAddress.0x37696eec with:
                                                                                     gas gas_remaining wei
                                                                                    args msg.sender, uint8(cd[4])
                                                        else:
                                                            _4639 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_4639] = 26
                                                            mem[_4639 + 32] = 'SafeMath: division by zero'
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not deadWalletAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            if stor33[address(this.address)]:
                                                                revert with 0, 'Blacklisted address'
                                                            mem[0] = deadWalletAddress
                                                            mem[32] = 33
                                                            if stor33[stor7]:
                                                                revert with 0, 'Blacklisted address'
                                                            emit Transfer(0, this.address, deadWalletAddress);
                                                            if not swapTokensAmount:
                                                                _5098 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_5098] = 26
                                                                mem[_5098 + 32] = 'SafeMath: division by zero'
                                                                _5277 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_5277] = 26
                                                                mem[_5277 + 32] = 'SafeMath: division by zero'
                                                                _5530 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_5530] = 30
                                                                mem[_5530 + 32] = 'SafeMath: subtraction overflow'
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not distributionPoolAddress:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                if stor33[address(this.address)]:
                                                                    revert with 0, 'Blacklisted address'
                                                                mem[0] = distributionPoolAddress
                                                                mem[32] = 33
                                                                if stor33[stor24]:
                                                                    revert with 0, 'Blacklisted address'
                                                                emit Transfer(0, this.address, distributionPoolAddress);
                                                                if not swapTokensAmount:
                                                                    _6079 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_6079] = 26
                                                                    mem[_6079 + 32] = 'SafeMath: division by zero'
                                                                    mem[0] = this.address
                                                                    mem[32] = 2
                                                                    _6299 = mem[64]
                                                                    mem[mem[64]] = 2
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_6299 + 32 len 64] = call.data[calldata.size len 64]
                                                                    if 0 >= mem[_6299]:
                                                                        revert with 0, 50
                                                                    mem[_6299 + 32] = this.address
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                            gas gas_remaining wei
                                                                    mem[_6299 + 96] = ext_call.return_data[0]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _6299 + ceil32(return_data.size) + 96
                                                                    require return_data.size >= 32
                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                    if 1 >= mem[_6299]:
                                                                        revert with 0, 50
                                                                    mem[_6299 + 64] = ext_call.return_data[12 len 20]
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                    emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                    mem[_6299 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                    mem[_6299 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                    mem[_6299 + ceil32(return_data.size) + 132] = 0
                                                                    mem[_6299 + ceil32(return_data.size) + 164] = 160
                                                                    mem[_6299 + ceil32(return_data.size) + 260] = mem[_6299]
                                                                    idx = 0
                                                                    s = _6299 + ceil32(return_data.size) + 292
                                                                    t = _6299 + 32
                                                                    while idx < mem[_6299]:
                                                                        mem[s] = mem[t + 12 len 20]
                                                                        idx = idx + 1
                                                                        s = s + 32
                                                                        t = t + 32
                                                                        continue 
                                                                    mem[_6299 + ceil32(return_data.size) + 196] = this.address
                                                                    mem[_6299 + ceil32(return_data.size) + 228] = block.timestamp
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _6299 + ceil32(return_data.size) + (32 * mem[_6299]) + -mem[64] + 288]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    uint8(stor30.field_0) = 0
                                                                    if not msg.sender:
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    if stor33[address(msg.sender)]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    if stor33[address(this.address)]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                    require ext_code.size(nodeRewardManagementAddress)
                                                                    call nodeRewardManagementAddress.0x37696eec with:
                                                                         gas gas_remaining wei
                                                                        args msg.sender, uint8(cd[4])
                                                                else:
                                                                    if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                        revert with 0, 17
                                                                    if not swapTokensAmount:
                                                                        revert with 0, 18
                                                                    if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                                    _6237 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_6237] = 26
                                                                    mem[_6237 + 32] = 'SafeMath: division by zero'
                                                                    if not swapTokensAmount * liquidityPoolFee / 100:
                                                                        mem[0] = this.address
                                                                        mem[32] = 2
                                                                        _6390 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_6390 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_6390]:
                                                                            revert with 0, 50
                                                                        mem[_6390 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_6390 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _6390 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_6390]:
                                                                            revert with 0, 50
                                                                        mem[_6390 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                        mem[_6390 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_6390 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                        mem[_6390 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_6390 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_6390 + ceil32(return_data.size) + 260] = mem[_6390]
                                                                        idx = 0
                                                                        s = _6390 + ceil32(return_data.size) + 292
                                                                        t = _6390 + 32
                                                                        while idx < mem[_6390]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[_6390 + ceil32(return_data.size) + 196] = this.address
                                                                        mem[_6390 + ceil32(return_data.size) + 228] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                             gas gas_remaining wei
                                                                            args mem[mem[64] + 4 len _6390 + ceil32(return_data.size) + (32 * mem[_6390]) + -mem[64] + 288]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        uint8(stor30.field_0) = 0
                                                                        if not msg.sender:
                                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                                        if not this.address:
                                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                                        if stor33[address(msg.sender)]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        if stor33[address(this.address)]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                        require ext_code.size(nodeRewardManagementAddress)
                                                                        call nodeRewardManagementAddress.0x37696eec with:
                                                                             gas gas_remaining wei
                                                                            args msg.sender, uint8(cd[4])
                                                                    else:
                                                                        _6367 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_6367] = 26
                                                                        mem[_6367 + 32] = 'SafeMath: division by zero'
                                                                        _6562 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_6562] = 30
                                                                        mem[_6562 + 32] = 'SafeMath: subtraction overflow'
                                                                        if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                            revert with 0, 17
                                                                        _6794 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_6794 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_6794]:
                                                                            revert with 0, 50
                                                                        mem[_6794 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_6794 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _6794 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_6794]:
                                                                            revert with 0, 50
                                                                        mem[_6794 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                        allowance[msg.sender][stor20].field_255 = 0
                                                                        emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                        mem[_6794 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_6794 + ceil32(return_data.size) + 100] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                        mem[_6794 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_6794 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_6794 + ceil32(return_data.size) + 260] = mem[_6794]
                                                                        idx = 0
                                                                        s = _6794 + ceil32(return_data.size) + 292
                                                                        t = _6794 + 32
                                                                        while idx < mem[_6794]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                             gas gas_remaining wei
                                                                            args Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_6794 + ceil32(return_data.size) + 260 len (32 * mem[_6794]) + 32]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[_6794 + ceil32(return_data.size) + 96] = 30
                                                                        mem[_6794 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                                                        if eth.balance(this.address) > eth.balance(this.address):
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if eth.balance(this.address) < eth.balance(this.address):
                                                                            revert with 0, 17
                                                                        allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                        emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                        mem[_6794 + ceil32(return_data.size) + 228] = 0
                                                                        mem[_6794 + ceil32(return_data.size) + 260] = 0
                                                                        mem[_6794 + ceil32(return_data.size) + 292] = 0
                                                                        mem[_6794 + ceil32(return_data.size) + 324] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                             gas gas_remaining wei
                                                                            args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                        mem[_6794 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        require return_data.size >= 96
                                                                        emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                        mem[_6794 + (2 * ceil32(return_data.size)) + 160] = 2
                                                                        mem[_6794 + (2 * ceil32(return_data.size)) + 192] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_6794 + (2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _6794 + (4 * ceil32(return_data.size)) + 256
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        mem[_6794 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                        mem[_6794 + (4 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_6794 + (4 * ceil32(return_data.size)) + 260] = balanceOf[address(this.address)]
                                                                        mem[_6794 + (4 * ceil32(return_data.size)) + 292] = 0
                                                                        mem[_6794 + (4 * ceil32(return_data.size)) + 324] = 160
                                                                        mem[_6794 + (4 * ceil32(return_data.size)) + 420] = 2
                                                                        idx = 0
                                                                        s = _6794 + (4 * ceil32(return_data.size)) + 452
                                                                        t = _6794 + (2 * ceil32(return_data.size)) + 192
                                                                        while idx < mem[_6794 + (2 * ceil32(return_data.size)) + 160]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[_6794 + (4 * ceil32(return_data.size)) + 356] = this.address
                                                                        mem[_6794 + (4 * ceil32(return_data.size)) + 388] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                             gas gas_remaining wei
                                                                            args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_6794 + (4 * ceil32(return_data.size)) + 420 len (32 * mem[_6794 + (2 * ceil32(return_data.size)) + 160]) + 32]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        uint8(stor30.field_0) = 0
                                                                        if not msg.sender:
                                                                            mem[_6794 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[_6794 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                            mem[_6794 + (4 * ceil32(return_data.size)) + 292] = 37
                                                                            mem[_6794 + (4 * ceil32(return_data.size)) + 324] = 'ERC20: transfer from the zero ad'
                                                                            mem[_6794 + (4 * ceil32(return_data.size)) + 356] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                            revert with memory
                                                                              from _6794 + (4 * ceil32(return_data.size)) + 256
                                                                               len (5 * ceil32(return_data.size)) + 132
                                                                        if not this.address:
                                                                            mem[_6794 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[_6794 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                            mem[_6794 + (4 * ceil32(return_data.size)) + 292] = 35
                                                                            mem[_6794 + (4 * ceil32(return_data.size)) + 324] = 'ERC20: transfer to the zero addr'
                                                                            mem[_6794 + (4 * ceil32(return_data.size)) + 356] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                            revert with memory
                                                                              from _6794 + (4 * ceil32(return_data.size)) + 256
                                                                               len (5 * ceil32(return_data.size)) + 132
                                                                        if stor33[address(msg.sender)]:
                                                                            mem[_6794 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[_6794 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                            mem[_6794 + (4 * ceil32(return_data.size)) + 292] = 19
                                                                            mem[_6794 + (4 * ceil32(return_data.size)) + 324] = 'Blacklisted address' << 104
                                                                            revert with memory
                                                                              from _6794 + (4 * ceil32(return_data.size)) + 256
                                                                               len (5 * ceil32(return_data.size)) + 100
                                                                        if stor33[address(this.address)]:
                                                                            mem[_6794 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[_6794 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                            mem[_6794 + (4 * ceil32(return_data.size)) + 292] = 19
                                                                            mem[_6794 + (4 * ceil32(return_data.size)) + 324] = 'Blacklisted address' << 104
                                                                            revert with memory
                                                                              from _6794 + (4 * ceil32(return_data.size)) + 256
                                                                               len (5 * ceil32(return_data.size)) + 100
                                                                        emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                        mem[_6794 + (4 * ceil32(return_data.size)) + 260] = msg.sender
                                                                        mem[_6794 + (4 * ceil32(return_data.size)) + 292] = uint8(cd[4])
                                                                        require ext_code.size(nodeRewardManagementAddress)
                                                                        call nodeRewardManagementAddress.0x37696eec with:
                                                                             gas gas_remaining wei
                                                                            args mem[_6794 + (4 * ceil32(return_data.size)) + 260 len (5 * ceil32(return_data.size)) + 64]
                                                            else:
                                                                if swapTokensAmount and rewardsFee > -1 / swapTokensAmount:
                                                                    revert with 0, 17
                                                                if not swapTokensAmount:
                                                                    revert with 0, 18
                                                                if swapTokensAmount * rewardsFee / swapTokensAmount != rewardsFee:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                _5183 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_5183] = 26
                                                                mem[_5183 + 32] = 'SafeMath: division by zero'
                                                                if not swapTokensAmount * rewardsFee / 100:
                                                                    _5491 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_5491] = 26
                                                                    mem[_5491 + 32] = 'SafeMath: division by zero'
                                                                    _5641 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_5641] = 30
                                                                    mem[_5641 + 32] = 'SafeMath: subtraction overflow'
                                                                    if 0 > swapTokensAmount * rewardsFee / 100:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if swapTokensAmount * rewardsFee / 100 < 0:
                                                                        revert with 0, 17
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not distributionPoolAddress:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    if stor33[address(this.address)]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    mem[0] = distributionPoolAddress
                                                                    mem[32] = 33
                                                                    if stor33[stor24]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    emit Transfer((swapTokensAmount * rewardsFee / 100), this.address, distributionPoolAddress);
                                                                    if not swapTokensAmount:
                                                                        _6236 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_6236] = 26
                                                                        mem[_6236 + 32] = 'SafeMath: division by zero'
                                                                        mem[0] = this.address
                                                                        mem[32] = 2
                                                                        _6388 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_6388 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_6388]:
                                                                            revert with 0, 50
                                                                        mem[_6388 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_6388 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _6388 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_6388]:
                                                                            revert with 0, 50
                                                                        mem[_6388 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                        mem[_6388 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_6388 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                        mem[_6388 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_6388 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_6388 + ceil32(return_data.size) + 260] = mem[_6388]
                                                                        idx = 0
                                                                        s = _6388 + ceil32(return_data.size) + 292
                                                                        t = _6388 + 32
                                                                        while idx < mem[_6388]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                             gas gas_remaining wei
                                                                            args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_6388 + ceil32(return_data.size) + 260 len (32 * mem[_6388]) + 32]
                                                                    else:
                                                                        if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                            revert with 0, 17
                                                                        if not swapTokensAmount:
                                                                            revert with 0, 18
                                                                        if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                                        _6323 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_6323] = 26
                                                                        mem[_6323 + 32] = 'SafeMath: division by zero'
                                                                        if not swapTokensAmount * liquidityPoolFee / 100:
                                                                            mem[0] = this.address
                                                                            mem[32] = 2
                                                                            _6532 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_6532 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_6532]:
                                                                                revert with 0, 50
                                                                            mem[_6532 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_6532 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _6532 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_6532]:
                                                                                revert with 0, 50
                                                                            mem[_6532 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_6532 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_6532 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                            mem[_6532 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_6532 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_6532 + ceil32(return_data.size) + 260] = mem[_6532]
                                                                            idx = 0
                                                                            s = _6532 + ceil32(return_data.size) + 292
                                                                            t = _6532 + 32
                                                                            while idx < mem[_6532]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            mem[_6532 + ceil32(return_data.size) + 196] = this.address
                                                                            mem[_6532 + ceil32(return_data.size) + 228] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                 gas gas_remaining wei
                                                                                args mem[mem[64] + 4 len _6532 + ceil32(return_data.size) + (32 * mem[_6532]) + -mem[64] + 288]
                                                                        else:
                                                                            _6500 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_6500] = 26
                                                                            mem[_6500 + 32] = 'SafeMath: division by zero'
                                                                            _6735 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_6735] = 30
                                                                            mem[_6735 + 32] = 'SafeMath: subtraction overflow'
                                                                            if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                revert with 0, 17
                                                                            _7003 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_7003 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_7003]:
                                                                                revert with 0, 50
                                                                            mem[_7003 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_7003 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _7003 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_7003]:
                                                                                revert with 0, 50
                                                                            mem[_7003 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                            allowance[msg.sender][stor20].field_255 = 0
                                                                            emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                            mem[_7003 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_7003 + ceil32(return_data.size) + 100] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                            mem[_7003 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_7003 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_7003 + ceil32(return_data.size) + 260] = mem[_7003]
                                                                            idx = 0
                                                                            s = _7003 + ceil32(return_data.size) + 292
                                                                            t = _7003 + 32
                                                                            while idx < mem[_7003]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                 gas gas_remaining wei
                                                                                args Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_7003 + ceil32(return_data.size) + 260 len (32 * mem[_7003]) + 32]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[_7003 + ceil32(return_data.size) + 96] = 30
                                                                            mem[_7003 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                                                            if eth.balance(this.address) > eth.balance(this.address):
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if eth.balance(this.address) < eth.balance(this.address):
                                                                                revert with 0, 17
                                                                            allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                            emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                            mem[_7003 + ceil32(return_data.size) + 228] = 0
                                                                            mem[_7003 + ceil32(return_data.size) + 260] = 0
                                                                            mem[_7003 + ceil32(return_data.size) + 292] = 0
                                                                            mem[_7003 + ceil32(return_data.size) + 324] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                 gas gas_remaining wei
                                                                                args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                            mem[_7003 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            require return_data.size >= 96
                                                                            emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                            mem[_7003 + (2 * ceil32(return_data.size)) + 160] = 2
                                                                            mem[_7003 + (2 * ceil32(return_data.size)) + 192] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_7003 + (2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _7003 + (4 * ceil32(return_data.size)) + 256
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            mem[_7003 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_7003 + (4 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_7003 + (4 * ceil32(return_data.size)) + 260] = balanceOf[address(this.address)]
                                                                            mem[_7003 + (4 * ceil32(return_data.size)) + 292] = 0
                                                                            mem[_7003 + (4 * ceil32(return_data.size)) + 324] = 160
                                                                            mem[_7003 + (4 * ceil32(return_data.size)) + 420] = 2
                                                                            idx = 0
                                                                            s = _7003 + (4 * ceil32(return_data.size)) + 452
                                                                            t = _7003 + (2 * ceil32(return_data.size)) + 192
                                                                            while idx < mem[_7003 + (2 * ceil32(return_data.size)) + 160]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            mem[_7003 + (4 * ceil32(return_data.size)) + 356] = this.address
                                                                            mem[_7003 + (4 * ceil32(return_data.size)) + 388] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                 gas gas_remaining wei
                                                                                args mem[mem[64] + 4 len _7003 + (4 * ceil32(return_data.size)) + (32 * mem[_7003 + (2 * ceil32(return_data.size)) + 160]) + -mem[64] + 448]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    uint8(stor30.field_0) = 0
                                                                    if not msg.sender:
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    if stor33[address(msg.sender)]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    if stor33[address(this.address)]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                    require ext_code.size(nodeRewardManagementAddress)
                                                                    call nodeRewardManagementAddress.0x37696eec with:
                                                                         gas gas_remaining wei
                                                                        args msg.sender, uint8(cd[4])
                                                                else:
                                                                    if swapTokensAmount * rewardsFee / 100 and stor29 > -1 / swapTokensAmount * rewardsFee / 100:
                                                                        revert with 0, 17
                                                                    if not swapTokensAmount * rewardsFee / 100:
                                                                        revert with 0, 18
                                                                    if swapTokensAmount * rewardsFee / 100 * stor29 / swapTokensAmount * rewardsFee / 100 != stor29:
                                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                                    _5589 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_5589] = 26
                                                                    mem[_5589 + 32] = 'SafeMath: division by zero'
                                                                    if not swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                        _5793 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_5793] = 30
                                                                        mem[_5793 + 32] = 'SafeMath: subtraction overflow'
                                                                        if swapTokensAmount * rewardsFee / 100 * stor29 / 100 > swapTokensAmount * rewardsFee / 100:
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if swapTokensAmount * rewardsFee / 100 < swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                            revert with 0, 17
                                                                        if not this.address:
                                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                                        if not distributionPoolAddress:
                                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                                        if stor33[address(this.address)]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        mem[0] = distributionPoolAddress
                                                                        mem[32] = 33
                                                                        if stor33[stor24]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        emit Transfer(((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)), this.address, distributionPoolAddress);
                                                                        if not swapTokensAmount:
                                                                            _6322 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_6322] = 26
                                                                            mem[_6322 + 32] = 'SafeMath: division by zero'
                                                                            mem[0] = this.address
                                                                            mem[32] = 2
                                                                            _6528 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_6528 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_6528]:
                                                                                revert with 0, 50
                                                                            mem[_6528 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_6528 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _6528 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_6528]:
                                                                                revert with 0, 50
                                                                            mem[_6528 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_6528 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_6528 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                            mem[_6528 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_6528 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_6528 + ceil32(return_data.size) + 260] = mem[_6528]
                                                                            idx = 0
                                                                            s = _6528 + ceil32(return_data.size) + 292
                                                                            t = _6528 + 32
                                                                            while idx < mem[_6528]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            mem[_6528 + ceil32(return_data.size) + 196] = this.address
                                                                            mem[_6528 + ceil32(return_data.size) + 228] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                 gas gas_remaining wei
                                                                                args mem[mem[64] + 4 len _6528 + ceil32(return_data.size) + (32 * mem[_6528]) + -mem[64] + 288]
                                                                        else:
                                                                            if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                                revert with 0, 17
                                                                            if not swapTokensAmount:
                                                                                revert with 0, 18
                                                                            if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                                            _6422 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_6422] = 26
                                                                            mem[_6422 + 32] = 'SafeMath: division by zero'
                                                                            if not swapTokensAmount * liquidityPoolFee / 100:
                                                                                mem[0] = this.address
                                                                                mem[32] = 2
                                                                                _6701 = mem[64]
                                                                                mem[mem[64]] = 2
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_6701 + 32 len 64] = call.data[calldata.size len 64]
                                                                                if 0 >= mem[_6701]:
                                                                                    revert with 0, 50
                                                                                mem[_6701 + 32] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_6701 + 96] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _6701 + ceil32(return_data.size) + 96
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                if 1 >= mem[_6701]:
                                                                                    revert with 0, 50
                                                                                mem[_6701 + 64] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                mem[_6701 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_6701 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                                mem[_6701 + ceil32(return_data.size) + 132] = 0
                                                                                mem[_6701 + ceil32(return_data.size) + 164] = 160
                                                                                mem[_6701 + ceil32(return_data.size) + 260] = mem[_6701]
                                                                                idx = 0
                                                                                s = _6701 + ceil32(return_data.size) + 292
                                                                                t = _6701 + 32
                                                                                while idx < mem[_6701]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                mem[_6701 + ceil32(return_data.size) + 196] = this.address
                                                                                mem[_6701 + ceil32(return_data.size) + 228] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                     gas gas_remaining wei
                                                                                    args mem[mem[64] + 4 len _6701 + ceil32(return_data.size) + (32 * mem[_6701]) + -mem[64] + 288]
                                                                            else:
                                                                                _6657 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_6657] = 26
                                                                                mem[_6657 + 32] = 'SafeMath: division by zero'
                                                                                _6931 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_6931] = 30
                                                                                mem[_6931 + 32] = 'SafeMath: subtraction overflow'
                                                                                if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                    revert with 0, 17
                                                                                _7265 = mem[64]
                                                                                mem[mem[64]] = 2
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_7265 + 32 len 64] = call.data[calldata.size len 64]
                                                                                if 0 >= mem[_7265]:
                                                                                    revert with 0, 50
                                                                                mem[_7265 + 32] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_7265 + 96] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _7265 + ceil32(return_data.size) + 96
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                if 1 >= mem[_7265]:
                                                                                    revert with 0, 50
                                                                                mem[_7265 + 64] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                allowance[msg.sender][stor20].field_255 = 0
                                                                                emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                                mem[_7265 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_7265 + ceil32(return_data.size) + 100] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                mem[_7265 + ceil32(return_data.size) + 132] = 0
                                                                                mem[_7265 + ceil32(return_data.size) + 164] = 160
                                                                                mem[_7265 + ceil32(return_data.size) + 260] = mem[_7265]
                                                                                idx = 0
                                                                                s = _7265 + ceil32(return_data.size) + 292
                                                                                t = _7265 + 32
                                                                                while idx < mem[_7265]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                mem[_7265 + ceil32(return_data.size) + 196] = this.address
                                                                                mem[_7265 + ceil32(return_data.size) + 228] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                     gas gas_remaining wei
                                                                                    args mem[mem[64] + 4 len _7265 + ceil32(return_data.size) + (32 * mem[_7265]) + -mem[64] + 288]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                _9549 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_9549] = 30
                                                                                mem[_9549 + 32] = 'SafeMath: subtraction overflow'
                                                                                if eth.balance(this.address) > eth.balance(this.address):
                                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                if eth.balance(this.address) < eth.balance(this.address):
                                                                                    revert with 0, 17
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                                mem[mem[64] + 68] = 0
                                                                                mem[mem[64] + 100] = 0
                                                                                mem[mem[64] + 132] = 0
                                                                                mem[mem[64] + 164] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                     gas gas_remaining wei
                                                                                    args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                                require return_data.size >= 96
                                                                                mem[mem[64] + 32] = 0
                                                                                mem[mem[64] + 64] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                                mem[0] = this.address
                                                                                mem[32] = 2
                                                                                _10783 = mem[64]
                                                                                mem[mem[64]] = 2
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_10783 + 32 len 64] = call.data[calldata.size len 64]
                                                                                if 0 >= mem[_10783]:
                                                                                    revert with 0, 50
                                                                                mem[_10783 + 32] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_10783 + 96] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _10783 + ceil32(return_data.size) + 96
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                if 1 >= mem[_10783]:
                                                                                    revert with 0, 50
                                                                                mem[_10783 + 64] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                mem[_10783 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_10783 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                                mem[_10783 + ceil32(return_data.size) + 132] = 0
                                                                                mem[_10783 + ceil32(return_data.size) + 164] = 160
                                                                                mem[_10783 + ceil32(return_data.size) + 260] = mem[_10783]
                                                                                idx = 0
                                                                                s = _10783 + ceil32(return_data.size) + 292
                                                                                t = _10783 + 32
                                                                                while idx < mem[_10783]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                mem[_10783 + ceil32(return_data.size) + 196] = this.address
                                                                                mem[_10783 + ceil32(return_data.size) + 228] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                     gas gas_remaining wei
                                                                                    args mem[mem[64] + 4 len _10783 + ceil32(return_data.size) + (32 * mem[_10783]) + -mem[64] + 288]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        uint8(stor30.field_0) = 0
                                                                        if not msg.sender:
                                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                                        if not this.address:
                                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                                        if stor33[address(msg.sender)]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        if stor33[address(this.address)]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                        require ext_code.size(nodeRewardManagementAddress)
                                                                        call nodeRewardManagementAddress.0x37696eec with:
                                                                             gas gas_remaining wei
                                                                            args msg.sender, uint8(cd[4])
                                                                    else:
                                                                        _5814 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_5814 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_5814]:
                                                                            revert with 0, 50
                                                                        mem[_5814 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_5814 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _5814 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_5814]:
                                                                            revert with 0, 50
                                                                        mem[_5814 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = swapTokensAmount * rewardsFee / 100 * stor29 / 100
                                                                        emit Approval((swapTokensAmount * rewardsFee / 100 * stor29 / 100), msg.sender, uniV2RouterAddress);
                                                                        mem[_5814 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_5814 + ceil32(return_data.size) + 100] = swapTokensAmount * rewardsFee / 100 * stor29 / 100
                                                                        mem[_5814 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_5814 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_5814 + ceil32(return_data.size) + 260] = mem[_5814]
                                                                        idx = 0
                                                                        s = _5814 + ceil32(return_data.size) + 292
                                                                        t = _5814 + 32
                                                                        while idx < mem[_5814]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[_5814 + ceil32(return_data.size) + 196] = this.address
                                                                        mem[_5814 + ceil32(return_data.size) + 228] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                             gas gas_remaining wei
                                                                            args mem[mem[64] + 4 len _5814 + ceil32(return_data.size) + (32 * mem[_5814]) + -mem[64] + 288]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        _9550 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_9550] = 30
                                                                        mem[_9550 + 32] = 'SafeMath: subtraction overflow'
                                                                        if eth.balance(this.address) > eth.balance(this.address):
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if eth.balance(this.address) < eth.balance(this.address):
                                                                            revert with 0, 17
                                                                        call distributionPoolAddress with:
                                                                             gas 30000 wei
                                                                        if not return_data.size:
                                                                            _10507 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_10507] = 30
                                                                            mem[_10507 + 32] = 'SafeMath: subtraction overflow'
                                                                            if swapTokensAmount * rewardsFee / 100 * stor29 / 100 > swapTokensAmount * rewardsFee / 100:
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if swapTokensAmount * rewardsFee / 100 < swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                                revert with 0, 17
                                                                            if not this.address:
                                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                                            if not distributionPoolAddress:
                                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                                            if stor33[address(this.address)]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            mem[0] = distributionPoolAddress
                                                                            mem[32] = 33
                                                                            if stor33[stor24]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            emit Transfer(((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)), this.address, distributionPoolAddress);
                                                                            if not swapTokensAmount:
                                                                                _10959 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_10959] = 26
                                                                                mem[_10959 + 32] = 'SafeMath: division by zero'
                                                                                mem[0] = this.address
                                                                                mem[32] = 2
                                                                                _11173 = mem[64]
                                                                                mem[mem[64]] = 2
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_11173 + 32 len 64] = call.data[calldata.size len 64]
                                                                                if 0 >= mem[_11173]:
                                                                                    revert with 0, 50
                                                                                mem[_11173 + 32] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_11173 + 96] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _11173 + ceil32(return_data.size) + 96
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                if 1 >= mem[_11173]:
                                                                                    revert with 0, 50
                                                                                mem[_11173 + 64] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                mem[_11173 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_11173 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                                mem[_11173 + ceil32(return_data.size) + 132] = 0
                                                                                mem[_11173 + ceil32(return_data.size) + 164] = 160
                                                                                mem[_11173 + ceil32(return_data.size) + 260] = mem[_11173]
                                                                                idx = 0
                                                                                s = _11173 + ceil32(return_data.size) + 292
                                                                                t = _11173 + 32
                                                                                while idx < mem[_11173]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                     gas gas_remaining wei
                                                                                    args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_11173 + ceil32(return_data.size) + 260 len (32 * mem[_11173]) + 32]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                uint8(stor30.field_0) = 0
                                                                                if not msg.sender:
                                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                                if not this.address:
                                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                                if stor33[address(msg.sender)]:
                                                                                    revert with 0, 'Blacklisted address'
                                                                                if stor33[address(this.address)]:
                                                                                    revert with 0, 'Blacklisted address'
                                                                                emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                                require ext_code.size(nodeRewardManagementAddress)
                                                                                call nodeRewardManagementAddress.0x37696eec with:
                                                                                     gas gas_remaining wei
                                                                                    args msg.sender, uint8(cd[4])
                                                                            else:
                                                                                if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                                    revert with 0, 17
                                                                                if not swapTokensAmount:
                                                                                    revert with 0, 18
                                                                                if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                                _11103 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_11103] = 26
                                                                                mem[_11103 + 32] = 'SafeMath: division by zero'
                                                                                if not swapTokensAmount * liquidityPoolFee / 100:
                                                                                    mem[0] = this.address
                                                                                    mem[32] = 2
                                                                                    _11333 = mem[64]
                                                                                    mem[mem[64]] = 2
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_11333 + 32 len 64] = call.data[calldata.size len 64]
                                                                                    if 0 >= mem[_11333]:
                                                                                        revert with 0, 50
                                                                                    mem[_11333 + 32] = this.address
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                            gas gas_remaining wei
                                                                                    mem[_11333 + 96] = ext_call.return_data[0]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = _11333 + ceil32(return_data.size) + 96
                                                                                    require return_data.size >= 32
                                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                    if 1 >= mem[_11333]:
                                                                                        revert with 0, 50
                                                                                    mem[_11333 + 64] = ext_call.return_data[12 len 20]
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                    emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                    mem[_11333 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                    mem[_11333 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                                    mem[_11333 + ceil32(return_data.size) + 132] = 0
                                                                                    mem[_11333 + ceil32(return_data.size) + 164] = 160
                                                                                    mem[_11333 + ceil32(return_data.size) + 260] = mem[_11333]
                                                                                    idx = 0
                                                                                    s = _11333 + ceil32(return_data.size) + 292
                                                                                    t = _11333 + 32
                                                                                    while idx < mem[_11333]:
                                                                                        mem[s] = mem[t + 12 len 20]
                                                                                        idx = idx + 1
                                                                                        s = s + 32
                                                                                        t = t + 32
                                                                                        continue 
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                         gas gas_remaining wei
                                                                                        args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_11333 + ceil32(return_data.size) + 260 len (32 * mem[_11333]) + 32]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    uint8(stor30.field_0) = 0
                                                                                    if not msg.sender:
                                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                                    if not this.address:
                                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                                    if stor33[address(msg.sender)]:
                                                                                        revert with 0, 'Blacklisted address'
                                                                                    if stor33[address(this.address)]:
                                                                                        revert with 0, 'Blacklisted address'
                                                                                    emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                                    require ext_code.size(nodeRewardManagementAddress)
                                                                                    call nodeRewardManagementAddress.0x37696eec with:
                                                                                         gas gas_remaining wei
                                                                                        args msg.sender, uint8(cd[4])
                                                                                else:
                                                                                    _11265 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_11265] = 26
                                                                                    mem[_11265 + 32] = 'SafeMath: division by zero'
                                                                                    _11603 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_11603] = 30
                                                                                    mem[_11603 + 32] = 'SafeMath: subtraction overflow'
                                                                                    if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                    if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                        revert with 0, 17
                                                                                    _11730 = mem[64]
                                                                                    mem[mem[64]] = 2
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_11730 + 32 len 64] = call.data[calldata.size len 64]
                                                                                    if 0 >= mem[_11730]:
                                                                                        revert with 0, 50
                                                                                    mem[_11730 + 32] = this.address
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                            gas gas_remaining wei
                                                                                    mem[_11730 + 96] = ext_call.return_data[0]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = _11730 + ceil32(return_data.size) + 96
                                                                                    require return_data.size >= 32
                                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                    if 1 >= mem[_11730]:
                                                                                        revert with 0, 50
                                                                                    mem[_11730 + 64] = ext_call.return_data[12 len 20]
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                    allowance[msg.sender][stor20].field_255 = 0
                                                                                    emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                                    mem[_11730 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                    mem[_11730 + ceil32(return_data.size) + 100] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                    mem[_11730 + ceil32(return_data.size) + 132] = 0
                                                                                    mem[_11730 + ceil32(return_data.size) + 164] = 160
                                                                                    mem[_11730 + ceil32(return_data.size) + 260] = mem[_11730]
                                                                                    idx = 0
                                                                                    s = _11730 + ceil32(return_data.size) + 292
                                                                                    t = _11730 + 32
                                                                                    while idx < mem[_11730]:
                                                                                        mem[s] = mem[t + 12 len 20]
                                                                                        idx = idx + 1
                                                                                        s = s + 32
                                                                                        t = t + 32
                                                                                        continue 
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                         gas gas_remaining wei
                                                                                        args Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_11730 + ceil32(return_data.size) + 260 len (32 * mem[_11730]) + 32]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[_11730 + ceil32(return_data.size) + 96] = 30
                                                                                    mem[_11730 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                                                                    if eth.balance(this.address) > eth.balance(this.address):
                                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                    if eth.balance(this.address) < eth.balance(this.address):
                                                                                        revert with 0, 17
                                                                                    allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                    emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                                    mem[_11730 + ceil32(return_data.size) + 228] = 0
                                                                                    mem[_11730 + ceil32(return_data.size) + 260] = 0
                                                                                    mem[_11730 + ceil32(return_data.size) + 292] = 0
                                                                                    mem[_11730 + ceil32(return_data.size) + 324] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                         gas gas_remaining wei
                                                                                        args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                                    mem[_11730 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    require return_data.size >= 96
                                                                                    emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                                    mem[_11730 + (2 * ceil32(return_data.size)) + 160] = 2
                                                                                    mem[_11730 + (2 * ceil32(return_data.size)) + 192] = this.address
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                            gas gas_remaining wei
                                                                                    mem[_11730 + (2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = _11730 + (4 * ceil32(return_data.size)) + 256
                                                                                    require return_data.size >= 32
                                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                    mem[_11730 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                    emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                    mem[_11730 + (4 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                    mem[_11730 + (4 * ceil32(return_data.size)) + 260] = balanceOf[address(this.address)]
                                                                                    mem[_11730 + (4 * ceil32(return_data.size)) + 292] = 0
                                                                                    mem[_11730 + (4 * ceil32(return_data.size)) + 324] = 160
                                                                                    mem[_11730 + (4 * ceil32(return_data.size)) + 420] = 2
                                                                                    idx = 0
                                                                                    s = _11730 + (4 * ceil32(return_data.size)) + 452
                                                                                    t = _11730 + (2 * ceil32(return_data.size)) + 192
                                                                                    while idx < mem[_11730 + (2 * ceil32(return_data.size)) + 160]:
                                                                                        mem[s] = mem[t + 12 len 20]
                                                                                        idx = idx + 1
                                                                                        s = s + 32
                                                                                        t = t + 32
                                                                                        continue 
                                                                                    mem[_11730 + (4 * ceil32(return_data.size)) + 356] = this.address
                                                                                    mem[_11730 + (4 * ceil32(return_data.size)) + 388] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                         gas gas_remaining wei
                                                                                        args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_11730 + (4 * ceil32(return_data.size)) + 420 len (32 * mem[_11730 + (2 * ceil32(return_data.size)) + 160]) + 32]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    uint8(stor30.field_0) = 0
                                                                                    if not msg.sender:
                                                                                        mem[_11730 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[_11730 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                                        mem[_11730 + (4 * ceil32(return_data.size)) + 292] = 37
                                                                                        mem[_11730 + (4 * ceil32(return_data.size)) + 324] = 'ERC20: transfer from the zero ad'
                                                                                        mem[_11730 + (4 * ceil32(return_data.size)) + 356] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                                        revert with memory
                                                                                          from _11730 + (4 * ceil32(return_data.size)) + 256
                                                                                           len (5 * ceil32(return_data.size)) + 132
                                                                                    if not this.address:
                                                                                        mem[_11730 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[_11730 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                                        mem[_11730 + (4 * ceil32(return_data.size)) + 292] = 35
                                                                                        mem[_11730 + (4 * ceil32(return_data.size)) + 324] = 'ERC20: transfer to the zero addr'
                                                                                        mem[_11730 + (4 * ceil32(return_data.size)) + 356] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                                        revert with memory
                                                                                          from _11730 + (4 * ceil32(return_data.size)) + 256
                                                                                           len (5 * ceil32(return_data.size)) + 132
                                                                                    if stor33[address(msg.sender)]:
                                                                                        mem[_11730 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[_11730 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                                        mem[_11730 + (4 * ceil32(return_data.size)) + 292] = 19
                                                                                        mem[_11730 + (4 * ceil32(return_data.size)) + 324] = 'Blacklisted address' << 104
                                                                                        revert with memory
                                                                                          from _11730 + (4 * ceil32(return_data.size)) + 256
                                                                                           len (5 * ceil32(return_data.size)) + 100
                                                                                    if stor33[address(this.address)]:
                                                                                        mem[_11730 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[_11730 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                                        mem[_11730 + (4 * ceil32(return_data.size)) + 292] = 19
                                                                                        mem[_11730 + (4 * ceil32(return_data.size)) + 324] = 'Blacklisted address' << 104
                                                                                        revert with memory
                                                                                          from _11730 + (4 * ceil32(return_data.size)) + 256
                                                                                           len (5 * ceil32(return_data.size)) + 100
                                                                                    emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                                    mem[_11730 + (4 * ceil32(return_data.size)) + 260] = msg.sender
                                                                                    mem[_11730 + (4 * ceil32(return_data.size)) + 292] = uint8(cd[4])
                                                                                    require ext_code.size(nodeRewardManagementAddress)
                                                                                    call nodeRewardManagementAddress.0x37696eec with:
                                                                                         gas gas_remaining wei
                                                                                        args mem[_11730 + (4 * ceil32(return_data.size)) + 260 len (5 * ceil32(return_data.size)) + 64]
                                                                        else:
                                                                            _10347 = mem[64]
                                                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                                                            mem[_10347] = return_data.size
                                                                            mem[_10347 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                            _10508 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_10508] = 30
                                                                            mem[_10508 + 32] = 'SafeMath: subtraction overflow'
                                                                            if swapTokensAmount * rewardsFee / 100 * stor29 / 100 > swapTokensAmount * rewardsFee / 100:
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if swapTokensAmount * rewardsFee / 100 < swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                                revert with 0, 17
                                                                            if not this.address:
                                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                                            if not distributionPoolAddress:
                                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                                            if stor33[address(this.address)]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            mem[0] = distributionPoolAddress
                                                                            mem[32] = 33
                                                                            if stor33[stor24]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            emit Transfer(((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)), this.address, distributionPoolAddress);
                                                                            if not swapTokensAmount:
                                                                                _10960 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_10960] = 26
                                                                                mem[_10960 + 32] = 'SafeMath: division by zero'
                                                                                mem[0] = this.address
                                                                                mem[32] = 2
                                                                                _11175 = mem[64]
                                                                                mem[mem[64]] = 2
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_11175 + 32 len 64] = call.data[calldata.size len 64]
                                                                                if 0 >= mem[_11175]:
                                                                                    revert with 0, 50
                                                                                mem[_11175 + 32] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_11175 + 96] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _11175 + ceil32(return_data.size) + 96
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                if 1 >= mem[_11175]:
                                                                                    revert with 0, 50
                                                                                mem[_11175 + 64] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                mem[_11175 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_11175 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                                mem[_11175 + ceil32(return_data.size) + 132] = 0
                                                                                mem[_11175 + ceil32(return_data.size) + 164] = 160
                                                                                mem[_11175 + ceil32(return_data.size) + 260] = mem[_11175]
                                                                                idx = 0
                                                                                s = _11175 + ceil32(return_data.size) + 292
                                                                                t = _11175 + 32
                                                                                while idx < mem[_11175]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                     gas gas_remaining wei
                                                                                    args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_11175 + ceil32(return_data.size) + 260 len (32 * mem[_11175]) + 32]
                                                                            else:
                                                                                if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                                    revert with 0, 17
                                                                                if not swapTokensAmount:
                                                                                    revert with 0, 18
                                                                                if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                                _11104 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_11104] = 26
                                                                                mem[_11104 + 32] = 'SafeMath: division by zero'
                                                                                if not swapTokensAmount * liquidityPoolFee / 100:
                                                                                    mem[0] = this.address
                                                                                    mem[32] = 2
                                                                                    _11335 = mem[64]
                                                                                    mem[mem[64]] = 2
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_11335 + 32 len 64] = call.data[calldata.size len 64]
                                                                                    if 0 >= mem[_11335]:
                                                                                        revert with 0, 50
                                                                                    mem[_11335 + 32] = this.address
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                            gas gas_remaining wei
                                                                                    mem[_11335 + 96] = ext_call.return_data[0]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = _11335 + ceil32(return_data.size) + 96
                                                                                    require return_data.size >= 32
                                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                    if 1 >= mem[_11335]:
                                                                                        revert with 0, 50
                                                                                    mem[_11335 + 64] = ext_call.return_data[12 len 20]
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                    emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                    mem[_11335 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                    mem[_11335 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                                    mem[_11335 + ceil32(return_data.size) + 132] = 0
                                                                                    mem[_11335 + ceil32(return_data.size) + 164] = 160
                                                                                    mem[_11335 + ceil32(return_data.size) + 260] = mem[_11335]
                                                                                    idx = 0
                                                                                    s = _11335 + ceil32(return_data.size) + 292
                                                                                    t = _11335 + 32
                                                                                    while idx < mem[_11335]:
                                                                                        mem[s] = mem[t + 12 len 20]
                                                                                        idx = idx + 1
                                                                                        s = s + 32
                                                                                        t = t + 32
                                                                                        continue 
                                                                                    mem[_11335 + ceil32(return_data.size) + 196] = this.address
                                                                                    mem[_11335 + ceil32(return_data.size) + 228] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                         gas gas_remaining wei
                                                                                        args mem[mem[64] + 4 len _11335 + ceil32(return_data.size) + (32 * mem[_11335]) + -mem[64] + 288]
                                                                                else:
                                                                                    _11267 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_11267] = 26
                                                                                    mem[_11267 + 32] = 'SafeMath: division by zero'
                                                                                    _11604 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_11604] = 30
                                                                                    mem[_11604 + 32] = 'SafeMath: subtraction overflow'
                                                                                    if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                    if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                        revert with 0, 17
                                                                                    _11734 = mem[64]
                                                                                    mem[mem[64]] = 2
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_11734 + 32 len 64] = call.data[calldata.size len 64]
                                                                                    if 0 >= mem[_11734]:
                                                                                        revert with 0, 50
                                                                                    mem[_11734 + 32] = this.address
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                            gas gas_remaining wei
                                                                                    mem[_11734 + 96] = ext_call.return_data[0]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = _11734 + ceil32(return_data.size) + 96
                                                                                    require return_data.size >= 32
                                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                    if 1 >= mem[_11734]:
                                                                                        revert with 0, 50
                                                                                    mem[_11734 + 64] = ext_call.return_data[12 len 20]
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                    allowance[msg.sender][stor20].field_255 = 0
                                                                                    emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                                    mem[_11734 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                    mem[_11734 + ceil32(return_data.size) + 100] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                    mem[_11734 + ceil32(return_data.size) + 132] = 0
                                                                                    mem[_11734 + ceil32(return_data.size) + 164] = 160
                                                                                    mem[_11734 + ceil32(return_data.size) + 260] = mem[_11734]
                                                                                    idx = 0
                                                                                    s = _11734 + ceil32(return_data.size) + 292
                                                                                    t = _11734 + 32
                                                                                    while idx < mem[_11734]:
                                                                                        mem[s] = mem[t + 12 len 20]
                                                                                        idx = idx + 1
                                                                                        s = s + 32
                                                                                        t = t + 32
                                                                                        continue 
                                                                                    mem[_11734 + ceil32(return_data.size) + 196] = this.address
                                                                                    mem[_11734 + ceil32(return_data.size) + 228] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                         gas gas_remaining wei
                                                                                        args mem[mem[64] + 4 len _11734 + ceil32(return_data.size) + (32 * mem[_11734]) + -mem[64] + 288]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    _12692 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_12692] = 30
                                                                                    mem[_12692 + 32] = 'SafeMath: subtraction overflow'
                                                                                    if eth.balance(this.address) > eth.balance(this.address):
                                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                    if eth.balance(this.address) < eth.balance(this.address):
                                                                                        revert with 0, 17
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                    emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                                    mem[mem[64] + 68] = 0
                                                                                    mem[mem[64] + 100] = 0
                                                                                    mem[mem[64] + 132] = 0
                                                                                    mem[mem[64] + 164] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                         gas gas_remaining wei
                                                                                        args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    mem[mem[64] + 32] = 0
                                                                                    mem[mem[64] + 64] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                    emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                                    mem[0] = this.address
                                                                                    mem[32] = 2
                                                                                    _13351 = mem[64]
                                                                                    mem[mem[64]] = 2
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_13351 + 32 len 64] = call.data[calldata.size len 64]
                                                                                    if 0 >= mem[_13351]:
                                                                                        revert with 0, 50
                                                                                    mem[_13351 + 32] = this.address
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                            gas gas_remaining wei
                                                                                    mem[_13351 + 96] = ext_call.return_data[0]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = _13351 + ceil32(return_data.size) + 96
                                                                                    require return_data.size >= 32
                                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                    if 1 >= mem[_13351]:
                                                                                        revert with 0, 50
                                                                                    mem[_13351 + 64] = ext_call.return_data[12 len 20]
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                    emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                    mem[_13351 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                    mem[_13351 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                                    mem[_13351 + ceil32(return_data.size) + 132] = 0
                                                                                    mem[_13351 + ceil32(return_data.size) + 164] = 160
                                                                                    mem[_13351 + ceil32(return_data.size) + 260] = mem[_13351]
                                                                                    idx = 0
                                                                                    s = _13351 + ceil32(return_data.size) + 292
                                                                                    t = _13351 + 32
                                                                                    while idx < mem[_13351]:
                                                                                        mem[s] = mem[t + 12 len 20]
                                                                                        idx = idx + 1
                                                                                        s = s + 32
                                                                                        t = t + 32
                                                                                        continue 
                                                                                    mem[_13351 + ceil32(return_data.size) + 196] = this.address
                                                                                    mem[_13351 + ceil32(return_data.size) + 228] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                         gas gas_remaining wei
                                                                                        args mem[mem[64] + 4 len _13351 + ceil32(return_data.size) + (32 * mem[_13351]) + -mem[64] + 288]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            uint8(stor30.field_0) = 0
                                                                            if not msg.sender:
                                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                                            if not this.address:
                                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                                            if stor33[address(msg.sender)]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            if stor33[address(this.address)]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                            require ext_code.size(nodeRewardManagementAddress)
                                                                            call nodeRewardManagementAddress.0x37696eec with:
                                                                                 gas gas_remaining wei
                                                                                args msg.sender, uint8(cd[4])
                                                    else:
                                                        _4484 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                                                        mem[_4484] = return_data.size
                                                        mem[_4484 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        if swapTokensAmount:
                                                            if swapTokensAmount and burnFee > -1 / swapTokensAmount:
                                                                revert with 0, 17
                                                            if not swapTokensAmount:
                                                                revert with 0, 18
                                                            if swapTokensAmount * burnFee / swapTokensAmount != burnFee:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _4807 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_4807] = 26
                                                            mem[_4807 + 32] = 'SafeMath: division by zero'
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not deadWalletAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            if stor33[address(this.address)]:
                                                                revert with 0, 'Blacklisted address'
                                                            mem[0] = deadWalletAddress
                                                            mem[32] = 33
                                                            if stor33[stor7]:
                                                                revert with 0, 'Blacklisted address'
                                                            emit Transfer((swapTokensAmount * burnFee / 100), this.address, deadWalletAddress);
                                                            if not swapTokensAmount:
                                                                _5184 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_5184] = 26
                                                                mem[_5184 + 32] = 'SafeMath: division by zero'
                                                                _5492 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_5492] = 26
                                                                mem[_5492 + 32] = 'SafeMath: division by zero'
                                                                _5642 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_5642] = 30
                                                                mem[_5642 + 32] = 'SafeMath: subtraction overflow'
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not distributionPoolAddress:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                if stor33[address(this.address)]:
                                                                    revert with 0, 'Blacklisted address'
                                                                mem[0] = distributionPoolAddress
                                                                mem[32] = 33
                                                                if stor33[stor24]:
                                                                    revert with 0, 'Blacklisted address'
                                                                emit Transfer(0, this.address, distributionPoolAddress);
                                                                if not swapTokensAmount:
                                                                    _6241 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_6241] = 26
                                                                    mem[_6241 + 32] = 'SafeMath: division by zero'
                                                                    mem[0] = this.address
                                                                    mem[32] = 2
                                                                    _6394 = mem[64]
                                                                    mem[mem[64]] = 2
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_6394 + 32 len 64] = call.data[calldata.size len 64]
                                                                    if 0 >= mem[_6394]:
                                                                        revert with 0, 50
                                                                    mem[_6394 + 32] = this.address
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                            gas gas_remaining wei
                                                                    mem[_6394 + 96] = ext_call.return_data[0]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _6394 + ceil32(return_data.size) + 96
                                                                    require return_data.size >= 32
                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                    if 1 >= mem[_6394]:
                                                                        revert with 0, 50
                                                                    mem[_6394 + 64] = ext_call.return_data[12 len 20]
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                    emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                    mem[_6394 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                    mem[_6394 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                    mem[_6394 + ceil32(return_data.size) + 132] = 0
                                                                    mem[_6394 + ceil32(return_data.size) + 164] = 160
                                                                    mem[_6394 + ceil32(return_data.size) + 260] = mem[_6394]
                                                                    idx = 0
                                                                    s = _6394 + ceil32(return_data.size) + 292
                                                                    t = _6394 + 32
                                                                    while idx < mem[_6394]:
                                                                        mem[s] = mem[t + 12 len 20]
                                                                        idx = idx + 1
                                                                        s = s + 32
                                                                        t = t + 32
                                                                        continue 
                                                                    mem[_6394 + ceil32(return_data.size) + 196] = this.address
                                                                    mem[_6394 + ceil32(return_data.size) + 228] = block.timestamp
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _6394 + ceil32(return_data.size) + (32 * mem[_6394]) + -mem[64] + 288]
                                                                else:
                                                                    if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                        revert with 0, 17
                                                                    if not swapTokensAmount:
                                                                        revert with 0, 18
                                                                    if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                                    _6329 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_6329] = 26
                                                                    mem[_6329 + 32] = 'SafeMath: division by zero'
                                                                    if not swapTokensAmount * liquidityPoolFee / 100:
                                                                        mem[0] = this.address
                                                                        mem[32] = 2
                                                                        _6539 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_6539 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_6539]:
                                                                            revert with 0, 50
                                                                        mem[_6539 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_6539 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _6539 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_6539]:
                                                                            revert with 0, 50
                                                                        mem[_6539 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                        mem[_6539 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_6539 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                        mem[_6539 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_6539 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_6539 + ceil32(return_data.size) + 260] = mem[_6539]
                                                                        idx = 0
                                                                        s = _6539 + ceil32(return_data.size) + 292
                                                                        t = _6539 + 32
                                                                        while idx < mem[_6539]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                             gas gas_remaining wei
                                                                            args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_6539 + ceil32(return_data.size) + 260 len (32 * mem[_6539]) + 32]
                                                                    else:
                                                                        _6507 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_6507] = 26
                                                                        mem[_6507 + 32] = 'SafeMath: division by zero'
                                                                        _6740 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_6740] = 30
                                                                        mem[_6740 + 32] = 'SafeMath: subtraction overflow'
                                                                        if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                            revert with 0, 17
                                                                        _7013 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_7013 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_7013]:
                                                                            revert with 0, 50
                                                                        mem[_7013 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_7013 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _7013 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_7013]:
                                                                            revert with 0, 50
                                                                        mem[_7013 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                        allowance[msg.sender][stor20].field_255 = 0
                                                                        emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                        mem[_7013 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_7013 + ceil32(return_data.size) + 100] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                        mem[_7013 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_7013 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_7013 + ceil32(return_data.size) + 260] = mem[_7013]
                                                                        idx = 0
                                                                        s = _7013 + ceil32(return_data.size) + 292
                                                                        t = _7013 + 32
                                                                        while idx < mem[_7013]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                             gas gas_remaining wei
                                                                            args Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_7013 + ceil32(return_data.size) + 260 len (32 * mem[_7013]) + 32]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[_7013 + ceil32(return_data.size) + 96] = 30
                                                                        mem[_7013 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                                                        if eth.balance(this.address) > eth.balance(this.address):
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if eth.balance(this.address) < eth.balance(this.address):
                                                                            revert with 0, 17
                                                                        allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                        emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                        mem[_7013 + ceil32(return_data.size) + 228] = 0
                                                                        mem[_7013 + ceil32(return_data.size) + 260] = 0
                                                                        mem[_7013 + ceil32(return_data.size) + 292] = 0
                                                                        mem[_7013 + ceil32(return_data.size) + 324] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                             gas gas_remaining wei
                                                                            args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                        mem[_7013 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        require return_data.size >= 96
                                                                        emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                        mem[_7013 + (2 * ceil32(return_data.size)) + 160] = 2
                                                                        mem[_7013 + (2 * ceil32(return_data.size)) + 192] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_7013 + (2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _7013 + (4 * ceil32(return_data.size)) + 256
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        mem[_7013 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                        mem[_7013 + (4 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_7013 + (4 * ceil32(return_data.size)) + 260] = balanceOf[address(this.address)]
                                                                        mem[_7013 + (4 * ceil32(return_data.size)) + 292] = 0
                                                                        mem[_7013 + (4 * ceil32(return_data.size)) + 324] = 160
                                                                        mem[_7013 + (4 * ceil32(return_data.size)) + 420] = 2
                                                                        idx = 0
                                                                        s = _7013 + (4 * ceil32(return_data.size)) + 452
                                                                        t = _7013 + (2 * ceil32(return_data.size)) + 192
                                                                        while idx < mem[_7013 + (2 * ceil32(return_data.size)) + 160]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[_7013 + (4 * ceil32(return_data.size)) + 356] = this.address
                                                                        mem[_7013 + (4 * ceil32(return_data.size)) + 388] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                             gas gas_remaining wei
                                                                            args mem[mem[64] + 4 len _7013 + (4 * ceil32(return_data.size)) + (32 * mem[_7013 + (2 * ceil32(return_data.size)) + 160]) + -mem[64] + 448]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                uint8(stor30.field_0) = 0
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                if stor33[address(msg.sender)]:
                                                                    revert with 0, 'Blacklisted address'
                                                                if stor33[address(this.address)]:
                                                                    revert with 0, 'Blacklisted address'
                                                                emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                require ext_code.size(nodeRewardManagementAddress)
                                                                call nodeRewardManagementAddress.0x37696eec with:
                                                                     gas gas_remaining wei
                                                                    args msg.sender, uint8(cd[4])
                                                            else:
                                                                if swapTokensAmount and rewardsFee > -1 / swapTokensAmount:
                                                                    revert with 0, 17
                                                                if not swapTokensAmount:
                                                                    revert with 0, 18
                                                                if swapTokensAmount * rewardsFee / swapTokensAmount != rewardsFee:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                _5278 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_5278] = 26
                                                                mem[_5278 + 32] = 'SafeMath: division by zero'
                                                                if not swapTokensAmount * rewardsFee / 100:
                                                                    _5590 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_5590] = 26
                                                                    mem[_5590 + 32] = 'SafeMath: division by zero'
                                                                    _5795 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_5795] = 30
                                                                    mem[_5795 + 32] = 'SafeMath: subtraction overflow'
                                                                    if 0 > swapTokensAmount * rewardsFee / 100:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if swapTokensAmount * rewardsFee / 100 < 0:
                                                                        revert with 0, 17
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not distributionPoolAddress:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    if stor33[address(this.address)]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    mem[0] = distributionPoolAddress
                                                                    mem[32] = 33
                                                                    if stor33[stor24]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    emit Transfer((swapTokensAmount * rewardsFee / 100), this.address, distributionPoolAddress);
                                                                    if not swapTokensAmount:
                                                                        _6328 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_6328] = 26
                                                                        mem[_6328 + 32] = 'SafeMath: division by zero'
                                                                        mem[0] = this.address
                                                                        mem[32] = 2
                                                                        _6537 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_6537 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_6537]:
                                                                            revert with 0, 50
                                                                        mem[_6537 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_6537 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _6537 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_6537]:
                                                                            revert with 0, 50
                                                                        mem[_6537 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                        mem[_6537 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_6537 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                        mem[_6537 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_6537 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_6537 + ceil32(return_data.size) + 260] = mem[_6537]
                                                                        idx = 0
                                                                        s = _6537 + ceil32(return_data.size) + 292
                                                                        t = _6537 + 32
                                                                        while idx < mem[_6537]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[_6537 + ceil32(return_data.size) + 196] = this.address
                                                                        mem[_6537 + ceil32(return_data.size) + 228] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                             gas gas_remaining wei
                                                                            args mem[mem[64] + 4 len _6537 + ceil32(return_data.size) + (32 * mem[_6537]) + -mem[64] + 288]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        uint8(stor30.field_0) = 0
                                                                        if not msg.sender:
                                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                                        if not this.address:
                                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                                        if stor33[address(msg.sender)]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        if stor33[address(this.address)]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                        require ext_code.size(nodeRewardManagementAddress)
                                                                        call nodeRewardManagementAddress.0x37696eec with:
                                                                             gas gas_remaining wei
                                                                            args msg.sender, uint8(cd[4])
                                                                    else:
                                                                        if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                            revert with 0, 17
                                                                        if not swapTokensAmount:
                                                                            revert with 0, 18
                                                                        if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                                        _6429 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_6429] = 26
                                                                        mem[_6429 + 32] = 'SafeMath: division by zero'
                                                                        if not swapTokensAmount * liquidityPoolFee / 100:
                                                                            mem[0] = this.address
                                                                            mem[32] = 2
                                                                            _6713 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_6713 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_6713]:
                                                                                revert with 0, 50
                                                                            mem[_6713 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_6713 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _6713 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_6713]:
                                                                                revert with 0, 50
                                                                            mem[_6713 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_6713 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_6713 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                            mem[_6713 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_6713 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_6713 + ceil32(return_data.size) + 260] = mem[_6713]
                                                                            idx = 0
                                                                            s = _6713 + ceil32(return_data.size) + 292
                                                                            t = _6713 + 32
                                                                            while idx < mem[_6713]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                 gas gas_remaining wei
                                                                                args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_6713 + ceil32(return_data.size) + 260 len (32 * mem[_6713]) + 32]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            uint8(stor30.field_0) = 0
                                                                            if not msg.sender:
                                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                                            if not this.address:
                                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                                            if stor33[address(msg.sender)]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            if stor33[address(this.address)]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                            require ext_code.size(nodeRewardManagementAddress)
                                                                            call nodeRewardManagementAddress.0x37696eec with:
                                                                                 gas gas_remaining wei
                                                                                args msg.sender, uint8(cd[4])
                                                                        else:
                                                                            _6672 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_6672] = 26
                                                                            mem[_6672 + 32] = 'SafeMath: division by zero'
                                                                            _6943 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_6943] = 30
                                                                            mem[_6943 + 32] = 'SafeMath: subtraction overflow'
                                                                            if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                revert with 0, 17
                                                                            _7277 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_7277 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_7277]:
                                                                                revert with 0, 50
                                                                            mem[_7277 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_7277 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _7277 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_7277]:
                                                                                revert with 0, 50
                                                                            mem[_7277 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                            allowance[msg.sender][stor20].field_255 = 0
                                                                            emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                            mem[_7277 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_7277 + ceil32(return_data.size) + 100] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                            mem[_7277 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_7277 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_7277 + ceil32(return_data.size) + 260] = mem[_7277]
                                                                            idx = 0
                                                                            s = _7277 + ceil32(return_data.size) + 292
                                                                            t = _7277 + 32
                                                                            while idx < mem[_7277]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                 gas gas_remaining wei
                                                                                args Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_7277 + ceil32(return_data.size) + 260 len (32 * mem[_7277]) + 32]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[_7277 + ceil32(return_data.size) + 96] = 30
                                                                            mem[_7277 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                                                            if eth.balance(this.address) > eth.balance(this.address):
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if eth.balance(this.address) < eth.balance(this.address):
                                                                                revert with 0, 17
                                                                            allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                            emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                            mem[_7277 + ceil32(return_data.size) + 228] = 0
                                                                            mem[_7277 + ceil32(return_data.size) + 260] = 0
                                                                            mem[_7277 + ceil32(return_data.size) + 292] = 0
                                                                            mem[_7277 + ceil32(return_data.size) + 324] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                 gas gas_remaining wei
                                                                                args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                            mem[_7277 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            require return_data.size >= 96
                                                                            emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                            mem[_7277 + (2 * ceil32(return_data.size)) + 160] = 2
                                                                            mem[_7277 + (2 * ceil32(return_data.size)) + 192] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_7277 + (2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _7277 + (4 * ceil32(return_data.size)) + 256
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            mem[_7277 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_7277 + (4 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_7277 + (4 * ceil32(return_data.size)) + 260] = balanceOf[address(this.address)]
                                                                            mem[_7277 + (4 * ceil32(return_data.size)) + 292] = 0
                                                                            mem[_7277 + (4 * ceil32(return_data.size)) + 324] = 160
                                                                            mem[_7277 + (4 * ceil32(return_data.size)) + 420] = 2
                                                                            idx = 0
                                                                            s = _7277 + (4 * ceil32(return_data.size)) + 452
                                                                            t = _7277 + (2 * ceil32(return_data.size)) + 192
                                                                            while idx < mem[_7277 + (2 * ceil32(return_data.size)) + 160]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            mem[_7277 + (4 * ceil32(return_data.size)) + 356] = this.address
                                                                            mem[_7277 + (4 * ceil32(return_data.size)) + 388] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                 gas gas_remaining wei
                                                                                args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_7277 + (4 * ceil32(return_data.size)) + 420 len (32 * mem[_7277 + (2 * ceil32(return_data.size)) + 160]) + 32]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            uint8(stor30.field_0) = 0
                                                                            if not msg.sender:
                                                                                mem[_7277 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[_7277 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                                mem[_7277 + (4 * ceil32(return_data.size)) + 292] = 37
                                                                                mem[_7277 + (4 * ceil32(return_data.size)) + 324] = 'ERC20: transfer from the zero ad'
                                                                                mem[_7277 + (4 * ceil32(return_data.size)) + 356] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                                revert with memory
                                                                                  from _7277 + (4 * ceil32(return_data.size)) + 256
                                                                                   len (5 * ceil32(return_data.size)) + 132
                                                                            if not this.address:
                                                                                mem[_7277 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[_7277 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                                mem[_7277 + (4 * ceil32(return_data.size)) + 292] = 35
                                                                                mem[_7277 + (4 * ceil32(return_data.size)) + 324] = 'ERC20: transfer to the zero addr'
                                                                                mem[_7277 + (4 * ceil32(return_data.size)) + 356] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                                revert with memory
                                                                                  from _7277 + (4 * ceil32(return_data.size)) + 256
                                                                                   len (5 * ceil32(return_data.size)) + 132
                                                                            if stor33[address(msg.sender)]:
                                                                                mem[_7277 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[_7277 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                                mem[_7277 + (4 * ceil32(return_data.size)) + 292] = 19
                                                                                mem[_7277 + (4 * ceil32(return_data.size)) + 324] = 'Blacklisted address' << 104
                                                                                revert with memory
                                                                                  from _7277 + (4 * ceil32(return_data.size)) + 256
                                                                                   len (5 * ceil32(return_data.size)) + 100
                                                                            if stor33[address(this.address)]:
                                                                                mem[_7277 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[_7277 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                                mem[_7277 + (4 * ceil32(return_data.size)) + 292] = 19
                                                                                mem[_7277 + (4 * ceil32(return_data.size)) + 324] = 'Blacklisted address' << 104
                                                                                revert with memory
                                                                                  from _7277 + (4 * ceil32(return_data.size)) + 256
                                                                                   len (5 * ceil32(return_data.size)) + 100
                                                                            emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                            mem[_7277 + (4 * ceil32(return_data.size)) + 260] = msg.sender
                                                                            mem[_7277 + (4 * ceil32(return_data.size)) + 292] = uint8(cd[4])
                                                                            require ext_code.size(nodeRewardManagementAddress)
                                                                            call nodeRewardManagementAddress.0x37696eec with:
                                                                                 gas gas_remaining wei
                                                                                args mem[_7277 + (4 * ceil32(return_data.size)) + 260 len (5 * ceil32(return_data.size)) + 64]
                                                                else:
                                                                    if swapTokensAmount * rewardsFee / 100 and stor29 > -1 / swapTokensAmount * rewardsFee / 100:
                                                                        revert with 0, 17
                                                                    if not swapTokensAmount * rewardsFee / 100:
                                                                        revert with 0, 18
                                                                    if swapTokensAmount * rewardsFee / 100 * stor29 / swapTokensAmount * rewardsFee / 100 != stor29:
                                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                                    _5713 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_5713] = 26
                                                                    mem[_5713 + 32] = 'SafeMath: division by zero'
                                                                    if not swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                        _5998 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_5998] = 30
                                                                        mem[_5998 + 32] = 'SafeMath: subtraction overflow'
                                                                        if swapTokensAmount * rewardsFee / 100 * stor29 / 100 > swapTokensAmount * rewardsFee / 100:
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if swapTokensAmount * rewardsFee / 100 < swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                            revert with 0, 17
                                                                        if not this.address:
                                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                                        if not distributionPoolAddress:
                                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                                        if stor33[address(this.address)]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        mem[0] = distributionPoolAddress
                                                                        mem[32] = 33
                                                                        if stor33[stor24]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        emit Transfer(((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)), this.address, distributionPoolAddress);
                                                                        if not swapTokensAmount:
                                                                            _6428 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_6428] = 26
                                                                            mem[_6428 + 32] = 'SafeMath: division by zero'
                                                                            mem[0] = this.address
                                                                            mem[32] = 2
                                                                            _6709 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_6709 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_6709]:
                                                                                revert with 0, 50
                                                                            mem[_6709 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_6709 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _6709 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_6709]:
                                                                                revert with 0, 50
                                                                            mem[_6709 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_6709 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_6709 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                            mem[_6709 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_6709 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_6709 + ceil32(return_data.size) + 260] = mem[_6709]
                                                                            idx = 0
                                                                            s = _6709 + ceil32(return_data.size) + 292
                                                                            t = _6709 + 32
                                                                            while idx < mem[_6709]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            mem[_6709 + ceil32(return_data.size) + 196] = this.address
                                                                            mem[_6709 + ceil32(return_data.size) + 228] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                 gas gas_remaining wei
                                                                                args mem[mem[64] + 4 len _6709 + ceil32(return_data.size) + (32 * mem[_6709]) + -mem[64] + 288]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            uint8(stor30.field_0) = 0
                                                                            if not msg.sender:
                                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                                            if not this.address:
                                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                                            if stor33[address(msg.sender)]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            if stor33[address(this.address)]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                            require ext_code.size(nodeRewardManagementAddress)
                                                                            call nodeRewardManagementAddress.0x37696eec with:
                                                                                 gas gas_remaining wei
                                                                                args msg.sender, uint8(cd[4])
                                                                        else:
                                                                            if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                                revert with 0, 17
                                                                            if not swapTokensAmount:
                                                                                revert with 0, 18
                                                                            if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                                            _6563 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_6563] = 26
                                                                            mem[_6563 + 32] = 'SafeMath: division by zero'
                                                                            if not swapTokensAmount * liquidityPoolFee / 100:
                                                                                mem[0] = this.address
                                                                                mem[32] = 2
                                                                                _6907 = mem[64]
                                                                                mem[mem[64]] = 2
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_6907 + 32 len 64] = call.data[calldata.size len 64]
                                                                                if 0 >= mem[_6907]:
                                                                                    revert with 0, 50
                                                                                mem[_6907 + 32] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_6907 + 96] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _6907 + ceil32(return_data.size) + 96
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                if 1 >= mem[_6907]:
                                                                                    revert with 0, 50
                                                                                mem[_6907 + 64] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                mem[_6907 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_6907 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                                mem[_6907 + ceil32(return_data.size) + 132] = 0
                                                                                mem[_6907 + ceil32(return_data.size) + 164] = 160
                                                                                mem[_6907 + ceil32(return_data.size) + 260] = mem[_6907]
                                                                                idx = 0
                                                                                s = _6907 + ceil32(return_data.size) + 292
                                                                                t = _6907 + 32
                                                                                while idx < mem[_6907]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                mem[_6907 + ceil32(return_data.size) + 196] = this.address
                                                                                mem[_6907 + ceil32(return_data.size) + 228] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                     gas gas_remaining wei
                                                                                    args mem[mem[64] + 4 len _6907 + ceil32(return_data.size) + (32 * mem[_6907]) + -mem[64] + 288]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                uint8(stor30.field_0) = 0
                                                                                if not msg.sender:
                                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                                if not this.address:
                                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                                if stor33[address(msg.sender)]:
                                                                                    revert with 0, 'Blacklisted address'
                                                                                if stor33[address(this.address)]:
                                                                                    revert with 0, 'Blacklisted address'
                                                                                emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                                require ext_code.size(nodeRewardManagementAddress)
                                                                                call nodeRewardManagementAddress.0x37696eec with:
                                                                                     gas gas_remaining wei
                                                                                    args msg.sender, uint8(cd[4])
                                                                            else:
                                                                                _6863 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_6863] = 26
                                                                                mem[_6863 + 32] = 'SafeMath: division by zero'
                                                                                _7178 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_7178] = 30
                                                                                mem[_7178 + 32] = 'SafeMath: subtraction overflow'
                                                                                if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                    revert with 0, 17
                                                                                _7514 = mem[64]
                                                                                mem[mem[64]] = 2
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_7514 + 32 len 64] = call.data[calldata.size len 64]
                                                                                if 0 >= mem[_7514]:
                                                                                    revert with 0, 50
                                                                                mem[_7514 + 32] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_7514 + 96] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _7514 + ceil32(return_data.size) + 96
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                if 1 >= mem[_7514]:
                                                                                    revert with 0, 50
                                                                                mem[_7514 + 64] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                allowance[msg.sender][stor20].field_255 = 0
                                                                                emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                                mem[_7514 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_7514 + ceil32(return_data.size) + 100] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                mem[_7514 + ceil32(return_data.size) + 132] = 0
                                                                                mem[_7514 + ceil32(return_data.size) + 164] = 160
                                                                                mem[_7514 + ceil32(return_data.size) + 260] = mem[_7514]
                                                                                idx = 0
                                                                                s = _7514 + ceil32(return_data.size) + 292
                                                                                t = _7514 + 32
                                                                                while idx < mem[_7514]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                     gas gas_remaining wei
                                                                                    args Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_7514 + ceil32(return_data.size) + 260 len (32 * mem[_7514]) + 32]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[_7514 + ceil32(return_data.size) + 96] = 30
                                                                                mem[_7514 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                                                                if eth.balance(this.address) > eth.balance(this.address):
                                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                if eth.balance(this.address) < eth.balance(this.address):
                                                                                    revert with 0, 17
                                                                                allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                                mem[_7514 + ceil32(return_data.size) + 228] = 0
                                                                                mem[_7514 + ceil32(return_data.size) + 260] = 0
                                                                                mem[_7514 + ceil32(return_data.size) + 292] = 0
                                                                                mem[_7514 + ceil32(return_data.size) + 324] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                     gas gas_remaining wei
                                                                                    args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                                mem[_7514 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                require return_data.size >= 96
                                                                                emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                                mem[_7514 + (2 * ceil32(return_data.size)) + 160] = 2
                                                                                mem[_7514 + (2 * ceil32(return_data.size)) + 192] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_7514 + (2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _7514 + (4 * ceil32(return_data.size)) + 256
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                mem[_7514 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                mem[_7514 + (4 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_7514 + (4 * ceil32(return_data.size)) + 260] = balanceOf[address(this.address)]
                                                                                mem[_7514 + (4 * ceil32(return_data.size)) + 292] = 0
                                                                                mem[_7514 + (4 * ceil32(return_data.size)) + 324] = 160
                                                                                mem[_7514 + (4 * ceil32(return_data.size)) + 420] = 2
                                                                                idx = 0
                                                                                s = _7514 + (4 * ceil32(return_data.size)) + 452
                                                                                t = _7514 + (2 * ceil32(return_data.size)) + 192
                                                                                while idx < mem[_7514 + (2 * ceil32(return_data.size)) + 160]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                mem[_7514 + (4 * ceil32(return_data.size)) + 356] = this.address
                                                                                mem[_7514 + (4 * ceil32(return_data.size)) + 388] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                     gas gas_remaining wei
                                                                                    args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_7514 + (4 * ceil32(return_data.size)) + 420 len (32 * mem[_7514 + (2 * ceil32(return_data.size)) + 160]) + 32]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                uint8(stor30.field_0) = 0
                                                                                if not msg.sender:
                                                                                    mem[_7514 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[_7514 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                                    mem[_7514 + (4 * ceil32(return_data.size)) + 292] = 37
                                                                                    mem[_7514 + (4 * ceil32(return_data.size)) + 324] = 'ERC20: transfer from the zero ad'
                                                                                    mem[_7514 + (4 * ceil32(return_data.size)) + 356] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                                    revert with memory
                                                                                      from _7514 + (4 * ceil32(return_data.size)) + 256
                                                                                       len (5 * ceil32(return_data.size)) + 132
                                                                                if not this.address:
                                                                                    mem[_7514 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[_7514 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                                    mem[_7514 + (4 * ceil32(return_data.size)) + 292] = 35
                                                                                    mem[_7514 + (4 * ceil32(return_data.size)) + 324] = 'ERC20: transfer to the zero addr'
                                                                                    mem[_7514 + (4 * ceil32(return_data.size)) + 356] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                                    revert with memory
                                                                                      from _7514 + (4 * ceil32(return_data.size)) + 256
                                                                                       len (5 * ceil32(return_data.size)) + 132
                                                                                if stor33[address(msg.sender)]:
                                                                                    mem[_7514 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[_7514 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                                    mem[_7514 + (4 * ceil32(return_data.size)) + 292] = 19
                                                                                    mem[_7514 + (4 * ceil32(return_data.size)) + 324] = 'Blacklisted address' << 104
                                                                                    revert with memory
                                                                                      from _7514 + (4 * ceil32(return_data.size)) + 256
                                                                                       len (5 * ceil32(return_data.size)) + 100
                                                                                if stor33[address(this.address)]:
                                                                                    mem[_7514 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[_7514 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                                    mem[_7514 + (4 * ceil32(return_data.size)) + 292] = 19
                                                                                    mem[_7514 + (4 * ceil32(return_data.size)) + 324] = 'Blacklisted address' << 104
                                                                                    revert with memory
                                                                                      from _7514 + (4 * ceil32(return_data.size)) + 256
                                                                                       len (5 * ceil32(return_data.size)) + 100
                                                                                emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                                mem[_7514 + (4 * ceil32(return_data.size)) + 260] = msg.sender
                                                                                mem[_7514 + (4 * ceil32(return_data.size)) + 292] = uint8(cd[4])
                                                                                require ext_code.size(nodeRewardManagementAddress)
                                                                                call nodeRewardManagementAddress.0x37696eec with:
                                                                                     gas gas_remaining wei
                                                                                    args mem[_7514 + (4 * ceil32(return_data.size)) + 260 len (5 * ceil32(return_data.size)) + 64]
                                                                    else:
                                                                        _6040 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_6040 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_6040]:
                                                                            revert with 0, 50
                                                                        mem[_6040 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_6040 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _6040 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_6040]:
                                                                            revert with 0, 50
                                                                        mem[_6040 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = swapTokensAmount * rewardsFee / 100 * stor29 / 100
                                                                        emit Approval((swapTokensAmount * rewardsFee / 100 * stor29 / 100), msg.sender, uniV2RouterAddress);
                                                                        mem[_6040 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_6040 + ceil32(return_data.size) + 100] = swapTokensAmount * rewardsFee / 100 * stor29 / 100
                                                                        mem[_6040 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_6040 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_6040 + ceil32(return_data.size) + 260] = mem[_6040]
                                                                        idx = 0
                                                                        s = _6040 + ceil32(return_data.size) + 292
                                                                        t = _6040 + 32
                                                                        while idx < mem[_6040]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[_6040 + ceil32(return_data.size) + 196] = this.address
                                                                        mem[_6040 + ceil32(return_data.size) + 228] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                             gas gas_remaining wei
                                                                            args swapTokensAmount * rewardsFee / 100 * stor29 / 100, 0, 160, address(this.address), block.timestamp, mem[_6040 + ceil32(return_data.size) + 260 len (32 * mem[_6040]) + 32]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[_6040 + ceil32(return_data.size) + 96] = 30
                                                                        mem[_6040 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                                                        if eth.balance(this.address) > eth.balance(this.address):
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if eth.balance(this.address) < eth.balance(this.address):
                                                                            revert with 0, 17
                                                                        call distributionPoolAddress with:
                                                                             gas 30000 wei
                                                                        if not return_data.size:
                                                                            mem[_6040 + ceil32(return_data.size) + 160] = 30
                                                                            mem[_6040 + ceil32(return_data.size) + 192] = 'SafeMath: subtraction overflow'
                                                                            if swapTokensAmount * rewardsFee / 100 * stor29 / 100 > swapTokensAmount * rewardsFee / 100:
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if swapTokensAmount * rewardsFee / 100 < swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                                revert with 0, 17
                                                                            if not this.address:
                                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                                            if not distributionPoolAddress:
                                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                                            if stor33[address(this.address)]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            if stor33[stor24]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            emit Transfer(((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)), this.address, distributionPoolAddress);
                                                                            if not swapTokensAmount:
                                                                                mem[_6040 + ceil32(return_data.size) + 224] = 26
                                                                                mem[_6040 + ceil32(return_data.size) + 256] = 'SafeMath: division by zero'
                                                                                mem[_6040 + ceil32(return_data.size) + 288] = 2
                                                                                mem[_6040 + ceil32(return_data.size) + 320] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_6040 + ceil32(return_data.size) + 384] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _6040 + (2 * ceil32(return_data.size)) + 384
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                mem[_6040 + ceil32(return_data.size) + 352] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                mem[_6040 + (2 * ceil32(return_data.size)) + 384] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_6040 + (2 * ceil32(return_data.size)) + 388] = balanceOf[address(this.address)]
                                                                                mem[_6040 + (2 * ceil32(return_data.size)) + 420] = 0
                                                                                mem[_6040 + (2 * ceil32(return_data.size)) + 452] = 160
                                                                                mem[_6040 + (2 * ceil32(return_data.size)) + 548] = 2
                                                                                idx = 0
                                                                                s = _6040 + (2 * ceil32(return_data.size)) + 580
                                                                                t = _6040 + ceil32(return_data.size) + 320
                                                                                while idx < mem[_6040 + ceil32(return_data.size) + 288]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                mem[_6040 + (2 * ceil32(return_data.size)) + 484] = this.address
                                                                                mem[_6040 + (2 * ceil32(return_data.size)) + 516] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                     gas gas_remaining wei
                                                                                    args mem[mem[64] + 4 len _6040 + (2 * ceil32(return_data.size)) + (32 * mem[_6040 + ceil32(return_data.size) + 288]) + -mem[64] + 576]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                uint8(stor30.field_0) = 0
                                                                                if not msg.sender:
                                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                                if not this.address:
                                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                                if stor33[address(msg.sender)]:
                                                                                    revert with 0, 'Blacklisted address'
                                                                                if stor33[address(this.address)]:
                                                                                    revert with 0, 'Blacklisted address'
                                                                                emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                                require ext_code.size(nodeRewardManagementAddress)
                                                                                call nodeRewardManagementAddress.0x37696eec with:
                                                                                     gas gas_remaining wei
                                                                                    args msg.sender, uint8(cd[4])
                                                                            else:
                                                                                if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                                    revert with 0, 17
                                                                                if not swapTokensAmount:
                                                                                    revert with 0, 18
                                                                                if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                                mem[_6040 + ceil32(return_data.size) + 224] = 26
                                                                                mem[_6040 + ceil32(return_data.size) + 256] = 'SafeMath: division by zero'
                                                                                if not swapTokensAmount * liquidityPoolFee / 100:
                                                                                    mem[_6040 + ceil32(return_data.size) + 288] = 2
                                                                                    mem[_6040 + ceil32(return_data.size) + 320] = this.address
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                            gas gas_remaining wei
                                                                                    mem[_6040 + ceil32(return_data.size) + 384] = ext_call.return_data[0]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = _6040 + (2 * ceil32(return_data.size)) + 384
                                                                                    require return_data.size >= 32
                                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                    mem[_6040 + ceil32(return_data.size) + 352] = ext_call.return_data[12 len 20]
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                    emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                    mem[_6040 + (2 * ceil32(return_data.size)) + 384] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                    mem[_6040 + (2 * ceil32(return_data.size)) + 388] = balanceOf[address(this.address)]
                                                                                    mem[_6040 + (2 * ceil32(return_data.size)) + 420] = 0
                                                                                    mem[_6040 + (2 * ceil32(return_data.size)) + 452] = 160
                                                                                    mem[_6040 + (2 * ceil32(return_data.size)) + 548] = 2
                                                                                    idx = 0
                                                                                    s = _6040 + (2 * ceil32(return_data.size)) + 580
                                                                                    t = _6040 + ceil32(return_data.size) + 320
                                                                                    while idx < mem[_6040 + ceil32(return_data.size) + 288]:
                                                                                        mem[s] = mem[t + 12 len 20]
                                                                                        idx = idx + 1
                                                                                        s = s + 32
                                                                                        t = t + 32
                                                                                        continue 
                                                                                    mem[_6040 + (2 * ceil32(return_data.size)) + 484] = this.address
                                                                                    mem[_6040 + (2 * ceil32(return_data.size)) + 516] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                         gas gas_remaining wei
                                                                                        args mem[mem[64] + 4 len _6040 + (2 * ceil32(return_data.size)) + (32 * mem[_6040 + ceil32(return_data.size) + 288]) + -mem[64] + 576]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    uint8(stor30.field_0) = 0
                                                                                    if not msg.sender:
                                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                                    if not this.address:
                                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                                    if stor33[address(msg.sender)]:
                                                                                        revert with 0, 'Blacklisted address'
                                                                                    if stor33[address(this.address)]:
                                                                                        revert with 0, 'Blacklisted address'
                                                                                    emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                                    require ext_code.size(nodeRewardManagementAddress)
                                                                                    call nodeRewardManagementAddress.0x37696eec with:
                                                                                         gas gas_remaining wei
                                                                                        args msg.sender, uint8(cd[4])
                                                                                else:
                                                                                    mem[_6040 + ceil32(return_data.size) + 288] = 26
                                                                                    mem[_6040 + ceil32(return_data.size) + 320] = 'SafeMath: division by zero'
                                                                                    mem[_6040 + ceil32(return_data.size) + 352] = 30
                                                                                    mem[_6040 + ceil32(return_data.size) + 384] = 'SafeMath: subtraction overflow'
                                                                                    if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                    if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                        revert with 0, 17
                                                                                    mem[_6040 + ceil32(return_data.size) + 416] = 2
                                                                                    mem[_6040 + ceil32(return_data.size) + 448] = this.address
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                            gas gas_remaining wei
                                                                                    mem[_6040 + ceil32(return_data.size) + 512] = ext_call.return_data[0]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = _6040 + (2 * ceil32(return_data.size)) + 512
                                                                                    require return_data.size >= 32
                                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                    mem[_6040 + ceil32(return_data.size) + 480] = ext_call.return_data[12 len 20]
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                    allowance[msg.sender][stor20].field_255 = 0
                                                                                    emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                                    mem[_6040 + (2 * ceil32(return_data.size)) + 512] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                    mem[_6040 + (2 * ceil32(return_data.size)) + 516] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                    mem[_6040 + (2 * ceil32(return_data.size)) + 548] = 0
                                                                                    mem[_6040 + (2 * ceil32(return_data.size)) + 580] = 160
                                                                                    mem[_6040 + (2 * ceil32(return_data.size)) + 676] = 2
                                                                                    idx = 0
                                                                                    s = _6040 + (2 * ceil32(return_data.size)) + 708
                                                                                    t = _6040 + ceil32(return_data.size) + 448
                                                                                    while idx < mem[_6040 + ceil32(return_data.size) + 416]:
                                                                                        mem[s] = mem[t + 12 len 20]
                                                                                        idx = idx + 1
                                                                                        s = s + 32
                                                                                        t = t + 32
                                                                                        continue 
                                                                                    mem[_6040 + (2 * ceil32(return_data.size)) + 612] = this.address
                                                                                    mem[_6040 + (2 * ceil32(return_data.size)) + 644] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                         gas gas_remaining wei
                                                                                        args Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_6040 + (2 * ceil32(return_data.size)) + 676 len (32 * mem[_6040 + ceil32(return_data.size) + 416]) + 32]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[_6040 + (2 * ceil32(return_data.size)) + 512] = 30
                                                                                    mem[_6040 + (2 * ceil32(return_data.size)) + 544] = 'SafeMath: subtraction overflow'
                                                                                    if eth.balance(this.address) > eth.balance(this.address):
                                                                                        mem[_6040 + (2 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[_6040 + (2 * ceil32(return_data.size)) + 580] = 32
                                                                                        mem[_6040 + (2 * ceil32(return_data.size)) + 612] = 30
                                                                                        mem[_6040 + (2 * ceil32(return_data.size)) + 644] = 'SafeMath: subtraction overflow'
                                                                                        mem[_6040 + (2 * ceil32(return_data.size)) + 674] = 0
                                                                                        revert with memory
                                                                                          from _6040 + (2 * ceil32(return_data.size)) + 576
                                                                                           len ceil32(return_data.size) + 100
                                                                                    if eth.balance(this.address) < eth.balance(this.address):
                                                                                        revert with 0, 17
                                                                                    allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                    emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                                    mem[_6040 + (2 * ceil32(return_data.size)) + 580] = this.address
                                                                                    mem[_6040 + (2 * ceil32(return_data.size)) + 612] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                    mem[_6040 + (2 * ceil32(return_data.size)) + 644] = 0
                                                                                    mem[_6040 + (2 * ceil32(return_data.size)) + 676] = 0
                                                                                    mem[_6040 + (2 * ceil32(return_data.size)) + 708] = 0
                                                                                    mem[_6040 + (2 * ceil32(return_data.size)) + 740] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                         gas gas_remaining wei
                                                                                        args mem[_6040 + (2 * ceil32(return_data.size)) + 580 len ceil32(return_data.size) + 192]
                                                                                    mem[_6040 + (2 * ceil32(return_data.size)) + 576 len 96] = ext_call.return_data[0 len 96]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    require return_data.size >= 96
                                                                                    mem[_6040 + (4 * ceil32(return_data.size)) + 576] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                    mem[_6040 + (4 * ceil32(return_data.size)) + 608] = 0
                                                                                    mem[_6040 + (4 * ceil32(return_data.size)) + 640] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                    emit SwapAndLiquify(uint256 arg1, uint256 arg2, uint256 arg3):
                                                                                                        mem[_6040 + (4 * ceil32(return_data.size)) + 576 len (5 * ceil32(return_data.size)) + 96],
                                                                                    mem[_6040 + (4 * ceil32(return_data.size)) + 576] = 2
                                                                                    mem[_6040 + (4 * ceil32(return_data.size)) + 608] = this.address
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                            gas gas_remaining wei
                                                                                    mem[_6040 + (4 * ceil32(return_data.size)) + 672] = ext_call.return_data[0]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = _6040 + (6 * ceil32(return_data.size)) + 672
                                                                                    require return_data.size >= 32
                                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                    mem[_6040 + (4 * ceil32(return_data.size)) + 640] = ext_call.return_data[12 len 20]
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                    emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                    mem[_6040 + (6 * ceil32(return_data.size)) + 672] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                    mem[_6040 + (6 * ceil32(return_data.size)) + 676] = balanceOf[address(this.address)]
                                                                                    mem[_6040 + (6 * ceil32(return_data.size)) + 708] = 0
                                                                                    mem[_6040 + (6 * ceil32(return_data.size)) + 740] = 160
                                                                                    mem[_6040 + (6 * ceil32(return_data.size)) + 836] = 2
                                                                                    idx = 0
                                                                                    s = _6040 + (6 * ceil32(return_data.size)) + 868
                                                                                    t = _6040 + (4 * ceil32(return_data.size)) + 608
                                                                                    while idx < mem[_6040 + (4 * ceil32(return_data.size)) + 576]:
                                                                                        mem[s] = mem[t + 12 len 20]
                                                                                        idx = idx + 1
                                                                                        s = s + 32
                                                                                        t = t + 32
                                                                                        continue 
                                                                                    mem[_6040 + (6 * ceil32(return_data.size)) + 772] = this.address
                                                                                    mem[_6040 + (6 * ceil32(return_data.size)) + 804] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                         gas gas_remaining wei
                                                                                        args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_6040 + (6 * ceil32(return_data.size)) + 836 len (32 * mem[_6040 + (4 * ceil32(return_data.size)) + 576]) + 32]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    uint8(stor30.field_0) = 0
                                                                                    if not msg.sender:
                                                                                        revert with 0, 
                                                                                                    'ERC20: transfer from the zero address',
                                                                                                    mem[_6040 + (6 * ceil32(return_data.size)) + 804 len 9 * ceil32(return_data.size)]
                                                                                    if not this.address:
                                                                                        revert with 0, 
                                                                                                    'ERC20: transfer to the zero address',
                                                                                                    mem[_6040 + (6 * ceil32(return_data.size)) + 804 len 9 * ceil32(return_data.size)]
                                                                                    if stor33[address(msg.sender)]:
                                                                                        revert with 0, 'Blacklisted address', mem[_6040 + (6 * ceil32(return_data.size)) + 772 len 9 * ceil32(return_data.size)]
                                                                                    if stor33[address(this.address)]:
                                                                                        revert with 0, 'Blacklisted address', mem[_6040 + (6 * ceil32(return_data.size)) + 772 len 9 * ceil32(return_data.size)]
                                                                                    emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                                    require ext_code.size(nodeRewardManagementAddress)
                                                                                    call nodeRewardManagementAddress.0x37696eec with:
                                                                                         gas gas_remaining wei
                                                                                        args msg.sender, cd[4] << 248, mem[_6040 + (6 * ceil32(return_data.size)) + 740 len 9 * ceil32(return_data.size)]
                                                                        else:
                                                                            mem[_6040 + ceil32(return_data.size) + 160] = return_data.size
                                                                            mem[_6040 + ceil32(return_data.size) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                            mem[_6040 + ceil32(return_data.size) + ceil32(return_data.size) + 161] = 30
                                                                            mem[_6040 + ceil32(return_data.size) + ceil32(return_data.size) + 193] = 'SafeMath: subtraction overflow'
                                                                            if swapTokensAmount * rewardsFee / 100 * stor29 / 100 > swapTokensAmount * rewardsFee / 100:
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if swapTokensAmount * rewardsFee / 100 < swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                                revert with 0, 17
                                                                            if not this.address:
                                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                                            if not distributionPoolAddress:
                                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                                            if stor33[address(this.address)]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            if stor33[stor24]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            emit Transfer(((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)), this.address, distributionPoolAddress);
                                                                            if not swapTokensAmount:
                                                                                mem[_6040 + ceil32(return_data.size) + ceil32(return_data.size) + 225] = 26
                                                                                mem[_6040 + ceil32(return_data.size) + ceil32(return_data.size) + 257] = 'SafeMath: division by zero'
                                                                                mem[_6040 + ceil32(return_data.size) + ceil32(return_data.size) + 289] = 2
                                                                                mem[_6040 + ceil32(return_data.size) + ceil32(return_data.size) + 321] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_6040 + ceil32(return_data.size) + ceil32(return_data.size) + 385] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _6040 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 385
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                mem[_6040 + ceil32(return_data.size) + ceil32(return_data.size) + 353] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                mem[_6040 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 385] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_6040 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 389] = balanceOf[address(this.address)]
                                                                                mem[_6040 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 421] = 0
                                                                                mem[_6040 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 453] = 160
                                                                                mem[_6040 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 549] = 2
                                                                                idx = 0
                                                                                s = _6040 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 581
                                                                                t = _6040 + ceil32(return_data.size) + ceil32(return_data.size) + 321
                                                                                while idx < mem[_6040 + ceil32(return_data.size) + ceil32(return_data.size) + 289]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                mem[_6040 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 485] = this.address
                                                                                mem[_6040 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 517] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                     gas gas_remaining wei
                                                                                    args mem[mem[64] + 4 len _6040 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * mem[_6040 + ceil32(return_data.size) + ceil32(return_data.size) + 289]) + -mem[64] + 577]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                uint8(stor30.field_0) = 0
                                                                                if not msg.sender:
                                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                                if not this.address:
                                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                                if stor33[address(msg.sender)]:
                                                                                    revert with 0, 'Blacklisted address'
                                                                                if stor33[address(this.address)]:
                                                                                    revert with 0, 'Blacklisted address'
                                                                                emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                                require ext_code.size(nodeRewardManagementAddress)
                                                                                call nodeRewardManagementAddress.0x37696eec with:
                                                                                     gas gas_remaining wei
                                                                                    args msg.sender, uint8(cd[4])
                                                                            else:
                                                                                if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                                    revert with 0, 17
                                                                                if not swapTokensAmount:
                                                                                    revert with 0, 18
                                                                                if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                                mem[_6040 + ceil32(return_data.size) + ceil32(return_data.size) + 225] = 26
                                                                                mem[_6040 + ceil32(return_data.size) + ceil32(return_data.size) + 257] = 'SafeMath: division by zero'
                                                                                if not swapTokensAmount * liquidityPoolFee / 100:
                                                                                    mem[_6040 + ceil32(return_data.size) + ceil32(return_data.size) + 289] = 2
                                                                                    mem[_6040 + ceil32(return_data.size) + ceil32(return_data.size) + 321] = this.address
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                            gas gas_remaining wei
                                                                                    mem[_6040 + ceil32(return_data.size) + ceil32(return_data.size) + 385] = ext_call.return_data[0]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = _6040 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 385
                                                                                    require return_data.size >= 32
                                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                    mem[_6040 + ceil32(return_data.size) + ceil32(return_data.size) + 353] = ext_call.return_data[12 len 20]
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                    emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                    mem[_6040 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 385] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                    mem[_6040 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 389] = balanceOf[address(this.address)]
                                                                                    mem[_6040 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 421] = 0
                                                                                    mem[_6040 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 453] = 160
                                                                                    mem[_6040 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 549] = 2
                                                                                    idx = 0
                                                                                    s = _6040 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 581
                                                                                    t = _6040 + ceil32(return_data.size) + ceil32(return_data.size) + 321
                                                                                    while idx < mem[_6040 + ceil32(return_data.size) + ceil32(return_data.size) + 289]:
                                                                                        mem[s] = mem[t + 12 len 20]
                                                                                        idx = idx + 1
                                                                                        s = s + 32
                                                                                        t = t + 32
                                                                                        continue 
                                                                                    mem[_6040 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 485] = this.address
                                                                                    mem[_6040 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 517] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                         gas gas_remaining wei
                                                                                        args mem[mem[64] + 4 len _6040 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * mem[_6040 + ceil32(return_data.size) + ceil32(return_data.size) + 289]) + -mem[64] + 577]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    uint8(stor30.field_0) = 0
                                                                                    if not msg.sender:
                                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                                    if not this.address:
                                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                                    if stor33[address(msg.sender)]:
                                                                                        revert with 0, 'Blacklisted address'
                                                                                    if stor33[address(this.address)]:
                                                                                        revert with 0, 'Blacklisted address'
                                                                                    emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                                    require ext_code.size(nodeRewardManagementAddress)
                                                                                    call nodeRewardManagementAddress.0x37696eec with:
                                                                                         gas gas_remaining wei
                                                                                        args msg.sender, uint8(cd[4])
                                                                                else:
                                                                                    mem[_6040 + ceil32(return_data.size) + ceil32(return_data.size) + 289] = 26
                                                                                    mem[_6040 + ceil32(return_data.size) + ceil32(return_data.size) + 321] = 'SafeMath: division by zero'
                                                                                    mem[_6040 + ceil32(return_data.size) + ceil32(return_data.size) + 353] = 30
                                                                                    mem[_6040 + ceil32(return_data.size) + ceil32(return_data.size) + 385] = 'SafeMath: subtraction overflow'
                                                                                    if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                    if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                        revert with 0, 17
                                                                                    mem[_6040 + ceil32(return_data.size) + ceil32(return_data.size) + 417] = 2
                                                                                    mem[_6040 + ceil32(return_data.size) + ceil32(return_data.size) + 449] = this.address
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                            gas gas_remaining wei
                                                                                    mem[_6040 + ceil32(return_data.size) + ceil32(return_data.size) + 513] = ext_call.return_data[0]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = _6040 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 513
                                                                                    require return_data.size >= 32
                                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                    mem[_6040 + ceil32(return_data.size) + ceil32(return_data.size) + 481] = ext_call.return_data[12 len 20]
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                    allowance[msg.sender][stor20].field_255 = 0
                                                                                    emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                                    mem[_6040 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 513] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                    mem[_6040 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 517] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                    mem[_6040 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 549] = 0
                                                                                    mem[_6040 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 581] = 160
                                                                                    mem[_6040 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 677] = 2
                                                                                    idx = 0
                                                                                    s = _6040 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 709
                                                                                    t = _6040 + ceil32(return_data.size) + ceil32(return_data.size) + 449
                                                                                    while idx < mem[_6040 + ceil32(return_data.size) + ceil32(return_data.size) + 417]:
                                                                                        mem[s] = mem[t + 12 len 20]
                                                                                        idx = idx + 1
                                                                                        s = s + 32
                                                                                        t = t + 32
                                                                                        continue 
                                                                                    mem[_6040 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 613] = this.address
                                                                                    mem[_6040 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 645] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                         gas gas_remaining wei
                                                                                        args Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_6040 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 677 len (32 * mem[_6040 + ceil32(return_data.size) + ceil32(return_data.size) + 417]) + 32]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[_6040 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 513] = 30
                                                                                    mem[_6040 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 545] = 'SafeMath: subtraction overflow'
                                                                                    if eth.balance(this.address) > eth.balance(this.address):
                                                                                        mem[_6040 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 577] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[_6040 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 581] = 32
                                                                                        mem[_6040 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 613] = 30
                                                                                        mem[_6040 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 645] = 'SafeMath: subtraction overflow'
                                                                                        mem[_6040 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 675] = 0
                                                                                        revert with memory
                                                                                          from _6040 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 577
                                                                                           len ceil32(return_data.size) + 100
                                                                                    if eth.balance(this.address) < eth.balance(this.address):
                                                                                        revert with 0, 17
                                                                                    allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                    emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                                    mem[_6040 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 581] = this.address
                                                                                    mem[_6040 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 613] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                    mem[_6040 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 645] = 0
                                                                                    mem[_6040 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 677] = 0
                                                                                    mem[_6040 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 709] = 0
                                                                                    mem[_6040 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 741] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                         gas gas_remaining wei
                                                                                        args mem[_6040 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 581 len ceil32(return_data.size) + 192]
                                                                                    mem[_6040 + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 577 len 96] = ext_call.return_data[0 len 96]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    require return_data.size >= 96
                                                                                    mem[_6040 + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 577] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                    mem[_6040 + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 609] = 0
                                                                                    mem[_6040 + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 641] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                    emit SwapAndLiquify(uint256 arg1, uint256 arg2, uint256 arg3):
                                                                                                        mem[_6040 + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 577 len (5 * ceil32(return_data.size)) + 96],
                                                                                    mem[_6040 + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 577] = 2
                                                                                    mem[_6040 + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 609] = this.address
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                            gas gas_remaining wei
                                                                                    mem[_6040 + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 673] = ext_call.return_data[0]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = _6040 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 673
                                                                                    require return_data.size >= 32
                                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                    mem[_6040 + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 641] = ext_call.return_data[12 len 20]
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                    emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                    mem[_6040 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 673] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                    mem[_6040 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 677] = balanceOf[address(this.address)]
                                                                                    mem[_6040 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 709] = 0
                                                                                    mem[_6040 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 741] = 160
                                                                                    mem[_6040 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 837] = 2
                                                                                    idx = 0
                                                                                    s = _6040 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 869
                                                                                    t = _6040 + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 609
                                                                                    while idx < mem[_6040 + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 577]:
                                                                                        mem[s] = mem[t + 12 len 20]
                                                                                        idx = idx + 1
                                                                                        s = s + 32
                                                                                        t = t + 32
                                                                                        continue 
                                                                                    mem[_6040 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 773] = this.address
                                                                                    mem[_6040 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 805] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                         gas gas_remaining wei
                                                                                        args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_6040 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 837 len (32 * mem[_6040 + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 577]) + 32]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    uint8(stor30.field_0) = 0
                                                                                    if not msg.sender:
                                                                                        revert with 0, 
                                                                                                    'ERC20: transfer from the zero address',
                                                                                                    mem[_6040 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 805 len 9 * ceil32(return_data.size)]
                                                                                    if not this.address:
                                                                                        revert with 0, 
                                                                                                    'ERC20: transfer to the zero address',
                                                                                                    mem[_6040 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 805 len 9 * ceil32(return_data.size)]
                                                                                    if stor33[address(msg.sender)]:
                                                                                        revert with 0, 
                                                                                                    'Blacklisted address',
                                                                                                    mem[_6040 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 773 len 9 * ceil32(return_data.size)]
                                                                                    if stor33[address(this.address)]:
                                                                                        revert with 0, 
                                                                                                    'Blacklisted address',
                                                                                                    mem[_6040 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 773 len 9 * ceil32(return_data.size)]
                                                                                    emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                                    require ext_code.size(nodeRewardManagementAddress)
                                                                                    call nodeRewardManagementAddress.0x37696eec with:
                                                                                         gas gas_remaining wei
                                                                                        args msg.sender, cd[4] << 248, mem[_6040 + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 741 len 9 * ceil32(return_data.size)]
                                                        else:
                                                            _4640 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_4640] = 26
                                                            mem[_4640 + 32] = 'SafeMath: division by zero'
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not deadWalletAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            if stor33[address(this.address)]:
                                                                revert with 0, 'Blacklisted address'
                                                            mem[0] = deadWalletAddress
                                                            mem[32] = 33
                                                            if stor33[stor7]:
                                                                revert with 0, 'Blacklisted address'
                                                            emit Transfer(0, this.address, deadWalletAddress);
                                                            if not swapTokensAmount:
                                                                _5101 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_5101] = 26
                                                                mem[_5101 + 32] = 'SafeMath: division by zero'
                                                                _5279 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_5279] = 26
                                                                mem[_5279 + 32] = 'SafeMath: division by zero'
                                                                _5531 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_5531] = 30
                                                                mem[_5531 + 32] = 'SafeMath: subtraction overflow'
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not distributionPoolAddress:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                if stor33[address(this.address)]:
                                                                    revert with 0, 'Blacklisted address'
                                                                mem[0] = distributionPoolAddress
                                                                mem[32] = 33
                                                                if stor33[stor24]:
                                                                    revert with 0, 'Blacklisted address'
                                                                emit Transfer(0, this.address, distributionPoolAddress);
                                                                if not swapTokensAmount:
                                                                    _6089 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_6089] = 26
                                                                    mem[_6089 + 32] = 'SafeMath: division by zero'
                                                                    mem[0] = this.address
                                                                    mem[32] = 2
                                                                    _6308 = mem[64]
                                                                    mem[mem[64]] = 2
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_6308 + 32 len 64] = call.data[calldata.size len 64]
                                                                    if 0 >= mem[_6308]:
                                                                        revert with 0, 50
                                                                    mem[_6308 + 32] = this.address
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                            gas gas_remaining wei
                                                                    mem[_6308 + 96] = ext_call.return_data[0]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    mem[64] = _6308 + ceil32(return_data.size) + 96
                                                                    require return_data.size >= 32
                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                    if 1 >= mem[_6308]:
                                                                        revert with 0, 50
                                                                    mem[_6308 + 64] = ext_call.return_data[12 len 20]
                                                                    mem[0] = uniV2RouterAddress
                                                                    mem[32] = sha3(msg.sender, 3)
                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                    emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                    mem[_6308 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                    mem[_6308 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                    mem[_6308 + ceil32(return_data.size) + 132] = 0
                                                                    mem[_6308 + ceil32(return_data.size) + 164] = 160
                                                                    mem[_6308 + ceil32(return_data.size) + 260] = mem[_6308]
                                                                    idx = 0
                                                                    s = _6308 + ceil32(return_data.size) + 292
                                                                    t = _6308 + 32
                                                                    while idx < mem[_6308]:
                                                                        mem[s] = mem[t + 12 len 20]
                                                                        idx = idx + 1
                                                                        s = s + 32
                                                                        t = t + 32
                                                                        continue 
                                                                    mem[_6308 + ceil32(return_data.size) + 196] = this.address
                                                                    mem[_6308 + ceil32(return_data.size) + 228] = block.timestamp
                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                         gas gas_remaining wei
                                                                        args mem[mem[64] + 4 len _6308 + ceil32(return_data.size) + (32 * mem[_6308]) + -mem[64] + 288]
                                                                else:
                                                                    if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                        revert with 0, 17
                                                                    if not swapTokensAmount:
                                                                        revert with 0, 18
                                                                    if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                                    _6245 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_6245] = 26
                                                                    mem[_6245 + 32] = 'SafeMath: division by zero'
                                                                    if not swapTokensAmount * liquidityPoolFee / 100:
                                                                        mem[0] = this.address
                                                                        mem[32] = 2
                                                                        _6400 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_6400 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_6400]:
                                                                            revert with 0, 50
                                                                        mem[_6400 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_6400 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _6400 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_6400]:
                                                                            revert with 0, 50
                                                                        mem[_6400 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                        mem[_6400 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_6400 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                        mem[_6400 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_6400 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_6400 + ceil32(return_data.size) + 260] = mem[_6400]
                                                                        idx = 0
                                                                        s = _6400 + ceil32(return_data.size) + 292
                                                                        t = _6400 + 32
                                                                        while idx < mem[_6400]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[_6400 + ceil32(return_data.size) + 196] = this.address
                                                                        mem[_6400 + ceil32(return_data.size) + 228] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                             gas gas_remaining wei
                                                                            args mem[mem[64] + 4 len _6400 + ceil32(return_data.size) + (32 * mem[_6400]) + -mem[64] + 288]
                                                                    else:
                                                                        _6372 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_6372] = 26
                                                                        mem[_6372 + 32] = 'SafeMath: division by zero'
                                                                        _6573 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_6573] = 30
                                                                        mem[_6573 + 32] = 'SafeMath: subtraction overflow'
                                                                        if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                            revert with 0, 17
                                                                        _6811 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_6811 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_6811]:
                                                                            revert with 0, 50
                                                                        mem[_6811 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_6811 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _6811 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_6811]:
                                                                            revert with 0, 50
                                                                        mem[_6811 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                        allowance[msg.sender][stor20].field_255 = 0
                                                                        emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                        mem[_6811 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_6811 + ceil32(return_data.size) + 100] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                        mem[_6811 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_6811 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_6811 + ceil32(return_data.size) + 260] = mem[_6811]
                                                                        idx = 0
                                                                        s = _6811 + ceil32(return_data.size) + 292
                                                                        t = _6811 + 32
                                                                        while idx < mem[_6811]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[_6811 + ceil32(return_data.size) + 196] = this.address
                                                                        mem[_6811 + ceil32(return_data.size) + 228] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                             gas gas_remaining wei
                                                                            args mem[mem[64] + 4 len _6811 + ceil32(return_data.size) + (32 * mem[_6811]) + -mem[64] + 288]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        _9560 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_9560] = 30
                                                                        mem[_9560 + 32] = 'SafeMath: subtraction overflow'
                                                                        if eth.balance(this.address) > eth.balance(this.address):
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if eth.balance(this.address) < eth.balance(this.address):
                                                                            revert with 0, 17
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                        emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                        mem[mem[64] + 68] = 0
                                                                        mem[mem[64] + 100] = 0
                                                                        mem[mem[64] + 132] = 0
                                                                        mem[mem[64] + 164] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                             gas gas_remaining wei
                                                                            args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                                        require return_data.size >= 96
                                                                        mem[mem[64] + 32] = 0
                                                                        mem[mem[64] + 64] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                        emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                        mem[0] = this.address
                                                                        mem[32] = 2
                                                                        _10811 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_10811 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_10811]:
                                                                            revert with 0, 50
                                                                        mem[_10811 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_10811 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _10811 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_10811]:
                                                                            revert with 0, 50
                                                                        mem[_10811 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                        mem[_10811 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_10811 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                        mem[_10811 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_10811 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_10811 + ceil32(return_data.size) + 260] = mem[_10811]
                                                                        idx = 0
                                                                        s = _10811 + ceil32(return_data.size) + 292
                                                                        t = _10811 + 32
                                                                        while idx < mem[_10811]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                             gas gas_remaining wei
                                                                            args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_10811 + ceil32(return_data.size) + 260 len (32 * mem[_10811]) + 32]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                uint8(stor30.field_0) = 0
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                if stor33[address(msg.sender)]:
                                                                    revert with 0, 'Blacklisted address'
                                                                if stor33[address(this.address)]:
                                                                    revert with 0, 'Blacklisted address'
                                                                emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                require ext_code.size(nodeRewardManagementAddress)
                                                                call nodeRewardManagementAddress.0x37696eec with:
                                                                     gas gas_remaining wei
                                                                    args msg.sender, uint8(cd[4])
                                                            else:
                                                                if swapTokensAmount and rewardsFee > -1 / swapTokensAmount:
                                                                    revert with 0, 17
                                                                if not swapTokensAmount:
                                                                    revert with 0, 18
                                                                if swapTokensAmount * rewardsFee / swapTokensAmount != rewardsFee:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                _5185 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_5185] = 26
                                                                mem[_5185 + 32] = 'SafeMath: division by zero'
                                                                if not swapTokensAmount * rewardsFee / 100:
                                                                    _5493 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_5493] = 26
                                                                    mem[_5493 + 32] = 'SafeMath: division by zero'
                                                                    _5643 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_5643] = 30
                                                                    mem[_5643 + 32] = 'SafeMath: subtraction overflow'
                                                                    if 0 > swapTokensAmount * rewardsFee / 100:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if swapTokensAmount * rewardsFee / 100 < 0:
                                                                        revert with 0, 17
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not distributionPoolAddress:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    if stor33[address(this.address)]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    mem[0] = distributionPoolAddress
                                                                    mem[32] = 33
                                                                    if stor33[stor24]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    emit Transfer((swapTokensAmount * rewardsFee / 100), this.address, distributionPoolAddress);
                                                                    if not swapTokensAmount:
                                                                        _6244 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_6244] = 26
                                                                        mem[_6244 + 32] = 'SafeMath: division by zero'
                                                                        mem[0] = this.address
                                                                        mem[32] = 2
                                                                        _6398 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_6398 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_6398]:
                                                                            revert with 0, 50
                                                                        mem[_6398 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_6398 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _6398 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_6398]:
                                                                            revert with 0, 50
                                                                        mem[_6398 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                        emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                        mem[_6398 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_6398 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                        mem[_6398 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_6398 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_6398 + ceil32(return_data.size) + 260] = mem[_6398]
                                                                        idx = 0
                                                                        s = _6398 + ceil32(return_data.size) + 292
                                                                        t = _6398 + 32
                                                                        while idx < mem[_6398]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[_6398 + ceil32(return_data.size) + 196] = this.address
                                                                        mem[_6398 + ceil32(return_data.size) + 228] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                             gas gas_remaining wei
                                                                            args mem[mem[64] + 4 len _6398 + ceil32(return_data.size) + (32 * mem[_6398]) + -mem[64] + 288]
                                                                    else:
                                                                        if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                            revert with 0, 17
                                                                        if not swapTokensAmount:
                                                                            revert with 0, 18
                                                                        if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                                        _6331 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_6331] = 26
                                                                        mem[_6331 + 32] = 'SafeMath: division by zero'
                                                                        if not swapTokensAmount * liquidityPoolFee / 100:
                                                                            mem[0] = this.address
                                                                            mem[32] = 2
                                                                            _6545 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_6545 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_6545]:
                                                                                revert with 0, 50
                                                                            mem[_6545 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_6545 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _6545 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_6545]:
                                                                                revert with 0, 50
                                                                            mem[_6545 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_6545 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_6545 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                            mem[_6545 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_6545 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_6545 + ceil32(return_data.size) + 260] = mem[_6545]
                                                                            idx = 0
                                                                            s = _6545 + ceil32(return_data.size) + 292
                                                                            t = _6545 + 32
                                                                            while idx < mem[_6545]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                 gas gas_remaining wei
                                                                                args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_6545 + ceil32(return_data.size) + 260 len (32 * mem[_6545]) + 32]
                                                                        else:
                                                                            _6512 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_6512] = 26
                                                                            mem[_6512 + 32] = 'SafeMath: division by zero'
                                                                            _6743 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_6743] = 30
                                                                            mem[_6743 + 32] = 'SafeMath: subtraction overflow'
                                                                            if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                revert with 0, 17
                                                                            _7022 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_7022 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_7022]:
                                                                                revert with 0, 50
                                                                            mem[_7022 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_7022 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _7022 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_7022]:
                                                                                revert with 0, 50
                                                                            mem[_7022 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                            allowance[msg.sender][stor20].field_255 = 0
                                                                            emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                            mem[_7022 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_7022 + ceil32(return_data.size) + 100] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                            mem[_7022 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_7022 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_7022 + ceil32(return_data.size) + 260] = mem[_7022]
                                                                            idx = 0
                                                                            s = _7022 + ceil32(return_data.size) + 292
                                                                            t = _7022 + 32
                                                                            while idx < mem[_7022]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                 gas gas_remaining wei
                                                                                args Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_7022 + ceil32(return_data.size) + 260 len (32 * mem[_7022]) + 32]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[_7022 + ceil32(return_data.size) + 96] = 30
                                                                            mem[_7022 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                                                            if eth.balance(this.address) > eth.balance(this.address):
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if eth.balance(this.address) < eth.balance(this.address):
                                                                                revert with 0, 17
                                                                            allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                            emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                            mem[_7022 + ceil32(return_data.size) + 228] = 0
                                                                            mem[_7022 + ceil32(return_data.size) + 260] = 0
                                                                            mem[_7022 + ceil32(return_data.size) + 292] = 0
                                                                            mem[_7022 + ceil32(return_data.size) + 324] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                 gas gas_remaining wei
                                                                                args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                            mem[_7022 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            require return_data.size >= 96
                                                                            emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                            mem[_7022 + (2 * ceil32(return_data.size)) + 160] = 2
                                                                            mem[_7022 + (2 * ceil32(return_data.size)) + 192] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_7022 + (2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _7022 + (4 * ceil32(return_data.size)) + 256
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            mem[_7022 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_7022 + (4 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_7022 + (4 * ceil32(return_data.size)) + 260] = balanceOf[address(this.address)]
                                                                            mem[_7022 + (4 * ceil32(return_data.size)) + 292] = 0
                                                                            mem[_7022 + (4 * ceil32(return_data.size)) + 324] = 160
                                                                            mem[_7022 + (4 * ceil32(return_data.size)) + 420] = 2
                                                                            idx = 0
                                                                            s = _7022 + (4 * ceil32(return_data.size)) + 452
                                                                            t = _7022 + (2 * ceil32(return_data.size)) + 192
                                                                            while idx < mem[_7022 + (2 * ceil32(return_data.size)) + 160]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            mem[_7022 + (4 * ceil32(return_data.size)) + 356] = this.address
                                                                            mem[_7022 + (4 * ceil32(return_data.size)) + 388] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                 gas gas_remaining wei
                                                                                args mem[mem[64] + 4 len _7022 + (4 * ceil32(return_data.size)) + (32 * mem[_7022 + (2 * ceil32(return_data.size)) + 160]) + -mem[64] + 448]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    uint8(stor30.field_0) = 0
                                                                    if not msg.sender:
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    if stor33[address(msg.sender)]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    if stor33[address(this.address)]:
                                                                        revert with 0, 'Blacklisted address'
                                                                    emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                    require ext_code.size(nodeRewardManagementAddress)
                                                                    call nodeRewardManagementAddress.0x37696eec with:
                                                                         gas gas_remaining wei
                                                                        args msg.sender, uint8(cd[4])
                                                                else:
                                                                    if swapTokensAmount * rewardsFee / 100 and stor29 > -1 / swapTokensAmount * rewardsFee / 100:
                                                                        revert with 0, 17
                                                                    if not swapTokensAmount * rewardsFee / 100:
                                                                        revert with 0, 18
                                                                    if swapTokensAmount * rewardsFee / 100 * stor29 / swapTokensAmount * rewardsFee / 100 != stor29:
                                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                                    _5591 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_5591] = 26
                                                                    mem[_5591 + 32] = 'SafeMath: division by zero'
                                                                    if not swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                        _5796 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_5796] = 30
                                                                        mem[_5796 + 32] = 'SafeMath: subtraction overflow'
                                                                        if swapTokensAmount * rewardsFee / 100 * stor29 / 100 > swapTokensAmount * rewardsFee / 100:
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if swapTokensAmount * rewardsFee / 100 < swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                            revert with 0, 17
                                                                        if not this.address:
                                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                                        if not distributionPoolAddress:
                                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                                        if stor33[address(this.address)]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        mem[0] = distributionPoolAddress
                                                                        mem[32] = 33
                                                                        if stor33[stor24]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        emit Transfer(((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)), this.address, distributionPoolAddress);
                                                                        if not swapTokensAmount:
                                                                            _6330 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_6330] = 26
                                                                            mem[_6330 + 32] = 'SafeMath: division by zero'
                                                                            mem[0] = this.address
                                                                            mem[32] = 2
                                                                            _6541 = mem[64]
                                                                            mem[mem[64]] = 2
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_6541 + 32 len 64] = call.data[calldata.size len 64]
                                                                            if 0 >= mem[_6541]:
                                                                                revert with 0, 50
                                                                            mem[_6541 + 32] = this.address
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                    gas gas_remaining wei
                                                                            mem[_6541 + 96] = ext_call.return_data[0]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[64] = _6541 + ceil32(return_data.size) + 96
                                                                            require return_data.size >= 32
                                                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                            if 1 >= mem[_6541]:
                                                                                revert with 0, 50
                                                                            mem[_6541 + 64] = ext_call.return_data[12 len 20]
                                                                            mem[0] = uniV2RouterAddress
                                                                            mem[32] = sha3(msg.sender, 3)
                                                                            allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                            emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                            mem[_6541 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                            mem[_6541 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                            mem[_6541 + ceil32(return_data.size) + 132] = 0
                                                                            mem[_6541 + ceil32(return_data.size) + 164] = 160
                                                                            mem[_6541 + ceil32(return_data.size) + 260] = mem[_6541]
                                                                            idx = 0
                                                                            s = _6541 + ceil32(return_data.size) + 292
                                                                            t = _6541 + 32
                                                                            while idx < mem[_6541]:
                                                                                mem[s] = mem[t + 12 len 20]
                                                                                idx = idx + 1
                                                                                s = s + 32
                                                                                t = t + 32
                                                                                continue 
                                                                            mem[_6541 + ceil32(return_data.size) + 196] = this.address
                                                                            mem[_6541 + ceil32(return_data.size) + 228] = block.timestamp
                                                                            require ext_code.size(uniswapV2RouterAddress)
                                                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                 gas gas_remaining wei
                                                                                args mem[mem[64] + 4 len _6541 + ceil32(return_data.size) + (32 * mem[_6541]) + -mem[64] + 288]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            uint8(stor30.field_0) = 0
                                                                            if not msg.sender:
                                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                                            if not this.address:
                                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                                            if stor33[address(msg.sender)]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            if stor33[address(this.address)]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                            require ext_code.size(nodeRewardManagementAddress)
                                                                            call nodeRewardManagementAddress.0x37696eec with:
                                                                                 gas gas_remaining wei
                                                                                args msg.sender, uint8(cd[4])
                                                                        else:
                                                                            if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                                revert with 0, 17
                                                                            if not swapTokensAmount:
                                                                                revert with 0, 18
                                                                            if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                                            _6432 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_6432] = 26
                                                                            mem[_6432 + 32] = 'SafeMath: division by zero'
                                                                            if not swapTokensAmount * liquidityPoolFee / 100:
                                                                                mem[0] = this.address
                                                                                mem[32] = 2
                                                                                _6716 = mem[64]
                                                                                mem[mem[64]] = 2
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_6716 + 32 len 64] = call.data[calldata.size len 64]
                                                                                if 0 >= mem[_6716]:
                                                                                    revert with 0, 50
                                                                                mem[_6716 + 32] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_6716 + 96] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _6716 + ceil32(return_data.size) + 96
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                if 1 >= mem[_6716]:
                                                                                    revert with 0, 50
                                                                                mem[_6716 + 64] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                mem[_6716 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_6716 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                                mem[_6716 + ceil32(return_data.size) + 132] = 0
                                                                                mem[_6716 + ceil32(return_data.size) + 164] = 160
                                                                                mem[_6716 + ceil32(return_data.size) + 260] = mem[_6716]
                                                                                idx = 0
                                                                                s = _6716 + ceil32(return_data.size) + 292
                                                                                t = _6716 + 32
                                                                                while idx < mem[_6716]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                mem[_6716 + ceil32(return_data.size) + 196] = this.address
                                                                                mem[_6716 + ceil32(return_data.size) + 228] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                     gas gas_remaining wei
                                                                                    args mem[mem[64] + 4 len _6716 + ceil32(return_data.size) + (32 * mem[_6716]) + -mem[64] + 288]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                uint8(stor30.field_0) = 0
                                                                                if not msg.sender:
                                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                                if not this.address:
                                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                                if stor33[address(msg.sender)]:
                                                                                    revert with 0, 'Blacklisted address'
                                                                                if stor33[address(this.address)]:
                                                                                    revert with 0, 'Blacklisted address'
                                                                                emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                                require ext_code.size(nodeRewardManagementAddress)
                                                                                call nodeRewardManagementAddress.0x37696eec with:
                                                                                     gas gas_remaining wei
                                                                                    args msg.sender, uint8(cd[4])
                                                                            else:
                                                                                _6678 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_6678] = 26
                                                                                mem[_6678 + 32] = 'SafeMath: division by zero'
                                                                                _6944 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_6944] = 30
                                                                                mem[_6944 + 32] = 'SafeMath: subtraction overflow'
                                                                                if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                    revert with 0, 17
                                                                                _7282 = mem[64]
                                                                                mem[mem[64]] = 2
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_7282 + 32 len 64] = call.data[calldata.size len 64]
                                                                                if 0 >= mem[_7282]:
                                                                                    revert with 0, 50
                                                                                mem[_7282 + 32] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_7282 + 96] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _7282 + ceil32(return_data.size) + 96
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                if 1 >= mem[_7282]:
                                                                                    revert with 0, 50
                                                                                mem[_7282 + 64] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                allowance[msg.sender][stor20].field_255 = 0
                                                                                emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                                mem[_7282 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_7282 + ceil32(return_data.size) + 100] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                mem[_7282 + ceil32(return_data.size) + 132] = 0
                                                                                mem[_7282 + ceil32(return_data.size) + 164] = 160
                                                                                mem[_7282 + ceil32(return_data.size) + 260] = mem[_7282]
                                                                                idx = 0
                                                                                s = _7282 + ceil32(return_data.size) + 292
                                                                                t = _7282 + 32
                                                                                while idx < mem[_7282]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                     gas gas_remaining wei
                                                                                    args Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_7282 + ceil32(return_data.size) + 260 len (32 * mem[_7282]) + 32]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[_7282 + ceil32(return_data.size) + 96] = 30
                                                                                mem[_7282 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                                                                if eth.balance(this.address) > eth.balance(this.address):
                                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                if eth.balance(this.address) < eth.balance(this.address):
                                                                                    revert with 0, 17
                                                                                allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                                mem[_7282 + ceil32(return_data.size) + 228] = 0
                                                                                mem[_7282 + ceil32(return_data.size) + 260] = 0
                                                                                mem[_7282 + ceil32(return_data.size) + 292] = 0
                                                                                mem[_7282 + ceil32(return_data.size) + 324] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                     gas gas_remaining wei
                                                                                    args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                                mem[_7282 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                require return_data.size >= 96
                                                                                emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                                mem[_7282 + (2 * ceil32(return_data.size)) + 160] = 2
                                                                                mem[_7282 + (2 * ceil32(return_data.size)) + 192] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_7282 + (2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _7282 + (4 * ceil32(return_data.size)) + 256
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                mem[_7282 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                mem[_7282 + (4 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_7282 + (4 * ceil32(return_data.size)) + 260] = balanceOf[address(this.address)]
                                                                                mem[_7282 + (4 * ceil32(return_data.size)) + 292] = 0
                                                                                mem[_7282 + (4 * ceil32(return_data.size)) + 324] = 160
                                                                                mem[_7282 + (4 * ceil32(return_data.size)) + 420] = 2
                                                                                idx = 0
                                                                                s = _7282 + (4 * ceil32(return_data.size)) + 452
                                                                                t = _7282 + (2 * ceil32(return_data.size)) + 192
                                                                                while idx < mem[_7282 + (2 * ceil32(return_data.size)) + 160]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                mem[_7282 + (4 * ceil32(return_data.size)) + 356] = this.address
                                                                                mem[_7282 + (4 * ceil32(return_data.size)) + 388] = block.timestamp
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                     gas gas_remaining wei
                                                                                    args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_7282 + (4 * ceil32(return_data.size)) + 420 len (32 * mem[_7282 + (2 * ceil32(return_data.size)) + 160]) + 32]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                uint8(stor30.field_0) = 0
                                                                                if not msg.sender:
                                                                                    mem[_7282 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[_7282 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                                    mem[_7282 + (4 * ceil32(return_data.size)) + 292] = 37
                                                                                    mem[_7282 + (4 * ceil32(return_data.size)) + 324] = 'ERC20: transfer from the zero ad'
                                                                                    mem[_7282 + (4 * ceil32(return_data.size)) + 356] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                                    revert with memory
                                                                                      from _7282 + (4 * ceil32(return_data.size)) + 256
                                                                                       len (5 * ceil32(return_data.size)) + 132
                                                                                if not this.address:
                                                                                    mem[_7282 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[_7282 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                                    mem[_7282 + (4 * ceil32(return_data.size)) + 292] = 35
                                                                                    mem[_7282 + (4 * ceil32(return_data.size)) + 324] = 'ERC20: transfer to the zero addr'
                                                                                    mem[_7282 + (4 * ceil32(return_data.size)) + 356] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                                    revert with memory
                                                                                      from _7282 + (4 * ceil32(return_data.size)) + 256
                                                                                       len (5 * ceil32(return_data.size)) + 132
                                                                                if stor33[address(msg.sender)]:
                                                                                    mem[_7282 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[_7282 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                                    mem[_7282 + (4 * ceil32(return_data.size)) + 292] = 19
                                                                                    mem[_7282 + (4 * ceil32(return_data.size)) + 324] = 'Blacklisted address' << 104
                                                                                    revert with memory
                                                                                      from _7282 + (4 * ceil32(return_data.size)) + 256
                                                                                       len (5 * ceil32(return_data.size)) + 100
                                                                                if stor33[address(this.address)]:
                                                                                    mem[_7282 + (4 * ceil32(return_data.size)) + 256] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[_7282 + (4 * ceil32(return_data.size)) + 260] = 32
                                                                                    mem[_7282 + (4 * ceil32(return_data.size)) + 292] = 19
                                                                                    mem[_7282 + (4 * ceil32(return_data.size)) + 324] = 'Blacklisted address' << 104
                                                                                    revert with memory
                                                                                      from _7282 + (4 * ceil32(return_data.size)) + 256
                                                                                       len (5 * ceil32(return_data.size)) + 100
                                                                                emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                                mem[_7282 + (4 * ceil32(return_data.size)) + 260] = msg.sender
                                                                                mem[_7282 + (4 * ceil32(return_data.size)) + 292] = uint8(cd[4])
                                                                                require ext_code.size(nodeRewardManagementAddress)
                                                                                call nodeRewardManagementAddress.0x37696eec with:
                                                                                     gas gas_remaining wei
                                                                                    args mem[_7282 + (4 * ceil32(return_data.size)) + 260 len (5 * ceil32(return_data.size)) + 64]
                                                                    else:
                                                                        _5820 = mem[64]
                                                                        mem[mem[64]] = 2
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_5820 + 32 len 64] = call.data[calldata.size len 64]
                                                                        if 0 >= mem[_5820]:
                                                                            revert with 0, 50
                                                                        mem[_5820 + 32] = this.address
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                gas gas_remaining wei
                                                                        mem[_5820 + 96] = ext_call.return_data[0]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        mem[64] = _5820 + ceil32(return_data.size) + 96
                                                                        require return_data.size >= 32
                                                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                        if 1 >= mem[_5820]:
                                                                            revert with 0, 50
                                                                        mem[_5820 + 64] = ext_call.return_data[12 len 20]
                                                                        mem[0] = uniV2RouterAddress
                                                                        mem[32] = sha3(msg.sender, 3)
                                                                        allowance[msg.sender][stor20].field_0 = swapTokensAmount * rewardsFee / 100 * stor29 / 100
                                                                        emit Approval((swapTokensAmount * rewardsFee / 100 * stor29 / 100), msg.sender, uniV2RouterAddress);
                                                                        mem[_5820 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                        mem[_5820 + ceil32(return_data.size) + 100] = swapTokensAmount * rewardsFee / 100 * stor29 / 100
                                                                        mem[_5820 + ceil32(return_data.size) + 132] = 0
                                                                        mem[_5820 + ceil32(return_data.size) + 164] = 160
                                                                        mem[_5820 + ceil32(return_data.size) + 260] = mem[_5820]
                                                                        idx = 0
                                                                        s = _5820 + ceil32(return_data.size) + 292
                                                                        t = _5820 + 32
                                                                        while idx < mem[_5820]:
                                                                            mem[s] = mem[t + 12 len 20]
                                                                            idx = idx + 1
                                                                            s = s + 32
                                                                            t = t + 32
                                                                            continue 
                                                                        mem[_5820 + ceil32(return_data.size) + 196] = this.address
                                                                        mem[_5820 + ceil32(return_data.size) + 228] = block.timestamp
                                                                        require ext_code.size(uniswapV2RouterAddress)
                                                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                             gas gas_remaining wei
                                                                            args mem[mem[64] + 4 len _5820 + ceil32(return_data.size) + (32 * mem[_5820]) + -mem[64] + 288]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        _9558 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_9558] = 30
                                                                        mem[_9558 + 32] = 'SafeMath: subtraction overflow'
                                                                        if eth.balance(this.address) > eth.balance(this.address):
                                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                                        if eth.balance(this.address) < eth.balance(this.address):
                                                                            revert with 0, 17
                                                                        call distributionPoolAddress with:
                                                                             gas 30000 wei
                                                                        if not return_data.size:
                                                                            _10511 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_10511] = 30
                                                                            mem[_10511 + 32] = 'SafeMath: subtraction overflow'
                                                                            if swapTokensAmount * rewardsFee / 100 * stor29 / 100 > swapTokensAmount * rewardsFee / 100:
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if swapTokensAmount * rewardsFee / 100 < swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                                revert with 0, 17
                                                                            if not this.address:
                                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                                            if not distributionPoolAddress:
                                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                                            if stor33[address(this.address)]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            mem[0] = distributionPoolAddress
                                                                            mem[32] = 33
                                                                            if stor33[stor24]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            emit Transfer(((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)), this.address, distributionPoolAddress);
                                                                            if not swapTokensAmount:
                                                                                _10969 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_10969] = 26
                                                                                mem[_10969 + 32] = 'SafeMath: division by zero'
                                                                                mem[0] = this.address
                                                                                mem[32] = 2
                                                                                _11181 = mem[64]
                                                                                mem[mem[64]] = 2
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_11181 + 32 len 64] = call.data[calldata.size len 64]
                                                                                if 0 >= mem[_11181]:
                                                                                    revert with 0, 50
                                                                                mem[_11181 + 32] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_11181 + 96] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _11181 + ceil32(return_data.size) + 96
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                if 1 >= mem[_11181]:
                                                                                    revert with 0, 50
                                                                                mem[_11181 + 64] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                mem[_11181 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_11181 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                                mem[_11181 + ceil32(return_data.size) + 132] = 0
                                                                                mem[_11181 + ceil32(return_data.size) + 164] = 160
                                                                                mem[_11181 + ceil32(return_data.size) + 260] = mem[_11181]
                                                                                idx = 0
                                                                                s = _11181 + ceil32(return_data.size) + 292
                                                                                t = _11181 + 32
                                                                                while idx < mem[_11181]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                     gas gas_remaining wei
                                                                                    args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_11181 + ceil32(return_data.size) + 260 len (32 * mem[_11181]) + 32]
                                                                            else:
                                                                                if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                                    revert with 0, 17
                                                                                if not swapTokensAmount:
                                                                                    revert with 0, 18
                                                                                if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                                _11113 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_11113] = 26
                                                                                mem[_11113 + 32] = 'SafeMath: division by zero'
                                                                                if not swapTokensAmount * liquidityPoolFee / 100:
                                                                                    mem[0] = this.address
                                                                                    mem[32] = 2
                                                                                    _11353 = mem[64]
                                                                                    mem[mem[64]] = 2
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_11353 + 32 len 64] = call.data[calldata.size len 64]
                                                                                    if 0 >= mem[_11353]:
                                                                                        revert with 0, 50
                                                                                    mem[_11353 + 32] = this.address
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                            gas gas_remaining wei
                                                                                    mem[_11353 + 96] = ext_call.return_data[0]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = _11353 + ceil32(return_data.size) + 96
                                                                                    require return_data.size >= 32
                                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                    if 1 >= mem[_11353]:
                                                                                        revert with 0, 50
                                                                                    mem[_11353 + 64] = ext_call.return_data[12 len 20]
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                    emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                    mem[_11353 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                    mem[_11353 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                                    mem[_11353 + ceil32(return_data.size) + 132] = 0
                                                                                    mem[_11353 + ceil32(return_data.size) + 164] = 160
                                                                                    mem[_11353 + ceil32(return_data.size) + 260] = mem[_11353]
                                                                                    idx = 0
                                                                                    s = _11353 + ceil32(return_data.size) + 292
                                                                                    t = _11353 + 32
                                                                                    while idx < mem[_11353]:
                                                                                        mem[s] = mem[t + 12 len 20]
                                                                                        idx = idx + 1
                                                                                        s = s + 32
                                                                                        t = t + 32
                                                                                        continue 
                                                                                    mem[_11353 + ceil32(return_data.size) + 196] = this.address
                                                                                    mem[_11353 + ceil32(return_data.size) + 228] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                         gas gas_remaining wei
                                                                                        args mem[mem[64] + 4 len _11353 + ceil32(return_data.size) + (32 * mem[_11353]) + -mem[64] + 288]
                                                                                else:
                                                                                    _11291 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_11291] = 26
                                                                                    mem[_11291 + 32] = 'SafeMath: division by zero'
                                                                                    _11607 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_11607] = 30
                                                                                    mem[_11607 + 32] = 'SafeMath: subtraction overflow'
                                                                                    if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                    if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                        revert with 0, 17
                                                                                    _11746 = mem[64]
                                                                                    mem[mem[64]] = 2
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_11746 + 32 len 64] = call.data[calldata.size len 64]
                                                                                    if 0 >= mem[_11746]:
                                                                                        revert with 0, 50
                                                                                    mem[_11746 + 32] = this.address
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                            gas gas_remaining wei
                                                                                    mem[_11746 + 96] = ext_call.return_data[0]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = _11746 + ceil32(return_data.size) + 96
                                                                                    require return_data.size >= 32
                                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                    if 1 >= mem[_11746]:
                                                                                        revert with 0, 50
                                                                                    mem[_11746 + 64] = ext_call.return_data[12 len 20]
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                    allowance[msg.sender][stor20].field_255 = 0
                                                                                    emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                                    mem[_11746 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                    mem[_11746 + ceil32(return_data.size) + 100] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                    mem[_11746 + ceil32(return_data.size) + 132] = 0
                                                                                    mem[_11746 + ceil32(return_data.size) + 164] = 160
                                                                                    mem[_11746 + ceil32(return_data.size) + 260] = mem[_11746]
                                                                                    idx = 0
                                                                                    s = _11746 + ceil32(return_data.size) + 292
                                                                                    t = _11746 + 32
                                                                                    while idx < mem[_11746]:
                                                                                        mem[s] = mem[t + 12 len 20]
                                                                                        idx = idx + 1
                                                                                        s = s + 32
                                                                                        t = t + 32
                                                                                        continue 
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                         gas gas_remaining wei
                                                                                        args Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, 160, address(this.address), block.timestamp, mem[_11746 + ceil32(return_data.size) + 260 len (32 * mem[_11746]) + 32]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[_11746 + ceil32(return_data.size) + 96] = 30
                                                                                    mem[_11746 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                                                                    if eth.balance(this.address) > eth.balance(this.address):
                                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                    if eth.balance(this.address) < eth.balance(this.address):
                                                                                        revert with 0, 17
                                                                                    allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                    emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                                    mem[_11746 + ceil32(return_data.size) + 228] = 0
                                                                                    mem[_11746 + ceil32(return_data.size) + 260] = 0
                                                                                    mem[_11746 + ceil32(return_data.size) + 292] = 0
                                                                                    mem[_11746 + ceil32(return_data.size) + 324] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                         gas gas_remaining wei
                                                                                        args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                                    mem[_11746 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    require return_data.size >= 96
                                                                                    emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                                    mem[_11746 + (2 * ceil32(return_data.size)) + 160] = 2
                                                                                    mem[_11746 + (2 * ceil32(return_data.size)) + 192] = this.address
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                            gas gas_remaining wei
                                                                                    mem[_11746 + (2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = _11746 + (4 * ceil32(return_data.size)) + 256
                                                                                    require return_data.size >= 32
                                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                    mem[_11746 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                    emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                    mem[_11746 + (4 * ceil32(return_data.size)) + 256] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                    mem[_11746 + (4 * ceil32(return_data.size)) + 260] = balanceOf[address(this.address)]
                                                                                    mem[_11746 + (4 * ceil32(return_data.size)) + 292] = 0
                                                                                    mem[_11746 + (4 * ceil32(return_data.size)) + 324] = 160
                                                                                    mem[_11746 + (4 * ceil32(return_data.size)) + 420] = 2
                                                                                    idx = 0
                                                                                    s = _11746 + (4 * ceil32(return_data.size)) + 452
                                                                                    t = _11746 + (2 * ceil32(return_data.size)) + 192
                                                                                    while idx < mem[_11746 + (2 * ceil32(return_data.size)) + 160]:
                                                                                        mem[s] = mem[t + 12 len 20]
                                                                                        idx = idx + 1
                                                                                        s = s + 32
                                                                                        t = t + 32
                                                                                        continue 
                                                                                    mem[_11746 + (4 * ceil32(return_data.size)) + 356] = this.address
                                                                                    mem[_11746 + (4 * ceil32(return_data.size)) + 388] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                         gas gas_remaining wei
                                                                                        args mem[mem[64] + 4 len _11746 + (4 * ceil32(return_data.size)) + (32 * mem[_11746 + (2 * ceil32(return_data.size)) + 160]) + -mem[64] + 448]
                                                                        else:
                                                                            _10381 = mem[64]
                                                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                                                            mem[_10381] = return_data.size
                                                                            mem[_10381 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                                            _10512 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_10512] = 30
                                                                            mem[_10512 + 32] = 'SafeMath: subtraction overflow'
                                                                            if swapTokensAmount * rewardsFee / 100 * stor29 / 100 > swapTokensAmount * rewardsFee / 100:
                                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                                            if swapTokensAmount * rewardsFee / 100 < swapTokensAmount * rewardsFee / 100 * stor29 / 100:
                                                                                revert with 0, 17
                                                                            if not this.address:
                                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                                            if not distributionPoolAddress:
                                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                                            if stor33[address(this.address)]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            mem[0] = distributionPoolAddress
                                                                            mem[32] = 33
                                                                            if stor33[stor24]:
                                                                                revert with 0, 'Blacklisted address'
                                                                            emit Transfer(((swapTokensAmount * rewardsFee / 100) - (swapTokensAmount * rewardsFee / 100 * stor29 / 100)), this.address, distributionPoolAddress);
                                                                            if not swapTokensAmount:
                                                                                _10970 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_10970] = 26
                                                                                mem[_10970 + 32] = 'SafeMath: division by zero'
                                                                                mem[0] = this.address
                                                                                mem[32] = 2
                                                                                _11183 = mem[64]
                                                                                mem[mem[64]] = 2
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_11183 + 32 len 64] = call.data[calldata.size len 64]
                                                                                if 0 >= mem[_11183]:
                                                                                    revert with 0, 50
                                                                                mem[_11183 + 32] = this.address
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                        gas gas_remaining wei
                                                                                mem[_11183 + 96] = ext_call.return_data[0]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                mem[64] = _11183 + ceil32(return_data.size) + 96
                                                                                require return_data.size >= 32
                                                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                if 1 >= mem[_11183]:
                                                                                    revert with 0, 50
                                                                                mem[_11183 + 64] = ext_call.return_data[12 len 20]
                                                                                mem[0] = uniV2RouterAddress
                                                                                mem[32] = sha3(msg.sender, 3)
                                                                                allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                mem[_11183 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                mem[_11183 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                                mem[_11183 + ceil32(return_data.size) + 132] = 0
                                                                                mem[_11183 + ceil32(return_data.size) + 164] = 160
                                                                                mem[_11183 + ceil32(return_data.size) + 260] = mem[_11183]
                                                                                idx = 0
                                                                                s = _11183 + ceil32(return_data.size) + 292
                                                                                t = _11183 + 32
                                                                                while idx < mem[_11183]:
                                                                                    mem[s] = mem[t + 12 len 20]
                                                                                    idx = idx + 1
                                                                                    s = s + 32
                                                                                    t = t + 32
                                                                                    continue 
                                                                                require ext_code.size(uniswapV2RouterAddress)
                                                                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                                                     gas gas_remaining wei
                                                                                    args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, mem[_11183 + ceil32(return_data.size) + 260 len (32 * mem[_11183]) + 32]
                                                                            else:
                                                                                if swapTokensAmount and liquidityPoolFee > -1 / swapTokensAmount:
                                                                                    revert with 0, 17
                                                                                if not swapTokensAmount:
                                                                                    revert with 0, 18
                                                                                if swapTokensAmount * liquidityPoolFee / swapTokensAmount != liquidityPoolFee:
                                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                                _11114 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_11114] = 26
                                                                                mem[_11114 + 32] = 'SafeMath: division by zero'
                                                                                if not swapTokensAmount * liquidityPoolFee / 100:
                                                                                    mem[0] = this.address
                                                                                    mem[32] = 2
                                                                                    _11355 = mem[64]
                                                                                    mem[mem[64]] = 2
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_11355 + 32 len 64] = call.data[calldata.size len 64]
                                                                                    if 0 >= mem[_11355]:
                                                                                        revert with 0, 50
                                                                                    mem[_11355 + 32] = this.address
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                            gas gas_remaining wei
                                                                                    mem[_11355 + 96] = ext_call.return_data[0]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = _11355 + ceil32(return_data.size) + 96
                                                                                    require return_data.size >= 32
                                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                    if 1 >= mem[_11355]:
                                                                                        revert with 0, 50
                                                                                    mem[_11355 + 64] = ext_call.return_data[12 len 20]
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                    emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                    mem[_11355 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                    mem[_11355 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                                    mem[_11355 + ceil32(return_data.size) + 132] = 0
                                                                                    mem[_11355 + ceil32(return_data.size) + 164] = 160
                                                                                    mem[_11355 + ceil32(return_data.size) + 260] = mem[_11355]
                                                                                    idx = 0
                                                                                    s = _11355 + ceil32(return_data.size) + 292
                                                                                    t = _11355 + 32
                                                                                    while idx < mem[_11355]:
                                                                                        mem[s] = mem[t + 12 len 20]
                                                                                        idx = idx + 1
                                                                                        s = s + 32
                                                                                        t = t + 32
                                                                                        continue 
                                                                                    mem[_11355 + ceil32(return_data.size) + 196] = this.address
                                                                                    mem[_11355 + ceil32(return_data.size) + 228] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                         gas gas_remaining wei
                                                                                        args mem[mem[64] + 4 len _11355 + ceil32(return_data.size) + (32 * mem[_11355]) + -mem[64] + 288]
                                                                                else:
                                                                                    _11293 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_11293] = 26
                                                                                    mem[_11293 + 32] = 'SafeMath: division by zero'
                                                                                    _11608 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_11608] = 30
                                                                                    mem[_11608 + 32] = 'SafeMath: subtraction overflow'
                                                                                    if swapTokensAmount * liquidityPoolFee / 100 / 2 > swapTokensAmount * liquidityPoolFee / 100:
                                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                    if swapTokensAmount * liquidityPoolFee / 100 < swapTokensAmount * liquidityPoolFee / 100 / 2:
                                                                                        revert with 0, 17
                                                                                    _11750 = mem[64]
                                                                                    mem[mem[64]] = 2
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_11750 + 32 len 64] = call.data[calldata.size len 64]
                                                                                    if 0 >= mem[_11750]:
                                                                                        revert with 0, 50
                                                                                    mem[_11750 + 32] = this.address
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                            gas gas_remaining wei
                                                                                    mem[_11750 + 96] = ext_call.return_data[0]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = _11750 + ceil32(return_data.size) + 96
                                                                                    require return_data.size >= 32
                                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                    if 1 >= mem[_11750]:
                                                                                        revert with 0, 50
                                                                                    mem[_11750 + 64] = ext_call.return_data[12 len 20]
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                    allowance[msg.sender][stor20].field_255 = 0
                                                                                    emit Approval((swapTokensAmount * liquidityPoolFee / 100 / 2), msg.sender, uniV2RouterAddress);
                                                                                    mem[_11750 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                    mem[_11750 + ceil32(return_data.size) + 100] = swapTokensAmount * liquidityPoolFee / 100 / 2
                                                                                    mem[_11750 + ceil32(return_data.size) + 132] = 0
                                                                                    mem[_11750 + ceil32(return_data.size) + 164] = 160
                                                                                    mem[_11750 + ceil32(return_data.size) + 260] = mem[_11750]
                                                                                    idx = 0
                                                                                    s = _11750 + ceil32(return_data.size) + 292
                                                                                    t = _11750 + 32
                                                                                    while idx < mem[_11750]:
                                                                                        mem[s] = mem[t + 12 len 20]
                                                                                        idx = idx + 1
                                                                                        s = s + 32
                                                                                        t = t + 32
                                                                                        continue 
                                                                                    mem[_11750 + ceil32(return_data.size) + 196] = this.address
                                                                                    mem[_11750 + ceil32(return_data.size) + 228] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                         gas gas_remaining wei
                                                                                        args mem[mem[64] + 4 len _11750 + ceil32(return_data.size) + (32 * mem[_11750]) + -mem[64] + 288]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    _12696 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_12696] = 30
                                                                                    mem[_12696 + 32] = 'SafeMath: subtraction overflow'
                                                                                    if eth.balance(this.address) > eth.balance(this.address):
                                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                                    if eth.balance(this.address) < eth.balance(this.address):
                                                                                        revert with 0, 17
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                    emit Approval(((swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)), msg.sender, uniV2RouterAddress);
                                                                                    mem[mem[64] + 68] = 0
                                                                                    mem[mem[64] + 100] = 0
                                                                                    mem[mem[64] + 132] = 0
                                                                                    mem[mem[64] + 164] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.addLiquidityAVAX(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                                                         gas gas_remaining wei
                                                                                        args this.address, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2), 0, 0, 0, block.timestamp
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    mem[mem[64] + 32] = 0
                                                                                    mem[mem[64] + 64] = (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2)
                                                                                    emit SwapAndLiquify(Mask(255, 1, swapTokensAmount * liquidityPoolFee / 100), 0, (swapTokensAmount * liquidityPoolFee / 100) - (swapTokensAmount * liquidityPoolFee / 100 / 2));
                                                                                    mem[0] = this.address
                                                                                    mem[32] = 2
                                                                                    _13359 = mem[64]
                                                                                    mem[mem[64]] = 2
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_13359 + 32 len 64] = call.data[calldata.size len 64]
                                                                                    if 0 >= mem[_13359]:
                                                                                        revert with 0, 50
                                                                                    mem[_13359 + 32] = this.address
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    staticcall uniswapV2RouterAddress.WAVAX() with:
                                                                                            gas gas_remaining wei
                                                                                    mem[_13359 + 96] = ext_call.return_data[0]
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[64] = _13359 + ceil32(return_data.size) + 96
                                                                                    require return_data.size >= 32
                                                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                                                    if 1 >= mem[_13359]:
                                                                                        revert with 0, 50
                                                                                    mem[_13359 + 64] = ext_call.return_data[12 len 20]
                                                                                    mem[0] = uniV2RouterAddress
                                                                                    mem[32] = sha3(msg.sender, 3)
                                                                                    allowance[msg.sender][stor20].field_0 = balanceOf[address(this.address)]
                                                                                    emit Approval(balanceOf[address(this.address)], msg.sender, uniV2RouterAddress);
                                                                                    mem[_13359 + ceil32(return_data.size) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                                                                    mem[_13359 + ceil32(return_data.size) + 100] = balanceOf[address(this.address)]
                                                                                    mem[_13359 + ceil32(return_data.size) + 132] = 0
                                                                                    mem[_13359 + ceil32(return_data.size) + 164] = 160
                                                                                    mem[_13359 + ceil32(return_data.size) + 260] = mem[_13359]
                                                                                    idx = 0
                                                                                    s = _13359 + ceil32(return_data.size) + 292
                                                                                    t = _13359 + 32
                                                                                    while idx < mem[_13359]:
                                                                                        mem[s] = mem[t + 12 len 20]
                                                                                        idx = idx + 1
                                                                                        s = s + 32
                                                                                        t = t + 32
                                                                                        continue 
                                                                                    mem[_13359 + ceil32(return_data.size) + 196] = this.address
                                                                                    mem[_13359 + ceil32(return_data.size) + 228] = block.timestamp
                                                                                    require ext_code.size(uniswapV2RouterAddress)
                                                                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                                                         gas gas_remaining wei
                                                                                        args mem[mem[64] + 4 len _13359 + ceil32(return_data.size) + (32 * mem[_13359]) + -mem[64] + 288]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        uint8(stor30.field_0) = 0
                                                                        if not msg.sender:
                                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                                        if not this.address:
                                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                                        if stor33[address(msg.sender)]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        if stor33[address(this.address)]:
                                                                            revert with 0, 'Blacklisted address'
                                                                        emit Transfer(ext_call.return_data[0], msg.sender, this.address);
                                                                        require ext_code.size(nodeRewardManagementAddress)
                                                                        call nodeRewardManagementAddress.0x37696eec with:
                                                                             gas gas_remaining wei
                                                                            args msg.sender, uint8(cd[4])
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
}



}

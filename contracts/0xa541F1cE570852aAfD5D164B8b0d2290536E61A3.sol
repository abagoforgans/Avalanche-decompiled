contract main {




// =====================  Runtime code  =====================


#
#  - sub_14564cfb(?)
#  - sub_1aeab058(?)
#  - sub_23a28325(?)
#  - sub_fea6b5d2(?)
#
const getChainId = chainid

const ERC712_VERSION = '', 0

const DEFAULT_ADMIN_ROLE = 0

const DEPOSITOR_ROLE = 0x8f4f2da22e8ac8f11e15f9fc141cddbb5deea8800186560abb6e68c5496619a9


mapping of uint256 balanceOf;
mapping of uint8 stor1;
mapping of struct roleAdmin;
address owner;
uint256 domainSeperator;
mapping of uint8 stor6;
uint8 stor7;
mapping of uint256 sub_fc86b662;
mapping of uint256 sub_79920951;
mapping of uint256 sub_0f699e80;
mapping of uint8 stor11;
mapping of uint8 stor12;
mapping of uint8 stor13;
mapping of uint256 mintNumber;
mapping of struct stor15;
array of struct stor16;
array of struct stor17;
array of struct stor18;

function balanceOf(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC1155: balance query for the zero address'
    return balanceOf[arg2][address(arg1)]
}

function sub_0f699e80(?) {
    require calldata.size - 4 >= 32
    return sub_0f699e80[arg1]
}

function getDomainSeperator() {
    return domainSeperator
}

function getRoleAdmin(bytes32 arg1) {
    require calldata.size - 4 >= 32
    return roleAdmin[arg1].field_256
}

function getNonce(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return nonce[address(arg1)].field_0
}

function sub_3199da02(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return bool(stor6[address(arg1)])
}

function sub_79920951(?) {
    require calldata.size - 4 >= 32
    return sub_79920951[arg1]
}

function sub_7c638212(?) {
    return bool(stor7)
}

function owner() {
    return owner
}

function hasRole(bytes32 arg1, address arg2) {
    require calldata.size - 4 >= 64
    require arg2 == arg2
    return bool(uint8(roleAdmin[arg1][address(arg2)].field_0))
}

function sub_aed0ddf2(?) {
    require calldata.size - 4 >= 32
    return bool(stor12[arg1])
}

function sub_bb720188(?) {
    require calldata.size - 4 >= 32
    return bool(stor11[arg1])
}

function sub_d3d57d89(?) {
    require calldata.size - 4 >= 32
    return bool(stor13[arg1])
}

function mintNumber(uint256 arg1) {
    require calldata.size - 4 >= 32
    return mintNumber[arg1]
}

function sub_fc86b662(?) {
    require calldata.size - 4 >= 32
    return sub_fc86b662[arg1]
}

function _fallback() payable {
    revert
}

function isApprovedForAll(address arg1, address arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if stor1[address(arg1)][address(arg2)]:
        return bool(stor1[address(arg1)][address(arg2)])
    return (1 == bool(stor6[address(arg2)]))
}

function supportsInterface(bytes4 arg1) {
    require calldata.size - 4 >= 32
    require arg1 == Mask(32, 224, arg1)
    if 0x7965db0b00000000000000000000000000000000000000000000000000000000 == Mask(32, 224, arg1):
        return True
    if 0x1ffc9a700000000000000000000000000000000000000000000000000000000 == Mask(32, 224, arg1):
        return True
    if 0xd9b67a2600000000000000000000000000000000000000000000000000000000 == Mask(32, 224, arg1):
        return True
    if 0xe89341c00000000000000000000000000000000000000000000000000000000 == Mask(32, 224, arg1):
        return True
    return (0xf79f20b500000000000000000000000000000000000000000000000000000000 == Mask(32, 224, arg1))
}

function renounceRole(bytes32 arg1, address arg2) {
    require calldata.size - 4 >= 64
    require arg2 == arg2
    if msg.sender != this.address:
        if arg2 != msg.sender:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'AccessControl: can only renounce roles for self'
        if uint8(roleAdmin[arg1][address(arg2)].field_0):
            uint8(roleAdmin[arg1][address(arg2)].field_0) = 0
            if msg.sender != this.address:
                emit RoleRevoked(arg1, arg2, msg.sender);
            else:
                mem[96] = calldata.size
                mem[128 len calldata.size] = call.data[0 len calldata.size]
                emit RoleRevoked(arg1, arg2, mem[calldata.size + 108 len 20]);
    else:
        mem[96] = calldata.size
        mem[128 len calldata.size] = call.data[0 len calldata.size]
        if arg2 != mem[calldata.size + 108 len 20]:
            revert with 0, 'AccessControl: can only renounce roles for self'
        if uint8(roleAdmin[arg1][address(arg2)].field_0):
            uint8(roleAdmin[arg1][address(arg2)].field_0) = 0
            if msg.sender != this.address:
                emit RoleRevoked(arg1, arg2, msg.sender);
            else:
                mem[ceil32(calldata.size) + 128] = calldata.size
                mem[ceil32(calldata.size) + 160 len calldata.size] = call.data[0 len calldata.size]
                emit RoleRevoked(arg1, arg2, mem[calldata.size + ceil32(calldata.size) + 140 len 20]);
}

function setApprovalForAll(address arg1, bool arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if msg.sender != this.address:
        if msg.sender == arg1:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC1155: setting approval status for self'
        if msg.sender != this.address:
            stor1[address(msg.sender)][address(arg1)] = uint8(arg2)
            emit ApprovalForAll(arg2, msg.sender, arg1);
        else:
            mem[96] = calldata.size
            mem[128 len calldata.size] = call.data[0 len calldata.size]
            stor1[mem[calldata.size + 108 len 20]][address(arg1)] = uint8(arg2)
            mem[ceil32(calldata.size) + 128] = calldata.size
            mem[ceil32(calldata.size) + 160 len calldata.size] = call.data[0 len calldata.size]
            emit ApprovalForAll(arg2, mem[calldata.size + ceil32(calldata.size) + 140 len 20], arg1);
    else:
        mem[96] = calldata.size
        mem[128 len calldata.size] = call.data[0 len calldata.size]
        if mem[calldata.size + 108 len 20] == arg1:
            revert with 0, 'ERC1155: setting approval status for self'
        if msg.sender != this.address:
            stor1[address(msg.sender)][address(arg1)] = uint8(arg2)
            emit ApprovalForAll(arg2, msg.sender, arg1);
        else:
            mem[ceil32(calldata.size) + 128] = calldata.size
            mem[ceil32(calldata.size) + 160 len calldata.size] = call.data[0 len calldata.size]
            stor1[mem[calldata.size + ceil32(calldata.size) + 140 len 20]][address(arg1)] = uint8(arg2)
            mem[(2 * ceil32(calldata.size)) + 160] = calldata.size
            mem[(2 * ceil32(calldata.size)) + 192 len calldata.size] = call.data[0 len calldata.size]
            emit ApprovalForAll(arg2, mem[calldata.size + (2 * ceil32(calldata.size)) + 172 len 20], arg1);
}

function withdrawSingle(uint256 arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    if msg.sender != this.address:
        if not msg.sender:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC1155: burn from the zero address'
        if msg.sender != this.address:
            if balanceOf[arg1][address(msg.sender)] < arg2:
                revert with 0, 'ERC1155: burn amount exceeds balance'
            balanceOf[arg1][address(msg.sender)] -= arg2
            emit TransferSingle(arg1, arg2, msg.sender, msg.sender, 0);
        else:
            mem[96] = calldata.size
            mem[128 len calldata.size] = call.data[0 len calldata.size]
            if balanceOf[arg1][address(msg.sender)] < arg2:
                revert with 0, 'ERC1155: burn amount exceeds balance'
            balanceOf[arg1][address(msg.sender)] -= arg2
            emit TransferSingle(arg1, arg2, mem[calldata.size + 108 len 20], msg.sender, 0);
    else:
        mem[96] = calldata.size
        mem[128 len calldata.size] = call.data[0 len calldata.size]
        if not mem[calldata.size + 108 len 20]:
            revert with 0, 'ERC1155: burn from the zero address'
        if msg.sender != this.address:
            if balanceOf[arg1][address(mem[calldata.size + 96])] < arg2:
                revert with 0, 'ERC1155: burn amount exceeds balance'
            balanceOf[arg1][address(mem[calldata.size + 96])] -= arg2
            emit TransferSingle(arg1, arg2, msg.sender, mem[calldata.size + 108 len 20], 0);
        else:
            mem[ceil32(calldata.size) + 128] = calldata.size
            mem[ceil32(calldata.size) + 160 len calldata.size] = call.data[0 len calldata.size]
            mem[(2 * ceil32(calldata.size)) + 192] = arg1
            mem[(2 * ceil32(calldata.size)) + 224] = 1
            mem[(2 * ceil32(calldata.size)) + 256] = arg2
            mem[(2 * ceil32(calldata.size)) + 288] = 0
            if balanceOf[arg1][address(mem[calldata.size + 96])] < arg2:
                revert with 0, 'ERC1155: burn amount exceeds balance'
            balanceOf[arg1][address(mem[calldata.size + 96])] -= arg2
            mem[(2 * ceil32(calldata.size)) + 320] = arg1
            mem[(2 * ceil32(calldata.size)) + 352] = arg2
            emit TransferSingle(arg1, arg2, mem[calldata.size + ceil32(calldata.size) + 140 len 20], mem[calldata.size + 108 len 20], 0);
}

function balanceOfBatch(address[] arg1, uint256[] arg2) {
    require calldata.size - 4 >= 64
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    if arg1.length > test266151307():
        revert with 0, 65
    if ceil32(32 * arg1.length) + 97 < 96 or ceil32(32 * arg1.length) + 97 > test266151307():
        revert with 0, 65
    mem[96] = arg1.length
    require arg1 + (32 * arg1.length) + 36 <= calldata.size
    s = 128
    idx = arg1 + 36
    while idx < arg1 + (32 * arg1.length) + 36:
        require cd[idx] == address(cd[idx])
        mem[s] = cd[idx]
        s = s + 32
        idx = idx + 32
        continue 
    require arg2 <= test266151307()
    require arg2 + 35 < calldata.size
    if arg2.length > test266151307():
        revert with 0, 65
    if ceil32(32 * arg2.length) + 98 < 97 or ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 98 > test266151307():
        revert with 0, 65
    mem[ceil32(32 * arg1.length) + 97] = arg2.length
    require arg2 + (32 * arg2.length) + 36 <= calldata.size
    idx = arg2 + 36
    s = ceil32(32 * arg1.length) + 129
    while idx < arg2 + (32 * arg2.length) + 36:
        mem[s] = cd[idx]
        idx = idx + 32
        s = s + 32
        continue 
    if arg1.length != arg2.length:
        revert with 0, 'ERC1155: accounts and ids length mismatch'
    if arg1.length > test266151307():
        revert with 0, 65
    mem[ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 98] = arg1.length
    if arg1.length:
        mem[ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 130 len 32 * arg1.length] = call.data[calldata.size len 32 * arg1.length]
    idx = 0
    while idx < arg1.length:
        if idx >= arg1.length:
            revert with 0, 50
        if idx >= arg2.length:
            revert with 0, 50
        if not mem[(32 * idx) + 140 len 20]:
            revert with 0, 'ERC1155: balance query for the zero address'
        mem[0] = mem[(32 * idx) + 140 len 20]
        mem[32] = sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 0)
        if idx >= arg1.length:
            revert with 0, 50
        mem[(32 * idx) + ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 130] = balanceOf[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]][address(mem[(32 * idx) + 128])]
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
    return Array(len=arg1.length, data=mem[ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 130 len 32 * arg1.length])
}

function renounceOwnership() {
    if msg.sender != this.address:
        if uint8(roleAdmin[0][address(msg.sender)].field_0):
            owner = 0
            emit OwnershipTransferred(owner, 0);
        mem[128 len 42] = call.data[calldata.size len 42]
        idx = 41
        s = address(msg.sender)
        while idx > 1:
            if s % 16 >= 16:
                revert with 0, 50
            if idx >= 42:
                revert with 0, 50
            mem[idx + 128 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
            if not idx:
                revert with 0, 17
            idx = idx - 1
            s = Mask(252, 0, s) * 0.0625
            continue 
        if msg.sender + 10240:
            revert with 0, 'Strings: hex length insufficient'
        mem[224 len 66] = call.data[calldata.size len 66]
        idx = 65
        while idx > 1:
            if idx >= 66:
                revert with 0, 50
            mem[idx + 224 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
            if not idx:
                revert with 0, 17
            idx = idx - 1
            continue 
        revert with 0, 32, 148, 'AccessControl: account ', mem[160 len 42], 8297, mem[288 len 66], 0, 0 >> 928, 0
    mem[96] = calldata.size
    mem[128 len calldata.size] = call.data[0 len calldata.size]
    if uint8(roleAdmin[0][address(mem[calldata.size + 96])].field_0):
        owner = 0
        emit OwnershipTransferred(owner, 0);
    mem[ceil32(calldata.size) + 160 len 42] = call.data[calldata.size len 42]
    idx = 41
    s = mem[calldata.size + 108 len 20]
    while idx > 1:
        if s % 16 >= 16:
            revert with 0, 50
        if idx >= 42:
            revert with 0, 50
        mem[idx + ceil32(calldata.size) + 160 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
        if not idx:
            revert with 0, 17
        idx = idx - 1
        s = Mask(252, 0, s) * 0.0625
        continue 
    if mem[calldata.size + 108 len 20] + 10240:
        revert with 0, 'Strings: hex length insufficient'
    mem[ceil32(calldata.size) + 256 len 66] = call.data[calldata.size len 66]
    idx = 65
    while idx > 1:
        if idx >= 66:
            revert with 0, 50
        mem[idx + ceil32(calldata.size) + 256 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
        if not idx:
            revert with 0, 17
        idx = idx - 1
        continue 
    revert with 0, 
                32,
                148,
                'AccessControl: account ', mem[ceil32(calldata.size) + 192 len 42], 8297, mem[ceil32(calldata.size) + 320 len 66], 0, 0 >> 928,
                0
}

function executeMetaTransaction(address arg1, bytes arg2, bytes32 arg3, bytes32 arg4, uint8 arg5) payable {
    require calldata.size - 4 >= 160
    require arg1 == arg1
    require arg2 <= test266151307()
    require arg2 + 35 < calldata.size
    if arg2.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg2.length)) + 97 < 96 or ceil32(ceil32(arg2.length)) + 97 > test266151307():
        revert with 0, 65
    require arg2 + arg2.length + 36 <= calldata.size
    require arg5 == arg5
    if not arg1:
        revert with 0, 'NativeMetaTransaction: INVALID_SIGNER'
    signer = erecover(sha3(0, domainSeperator, sha3(sha3(0xfe4d6574615472616e73616374696f6e2875696e74323536206e6f6e63652c616464726573732066726f6d2c62797465732066756e6374696f6e5369676e6174757265), nonce[address(arg1)].field_0, address(arg1), sha3(arg2[all]))), arg5 << 248, arg3, arg4) 
    if not erecover.result:
        revert with ext_call.return_data[0 len return_data.size]
    if arg1 != address(signer):
        revert with 0, 'Signer and signature do not match'
    if nonce[address(arg1)].field_0 > -2:
        revert with 0, 17
    nonce[address(arg1)].field_0++
    mem[ceil32(ceil32(arg2.length)) + 675] = 96
    mem[ceil32(ceil32(arg2.length)) + 707] = arg2.length
    mem[ceil32(ceil32(arg2.length)) + 739 len ceil32(arg2.length)] = arg2[all], Mask(8 * ceil32(arg2.length) - arg2.length, 0, nonce[address(arg1)].field_-(8 * ceil32(arg2.length) + -ceil32(ceil32(arg2.length)) + 31) + 256)
    if ceil32(arg2.length) > arg2.length:
        mem[arg2.length + ceil32(ceil32(arg2.length)) + 739] = 0
    emit MetaTransactionExecuted(address(arg1), msg.sender, Array(len=arg2.length, data=arg2[all]));
    mem[arg2.length + ceil32(ceil32(arg2.length)) + 663 len floor32(arg2.length + 51)] = Mask(8 * ceil32(arg2.length), -(8 * ceil32(arg2.length)) + 256, arg2[all], Mask(8 * ceil32(arg2.length) - arg2.length, 0, nonce[address(arg1)].field_-(8 * ceil32(arg2.length) + -ceil32(ceil32(arg2.length)) + 31) + 256)) << (8 * ceil32(arg2.length)) - 256, Mask((8 * -ceil32(arg2.length) + arg2.length + 32) - 96, 0, arg1) << 96, mem[ceil32(ceil32(arg2.length)) + arg2.length + 675 len floor32(arg2.length + 51) + -arg2.length - 32]
    if floor32(arg2.length + 51) > arg2.length + 20:
        mem[(2 * arg2.length) + ceil32(ceil32(arg2.length)) + 683] = 0
    call this.address.mem[arg2.length + ceil32(ceil32(arg2.length)) + 663 len 4] with:
         gas gas_remaining wei
        args mem[arg2.length + ceil32(ceil32(arg2.length)) + 667 len arg2.length + 16]
    if not ext_call.success:
        revert with 0, 'Function call not successful'
    if not return_data.size:
        return Array(len=arg2.length, data=arg2[all])
    return Array(len=return_data.size, data=ext_call.return_data[0 len return_data.size])
}

function sub_fcb440b6(?) {
    require calldata.size - 4 >= 32
    require arg1 == bool(arg1)
    if msg.sender != this.address:
        if uint8(roleAdmin[0][address(msg.sender)].field_0):
            if stor7:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Auto-approved addresses are locked'
            stor7 = uint8(bool(arg1))
        mem[128 len 42] = call.data[calldata.size len 42]
        idx = 41
        s = address(msg.sender)
        while idx > 1:
            if s % 16 >= 16:
                revert with 0, 50
            if idx >= 42:
                revert with 0, 50
            mem[idx + 128 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
            if not idx:
                revert with 0, 17
            idx = idx - 1
            s = Mask(252, 0, s) * 0.0625
            continue 
        if msg.sender + 10240:
            revert with 0, 'Strings: hex length insufficient'
        mem[224 len 66] = call.data[calldata.size len 66]
        idx = 65
        while idx > 1:
            if idx >= 66:
                revert with 0, 50
            mem[idx + 224 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
            if not idx:
                revert with 0, 17
            idx = idx - 1
            continue 
        revert with 0, 32, 148, 'AccessControl: account ', mem[160 len 42], 8297, mem[288 len 66], 0, 0 >> 928, 0
    mem[96] = calldata.size
    mem[128 len calldata.size] = call.data[0 len calldata.size]
    if uint8(roleAdmin[0][address(mem[calldata.size + 96])].field_0):
        if stor7:
            revert with 0, 'Auto-approved addresses are locked'
        stor7 = uint8(bool(arg1))
    mem[ceil32(calldata.size) + 160 len 42] = call.data[calldata.size len 42]
    idx = 41
    s = mem[calldata.size + 108 len 20]
    while idx > 1:
        if s % 16 >= 16:
            revert with 0, 50
        if idx >= 42:
            revert with 0, 50
        mem[idx + ceil32(calldata.size) + 160 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
        if not idx:
            revert with 0, 17
        idx = idx - 1
        s = Mask(252, 0, s) * 0.0625
        continue 
    if mem[calldata.size + 108 len 20] + 10240:
        revert with 0, 'Strings: hex length insufficient'
    mem[ceil32(calldata.size) + 256 len 66] = call.data[calldata.size len 66]
    idx = 65
    while idx > 1:
        if idx >= 66:
            revert with 0, 50
        mem[idx + ceil32(calldata.size) + 256 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
        if not idx:
            revert with 0, 17
        idx = idx - 1
        continue 
    revert with 0, 
                32,
                148,
                'AccessControl: account ', mem[ceil32(calldata.size) + 192 len 42], 8297, mem[ceil32(calldata.size) + 320 len 66], 0, 0 >> 928,
                0
}

function transferOwnership(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if msg.sender != this.address:
        if uint8(roleAdmin[0][address(msg.sender)].field_0):
            if not arg1:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
            owner = arg1
            emit OwnershipTransferred(owner, arg1);
        mem[128 len 42] = call.data[calldata.size len 42]
        idx = 41
        s = address(msg.sender)
        while idx > 1:
            if s % 16 >= 16:
                revert with 0, 50
            if idx >= 42:
                revert with 0, 50
            mem[idx + 128 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
            if not idx:
                revert with 0, 17
            idx = idx - 1
            s = Mask(252, 0, s) * 0.0625
            continue 
        if msg.sender + 10240:
            revert with 0, 'Strings: hex length insufficient'
        mem[224 len 66] = call.data[calldata.size len 66]
        idx = 65
        while idx > 1:
            if idx >= 66:
                revert with 0, 50
            mem[idx + 224 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
            if not idx:
                revert with 0, 17
            idx = idx - 1
            continue 
        revert with 0, 32, 148, 'AccessControl: account ', mem[160 len 42], 8297, mem[288 len 66], 0, 0 >> 928, 0
    mem[96] = calldata.size
    mem[128 len calldata.size] = call.data[0 len calldata.size]
    if uint8(roleAdmin[0][address(mem[calldata.size + 96])].field_0):
        if not arg1:
            revert with 0, 'Ownable: new owner is the zero address'
        owner = arg1
        emit OwnershipTransferred(owner, arg1);
    mem[ceil32(calldata.size) + 160 len 42] = call.data[calldata.size len 42]
    idx = 41
    s = mem[calldata.size + 108 len 20]
    while idx > 1:
        if s % 16 >= 16:
            revert with 0, 50
        if idx >= 42:
            revert with 0, 50
        mem[idx + ceil32(calldata.size) + 160 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
        if not idx:
            revert with 0, 17
        idx = idx - 1
        s = Mask(252, 0, s) * 0.0625
        continue 
    if mem[calldata.size + 108 len 20] + 10240:
        revert with 0, 'Strings: hex length insufficient'
    mem[ceil32(calldata.size) + 256 len 66] = call.data[calldata.size len 66]
    idx = 65
    while idx > 1:
        if idx >= 66:
            revert with 0, 50
        mem[idx + ceil32(calldata.size) + 256 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
        if not idx:
            revert with 0, 17
        idx = idx - 1
        continue 
    revert with 0, 
                32,
                148,
                'AccessControl: account ', mem[ceil32(calldata.size) + 192 len 42], 8297, mem[ceil32(calldata.size) + 320 len 66], 0, 0 >> 928,
                0
}

function sub_64c58994(?) {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    require arg2 == bool(arg2)
    if msg.sender != this.address:
        if uint8(roleAdmin[0][address(msg.sender)].field_0):
            if stor7:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Auto-approved addresses are locked'
            stor6[address(arg1)] = uint8(bool(arg2))
            emit 0xf945d041: address(arg1), bool(arg2)
        mem[128 len 42] = call.data[calldata.size len 42]
        idx = 41
        s = address(msg.sender)
        while idx > 1:
            if s % 16 >= 16:
                revert with 0, 50
            if idx >= 42:
                revert with 0, 50
            mem[idx + 128 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
            if not idx:
                revert with 0, 17
            idx = idx - 1
            s = Mask(252, 0, s) * 0.0625
            continue 
        if msg.sender + 10240:
            revert with 0, 'Strings: hex length insufficient'
        mem[224 len 66] = call.data[calldata.size len 66]
        idx = 65
        while idx > 1:
            if idx >= 66:
                revert with 0, 50
            mem[idx + 224 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
            if not idx:
                revert with 0, 17
            idx = idx - 1
            continue 
        revert with 0, 32, 148, 'AccessControl: account ', mem[160 len 42], 8297, mem[288 len 66], 0, 0 >> 928, 0
    mem[96] = calldata.size
    mem[128 len calldata.size] = call.data[0 len calldata.size]
    if uint8(roleAdmin[0][address(mem[calldata.size + 96])].field_0):
        if stor7:
            revert with 0, 'Auto-approved addresses are locked'
        stor6[address(arg1)] = uint8(bool(arg2))
        emit 0xf945d041: address(arg1), bool(arg2)
    mem[ceil32(calldata.size) + 160 len 42] = call.data[calldata.size len 42]
    idx = 41
    s = mem[calldata.size + 108 len 20]
    while idx > 1:
        if s % 16 >= 16:
            revert with 0, 50
        if idx >= 42:
            revert with 0, 50
        mem[idx + ceil32(calldata.size) + 160 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
        if not idx:
            revert with 0, 17
        idx = idx - 1
        s = Mask(252, 0, s) * 0.0625
        continue 
    if mem[calldata.size + 108 len 20] + 10240:
        revert with 0, 'Strings: hex length insufficient'
    mem[ceil32(calldata.size) + 256 len 66] = call.data[calldata.size len 66]
    idx = 65
    while idx > 1:
        if idx >= 66:
            revert with 0, 50
        mem[idx + ceil32(calldata.size) + 256 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
        if not idx:
            revert with 0, 17
        idx = idx - 1
        continue 
    revert with 0, 
                32,
                148,
                'AccessControl: account ', mem[ceil32(calldata.size) + 192 len 42], 8297, mem[ceil32(calldata.size) + 320 len 66], 0, 0 >> 928,
                0
}

function revokeRole(bytes32 arg1, address arg2) {
    require calldata.size - 4 >= 64
    require arg2 == arg2
    if msg.sender != this.address:
        if uint8(roleAdmin[roleAdmin[arg1].field_256][address(msg.sender)].field_0):
            if uint8(roleAdmin[arg1][address(arg2)].field_0):
                uint8(roleAdmin[arg1][address(arg2)].field_0) = 0
                if msg.sender != this.address:
                    emit RoleRevoked(arg1, arg2, msg.sender);
                else:
                    mem[96] = calldata.size
                    mem[128 len calldata.size] = call.data[0 len calldata.size]
                    emit RoleRevoked(arg1, arg2, mem[calldata.size + 108 len 20]);
        mem[128 len 42] = call.data[calldata.size len 42]
        idx = 41
        s = address(msg.sender)
        while idx > 1:
            if s % 16 >= 16:
                revert with 0, 50
            if idx >= 42:
                revert with 0, 50
            mem[idx + 128 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
            if not idx:
                revert with 0, 17
            idx = idx - 1
            s = Mask(252, 0, s) * 0.0625
            continue 
        if msg.sender + 10240:
            revert with 0, 'Strings: hex length insufficient'
        mem[224 len 66] = call.data[calldata.size len 66]
        idx = 65
        s = roleAdmin[arg1].field_256
        while idx > 1:
            if s % 16 >= 16:
                revert with 0, 50
            if idx >= 66:
                revert with 0, 50
            mem[idx + 224 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
            if not idx:
                revert with 0, 17
            idx = idx - 1
            s = Mask(252, 0, s) * 0.0625
            continue 
        if roleAdmin[arg1].field_256 + 16384:
            revert with 0, 'Strings: hex length insufficient'
        revert with 0, 32, 148, 'AccessControl: account ', mem[160 len 42], 8297, mem[288 len 66], 0, 0 >> 928, 0
    mem[96] = calldata.size
    mem[128 len calldata.size] = call.data[0 len calldata.size]
    if uint8(roleAdmin[roleAdmin[arg1].field_256][address(mem[calldata.size + 96])].field_0):
        if uint8(roleAdmin[arg1][address(arg2)].field_0):
            uint8(roleAdmin[arg1][address(arg2)].field_0) = 0
            if msg.sender != this.address:
                emit RoleRevoked(arg1, arg2, msg.sender);
            else:
                mem[ceil32(calldata.size) + 128] = calldata.size
                mem[ceil32(calldata.size) + 160 len calldata.size] = call.data[0 len calldata.size]
                emit RoleRevoked(arg1, arg2, mem[calldata.size + ceil32(calldata.size) + 140 len 20]);
    mem[ceil32(calldata.size) + 160 len 42] = call.data[calldata.size len 42]
    idx = 41
    s = mem[calldata.size + 108 len 20]
    while idx > 1:
        if s % 16 >= 16:
            revert with 0, 50
        if idx >= 42:
            revert with 0, 50
        mem[idx + ceil32(calldata.size) + 160 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
        if not idx:
            revert with 0, 17
        idx = idx - 1
        s = Mask(252, 0, s) * 0.0625
        continue 
    if mem[calldata.size + 108 len 20] + 10240:
        revert with 0, 'Strings: hex length insufficient'
    mem[ceil32(calldata.size) + 256 len 66] = call.data[calldata.size len 66]
    idx = 65
    s = roleAdmin[arg1].field_256
    while idx > 1:
        if s % 16 >= 16:
            revert with 0, 50
        if idx >= 66:
            revert with 0, 50
        mem[idx + ceil32(calldata.size) + 256 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
        if not idx:
            revert with 0, 17
        idx = idx - 1
        s = Mask(252, 0, s) * 0.0625
        continue 
    if roleAdmin[arg1].field_256 + 16384:
        revert with 0, 'Strings: hex length insufficient'
    revert with 0, 
                32,
                148,
                'AccessControl: account ', mem[ceil32(calldata.size) + 192 len 42], 8297, mem[ceil32(calldata.size) + 320 len 66], 0, 0 >> 928,
                0
}

function grantRole(bytes32 arg1, address arg2) {
    require calldata.size - 4 >= 64
    require arg2 == arg2
    if msg.sender != this.address:
        if uint8(roleAdmin[roleAdmin[arg1].field_256][address(msg.sender)].field_0):
            if not uint8(roleAdmin[arg1][address(arg2)].field_0):
                uint8(roleAdmin[arg1][address(arg2)].field_0) = 1
                if msg.sender != this.address:
                    emit RoleGranted(arg1, arg2, msg.sender);
                else:
                    mem[96] = calldata.size
                    mem[128 len calldata.size] = call.data[0 len calldata.size]
                    emit RoleGranted(arg1, arg2, mem[calldata.size + 108 len 20]);
        mem[128 len 42] = call.data[calldata.size len 42]
        idx = 41
        s = address(msg.sender)
        while idx > 1:
            if s % 16 >= 16:
                revert with 0, 50
            if idx >= 42:
                revert with 0, 50
            mem[idx + 128 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
            if not idx:
                revert with 0, 17
            idx = idx - 1
            s = Mask(252, 0, s) * 0.0625
            continue 
        if msg.sender + 10240:
            revert with 0, 'Strings: hex length insufficient'
        mem[224 len 66] = call.data[calldata.size len 66]
        idx = 65
        s = roleAdmin[arg1].field_256
        while idx > 1:
            if s % 16 >= 16:
                revert with 0, 50
            if idx >= 66:
                revert with 0, 50
            mem[idx + 224 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
            if not idx:
                revert with 0, 17
            idx = idx - 1
            s = Mask(252, 0, s) * 0.0625
            continue 
        if roleAdmin[arg1].field_256 + 16384:
            revert with 0, 'Strings: hex length insufficient'
        revert with 0, 32, 148, 'AccessControl: account ', mem[160 len 42], 8297, mem[288 len 66], 0, 0 >> 928, 0
    mem[96] = calldata.size
    mem[128 len calldata.size] = call.data[0 len calldata.size]
    if uint8(roleAdmin[roleAdmin[arg1].field_256][address(mem[calldata.size + 96])].field_0):
        if not uint8(roleAdmin[arg1][address(arg2)].field_0):
            uint8(roleAdmin[arg1][address(arg2)].field_0) = 1
            if msg.sender != this.address:
                emit RoleGranted(arg1, arg2, msg.sender);
            else:
                mem[ceil32(calldata.size) + 128] = calldata.size
                mem[ceil32(calldata.size) + 160 len calldata.size] = call.data[0 len calldata.size]
                emit RoleGranted(arg1, arg2, mem[calldata.size + ceil32(calldata.size) + 140 len 20]);
    mem[ceil32(calldata.size) + 160 len 42] = call.data[calldata.size len 42]
    idx = 41
    s = mem[calldata.size + 108 len 20]
    while idx > 1:
        if s % 16 >= 16:
            revert with 0, 50
        if idx >= 42:
            revert with 0, 50
        mem[idx + ceil32(calldata.size) + 160 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
        if not idx:
            revert with 0, 17
        idx = idx - 1
        s = Mask(252, 0, s) * 0.0625
        continue 
    if mem[calldata.size + 108 len 20] + 10240:
        revert with 0, 'Strings: hex length insufficient'
    mem[ceil32(calldata.size) + 256 len 66] = call.data[calldata.size len 66]
    idx = 65
    s = roleAdmin[arg1].field_256
    while idx > 1:
        if s % 16 >= 16:
            revert with 0, 50
        if idx >= 66:
            revert with 0, 50
        mem[idx + ceil32(calldata.size) + 256 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
        if not idx:
            revert with 0, 17
        idx = idx - 1
        s = Mask(252, 0, s) * 0.0625
        continue 
    if roleAdmin[arg1].field_256 + 16384:
        revert with 0, 'Strings: hex length insufficient'
    revert with 0, 
                32,
                148,
                'AccessControl: account ', mem[ceil32(calldata.size) + 192 len 42], 8297, mem[ceil32(calldata.size) + 320 len 66], 0, 0 >> 928,
                0
}

function name() {
    if bool(stor16.length):
        if bool(stor16.length) == uint255(stor16.length) * 0.5 < 32:
            revert with 0, 34
        if bool(stor16.length):
            if bool(stor16.length) == uint255(stor16.length) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, stor16.length):
                if 31 < uint255(stor16.length) * 0.5:
                    mem[128] = uint256(stor16.field_0)
                    idx = 128
                    s = 0
                    while (uint255(stor16.length) * 0.5) + 96 > idx:
                        mem[idx + 32] = stor16[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor16.length), data=mem[128 len ceil32(uint255(stor16.length) * 0.5)])
                mem[128] = 256 * Mask(248, 0, stor16.length.field_8)
        else:
            if bool(stor16.length) == stor16.length.field_1 % 128 < 32:
                revert with 0, 34
            if stor16.length.field_1 % 128:
                if 31 < stor16.length.field_1 % 128:
                    mem[128] = uint256(stor16.field_0)
                    idx = 128
                    s = 0
                    while stor16.length.field_1 % 128 + 96 > idx:
                        mem[idx + 32] = stor16[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor16.length), data=mem[128 len ceil32(uint255(stor16.length) * 0.5)])
                mem[128] = 256 * Mask(248, 0, stor16.length.field_8)
        mem[ceil32(uint255(stor16.length) * 0.5) + 192 len ceil32(uint255(stor16.length) * 0.5)] = mem[128 len ceil32(uint255(stor16.length) * 0.5)]
        if ceil32(uint255(stor16.length) * 0.5) > uint255(stor16.length) * 0.5:
            mem[(uint255(stor16.length) * 0.5) + ceil32(uint255(stor16.length) * 0.5) + 192] = 0
        return Array(len=2 * Mask(256, -1, stor16.length), data=mem[128 len ceil32(uint255(stor16.length) * 0.5)], mem[(2 * ceil32(uint255(stor16.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor16.length) * 0.5)]), 
    if bool(stor16.length) == stor16.length.field_1 % 128 < 32:
        revert with 0, 34
    if bool(stor16.length):
        if bool(stor16.length) == uint255(stor16.length) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, stor16.length):
            if 31 < uint255(stor16.length) * 0.5:
                mem[128] = uint256(stor16.field_0)
                idx = 128
                s = 0
                while (uint255(stor16.length) * 0.5) + 96 > idx:
                    mem[idx + 32] = stor16[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor16.length % 128, data=mem[128 len ceil32(stor16.length.field_1 % 128)])
            mem[128] = 256 * Mask(248, 0, stor16.length.field_8)
    else:
        if bool(stor16.length) == stor16.length.field_1 % 128 < 32:
            revert with 0, 34
        if stor16.length.field_1 % 128:
            if 31 < stor16.length.field_1 % 128:
                mem[128] = uint256(stor16.field_0)
                idx = 128
                s = 0
                while stor16.length.field_1 % 128 + 96 > idx:
                    mem[idx + 32] = stor16[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor16.length % 128, data=mem[128 len ceil32(stor16.length.field_1 % 128)])
            mem[128] = 256 * Mask(248, 0, stor16.length.field_8)
    mem[ceil32(stor16.length.field_1 % 128) + 192 len ceil32(stor16.length.field_1 % 128)] = mem[128 len ceil32(stor16.length.field_1 % 128)]
    if ceil32(stor16.length.field_1 % 128) > stor16.length.field_1 % 128:
        mem[stor16.length.field_1 % 128 + ceil32(stor16.length.field_1 % 128) + 192] = 0
    return Array(len=stor16.length % 128, data=mem[128 len ceil32(stor16.length.field_1 % 128)], mem[(2 * ceil32(stor16.length.field_1 % 128)) + 192 len 2 * ceil32(stor16.length.field_1 % 128)]), 
}

function symbol() {
    if bool(stor17.length):
        if bool(stor17.length) == uint255(stor17.length) * 0.5 < 32:
            revert with 0, 34
        if bool(stor17.length):
            if bool(stor17.length) == uint255(stor17.length) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, stor17.length):
                if 31 < uint255(stor17.length) * 0.5:
                    mem[128] = uint256(stor17.field_0)
                    idx = 128
                    s = 0
                    while (uint255(stor17.length) * 0.5) + 96 > idx:
                        mem[idx + 32] = stor17[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor17.length), data=mem[128 len ceil32(uint255(stor17.length) * 0.5)])
                mem[128] = 256 * Mask(248, 0, stor17.length.field_8)
        else:
            if bool(stor17.length) == stor17.length.field_1 % 128 < 32:
                revert with 0, 34
            if stor17.length.field_1 % 128:
                if 31 < stor17.length.field_1 % 128:
                    mem[128] = uint256(stor17.field_0)
                    idx = 128
                    s = 0
                    while stor17.length.field_1 % 128 + 96 > idx:
                        mem[idx + 32] = stor17[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor17.length), data=mem[128 len ceil32(uint255(stor17.length) * 0.5)])
                mem[128] = 256 * Mask(248, 0, stor17.length.field_8)
        mem[ceil32(uint255(stor17.length) * 0.5) + 192 len ceil32(uint255(stor17.length) * 0.5)] = mem[128 len ceil32(uint255(stor17.length) * 0.5)]
        if ceil32(uint255(stor17.length) * 0.5) > uint255(stor17.length) * 0.5:
            mem[(uint255(stor17.length) * 0.5) + ceil32(uint255(stor17.length) * 0.5) + 192] = 0
        return Array(len=2 * Mask(256, -1, stor17.length), data=mem[128 len ceil32(uint255(stor17.length) * 0.5)], mem[(2 * ceil32(uint255(stor17.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor17.length) * 0.5)]), 
    if bool(stor17.length) == stor17.length.field_1 % 128 < 32:
        revert with 0, 34
    if bool(stor17.length):
        if bool(stor17.length) == uint255(stor17.length) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, stor17.length):
            if 31 < uint255(stor17.length) * 0.5:
                mem[128] = uint256(stor17.field_0)
                idx = 128
                s = 0
                while (uint255(stor17.length) * 0.5) + 96 > idx:
                    mem[idx + 32] = stor17[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor17.length % 128, data=mem[128 len ceil32(stor17.length.field_1 % 128)])
            mem[128] = 256 * Mask(248, 0, stor17.length.field_8)
    else:
        if bool(stor17.length) == stor17.length.field_1 % 128 < 32:
            revert with 0, 34
        if stor17.length.field_1 % 128:
            if 31 < stor17.length.field_1 % 128:
                mem[128] = uint256(stor17.field_0)
                idx = 128
                s = 0
                while stor17.length.field_1 % 128 + 96 > idx:
                    mem[idx + 32] = stor17[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor17.length % 128, data=mem[128 len ceil32(stor17.length.field_1 % 128)])
            mem[128] = 256 * Mask(248, 0, stor17.length.field_8)
    mem[ceil32(stor17.length.field_1 % 128) + 192 len ceil32(stor17.length.field_1 % 128)] = mem[128 len ceil32(stor17.length.field_1 % 128)]
    if ceil32(stor17.length.field_1 % 128) > stor17.length.field_1 % 128:
        mem[stor17.length.field_1 % 128 + ceil32(stor17.length.field_1 % 128) + 192] = 0
    return Array(len=stor17.length % 128, data=mem[128 len ceil32(stor17.length.field_1 % 128)], mem[(2 * ceil32(stor17.length.field_1 % 128)) + 192 len 2 * ceil32(stor17.length.field_1 % 128)]), 
}

function contractURI() {
    if bool(stor18.length):
        if bool(stor18.length) == uint255(stor18.length) * 0.5 < 32:
            revert with 0, 34
        if bool(stor18.length):
            if bool(stor18.length) == uint255(stor18.length) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, stor18.length):
                if 31 < uint255(stor18.length) * 0.5:
                    mem[128] = uint256(stor18.field_0)
                    idx = 128
                    s = 0
                    while (uint255(stor18.length) * 0.5) + 96 > idx:
                        mem[idx + 32] = stor18[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor18.length), data=mem[128 len ceil32(uint255(stor18.length) * 0.5)])
                mem[128] = 256 * Mask(248, 0, stor18.length.field_8)
        else:
            if bool(stor18.length) == stor18.length.field_1 % 128 < 32:
                revert with 0, 34
            if stor18.length.field_1 % 128:
                if 31 < stor18.length.field_1 % 128:
                    mem[128] = uint256(stor18.field_0)
                    idx = 128
                    s = 0
                    while stor18.length.field_1 % 128 + 96 > idx:
                        mem[idx + 32] = stor18[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor18.length), data=mem[128 len ceil32(uint255(stor18.length) * 0.5)])
                mem[128] = 256 * Mask(248, 0, stor18.length.field_8)
        mem[ceil32(uint255(stor18.length) * 0.5) + 192 len ceil32(uint255(stor18.length) * 0.5)] = mem[128 len ceil32(uint255(stor18.length) * 0.5)]
        if ceil32(uint255(stor18.length) * 0.5) > uint255(stor18.length) * 0.5:
            mem[(uint255(stor18.length) * 0.5) + ceil32(uint255(stor18.length) * 0.5) + 192] = 0
        return Array(len=2 * Mask(256, -1, stor18.length), data=mem[128 len ceil32(uint255(stor18.length) * 0.5)], mem[(2 * ceil32(uint255(stor18.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor18.length) * 0.5)]), 
    if bool(stor18.length) == stor18.length.field_1 % 128 < 32:
        revert with 0, 34
    if bool(stor18.length):
        if bool(stor18.length) == uint255(stor18.length) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, stor18.length):
            if 31 < uint255(stor18.length) * 0.5:
                mem[128] = uint256(stor18.field_0)
                idx = 128
                s = 0
                while (uint255(stor18.length) * 0.5) + 96 > idx:
                    mem[idx + 32] = stor18[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor18.length % 128, data=mem[128 len ceil32(stor18.length.field_1 % 128)])
            mem[128] = 256 * Mask(248, 0, stor18.length.field_8)
    else:
        if bool(stor18.length) == stor18.length.field_1 % 128 < 32:
            revert with 0, 34
        if stor18.length.field_1 % 128:
            if 31 < stor18.length.field_1 % 128:
                mem[128] = uint256(stor18.field_0)
                idx = 128
                s = 0
                while stor18.length.field_1 % 128 + 96 > idx:
                    mem[idx + 32] = stor18[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor18.length % 128, data=mem[128 len ceil32(stor18.length.field_1 % 128)])
            mem[128] = 256 * Mask(248, 0, stor18.length.field_8)
    mem[ceil32(stor18.length.field_1 % 128) + 192 len ceil32(stor18.length.field_1 % 128)] = mem[128 len ceil32(stor18.length.field_1 % 128)]
    if ceil32(stor18.length.field_1 % 128) > stor18.length.field_1 % 128:
        mem[stor18.length.field_1 % 128 + ceil32(stor18.length.field_1 % 128) + 192] = 0
    return Array(len=stor18.length % 128, data=mem[128 len ceil32(stor18.length.field_1 % 128)], mem[(2 * ceil32(stor18.length.field_1 % 128)) + 192 len 2 * ceil32(stor18.length.field_1 % 128)]), 
}

function uri(uint256 arg1) {
    require calldata.size - 4 >= 32
    if bool(stor15[stor10[arg1]].field_0):
        if bool(stor15[stor10[arg1]].field_0) == uint255(stor15[stor10[arg1]].field_0) * 0.5 < 32:
            revert with 0, 34
        if bool(stor15[stor10[arg1]].field_0):
            if bool(stor15[stor10[arg1]].field_0) == uint255(stor15[stor10[arg1]].field_0) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, stor15[stor10[arg1]].field_0):
                if 31 < uint255(stor15[stor10[arg1]].field_0) * 0.5:
                    mem[128] = stor15[stor10[arg1]].field_0
                    idx = 128
                    s = 0
                    while (uint255(stor15[stor10[arg1]].field_0) * 0.5) + 96 > idx:
                        mem[idx + 32] = stor15[stor10[arg1]][s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor15[stor10[arg1]].field_0), data=mem[128 len ceil32(uint255(stor15[stor10[arg1]].field_0) * 0.5)]), 
                mem[128] = 256 * Mask(248, 0, stor15[stor10[arg1]].field_8)
        else:
            if bool(stor15[stor10[arg1]].field_0) == stor15[stor10[arg1]].field_1 % 128 < 32:
                revert with 0, 34
            if stor15[stor10[arg1]].field_1 % 128:
                if 31 < stor15[stor10[arg1]].field_1 % 128:
                    mem[128] = stor15[stor10[arg1]].field_0
                    idx = 128
                    s = 0
                    while stor15[stor10[arg1]].field_1 % 128 + 96 > idx:
                        mem[idx + 32] = stor15[stor10[arg1]][s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor15[stor10[arg1]].field_0), data=mem[128 len ceil32(uint255(stor15[stor10[arg1]].field_0) * 0.5)]), 
                mem[128] = 256 * Mask(248, 0, stor15[stor10[arg1]].field_8)
        mem[ceil32(uint255(stor15[stor10[arg1]].field_0) * 0.5) + 192 len ceil32(uint255(stor15[stor10[arg1]].field_0) * 0.5)] = mem[128 len ceil32(uint255(stor15[stor10[arg1]].field_0) * 0.5)]
        if ceil32(uint255(stor15[stor10[arg1]].field_0) * 0.5) > uint255(stor15[stor10[arg1]].field_0) * 0.5:
            mem[(uint255(stor15[stor10[arg1]].field_0) * 0.5) + ceil32(uint255(stor15[stor10[arg1]].field_0) * 0.5) + 192] = 0
        return Array(len=2 * Mask(256, -1, stor15[stor10[arg1]].field_0), data=mem[128 len ceil32(uint255(stor15[stor10[arg1]].field_0) * 0.5)], mem[(2 * ceil32(uint255(stor15[stor10[arg1]].field_0) * 0.5)) + 192 len 2 * ceil32(uint255(stor15[stor10[arg1]].field_0) * 0.5)]), 
    if bool(stor15[stor10[arg1]].field_0) == stor15[stor10[arg1]].field_1 % 128 < 32:
        revert with 0, 34
    if bool(stor15[stor10[arg1]].field_0):
        if bool(stor15[stor10[arg1]].field_0) == uint255(stor15[stor10[arg1]].field_0) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, stor15[stor10[arg1]].field_0):
            if 31 < uint255(stor15[stor10[arg1]].field_0) * 0.5:
                mem[128] = stor15[stor10[arg1]].field_0
                idx = 128
                s = 0
                while (uint255(stor15[stor10[arg1]].field_0) * 0.5) + 96 > idx:
                    mem[idx + 32] = stor15[stor10[arg1]][s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor15[stor10[arg1]].field_0 % 128, data=mem[128 len ceil32(stor15[stor10[arg1]].field_1 % 128)])
            mem[128] = 256 * Mask(248, 0, stor15[stor10[arg1]].field_8)
    else:
        if bool(stor15[stor10[arg1]].field_0) == stor15[stor10[arg1]].field_1 % 128 < 32:
            revert with 0, 34
        if stor15[stor10[arg1]].field_1 % 128:
            if 31 < stor15[stor10[arg1]].field_1 % 128:
                mem[128] = stor15[stor10[arg1]].field_0
                idx = 128
                s = 0
                while stor15[stor10[arg1]].field_1 % 128 + 96 > idx:
                    mem[idx + 32] = stor15[stor10[arg1]][s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor15[stor10[arg1]].field_0 % 128, data=mem[128 len ceil32(stor15[stor10[arg1]].field_1 % 128)])
            mem[128] = 256 * Mask(248, 0, stor15[stor10[arg1]].field_8)
    mem[ceil32(stor15[stor10[arg1]].field_1 % 128) + 192 len ceil32(stor15[stor10[arg1]].field_1 % 128)] = mem[128 len ceil32(stor15[stor10[arg1]].field_1 % 128)]
    if ceil32(stor15[stor10[arg1]].field_1 % 128) > stor15[stor10[arg1]].field_1 % 128:
        mem[stor15[stor10[arg1]].field_1 % 128 + ceil32(stor15[stor10[arg1]].field_1 % 128) + 192] = 0
    return Array(len=stor15[stor10[arg1]].field_0 % 128, data=mem[128 len ceil32(stor15[stor10[arg1]].field_1 % 128)], mem[(2 * ceil32(stor15[stor10[arg1]].field_1 % 128)) + 192 len 2 * ceil32(stor15[stor10[arg1]].field_1 % 128)]), 
}

function setContractURI(string arg1) {
    require calldata.size - 4 >= 32
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    if arg1.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg1.length)) + 97 < 96 or ceil32(ceil32(arg1.length)) + 97 > test266151307():
        revert with 0, 65
    require arg1 + arg1.length + 36 <= calldata.size
    mem[128 len arg1.length] = arg1[all]
    mem[arg1.length + 128] = 0
    if msg.sender != this.address:
        if uint8(roleAdmin[0][address(msg.sender)].field_0):
            if bool(stor18.length):
                if bool(stor18.length) == uint255(stor18.length) * 0.5 < 32:
                    revert with 0, 34
                if arg1.length:
                    stor18[].field_0 = Array(len=arg1.length, data=arg1[all])
                else:
                    stor18.length = 0
                    idx = 0
                    while (uint255(stor18.length) * 0.5) + 31 / 32 > idx:
                        stor18[idx].field_0 = 0
                        idx = idx + 1
                        continue 
            else:
                if bool(stor18.length) == stor18.length.field_1 % 128 < 32:
                    revert with 0, 34
                if arg1.length:
                    stor18[].field_0 = Array(len=arg1.length, data=arg1[all])
                else:
                    stor18.length = 0
                    idx = 0
                    while stor18.length.field_1 % 128 + 31 / 32 > idx:
                        stor18[idx].field_0 = 0
                        idx = idx + 1
                        continue 
        mem[ceil32(ceil32(arg1.length)) + 129 len 42] = call.data[calldata.size len 42]
        idx = 41
        s = address(msg.sender)
        while idx > 1:
            if s % 16 >= 16:
                revert with 0, 50
            if idx >= 42:
                revert with 0, 50
            mem[idx + ceil32(ceil32(arg1.length)) + 129 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
            if not idx:
                revert with 0, 17
            idx = idx - 1
            s = Mask(252, 0, s) * 0.0625
            continue 
        if msg.sender + 10240:
            revert with 0, 'Strings: hex length insufficient'
        mem[ceil32(ceil32(arg1.length)) + 225 len 66] = call.data[calldata.size len 66]
        idx = 65
        while idx > 1:
            if idx >= 66:
                revert with 0, 50
            mem[idx + ceil32(ceil32(arg1.length)) + 225 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
            if not idx:
                revert with 0, 17
            idx = idx - 1
            continue 
        revert with 0, 
                    32,
                    148,
                    'AccessControl: account ', mem[ceil32(ceil32(arg1.length)) + 161 len 42], 8297, mem[ceil32(ceil32(arg1.length)) + 289 len 66], 0, 0 >> 928,
                    0
    mem[ceil32(ceil32(arg1.length)) + 97] = calldata.size
    mem[ceil32(ceil32(arg1.length)) + 129 len calldata.size] = call.data[0 len calldata.size]
    if uint8(roleAdmin[0][address(mem[calldata.size + ceil32(ceil32(arg1.length)) + 97])].field_0):
        if bool(stor18.length):
            if bool(stor18.length) == uint255(stor18.length) * 0.5 < 32:
                revert with 0, 34
            if arg1.length:
                stor18[].field_0 = Array(len=arg1.length, data=arg1[all])
            else:
                stor18.length = 0
                idx = 0
                while (uint255(stor18.length) * 0.5) + 31 / 32 > idx:
                    stor18[idx].field_0 = 0
                    idx = idx + 1
                    continue 
        else:
            if bool(stor18.length) == stor18.length.field_1 % 128 < 32:
                revert with 0, 34
            if arg1.length:
                stor18[].field_0 = Array(len=arg1.length, data=arg1[all])
            else:
                stor18.length = 0
                idx = 0
                while stor18.length.field_1 % 128 + 31 / 32 > idx:
                    stor18[idx].field_0 = 0
                    idx = idx + 1
                    continue 
    mem[ceil32(ceil32(arg1.length)) + ceil32(calldata.size) + 161 len 42] = call.data[calldata.size len 42]
    idx = 41
    s = mem[calldata.size + ceil32(ceil32(arg1.length)) + 109 len 20]
    while idx > 1:
        if s % 16 >= 16:
            revert with 0, 50
        if idx >= 42:
            revert with 0, 50
        mem[idx + ceil32(ceil32(arg1.length)) + ceil32(calldata.size) + 161 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
        if not idx:
            revert with 0, 17
        idx = idx - 1
        s = Mask(252, 0, s) * 0.0625
        continue 
    if mem[calldata.size + ceil32(ceil32(arg1.length)) + 109 len 20] + 10240:
        revert with 0, 'Strings: hex length insufficient'
    mem[ceil32(ceil32(arg1.length)) + ceil32(calldata.size) + 257 len 66] = call.data[calldata.size len 66]
    idx = 65
    while idx > 1:
        if idx >= 66:
            revert with 0, 50
        mem[idx + ceil32(ceil32(arg1.length)) + ceil32(calldata.size) + 257 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
        if not idx:
            revert with 0, 17
        idx = idx - 1
        continue 
    revert with 0, 
                32,
                148,
                'AccessControl: account ', mem[ceil32(ceil32(arg1.length)) + ceil32(calldata.size) + 193 len 42], 8297, mem[ceil32(ceil32(arg1.length)) + ceil32(calldata.size) + 321 len 66], 0, 0 >> 928,
                0
}

function sub_a582e8f8(?) {
    require calldata.size - 4 >= 64
    require arg2 <= test266151307()
    require arg2 + 35 < calldata.size
    if arg2.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg2.length)) + 97 < 96 or ceil32(ceil32(arg2.length)) + 97 > test266151307():
        revert with 0, 65
    require arg2 + arg2.length + 36 <= calldata.size
    mem[128 len arg2.length] = arg2[all]
    mem[arg2.length + 128] = 0
    if msg.sender != this.address:
        if uint8(roleAdmin[0][address(msg.sender)].field_0):
            if bool(stor15[arg1].field_0):
                if bool(stor15[arg1].field_0) == uint255(stor15[arg1].field_0) * 0.5 < 32:
                    revert with 0, 34
                if arg2.length:
                    stor15[arg1][].field_0 = Array(len=arg2.length, data=arg2[all])
                else:
                    stor15[arg1].field_0 = 0
                    idx = 0
                    while (uint255(stor15[arg1].field_0) * 0.5) + 31 / 32 > idx:
                        stor15[arg1][idx].field_0 = 0
                        idx = idx + 1
                        continue 
            else:
                if bool(stor15[arg1].field_0) == stor15[arg1].field_1 % 128 < 32:
                    revert with 0, 34
                if arg2.length:
                    stor15[arg1][].field_0 = Array(len=arg2.length, data=arg2[all])
                else:
                    stor15[arg1].field_0 = 0
                    idx = 0
                    while stor15[arg1].field_1 % 128 + 31 / 32 > idx:
                        stor15[arg1][idx].field_0 = 0
                        idx = idx + 1
                        continue 
        mem[ceil32(ceil32(arg2.length)) + 129 len 42] = call.data[calldata.size len 42]
        idx = 41
        s = address(msg.sender)
        while idx > 1:
            if s % 16 >= 16:
                revert with 0, 50
            if idx >= 42:
                revert with 0, 50
            mem[idx + ceil32(ceil32(arg2.length)) + 129 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
            if not idx:
                revert with 0, 17
            idx = idx - 1
            s = Mask(252, 0, s) * 0.0625
            continue 
        if msg.sender + 10240:
            revert with 0, 'Strings: hex length insufficient'
        mem[ceil32(ceil32(arg2.length)) + 225 len 66] = call.data[calldata.size len 66]
        idx = 65
        while idx > 1:
            if idx >= 66:
                revert with 0, 50
            mem[idx + ceil32(ceil32(arg2.length)) + 225 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
            if not idx:
                revert with 0, 17
            idx = idx - 1
            continue 
        revert with 0, 
                    32,
                    148,
                    'AccessControl: account ', mem[ceil32(ceil32(arg2.length)) + 161 len 42], 8297, mem[ceil32(ceil32(arg2.length)) + 289 len 66], 0, 0 >> 928,
                    0
    mem[ceil32(ceil32(arg2.length)) + 97] = calldata.size
    mem[ceil32(ceil32(arg2.length)) + 129 len calldata.size] = call.data[0 len calldata.size]
    if uint8(roleAdmin[0][address(mem[calldata.size + ceil32(ceil32(arg2.length)) + 97])].field_0):
        if bool(stor15[arg1].field_0):
            if bool(stor15[arg1].field_0) == uint255(stor15[arg1].field_0) * 0.5 < 32:
                revert with 0, 34
            if arg2.length:
                stor15[arg1][].field_0 = Array(len=arg2.length, data=arg2[all])
            else:
                stor15[arg1].field_0 = 0
                idx = 0
                while (uint255(stor15[arg1].field_0) * 0.5) + 31 / 32 > idx:
                    stor15[arg1][idx].field_0 = 0
                    idx = idx + 1
                    continue 
        else:
            if bool(stor15[arg1].field_0) == stor15[arg1].field_1 % 128 < 32:
                revert with 0, 34
            if arg2.length:
                stor15[arg1][].field_0 = Array(len=arg2.length, data=arg2[all])
            else:
                stor15[arg1].field_0 = 0
                idx = 0
                while stor15[arg1].field_1 % 128 + 31 / 32 > idx:
                    stor15[arg1][idx].field_0 = 0
                    idx = idx + 1
                    continue 
    mem[ceil32(ceil32(arg2.length)) + ceil32(calldata.size) + 161 len 42] = call.data[calldata.size len 42]
    idx = 41
    s = mem[calldata.size + ceil32(ceil32(arg2.length)) + 109 len 20]
    while idx > 1:
        if s % 16 >= 16:
            revert with 0, 50
        if idx >= 42:
            revert with 0, 50
        mem[idx + ceil32(ceil32(arg2.length)) + ceil32(calldata.size) + 161 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
        if not idx:
            revert with 0, 17
        idx = idx - 1
        s = Mask(252, 0, s) * 0.0625
        continue 
    if mem[calldata.size + ceil32(ceil32(arg2.length)) + 109 len 20] + 10240:
        revert with 0, 'Strings: hex length insufficient'
    mem[ceil32(ceil32(arg2.length)) + ceil32(calldata.size) + 257 len 66] = call.data[calldata.size len 66]
    idx = 65
    while idx > 1:
        if idx >= 66:
            revert with 0, 50
        mem[idx + ceil32(ceil32(arg2.length)) + ceil32(calldata.size) + 257 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
        if not idx:
            revert with 0, 17
        idx = idx - 1
        continue 
    revert with 0, 
                32,
                148,
                'AccessControl: account ', mem[ceil32(ceil32(arg2.length)) + ceil32(calldata.size) + 193 len 42], 8297, mem[ceil32(ceil32(arg2.length)) + ceil32(calldata.size) + 321 len 66], 0, 0 >> 928,
                0
}

function burn(uint256 arg1, address arg2, uint256 arg3) {
    require calldata.size - 4 >= 96
    require arg2 == arg2
    if bool(stor11[stor10[arg1]]) != 1:
        revert with 0, 'Type of token must be burnable'
    if msg.sender != this.address:
        if arg2 == msg.sender:
            if not arg2:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC1155: burn from the zero address'
            if msg.sender != this.address:
                if balanceOf[arg1][address(arg2)] < arg3:
                    revert with 0, 'ERC1155: burn amount exceeds balance'
                balanceOf[arg1][address(arg2)] -= arg3
                emit TransferSingle(arg1, arg3, msg.sender, arg2, 0);
            else:
                mem[96] = calldata.size
                mem[128 len calldata.size] = call.data[0 len calldata.size]
                if balanceOf[arg1][address(arg2)] < arg3:
                    revert with 0, 'ERC1155: burn amount exceeds balance'
                balanceOf[arg1][address(arg2)] -= arg3
                emit TransferSingle(arg1, arg3, mem[calldata.size + 108 len 20], arg2, 0);
        else:
            if msg.sender != this.address:
                if not stor1[address(arg2)][address(msg.sender)]:
                    if bool(stor6[address(msg.sender)]) != 1:
                        revert with 0, 'Caller is not owner nor approved'
                if not arg2:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC1155: burn from the zero address'
                if msg.sender != this.address:
                    if balanceOf[arg1][address(arg2)] < arg3:
                        revert with 0, 'ERC1155: burn amount exceeds balance'
                    balanceOf[arg1][address(arg2)] -= arg3
                    emit TransferSingle(arg1, arg3, msg.sender, arg2, 0);
                else:
                    mem[96] = calldata.size
                    mem[128 len calldata.size] = call.data[0 len calldata.size]
                    if balanceOf[arg1][address(arg2)] < arg3:
                        revert with 0, 'ERC1155: burn amount exceeds balance'
                    balanceOf[arg1][address(arg2)] -= arg3
                    emit TransferSingle(arg1, arg3, mem[calldata.size + 108 len 20], arg2, 0);
            else:
                mem[96] = calldata.size
                mem[128 len calldata.size] = call.data[0 len calldata.size]
                if not stor1[address(arg2)][address(mem[calldata.size + 96])]:
                    if bool(stor6[address(mem[calldata.size + 96])]) != 1:
                        revert with 0, 'Caller is not owner nor approved'
                if not arg2:
                    revert with 0, 'ERC1155: burn from the zero address'
                if msg.sender != this.address:
                    if balanceOf[arg1][address(arg2)] < arg3:
                        revert with 0, 'ERC1155: burn amount exceeds balance'
                    balanceOf[arg1][address(arg2)] -= arg3
                    emit TransferSingle(arg1, arg3, msg.sender, arg2, 0);
                else:
                    mem[ceil32(calldata.size) + 128] = calldata.size
                    mem[ceil32(calldata.size) + 160 len calldata.size] = call.data[0 len calldata.size]
                    mem[(2 * ceil32(calldata.size)) + 192] = arg1
                    mem[(2 * ceil32(calldata.size)) + 224] = 1
                    mem[(2 * ceil32(calldata.size)) + 256] = arg3
                    mem[(2 * ceil32(calldata.size)) + 288] = 0
                    if balanceOf[arg1][address(arg2)] < arg3:
                        revert with 0, 'ERC1155: burn amount exceeds balance'
                    balanceOf[arg1][address(arg2)] -= arg3
                    mem[(2 * ceil32(calldata.size)) + 320] = arg1
                    mem[(2 * ceil32(calldata.size)) + 352] = arg3
                    emit TransferSingle(arg1, arg3, mem[calldata.size + ceil32(calldata.size) + 140 len 20], arg2, 0);
    else:
        mem[96] = calldata.size
        mem[128 len calldata.size] = call.data[0 len calldata.size]
        if arg2 == mem[calldata.size + 108 len 20]:
            if not arg2:
                revert with 0, 'ERC1155: burn from the zero address'
            if msg.sender != this.address:
                if balanceOf[arg1][address(arg2)] < arg3:
                    revert with 0, 'ERC1155: burn amount exceeds balance'
                balanceOf[arg1][address(arg2)] -= arg3
                emit TransferSingle(arg1, arg3, msg.sender, arg2, 0);
            else:
                mem[ceil32(calldata.size) + 128] = calldata.size
                mem[ceil32(calldata.size) + 160 len calldata.size] = call.data[0 len calldata.size]
                mem[(2 * ceil32(calldata.size)) + 192] = arg1
                mem[(2 * ceil32(calldata.size)) + 224] = 1
                mem[(2 * ceil32(calldata.size)) + 256] = arg3
                mem[(2 * ceil32(calldata.size)) + 288] = 0
                if balanceOf[arg1][address(arg2)] < arg3:
                    revert with 0, 'ERC1155: burn amount exceeds balance'
                balanceOf[arg1][address(arg2)] -= arg3
                mem[(2 * ceil32(calldata.size)) + 320] = arg1
                mem[(2 * ceil32(calldata.size)) + 352] = arg3
                emit TransferSingle(arg1, arg3, mem[calldata.size + ceil32(calldata.size) + 140 len 20], arg2, 0);
        else:
            if this.address == msg.sender:
                mem[ceil32(calldata.size) + 128] = calldata.size
                mem[ceil32(calldata.size) + 160 len calldata.size] = call.data[0 len calldata.size]
                if not stor1[address(arg2)][address(mem[calldata.size + ceil32(calldata.size) + 128])]:
                    if bool(stor6[address(mem[calldata.size + ceil32(calldata.size) + 128])]) != 1:
                        revert with 0, 'Caller is not owner nor approved'
                if not arg2:
                    revert with 0, 'ERC1155: burn from the zero address'
                if msg.sender != this.address:
                    if balanceOf[arg1][address(arg2)] < arg3:
                        revert with 0, 'ERC1155: burn amount exceeds balance'
                    balanceOf[arg1][address(arg2)] -= arg3
                    emit TransferSingle(arg1, arg3, msg.sender, arg2, 0);
                else:
                    mem[(2 * ceil32(calldata.size)) + 160] = calldata.size
                    mem[(2 * ceil32(calldata.size)) + 192 len calldata.size] = call.data[0 len calldata.size]
                    if balanceOf[arg1][address(arg2)] < arg3:
                        revert with 0, 'ERC1155: burn amount exceeds balance'
                    balanceOf[arg1][address(arg2)] -= arg3
                    mem[(4 * ceil32(calldata.size)) + 352] = arg1
                    mem[(4 * ceil32(calldata.size)) + 384] = arg3
                    emit TransferSingle(arg1, arg3, mem[calldata.size + (2 * ceil32(calldata.size)) + 172 len 20], arg2, 0);
            else:
                if not stor1[address(arg2)][address(msg.sender)]:
                    if bool(stor6[address(msg.sender)]) != 1:
                        revert with 0, 'Caller is not owner nor approved'
                if not arg2:
                    revert with 0, 'ERC1155: burn from the zero address'
                if msg.sender != this.address:
                    if balanceOf[arg1][address(arg2)] < arg3:
                        revert with 0, 'ERC1155: burn amount exceeds balance'
                    balanceOf[arg1][address(arg2)] -= arg3
                    emit TransferSingle(arg1, arg3, msg.sender, arg2, 0);
                else:
                    mem[ceil32(calldata.size) + 128] = calldata.size
                    mem[ceil32(calldata.size) + 160 len calldata.size] = call.data[0 len calldata.size]
                    mem[(2 * ceil32(calldata.size)) + 192] = arg1
                    mem[(2 * ceil32(calldata.size)) + 224] = 1
                    mem[(2 * ceil32(calldata.size)) + 256] = arg3
                    mem[(2 * ceil32(calldata.size)) + 288] = 0
                    if balanceOf[arg1][address(arg2)] < arg3:
                        revert with 0, 'ERC1155: burn amount exceeds balance'
                    balanceOf[arg1][address(arg2)] -= arg3
                    mem[(2 * ceil32(calldata.size)) + 320] = arg1
                    mem[(2 * ceil32(calldata.size)) + 352] = arg3
                    emit TransferSingle(arg1, arg3, mem[calldata.size + ceil32(calldata.size) + 140 len 20], arg2, 0);
}

function withdrawBatch(uint256[] arg1, uint256[] arg2) {
    require calldata.size - 4 >= 64
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    require arg1.length <= test266151307()
    require arg1 + (32 * arg1.length) + 36 <= calldata.size
    require arg2 <= test266151307()
    require arg2 + 35 < calldata.size
    require arg2.length <= test266151307()
    require arg2 + (32 * arg2.length) + 36 <= calldata.size
    if msg.sender != this.address:
        mem[128 len 32 * arg1.length] = call.data[arg1 + 36 len 32 * arg1.length]
        mem[(32 * arg1.length) + 128] = arg2.length
        mem[(32 * arg1.length) + 160 len 32 * arg2.length] = call.data[arg2 + 36 len 32 * arg2.length]
        if not msg.sender:
            revert with 0, 'ERC1155: burn from the zero address'
        if arg1.length != arg2.length:
            revert with 0, 'ERC1155: ids and amounts length mismatch'
        if msg.sender != this.address:
            mem[(32 * arg2.length) + (32 * arg1.length) + 160] = 0
            idx = 0
            while idx < arg1.length:
                if idx >= arg1.length:
                    revert with 0, 50
                if idx >= arg2.length:
                    revert with 0, 50
                if balanceOf[mem[(32 * idx) + 128]][address(msg.sender)] < mem[(32 * idx) + (32 * arg1.length) + 160]:
                    revert with 0, 'ERC1155: burn amount exceeds balance'
                mem[0] = msg.sender
                mem[32] = sha3(mem[(32 * idx) + 128], 0)
                balanceOf[mem[(32 * idx) + 128]][address(msg.sender)] -= mem[(32 * idx) + (32 * arg1.length) + 160]
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            mem[(32 * arg2.length) + (32 * arg1.length) + 192] = 64
            mem[(32 * arg2.length) + (32 * arg1.length) + 256] = arg1.length
            mem[(32 * arg2.length) + (32 * arg1.length) + 288 len 32 * arg1.length] = call.data[arg1 + 36 len 32 * arg1.length]
            mem[(32 * arg2.length) + (32 * arg1.length) + 224] = (32 * arg1.length) + 96
            mem[(32 * arg2.length) + (64 * arg1.length) + 288] = arg2.length
            mem[(32 * arg2.length) + (64 * arg1.length) + 320 len 32 * arg2.length] = call.data[arg2 + 36 len 32 * arg2.length]
            emit TransferBatch(address rg1, address rg2, address rg3, uint256[] rg4, uint256[] rg5):
                               mem[(32 * arg2.length) + (32 * arg1.length) + 192 len (96 * arg2.length) + (96 * arg1.length) + 128],
                               msg.sender,
                               msg.sender,
                               0,
        else:
            mem[(32 * arg2.length) + (32 * arg1.length) + 160] = calldata.size
            mem[(32 * arg2.length) + (32 * arg1.length) + 192 len calldata.size] = call.data[0 len calldata.size]
            mem[(32 * arg2.length) + (32 * arg1.length) + calldata.size + 192] = 0
            mem[(32 * arg2.length) + (32 * arg1.length) + ceil32(calldata.size) + 192] = 0
            idx = 0
            while idx < arg1.length:
                if idx >= arg1.length:
                    revert with 0, 50
                if idx >= arg2.length:
                    revert with 0, 50
                if balanceOf[mem[(32 * idx) + 128]][address(msg.sender)] < mem[(32 * idx) + (32 * arg1.length) + 160]:
                    revert with 0, 'ERC1155: burn amount exceeds balance'
                mem[0] = msg.sender
                mem[32] = sha3(mem[(32 * idx) + 128], 0)
                balanceOf[mem[(32 * idx) + 128]][address(msg.sender)] -= mem[(32 * idx) + (32 * arg1.length) + 160]
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            mem[(32 * arg2.length) + (32 * arg1.length) + ceil32(calldata.size) + 224] = 64
            mem[(32 * arg2.length) + (32 * arg1.length) + ceil32(calldata.size) + 288] = arg1.length
            mem[(32 * arg2.length) + (32 * arg1.length) + ceil32(calldata.size) + 320 len 32 * arg1.length] = call.data[arg1 + 36 len 32 * arg1.length]
            mem[(32 * arg2.length) + (32 * arg1.length) + ceil32(calldata.size) + 256] = (32 * arg1.length) + 96
            mem[(32 * arg2.length) + (64 * arg1.length) + ceil32(calldata.size) + 320] = arg2.length
            mem[(32 * arg2.length) + (64 * arg1.length) + ceil32(calldata.size) + 352 len 32 * arg2.length] = call.data[arg2 + 36 len 32 * arg2.length]
            emit TransferBatch(address rg1, address rg2, address rg3, uint256[] rg4, uint256[] rg5):
                               mem[(32 * arg2.length) + (32 * arg1.length) + ceil32(calldata.size) + 224 len (96 * arg2.length) + (96 * arg1.length) + 128],
                               mem[calldata.size + (32 * arg2.length) + (32 * arg1.length) + 172 len 20],
                               msg.sender,
                               0,
    else:
        mem[96] = calldata.size
        mem[128 len calldata.size] = call.data[0 len calldata.size]
        mem[ceil32(calldata.size) + 160 len 32 * arg1.length] = call.data[arg1 + 36 len 32 * arg1.length]
        mem[ceil32(calldata.size) + (32 * arg1.length) + 160] = arg2.length
        mem[ceil32(calldata.size) + (32 * arg1.length) + 192 len 32 * arg2.length] = call.data[arg2 + 36 len 32 * arg2.length]
        if not mem[calldata.size + 108 len 20]:
            revert with 0, 'ERC1155: burn from the zero address'
        if arg1.length != arg2.length:
            revert with 0, 'ERC1155: ids and amounts length mismatch'
        if msg.sender != this.address:
            mem[(32 * arg2.length) + ceil32(calldata.size) + (32 * arg1.length) + 192] = 0
            idx = 0
            while idx < arg1.length:
                if idx >= arg1.length:
                    revert with 0, 50
                if idx >= arg2.length:
                    revert with 0, 50
                if balanceOf[mem[(32 * idx) + ceil32(calldata.size) + 160]][address(mem[calldata.size + 96])] < mem[(32 * idx) + ceil32(calldata.size) + (32 * arg1.length) + 192]:
                    revert with 0, 'ERC1155: burn amount exceeds balance'
                mem[0] = mem[calldata.size + 108 len 20]
                mem[32] = sha3(mem[(32 * idx) + ceil32(calldata.size) + 160], 0)
                balanceOf[mem[(32 * idx) + ceil32(calldata.size) + 160]][address(mem[calldata.size + 96])] -= mem[(32 * idx) + ceil32(calldata.size) + (32 * arg1.length) + 192]
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            mem[(32 * arg2.length) + ceil32(calldata.size) + (32 * arg1.length) + 224] = 64
            mem[(32 * arg2.length) + ceil32(calldata.size) + (32 * arg1.length) + 288] = arg1.length
            mem[(32 * arg2.length) + ceil32(calldata.size) + (32 * arg1.length) + 320 len 32 * arg1.length] = call.data[arg1 + 36 len 32 * arg1.length]
            mem[(32 * arg2.length) + ceil32(calldata.size) + (32 * arg1.length) + 256] = (32 * arg1.length) + 96
            mem[(32 * arg2.length) + ceil32(calldata.size) + (64 * arg1.length) + 320] = arg2.length
            mem[(32 * arg2.length) + ceil32(calldata.size) + (64 * arg1.length) + 352 len 32 * arg2.length] = call.data[arg2 + 36 len 32 * arg2.length]
            emit TransferBatch(address rg1, address rg2, address rg3, uint256[] rg4, uint256[] rg5):
                               mem[(32 * arg2.length) + ceil32(calldata.size) + (32 * arg1.length) + 224 len (96 * arg2.length) + (96 * arg1.length) + 128],
                               msg.sender,
                               mem[calldata.size + 108 len 20],
                               0,
        else:
            mem[(32 * arg2.length) + ceil32(calldata.size) + (32 * arg1.length) + 192] = calldata.size
            mem[(32 * arg2.length) + ceil32(calldata.size) + (32 * arg1.length) + 224 len calldata.size] = call.data[0 len calldata.size]
            mem[(32 * arg2.length) + ceil32(calldata.size) + (32 * arg1.length) + calldata.size + 224] = 0
            mem[(32 * arg2.length) + (2 * ceil32(calldata.size)) + (32 * arg1.length) + 224] = 0
            idx = 0
            while idx < arg1.length:
                if idx >= arg1.length:
                    revert with 0, 50
                if idx >= arg2.length:
                    revert with 0, 50
                if balanceOf[mem[(32 * idx) + ceil32(calldata.size) + 160]][address(mem[calldata.size + 96])] < mem[(32 * idx) + ceil32(calldata.size) + (32 * arg1.length) + 192]:
                    revert with 0, 'ERC1155: burn amount exceeds balance'
                mem[0] = mem[calldata.size + 108 len 20]
                mem[32] = sha3(mem[(32 * idx) + ceil32(calldata.size) + 160], 0)
                balanceOf[mem[(32 * idx) + ceil32(calldata.size) + 160]][address(mem[calldata.size + 96])] -= mem[(32 * idx) + ceil32(calldata.size) + (32 * arg1.length) + 192]
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            mem[(32 * arg2.length) + (2 * ceil32(calldata.size)) + (32 * arg1.length) + 256] = 64
            mem[(32 * arg2.length) + (2 * ceil32(calldata.size)) + (32 * arg1.length) + 320] = arg1.length
            mem[(32 * arg2.length) + (2 * ceil32(calldata.size)) + (32 * arg1.length) + 352 len 32 * arg1.length] = call.data[arg1 + 36 len 32 * arg1.length]
            mem[(32 * arg2.length) + (2 * ceil32(calldata.size)) + (32 * arg1.length) + 288] = (32 * arg1.length) + 96
            mem[(32 * arg2.length) + (2 * ceil32(calldata.size)) + (64 * arg1.length) + 352] = arg2.length
            mem[(32 * arg2.length) + (2 * ceil32(calldata.size)) + (64 * arg1.length) + 384 len 32 * arg2.length] = call.data[arg2 + 36 len 32 * arg2.length]
            emit TransferBatch(address rg1, address rg2, address rg3, uint256[] rg4, uint256[] rg5):
                               mem[(32 * arg2.length) + (2 * ceil32(calldata.size)) + (32 * arg1.length) + 256 len (96 * arg2.length) + (96 * arg1.length) + 128],
                               mem[calldata.size + (32 * arg2.length) + ceil32(calldata.size) + (32 * arg1.length) + 204 len 20],
                               mem[calldata.size + 108 len 20],
                               0,
}

function sub_1f55a2bc(?) {
    require calldata.size - 4 >= 160
    require arg3 == bool(arg3)
    require arg4 == bool(arg4)
    require arg5 <= test266151307()
    require arg5 + 35 < calldata.size
    if arg5.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg5.length)) + 97 < 96 or ceil32(ceil32(arg5.length)) + 97 > test266151307():
        revert with 0, 65
    require arg5 + arg5.length + 36 <= calldata.size
    mem[128 len arg5.length] = arg5[all]
    mem[arg5.length + 128] = 0
    if msg.sender != this.address:
        if not uint8(roleAdmin[0][address(msg.sender)].field_0):
            mem[ceil32(ceil32(arg5.length)) + 129 len 42] = call.data[calldata.size len 42]
            idx = 41
            s = address(msg.sender)
            while idx > 1:
                if s % 16 >= 16:
                    revert with 0, 50
                if idx >= 42:
                    revert with 0, 50
                mem[idx + ceil32(ceil32(arg5.length)) + 129 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                if not idx:
                    revert with 0, 17
                idx = idx - 1
                s = Mask(252, 0, s) * 0.0625
                continue 
            if msg.sender + 10240:
                revert with 0, 'Strings: hex length insufficient'
            mem[ceil32(ceil32(arg5.length)) + 225 len 66] = call.data[calldata.size len 66]
            idx = 65
            while idx > 1:
                if idx >= 66:
                    revert with 0, 50
                mem[idx + ceil32(ceil32(arg5.length)) + 225 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                if not idx:
                    revert with 0, 17
                idx = idx - 1
                continue 
            revert with 0, 
                        32,
                        148,
                        'AccessControl: account ', mem[ceil32(ceil32(arg5.length)) + 161 len 42], 8297, mem[ceil32(ceil32(arg5.length)) + 289 len 66], 0, 0 >> 928,
                        0
        if msg.sender != this.address:
            if not uint8(roleAdmin[0][address(msg.sender)].field_0):
                mem[ceil32(ceil32(arg5.length)) + 129 len 42] = call.data[calldata.size len 42]
                idx = 41
                s = address(msg.sender)
                while idx > 1:
                    if s % 16 >= 16:
                        revert with 0, 50
                    if idx >= 42:
                        revert with 0, 50
                    mem[idx + ceil32(ceil32(arg5.length)) + 129 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                    if not idx:
                        revert with 0, 17
                    idx = idx - 1
                    s = Mask(252, 0, s) * 0.0625
                    continue 
                if msg.sender + 10240:
                    revert with 0, 'Strings: hex length insufficient'
                mem[ceil32(ceil32(arg5.length)) + 225 len 66] = call.data[calldata.size len 66]
                idx = 65
                while idx > 1:
                    if idx >= 66:
                        revert with 0, 50
                    mem[idx + ceil32(ceil32(arg5.length)) + 225 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                    if not idx:
                        revert with 0, 17
                    idx = idx - 1
                    continue 
                revert with 0, 
                            32,
                            148,
                            'AccessControl: account ', mem[ceil32(ceil32(arg5.length)) + 161 len 42], 8297, mem[ceil32(ceil32(arg5.length)) + 289 len 66], 0, 0 >> 928,
                            0
        else:
            mem[ceil32(ceil32(arg5.length)) + 97] = calldata.size
            mem[ceil32(ceil32(arg5.length)) + 129 len calldata.size] = call.data[0 len calldata.size]
            if not uint8(roleAdmin[0][address(mem[calldata.size + ceil32(ceil32(arg5.length)) + 97])].field_0):
                mem[ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 161 len 42] = call.data[calldata.size len 42]
                idx = 41
                s = mem[calldata.size + ceil32(ceil32(arg5.length)) + 109 len 20]
                while idx > 1:
                    if s % 16 >= 16:
                        revert with 0, 50
                    if idx >= 42:
                        revert with 0, 50
                    mem[idx + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 161 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                    if not idx:
                        revert with 0, 17
                    idx = idx - 1
                    s = Mask(252, 0, s) * 0.0625
                    continue 
                if mem[calldata.size + ceil32(ceil32(arg5.length)) + 109 len 20] + 10240:
                    revert with 0, 'Strings: hex length insufficient'
                mem[ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 257 len 66] = call.data[calldata.size len 66]
                idx = 65
                while idx > 1:
                    if idx >= 66:
                        revert with 0, 50
                    mem[idx + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 257 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                    if not idx:
                        revert with 0, 17
                    idx = idx - 1
                    continue 
                revert with 0, 
                            32,
                            148,
                            'AccessControl: account ', mem[ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 193 len 42], 8297, mem[ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 321 len 66], 0, 0 >> 928,
                            0
    else:
        mem[ceil32(ceil32(arg5.length)) + 97] = calldata.size
        mem[ceil32(ceil32(arg5.length)) + 129 len calldata.size] = call.data[0 len calldata.size]
        if not uint8(roleAdmin[0][address(mem[calldata.size + ceil32(ceil32(arg5.length)) + 97])].field_0):
            mem[ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 161 len 42] = call.data[calldata.size len 42]
            idx = 41
            s = mem[calldata.size + ceil32(ceil32(arg5.length)) + 109 len 20]
            while idx > 1:
                if s % 16 >= 16:
                    revert with 0, 50
                if idx >= 42:
                    revert with 0, 50
                mem[idx + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 161 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                if not idx:
                    revert with 0, 17
                idx = idx - 1
                s = Mask(252, 0, s) * 0.0625
                continue 
            if mem[calldata.size + ceil32(ceil32(arg5.length)) + 109 len 20] + 10240:
                revert with 0, 'Strings: hex length insufficient'
            mem[ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 257 len 66] = call.data[calldata.size len 66]
            idx = 65
            while idx > 1:
                if idx >= 66:
                    revert with 0, 50
                mem[idx + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 257 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                if not idx:
                    revert with 0, 17
                idx = idx - 1
                continue 
            revert with 0, 
                        32,
                        148,
                        'AccessControl: account ', mem[ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 193 len 42], 8297, mem[ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 321 len 66], 0, 0 >> 928,
                        0
        if msg.sender != this.address:
            if not uint8(roleAdmin[0][address(msg.sender)].field_0):
                mem[ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 161 len 42] = call.data[calldata.size len 42]
                idx = 41
                s = address(msg.sender)
                while idx > 1:
                    if s % 16 >= 16:
                        revert with 0, 50
                    if idx >= 42:
                        revert with 0, 50
                    mem[idx + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 161 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                    if not idx:
                        revert with 0, 17
                    idx = idx - 1
                    s = Mask(252, 0, s) * 0.0625
                    continue 
                if msg.sender + 10240:
                    revert with 0, 'Strings: hex length insufficient'
                mem[ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 257 len 66] = call.data[calldata.size len 66]
                idx = 65
                while idx > 1:
                    if idx >= 66:
                        revert with 0, 50
                    mem[idx + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 257 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                    if not idx:
                        revert with 0, 17
                    idx = idx - 1
                    continue 
                revert with 0, 
                            32,
                            148,
                            'AccessControl: account ', mem[ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 193 len 42], 8297, mem[ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 321 len 66], 0, 0 >> 928,
                            0
        else:
            mem[ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 129] = calldata.size
            mem[ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 161 len calldata.size] = call.data[0 len calldata.size]
            _11 = mem[calldata.size + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 129]
            if not uint8(roleAdmin[0][address(mem[calldata.size + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 129])].field_0):
                mem[ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 193 len 42] = call.data[calldata.size len 42]
                idx = 41
                s = mem[calldata.size + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 141 len 20]
                while idx > 1:
                    if s % 16 >= 16:
                        revert with 0, 50
                    if idx >= 42:
                        revert with 0, 50
                    mem[idx + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 193 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                    if not idx:
                        revert with 0, 17
                    idx = idx - 1
                    s = Mask(252, 0, s) * 0.0625
                    continue 
                if address(_11) + 10240:
                    revert with 0, 'Strings: hex length insufficient'
                mem[ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 289 len 66] = call.data[calldata.size len 66]
                idx = 65
                while idx > 1:
                    if idx >= 66:
                        revert with 0, 50
                    mem[idx + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 289 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                    if not idx:
                        revert with 0, 17
                    idx = idx - 1
                    continue 
                revert with 0, 
                            32,
                            148,
                            'AccessControl: account ', mem[ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 225 len 42], 8297, mem[ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 353 len 66], 0, 0 >> 928,
                            0
    if stor13[arg1]:
        revert with 0, 'Supplied typeId is already used'
    if arg2 <= 0:
        revert with 0, 'max supply must be > 0'
    sub_fc86b662[arg1] = arg2
    stor12[arg1] = uint8(bool(arg3))
    stor11[arg1] = uint8(bool(arg4))
    stor13[arg1] = 1
    if arg3:
        sub_0f699e80[arg1] = arg1
    if bool(stor15[arg1].field_0):
        if bool(stor15[arg1].field_0) == uint255(stor15[arg1].field_0) * 0.5 < 32:
            revert with 0, 34
        if arg5.length:
            stor15[arg1][].field_0 = Array(len=arg5.length, data=arg5[all])
        else:
            stor15[arg1].field_0 = 0
            idx = 0
            while (uint255(stor15[arg1].field_0) * 0.5) + 31 / 32 > idx:
                stor15[arg1][idx].field_0 = 0
                idx = idx + 1
                continue 
    else:
        if bool(stor15[arg1].field_0) == stor15[arg1].field_1 % 128 < 32:
            revert with 0, 34
        if arg5.length:
            stor15[arg1][].field_0 = Array(len=arg5.length, data=arg5[all])
        else:
            stor15[arg1].field_0 = 0
            idx = 0
            while stor15[arg1].field_1 % 128 + 31 / 32 > idx:
                stor15[arg1][idx].field_0 = 0
                idx = idx + 1
                continue 
    emit 0xdd645363: arg1, arg2, bool(arg3), bool(arg4), Array(len=arg5.length, data=arg5[all])
}

function sub_f807393a(?) {
    require calldata.size - 4 >= 96
    require arg2 == address(arg2)
    if msg.sender != this.address:
        if not uint8(roleAdmin[0][address(msg.sender)].field_0):
            mem[128 len 42] = call.data[calldata.size len 42]
            idx = 41
            s = address(msg.sender)
            while idx > 1:
                if s % 16 >= 16:
                    revert with 0, 50
                if idx >= 42:
                    revert with 0, 50
                mem[idx + 128 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                if not idx:
                    revert with 0, 17
                idx = idx - 1
                s = Mask(252, 0, s) * 0.0625
                continue 
            if msg.sender + 10240:
                revert with 0, 'Strings: hex length insufficient'
            mem[224 len 66] = call.data[calldata.size len 66]
            idx = 65
            while idx > 1:
                if idx >= 66:
                    revert with 0, 50
                mem[idx + 224 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                if not idx:
                    revert with 0, 17
                idx = idx - 1
                continue 
            revert with 0, 32, 148, 'AccessControl: account ', mem[160 len 42], 8297, mem[288 len 66], 0, 0 >> 928, 0
        if msg.sender != this.address:
            if not uint8(roleAdmin[0][address(msg.sender)].field_0):
                mem[128 len 42] = call.data[calldata.size len 42]
                idx = 41
                s = address(msg.sender)
                while idx > 1:
                    if s % 16 >= 16:
                        revert with 0, 50
                    if idx >= 42:
                        revert with 0, 50
                    mem[idx + 128 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                    if not idx:
                        revert with 0, 17
                    idx = idx - 1
                    s = Mask(252, 0, s) * 0.0625
                    continue 
                if msg.sender + 10240:
                    revert with 0, 'Strings: hex length insufficient'
                mem[224 len 66] = call.data[calldata.size len 66]
                idx = 65
                while idx > 1:
                    if idx >= 66:
                        revert with 0, 50
                    mem[idx + 224 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                    if not idx:
                        revert with 0, 17
                    idx = idx - 1
                    continue 
                revert with 0, 32, 148, 'AccessControl: account ', mem[160 len 42], 8297, mem[288 len 66], 0, 0 >> 928, 0
            require arg1 > 0
            if arg3 <= 0:
                revert with 0, 'Amount should be > 0'
            if sub_79920951[arg1] > !arg3:
                revert with 0, 17
            if sub_79920951[arg1] + arg3 > sub_fc86b662[arg1]:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            'Minting would exceed the max number of items for given type'
            if bool(stor12[arg1]) != 1:
                revert with 0, 'typeId is not fungible.'
            if sub_79920951[arg1] > !arg3:
                revert with 0, 17
            sub_79920951[arg1] += arg3
            if not address(arg2):
                revert with 0, 'ERC1155: mint to the zero address'
            if msg.sender != this.address:
                if balanceOf[arg1][address(arg2)] > !arg3:
                    revert with 0, 17
                balanceOf[arg1][address(arg2)] += arg3
                emit TransferSingle(arg1, arg3, msg.sender, 0, address(arg2));
                if ext_code.size(address(arg2)):
                    require ext_code.size(address(arg2))
                    call address(arg2).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                         gas gas_remaining wei
                        args msg.sender, 0, arg1, arg3, 160, 0
                    if not ext_call.success:
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    require return_data.size >= 32
                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                    if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                        revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
            else:
                mem[128] = calldata.size
                mem[160 len calldata.size] = call.data[0 len calldata.size]
                if balanceOf[arg1][address(arg2)] > !arg3:
                    revert with 0, 17
                balanceOf[arg1][address(arg2)] += arg3
                emit TransferSingle(arg1, arg3, mem[calldata.size + 140 len 20], 0, address(arg2));
                if ext_code.size(address(arg2)):
                    require ext_code.size(address(arg2))
                    call address(arg2).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                         gas gas_remaining wei
                        args mem[calldata.size + 140 len 20], 0, arg1, arg3, 160, 0
                    if not ext_call.success:
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    require return_data.size >= 32
                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                    if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                        revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
        else:
            mem[96] = calldata.size
            mem[128 len calldata.size] = call.data[0 len calldata.size]
            if not uint8(roleAdmin[0][address(mem[calldata.size + 96])].field_0):
                mem[ceil32(calldata.size) + 160 len 42] = call.data[calldata.size len 42]
                idx = 41
                s = mem[calldata.size + 108 len 20]
                while idx > 1:
                    if s % 16 >= 16:
                        revert with 0, 50
                    if idx >= 42:
                        revert with 0, 50
                    mem[idx + ceil32(calldata.size) + 160 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                    if not idx:
                        revert with 0, 17
                    idx = idx - 1
                    s = Mask(252, 0, s) * 0.0625
                    continue 
                if mem[calldata.size + 108 len 20] + 10240:
                    revert with 0, 'Strings: hex length insufficient'
                mem[ceil32(calldata.size) + 256 len 66] = call.data[calldata.size len 66]
                idx = 65
                while idx > 1:
                    if idx >= 66:
                        revert with 0, 50
                    mem[idx + ceil32(calldata.size) + 256 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                    if not idx:
                        revert with 0, 17
                    idx = idx - 1
                    continue 
                revert with 0, 
                            32,
                            148,
                            'AccessControl: account ', mem[ceil32(calldata.size) + 192 len 42], 8297, mem[ceil32(calldata.size) + 320 len 66], 0, 0 >> 928,
                            0
            require arg1 > 0
            if arg3 <= 0:
                revert with 0, 'Amount should be > 0'
            if sub_79920951[arg1] > !arg3:
                revert with 0, 17
            if sub_79920951[arg1] + arg3 > sub_fc86b662[arg1]:
                revert with 0, 'Minting would exceed the max number of items for given type'
            if bool(stor12[arg1]) != 1:
                revert with 0, 'typeId is not fungible.'
            if sub_79920951[arg1] > !arg3:
                revert with 0, 17
            sub_79920951[arg1] += arg3
            if not address(arg2):
                revert with 0, 'ERC1155: mint to the zero address'
            if msg.sender != this.address:
                if balanceOf[arg1][address(arg2)] > !arg3:
                    revert with 0, 17
                balanceOf[arg1][address(arg2)] += arg3
                emit TransferSingle(arg1, arg3, msg.sender, 0, address(arg2));
                if ext_code.size(address(arg2)):
                    require ext_code.size(address(arg2))
                    call address(arg2).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                         gas gas_remaining wei
                        args msg.sender, 0, arg1, arg3, 160, 0
                    if not ext_call.success:
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    require return_data.size >= 32
                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                    if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                        revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
            else:
                mem[ceil32(calldata.size) + 160] = calldata.size
                mem[ceil32(calldata.size) + 192 len calldata.size] = call.data[0 len calldata.size]
                mem[(2 * ceil32(calldata.size)) + 224] = arg1
                mem[(2 * ceil32(calldata.size)) + 256] = 1
                mem[(2 * ceil32(calldata.size)) + 288] = arg3
                if balanceOf[arg1][address(arg2)] > !arg3:
                    revert with 0, 17
                balanceOf[arg1][address(arg2)] += arg3
                mem[(2 * ceil32(calldata.size)) + 320] = arg1
                mem[(2 * ceil32(calldata.size)) + 352] = arg3
                emit TransferSingle(arg1, arg3, mem[calldata.size + ceil32(calldata.size) + 172 len 20], 0, address(arg2));
                if ext_code.size(address(arg2)):
                    mem[(2 * ceil32(calldata.size)) + 320] = 0xf23a6e6100000000000000000000000000000000000000000000000000000000
                    mem[(2 * ceil32(calldata.size)) + 324] = mem[calldata.size + ceil32(calldata.size) + 172 len 20]
                    mem[(2 * ceil32(calldata.size)) + 356] = 0
                    mem[(2 * ceil32(calldata.size)) + 388] = arg1
                    mem[(2 * ceil32(calldata.size)) + 420] = arg3
                    mem[(2 * ceil32(calldata.size)) + 452] = 160
                    mem[(2 * ceil32(calldata.size)) + 484] = 0
                    mem[(2 * ceil32(calldata.size)) + 516 len 0] = None
                    require ext_code.size(address(arg2))
                    call address(arg2).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                         gas gas_remaining wei
                        args mem[calldata.size + ceil32(calldata.size) + 172 len 20], 0, arg1, arg3, 160, 0
                    if not ext_call.success:
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    require return_data.size >= 32
                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                    if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                        revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
    else:
        mem[96] = calldata.size
        mem[128 len calldata.size] = call.data[0 len calldata.size]
        if not uint8(roleAdmin[0][address(mem[calldata.size + 96])].field_0):
            mem[ceil32(calldata.size) + 160 len 42] = call.data[calldata.size len 42]
            idx = 41
            s = mem[calldata.size + 108 len 20]
            while idx > 1:
                if s % 16 >= 16:
                    revert with 0, 50
                if idx >= 42:
                    revert with 0, 50
                mem[idx + ceil32(calldata.size) + 160 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                if not idx:
                    revert with 0, 17
                idx = idx - 1
                s = Mask(252, 0, s) * 0.0625
                continue 
            if mem[calldata.size + 108 len 20] + 10240:
                revert with 0, 'Strings: hex length insufficient'
            mem[ceil32(calldata.size) + 256 len 66] = call.data[calldata.size len 66]
            idx = 65
            while idx > 1:
                if idx >= 66:
                    revert with 0, 50
                mem[idx + ceil32(calldata.size) + 256 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                if not idx:
                    revert with 0, 17
                idx = idx - 1
                continue 
            revert with 0, 
                        32,
                        148,
                        'AccessControl: account ', mem[ceil32(calldata.size) + 192 len 42], 8297, mem[ceil32(calldata.size) + 320 len 66], 0, 0 >> 928,
                        0
        if this.address == msg.sender:
            mem[ceil32(calldata.size) + 128] = calldata.size
            mem[ceil32(calldata.size) + 160 len calldata.size] = call.data[0 len calldata.size]
            _10 = mem[calldata.size + ceil32(calldata.size) + 128]
            if not uint8(roleAdmin[0][address(mem[calldata.size + ceil32(calldata.size) + 128])].field_0):
                mem[(2 * ceil32(calldata.size)) + 192 len 42] = call.data[calldata.size len 42]
                idx = 41
                s = mem[calldata.size + ceil32(calldata.size) + 140 len 20]
                while idx > 1:
                    if s % 16 >= 16:
                        revert with 0, 50
                    if idx >= 42:
                        revert with 0, 50
                    mem[idx + (2 * ceil32(calldata.size)) + 192 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                    if not idx:
                        revert with 0, 17
                    idx = idx - 1
                    s = Mask(252, 0, s) * 0.0625
                    continue 
                if address(_10) + 10240:
                    revert with 0, 'Strings: hex length insufficient'
                mem[(2 * ceil32(calldata.size)) + 288 len 66] = call.data[calldata.size len 66]
                idx = 65
                while idx > 1:
                    if idx >= 66:
                        revert with 0, 50
                    mem[idx + (2 * ceil32(calldata.size)) + 288 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                    if not idx:
                        revert with 0, 17
                    idx = idx - 1
                    continue 
                revert with 0, 
                            32,
                            148,
                            'AccessControl: account ', mem[(2 * ceil32(calldata.size)) + 224 len 42], 8297, mem[(2 * ceil32(calldata.size)) + 352 len 66], 0, 0 >> 928,
                            0
            require arg1 > 0
            if arg3 <= 0:
                revert with 0, 'Amount should be > 0'
            if sub_79920951[arg1] > !arg3:
                revert with 0, 17
            if sub_79920951[arg1] + arg3 > sub_fc86b662[arg1]:
                revert with 0, 'Minting would exceed the max number of items for given type'
            if bool(stor12[arg1]) != 1:
                revert with 0, 'typeId is not fungible.'
            if sub_79920951[arg1] > !arg3:
                revert with 0, 17
            sub_79920951[arg1] += arg3
            if not address(arg2):
                revert with 0, 'ERC1155: mint to the zero address'
            if msg.sender != this.address:
                if balanceOf[arg1][address(arg2)] > !arg3:
                    revert with 0, 17
                balanceOf[arg1][address(arg2)] += arg3
                emit TransferSingle(arg1, arg3, msg.sender, 0, address(arg2));
                if ext_code.size(address(arg2)):
                    require ext_code.size(address(arg2))
                    call address(arg2).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                         gas gas_remaining wei
                        args msg.sender, 0, arg1, arg3, 160, 0
                    if not ext_call.success:
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    require return_data.size >= 32
                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                    if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                        revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
            else:
                mem[(2 * ceil32(calldata.size)) + 192] = calldata.size
                mem[(2 * ceil32(calldata.size)) + 224 len calldata.size] = call.data[0 len calldata.size]
                if balanceOf[arg1][address(arg2)] > !arg3:
                    revert with 0, 17
                balanceOf[arg1][address(arg2)] += arg3
                mem[(4 * ceil32(calldata.size)) + 384] = arg3
                emit TransferSingle(arg1, arg3, mem[calldata.size + (2 * ceil32(calldata.size)) + 204 len 20], 0, address(arg2));
                if ext_code.size(address(arg2)):
                    mem[(4 * ceil32(calldata.size)) + 388] = 0
                    mem[(4 * ceil32(calldata.size)) + 420] = arg1
                    mem[(4 * ceil32(calldata.size)) + 452] = arg3
                    mem[(4 * ceil32(calldata.size)) + 484] = 160
                    mem[(4 * ceil32(calldata.size)) + 516] = 0
                    mem[(4 * ceil32(calldata.size)) + 548 len 0] = None
                    require ext_code.size(address(arg2))
                    call address(arg2).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                         gas gas_remaining wei
                        args mem[calldata.size + (2 * ceil32(calldata.size)) + 204 len 20], 0, arg1, arg3, 160, 0
                    if not ext_call.success:
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    require return_data.size >= 32
                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                    if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                        revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
        else:
            if not uint8(roleAdmin[0][address(msg.sender)].field_0):
                mem[ceil32(calldata.size) + 160 len 42] = call.data[calldata.size len 42]
                idx = 41
                s = address(msg.sender)
                while idx > 1:
                    if s % 16 >= 16:
                        revert with 0, 50
                    if idx >= 42:
                        revert with 0, 50
                    mem[idx + ceil32(calldata.size) + 160 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                    if not idx:
                        revert with 0, 17
                    idx = idx - 1
                    s = Mask(252, 0, s) * 0.0625
                    continue 
                if msg.sender + 10240:
                    revert with 0, 'Strings: hex length insufficient'
                mem[ceil32(calldata.size) + 256 len 66] = call.data[calldata.size len 66]
                idx = 65
                while idx > 1:
                    if idx >= 66:
                        revert with 0, 50
                    mem[idx + ceil32(calldata.size) + 256 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                    if not idx:
                        revert with 0, 17
                    idx = idx - 1
                    continue 
                revert with 0, 
                            32,
                            148,
                            'AccessControl: account ', mem[ceil32(calldata.size) + 192 len 42], 8297, mem[ceil32(calldata.size) + 320 len 66], 0, 0 >> 928,
                            0
            require arg1 > 0
            if arg3 <= 0:
                revert with 0, 'Amount should be > 0'
            if sub_79920951[arg1] > !arg3:
                revert with 0, 17
            if sub_79920951[arg1] + arg3 > sub_fc86b662[arg1]:
                revert with 0, 'Minting would exceed the max number of items for given type'
            if bool(stor12[arg1]) != 1:
                revert with 0, 'typeId is not fungible.'
            if sub_79920951[arg1] > !arg3:
                revert with 0, 17
            sub_79920951[arg1] += arg3
            if not address(arg2):
                revert with 0, 'ERC1155: mint to the zero address'
            if msg.sender != this.address:
                if balanceOf[arg1][address(arg2)] > !arg3:
                    revert with 0, 17
                balanceOf[arg1][address(arg2)] += arg3
                emit TransferSingle(arg1, arg3, msg.sender, 0, address(arg2));
                if ext_code.size(address(arg2)):
                    require ext_code.size(address(arg2))
                    call address(arg2).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                         gas gas_remaining wei
                        args msg.sender, 0, arg1, arg3, 160, 0
                    if not ext_call.success:
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    require return_data.size >= 32
                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                    if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                        revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
            else:
                mem[ceil32(calldata.size) + 160] = calldata.size
                mem[ceil32(calldata.size) + 192 len calldata.size] = call.data[0 len calldata.size]
                mem[(2 * ceil32(calldata.size)) + 224] = arg1
                mem[(2 * ceil32(calldata.size)) + 256] = 1
                mem[(2 * ceil32(calldata.size)) + 288] = arg3
                if balanceOf[arg1][address(arg2)] > !arg3:
                    revert with 0, 17
                balanceOf[arg1][address(arg2)] += arg3
                mem[(2 * ceil32(calldata.size)) + 320] = arg1
                mem[(2 * ceil32(calldata.size)) + 352] = arg3
                emit TransferSingle(arg1, arg3, mem[calldata.size + ceil32(calldata.size) + 172 len 20], 0, address(arg2));
                if ext_code.size(address(arg2)):
                    mem[(2 * ceil32(calldata.size)) + 320] = 0xf23a6e6100000000000000000000000000000000000000000000000000000000
                    mem[(2 * ceil32(calldata.size)) + 324] = mem[calldata.size + ceil32(calldata.size) + 172 len 20]
                    mem[(2 * ceil32(calldata.size)) + 356] = 0
                    mem[(2 * ceil32(calldata.size)) + 388] = arg1
                    mem[(2 * ceil32(calldata.size)) + 420] = arg3
                    mem[(2 * ceil32(calldata.size)) + 452] = 160
                    mem[(2 * ceil32(calldata.size)) + 484] = 0
                    mem[(2 * ceil32(calldata.size)) + 516 len 0] = None
                    require ext_code.size(address(arg2))
                    call address(arg2).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                         gas gas_remaining wei
                        args mem[calldata.size + ceil32(calldata.size) + 172 len 20], 0, arg1, arg3, 160, 0
                    if not ext_call.success:
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    require return_data.size >= 32
                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                    if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                        revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
    emit 0x6a47e9a7: arg1, address(arg2), arg3
}

function sub_b88cbbd2(?) {
    require calldata.size - 4 >= 96
    require arg3 == address(arg3)
    if msg.sender != this.address:
        if not uint8(roleAdmin[0][address(msg.sender)].field_0):
            mem[128 len 42] = call.data[calldata.size len 42]
            idx = 41
            s = address(msg.sender)
            while idx > 1:
                if s % 16 >= 16:
                    revert with 0, 50
                if idx >= 42:
                    revert with 0, 50
                mem[idx + 128 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                if not idx:
                    revert with 0, 17
                idx = idx - 1
                s = Mask(252, 0, s) * 0.0625
                continue 
            if msg.sender + 10240:
                revert with 0, 'Strings: hex length insufficient'
            mem[224 len 66] = call.data[calldata.size len 66]
            idx = 65
            while idx > 1:
                if idx >= 66:
                    revert with 0, 50
                mem[idx + 224 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                if not idx:
                    revert with 0, 17
                idx = idx - 1
                continue 
            revert with 0, 32, 148, 'AccessControl: account ', mem[160 len 42], 8297, mem[288 len 66], 0, 0 >> 928, 0
        if msg.sender != this.address:
            if not uint8(roleAdmin[0][address(msg.sender)].field_0):
                mem[128 len 42] = call.data[calldata.size len 42]
                idx = 41
                s = address(msg.sender)
                while idx > 1:
                    if s % 16 >= 16:
                        revert with 0, 50
                    if idx >= 42:
                        revert with 0, 50
                    mem[idx + 128 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                    if not idx:
                        revert with 0, 17
                    idx = idx - 1
                    s = Mask(252, 0, s) * 0.0625
                    continue 
                if msg.sender + 10240:
                    revert with 0, 'Strings: hex length insufficient'
                mem[224 len 66] = call.data[calldata.size len 66]
                idx = 65
                while idx > 1:
                    if idx >= 66:
                        revert with 0, 50
                    mem[idx + 224 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                    if not idx:
                        revert with 0, 17
                    idx = idx - 1
                    continue 
                revert with 0, 32, 148, 'AccessControl: account ', mem[160 len 42], 8297, mem[288 len 66], 0, 0 >> 928, 0
            require arg2 > 0
            if sub_79920951[arg1] > -2:
                revert with 0, 17
            if sub_79920951[arg1] + 1 > sub_fc86b662[arg1]:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            'Minting would exceed the max number of items for given type'
            if stor13[arg2]:
                revert with 0, 'Supplied id is already used'
            if stor12[arg1]:
                revert with 0, 'Given type is fungible'
            stor13[arg2] = 1
            if sub_79920951[arg1] > -2:
                revert with 0, 17
            sub_79920951[arg1]++
            sub_0f699e80[arg2] = arg1
            mintNumber[arg2] = sub_79920951[arg1]
            if not address(arg3):
                revert with 0, 'ERC1155: mint to the zero address'
            if msg.sender != this.address:
                if balanceOf[arg2][address(arg3)] > -2:
                    revert with 0, 17
                balanceOf[arg2][address(arg3)]++
                emit TransferSingle(arg2, 1, msg.sender, 0, address(arg3));
                if ext_code.size(address(arg3)):
                    require ext_code.size(address(arg3))
                    call address(arg3).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                         gas gas_remaining wei
                        args msg.sender, 0, arg2, 1, 160, 0
                    if not ext_call.success:
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    require return_data.size >= 32
                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                    if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                        revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
            else:
                mem[128] = calldata.size
                mem[160 len calldata.size] = call.data[0 len calldata.size]
                if balanceOf[arg2][address(arg3)] > -2:
                    revert with 0, 17
                balanceOf[arg2][address(arg3)]++
                emit TransferSingle(arg2, 1, mem[calldata.size + 140 len 20], 0, address(arg3));
                if ext_code.size(address(arg3)):
                    require ext_code.size(address(arg3))
                    call address(arg3).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                         gas gas_remaining wei
                        args mem[calldata.size + 140 len 20], 0, arg2, 1, 160, 0
                    if not ext_call.success:
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    require return_data.size >= 32
                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                    if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                        revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
        else:
            mem[96] = calldata.size
            mem[128 len calldata.size] = call.data[0 len calldata.size]
            if not uint8(roleAdmin[0][address(mem[calldata.size + 96])].field_0):
                mem[ceil32(calldata.size) + 160 len 42] = call.data[calldata.size len 42]
                idx = 41
                s = mem[calldata.size + 108 len 20]
                while idx > 1:
                    if s % 16 >= 16:
                        revert with 0, 50
                    if idx >= 42:
                        revert with 0, 50
                    mem[idx + ceil32(calldata.size) + 160 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                    if not idx:
                        revert with 0, 17
                    idx = idx - 1
                    s = Mask(252, 0, s) * 0.0625
                    continue 
                if mem[calldata.size + 108 len 20] + 10240:
                    revert with 0, 'Strings: hex length insufficient'
                mem[ceil32(calldata.size) + 256 len 66] = call.data[calldata.size len 66]
                idx = 65
                while idx > 1:
                    if idx >= 66:
                        revert with 0, 50
                    mem[idx + ceil32(calldata.size) + 256 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                    if not idx:
                        revert with 0, 17
                    idx = idx - 1
                    continue 
                revert with 0, 
                            32,
                            148,
                            'AccessControl: account ', mem[ceil32(calldata.size) + 192 len 42], 8297, mem[ceil32(calldata.size) + 320 len 66], 0, 0 >> 928,
                            0
            require arg2 > 0
            if sub_79920951[arg1] > -2:
                revert with 0, 17
            if sub_79920951[arg1] + 1 > sub_fc86b662[arg1]:
                revert with 0, 'Minting would exceed the max number of items for given type'
            if stor13[arg2]:
                revert with 0, 'Supplied id is already used'
            if stor12[arg1]:
                revert with 0, 'Given type is fungible'
            stor13[arg2] = 1
            if sub_79920951[arg1] > -2:
                revert with 0, 17
            sub_79920951[arg1]++
            sub_0f699e80[arg2] = arg1
            mintNumber[arg2] = sub_79920951[arg1]
            if not address(arg3):
                revert with 0, 'ERC1155: mint to the zero address'
            if msg.sender != this.address:
                if balanceOf[arg2][address(arg3)] > -2:
                    revert with 0, 17
                balanceOf[arg2][address(arg3)]++
                emit TransferSingle(arg2, 1, msg.sender, 0, address(arg3));
                if ext_code.size(address(arg3)):
                    require ext_code.size(address(arg3))
                    call address(arg3).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                         gas gas_remaining wei
                        args msg.sender, 0, arg2, 1, 160, 0
                    if not ext_call.success:
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    require return_data.size >= 32
                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                    if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                        revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
            else:
                mem[ceil32(calldata.size) + 160] = calldata.size
                mem[ceil32(calldata.size) + 192 len calldata.size] = call.data[0 len calldata.size]
                mem[(2 * ceil32(calldata.size)) + 224] = arg2
                mem[(2 * ceil32(calldata.size)) + 256] = 1
                mem[(2 * ceil32(calldata.size)) + 288] = 1
                if balanceOf[arg2][address(arg3)] > -2:
                    revert with 0, 17
                balanceOf[arg2][address(arg3)]++
                mem[(2 * ceil32(calldata.size)) + 320] = arg2
                mem[(2 * ceil32(calldata.size)) + 352] = 1
                emit TransferSingle(arg2, 1, mem[calldata.size + ceil32(calldata.size) + 172 len 20], 0, address(arg3));
                if ext_code.size(address(arg3)):
                    mem[(2 * ceil32(calldata.size)) + 320] = 0xf23a6e6100000000000000000000000000000000000000000000000000000000
                    mem[(2 * ceil32(calldata.size)) + 324] = mem[calldata.size + ceil32(calldata.size) + 172 len 20]
                    mem[(2 * ceil32(calldata.size)) + 356] = 0
                    mem[(2 * ceil32(calldata.size)) + 388] = arg2
                    mem[(2 * ceil32(calldata.size)) + 420] = 1
                    mem[(2 * ceil32(calldata.size)) + 452] = 160
                    mem[(2 * ceil32(calldata.size)) + 484] = 0
                    mem[(2 * ceil32(calldata.size)) + 516 len 0] = None
                    require ext_code.size(address(arg3))
                    call address(arg3).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                         gas gas_remaining wei
                        args mem[calldata.size + ceil32(calldata.size) + 172 len 20], 0, arg2, 1, 160, 0
                    if not ext_call.success:
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    require return_data.size >= 32
                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                    if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                        revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
    else:
        mem[96] = calldata.size
        mem[128 len calldata.size] = call.data[0 len calldata.size]
        if not uint8(roleAdmin[0][address(mem[calldata.size + 96])].field_0):
            mem[ceil32(calldata.size) + 160 len 42] = call.data[calldata.size len 42]
            idx = 41
            s = mem[calldata.size + 108 len 20]
            while idx > 1:
                if s % 16 >= 16:
                    revert with 0, 50
                if idx >= 42:
                    revert with 0, 50
                mem[idx + ceil32(calldata.size) + 160 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                if not idx:
                    revert with 0, 17
                idx = idx - 1
                s = Mask(252, 0, s) * 0.0625
                continue 
            if mem[calldata.size + 108 len 20] + 10240:
                revert with 0, 'Strings: hex length insufficient'
            mem[ceil32(calldata.size) + 256 len 66] = call.data[calldata.size len 66]
            idx = 65
            while idx > 1:
                if idx >= 66:
                    revert with 0, 50
                mem[idx + ceil32(calldata.size) + 256 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                if not idx:
                    revert with 0, 17
                idx = idx - 1
                continue 
            revert with 0, 
                        32,
                        148,
                        'AccessControl: account ', mem[ceil32(calldata.size) + 192 len 42], 8297, mem[ceil32(calldata.size) + 320 len 66], 0, 0 >> 928,
                        0
        if this.address == msg.sender:
            mem[ceil32(calldata.size) + 128] = calldata.size
            mem[ceil32(calldata.size) + 160 len calldata.size] = call.data[0 len calldata.size]
            _10 = mem[calldata.size + ceil32(calldata.size) + 128]
            if not uint8(roleAdmin[0][address(mem[calldata.size + ceil32(calldata.size) + 128])].field_0):
                mem[(2 * ceil32(calldata.size)) + 192 len 42] = call.data[calldata.size len 42]
                idx = 41
                s = mem[calldata.size + ceil32(calldata.size) + 140 len 20]
                while idx > 1:
                    if s % 16 >= 16:
                        revert with 0, 50
                    if idx >= 42:
                        revert with 0, 50
                    mem[idx + (2 * ceil32(calldata.size)) + 192 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                    if not idx:
                        revert with 0, 17
                    idx = idx - 1
                    s = Mask(252, 0, s) * 0.0625
                    continue 
                if address(_10) + 10240:
                    revert with 0, 'Strings: hex length insufficient'
                mem[(2 * ceil32(calldata.size)) + 288 len 66] = call.data[calldata.size len 66]
                idx = 65
                while idx > 1:
                    if idx >= 66:
                        revert with 0, 50
                    mem[idx + (2 * ceil32(calldata.size)) + 288 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                    if not idx:
                        revert with 0, 17
                    idx = idx - 1
                    continue 
                revert with 0, 
                            32,
                            148,
                            'AccessControl: account ', mem[(2 * ceil32(calldata.size)) + 224 len 42], 8297, mem[(2 * ceil32(calldata.size)) + 352 len 66], 0, 0 >> 928,
                            0
            require arg2 > 0
            if sub_79920951[arg1] > -2:
                revert with 0, 17
            if sub_79920951[arg1] + 1 > sub_fc86b662[arg1]:
                revert with 0, 'Minting would exceed the max number of items for given type'
            if stor13[arg2]:
                revert with 0, 'Supplied id is already used'
            if stor12[arg1]:
                revert with 0, 'Given type is fungible'
            stor13[arg2] = 1
            if sub_79920951[arg1] > -2:
                revert with 0, 17
            sub_79920951[arg1]++
            sub_0f699e80[arg2] = arg1
            mintNumber[arg2] = sub_79920951[arg1]
            if not address(arg3):
                revert with 0, 'ERC1155: mint to the zero address'
            if msg.sender != this.address:
                if balanceOf[arg2][address(arg3)] > -2:
                    revert with 0, 17
                balanceOf[arg2][address(arg3)]++
                emit TransferSingle(arg2, 1, msg.sender, 0, address(arg3));
                if ext_code.size(address(arg3)):
                    require ext_code.size(address(arg3))
                    call address(arg3).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                         gas gas_remaining wei
                        args msg.sender, 0, arg2, 1, 160, 0
                    if not ext_call.success:
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    require return_data.size >= 32
                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                    if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                        revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
            else:
                mem[(2 * ceil32(calldata.size)) + 192] = calldata.size
                mem[(2 * ceil32(calldata.size)) + 224 len calldata.size] = call.data[0 len calldata.size]
                if balanceOf[arg2][address(arg3)] > -2:
                    revert with 0, 17
                balanceOf[arg2][address(arg3)]++
                mem[(4 * ceil32(calldata.size)) + 384] = 1
                emit TransferSingle(arg2, 1, mem[calldata.size + (2 * ceil32(calldata.size)) + 204 len 20], 0, address(arg3));
                if ext_code.size(address(arg3)):
                    mem[(4 * ceil32(calldata.size)) + 388] = 0
                    mem[(4 * ceil32(calldata.size)) + 420] = arg2
                    mem[(4 * ceil32(calldata.size)) + 452] = 1
                    mem[(4 * ceil32(calldata.size)) + 484] = 160
                    mem[(4 * ceil32(calldata.size)) + 516] = 0
                    mem[(4 * ceil32(calldata.size)) + 548 len 0] = None
                    require ext_code.size(address(arg3))
                    call address(arg3).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                         gas gas_remaining wei
                        args mem[calldata.size + (2 * ceil32(calldata.size)) + 204 len 20], 0, arg2, 1, 160, 0
                    if not ext_call.success:
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    require return_data.size >= 32
                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                    if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                        revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
        else:
            if not uint8(roleAdmin[0][address(msg.sender)].field_0):
                mem[ceil32(calldata.size) + 160 len 42] = call.data[calldata.size len 42]
                idx = 41
                s = address(msg.sender)
                while idx > 1:
                    if s % 16 >= 16:
                        revert with 0, 50
                    if idx >= 42:
                        revert with 0, 50
                    mem[idx + ceil32(calldata.size) + 160 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                    if not idx:
                        revert with 0, 17
                    idx = idx - 1
                    s = Mask(252, 0, s) * 0.0625
                    continue 
                if msg.sender + 10240:
                    revert with 0, 'Strings: hex length insufficient'
                mem[ceil32(calldata.size) + 256 len 66] = call.data[calldata.size len 66]
                idx = 65
                while idx > 1:
                    if idx >= 66:
                        revert with 0, 50
                    mem[idx + ceil32(calldata.size) + 256 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                    if not idx:
                        revert with 0, 17
                    idx = idx - 1
                    continue 
                revert with 0, 
                            32,
                            148,
                            'AccessControl: account ', mem[ceil32(calldata.size) + 192 len 42], 8297, mem[ceil32(calldata.size) + 320 len 66], 0, 0 >> 928,
                            0
            require arg2 > 0
            if sub_79920951[arg1] > -2:
                revert with 0, 17
            if sub_79920951[arg1] + 1 > sub_fc86b662[arg1]:
                revert with 0, 'Minting would exceed the max number of items for given type'
            if stor13[arg2]:
                revert with 0, 'Supplied id is already used'
            if stor12[arg1]:
                revert with 0, 'Given type is fungible'
            stor13[arg2] = 1
            if sub_79920951[arg1] > -2:
                revert with 0, 17
            sub_79920951[arg1]++
            sub_0f699e80[arg2] = arg1
            mintNumber[arg2] = sub_79920951[arg1]
            if not address(arg3):
                revert with 0, 'ERC1155: mint to the zero address'
            if msg.sender != this.address:
                if balanceOf[arg2][address(arg3)] > -2:
                    revert with 0, 17
                balanceOf[arg2][address(arg3)]++
                emit TransferSingle(arg2, 1, msg.sender, 0, address(arg3));
                if ext_code.size(address(arg3)):
                    require ext_code.size(address(arg3))
                    call address(arg3).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                         gas gas_remaining wei
                        args msg.sender, 0, arg2, 1, 160, 0
                    if not ext_call.success:
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    require return_data.size >= 32
                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                    if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                        revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
            else:
                mem[ceil32(calldata.size) + 160] = calldata.size
                mem[ceil32(calldata.size) + 192 len calldata.size] = call.data[0 len calldata.size]
                mem[(2 * ceil32(calldata.size)) + 224] = arg2
                mem[(2 * ceil32(calldata.size)) + 256] = 1
                mem[(2 * ceil32(calldata.size)) + 288] = 1
                if balanceOf[arg2][address(arg3)] > -2:
                    revert with 0, 17
                balanceOf[arg2][address(arg3)]++
                mem[(2 * ceil32(calldata.size)) + 320] = arg2
                mem[(2 * ceil32(calldata.size)) + 352] = 1
                emit TransferSingle(arg2, 1, mem[calldata.size + ceil32(calldata.size) + 172 len 20], 0, address(arg3));
                if ext_code.size(address(arg3)):
                    mem[(2 * ceil32(calldata.size)) + 320] = 0xf23a6e6100000000000000000000000000000000000000000000000000000000
                    mem[(2 * ceil32(calldata.size)) + 324] = mem[calldata.size + ceil32(calldata.size) + 172 len 20]
                    mem[(2 * ceil32(calldata.size)) + 356] = 0
                    mem[(2 * ceil32(calldata.size)) + 388] = arg2
                    mem[(2 * ceil32(calldata.size)) + 420] = 1
                    mem[(2 * ceil32(calldata.size)) + 452] = 160
                    mem[(2 * ceil32(calldata.size)) + 484] = 0
                    mem[(2 * ceil32(calldata.size)) + 516 len 0] = None
                    require ext_code.size(address(arg3))
                    call address(arg3).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                         gas gas_remaining wei
                        args mem[calldata.size + ceil32(calldata.size) + 172 len 20], 0, arg2, 1, 160, 0
                    if not ext_call.success:
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    require return_data.size >= 32
                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                    if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                        revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
    emit 0xaa31d15d: arg1, arg2, address(arg3)
}

function safeTransferFrom(address arg1, address arg2, uint256 arg3, uint256 arg4, bytes arg5) {
    require calldata.size - 4 >= 160
    require arg1 == arg1
    require arg2 == arg2
    require arg5 <= test266151307()
    require arg5 + 35 < calldata.size
    if arg5.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg5.length)) + 97 < 96 or ceil32(ceil32(arg5.length)) + 97 > test266151307():
        revert with 0, 65
    require arg5 + arg5.length + 36 <= calldata.size
    mem[128 len arg5.length] = arg5[all]
    mem[arg5.length + 128] = 0
    if not arg2:
        revert with 0, 'ERC1155: transfer to the zero address'
    if msg.sender != this.address:
        if arg1 == msg.sender:
            if msg.sender != this.address:
                if balanceOf[arg3][address(arg1)] < arg4:
                    revert with 0, 'ERC1155: insufficient balance for transfer'
                balanceOf[arg3][address(arg1)] -= arg4
                if balanceOf[arg3][arg2] > !arg4:
                    revert with 0, 17
                balanceOf[arg3][arg2] += arg4
                emit TransferSingle(arg3, arg4, msg.sender, arg1, arg2);
                if ext_code.size(arg2):
                    require ext_code.size(arg2)
                    call arg2.onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                         gas gas_remaining wei
                        args msg.sender, address(arg1), arg3, arg4, Array(len=arg5.length, data=arg5[all])
                    if not ext_call.success:
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    require return_data.size >= 32
                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                    if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                        revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
            else:
                mem[ceil32(ceil32(arg5.length)) + 97] = calldata.size
                mem[ceil32(ceil32(arg5.length)) + 129 len calldata.size] = call.data[0 len calldata.size]
                if balanceOf[arg3][address(arg1)] < arg4:
                    revert with 0, 'ERC1155: insufficient balance for transfer'
                balanceOf[arg3][address(arg1)] -= arg4
                if balanceOf[arg3][arg2] > !arg4:
                    revert with 0, 17
                balanceOf[arg3][arg2] += arg4
                emit TransferSingle(arg3, arg4, mem[calldata.size + ceil32(ceil32(arg5.length)) + 109 len 20], arg1, arg2);
                if ext_code.size(arg2):
                    require ext_code.size(arg2)
                    call arg2.onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                         gas gas_remaining wei
                        args mem[calldata.size + ceil32(ceil32(arg5.length)) + 109 len 20], address(arg1), arg3, arg4, Array(len=arg5.length, data=arg5[all])
                    if not ext_call.success:
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    require return_data.size >= 32
                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                    if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                        revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
        else:
            if msg.sender != this.address:
                if not stor1[address(arg1)][address(msg.sender)]:
                    if bool(stor6[address(msg.sender)]) != 1:
                        revert with 0, 'ERC1155: caller is not owner nor approved'
                if msg.sender != this.address:
                    if balanceOf[arg3][address(arg1)] < arg4:
                        revert with 0, 'ERC1155: insufficient balance for transfer'
                    balanceOf[arg3][address(arg1)] -= arg4
                    if balanceOf[arg3][arg2] > !arg4:
                        revert with 0, 17
                    balanceOf[arg3][arg2] += arg4
                    emit TransferSingle(arg3, arg4, msg.sender, arg1, arg2);
                    if ext_code.size(arg2):
                        require ext_code.size(arg2)
                        call arg2.onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                             gas gas_remaining wei
                            args msg.sender, address(arg1), arg3, arg4, Array(len=arg5.length, data=arg5[all])
                        if not ext_call.success:
                            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                        require return_data.size >= 32
                        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                        if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                            revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                else:
                    mem[ceil32(ceil32(arg5.length)) + 97] = calldata.size
                    mem[ceil32(ceil32(arg5.length)) + 129 len calldata.size] = call.data[0 len calldata.size]
                    if balanceOf[arg3][address(arg1)] < arg4:
                        revert with 0, 'ERC1155: insufficient balance for transfer'
                    balanceOf[arg3][address(arg1)] -= arg4
                    if balanceOf[arg3][arg2] > !arg4:
                        revert with 0, 17
                    balanceOf[arg3][arg2] += arg4
                    emit TransferSingle(arg3, arg4, mem[calldata.size + ceil32(ceil32(arg5.length)) + 109 len 20], arg1, arg2);
                    if ext_code.size(arg2):
                        require ext_code.size(arg2)
                        call arg2.onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                             gas gas_remaining wei
                            args mem[calldata.size + ceil32(ceil32(arg5.length)) + 109 len 20], address(arg1), arg3, arg4, Array(len=arg5.length, data=arg5[all])
                        if not ext_call.success:
                            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                        require return_data.size >= 32
                        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                        if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                            revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
            else:
                mem[ceil32(ceil32(arg5.length)) + 97] = calldata.size
                mem[ceil32(ceil32(arg5.length)) + 129 len calldata.size] = call.data[0 len calldata.size]
                if not stor1[address(arg1)][address(mem[calldata.size + ceil32(ceil32(arg5.length)) + 97])]:
                    if bool(stor6[address(mem[calldata.size + ceil32(ceil32(arg5.length)) + 97])]) != 1:
                        revert with 0, 'ERC1155: caller is not owner nor approved'
                if msg.sender != this.address:
                    if balanceOf[arg3][address(arg1)] < arg4:
                        revert with 0, 'ERC1155: insufficient balance for transfer'
                    balanceOf[arg3][address(arg1)] -= arg4
                    if balanceOf[arg3][arg2] > !arg4:
                        revert with 0, 17
                    balanceOf[arg3][arg2] += arg4
                    emit TransferSingle(arg3, arg4, msg.sender, arg1, arg2);
                    if ext_code.size(arg2):
                        require ext_code.size(arg2)
                        call arg2.onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                             gas gas_remaining wei
                            args msg.sender, address(arg1), arg3, arg4, Array(len=arg5.length, data=arg5[all])
                        if not ext_call.success:
                            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                        require return_data.size >= 32
                        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                        if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                            revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                else:
                    mem[ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 129] = calldata.size
                    mem[ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 161 len calldata.size] = call.data[0 len calldata.size]
                    mem[ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 193] = arg3
                    mem[ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 225] = 1
                    mem[ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 257] = arg4
                    if balanceOf[arg3][address(arg1)] < arg4:
                        revert with 0, 'ERC1155: insufficient balance for transfer'
                    balanceOf[arg3][address(arg1)] -= arg4
                    if balanceOf[arg3][arg2] > !arg4:
                        revert with 0, 17
                    balanceOf[arg3][arg2] += arg4
                    mem[ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 289] = arg3
                    mem[ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 321] = arg4
                    emit TransferSingle(arg3, arg4, mem[calldata.size + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 141 len 20], arg1, arg2);
                    if ext_code.size(arg2):
                        mem[ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 289] = 0xf23a6e6100000000000000000000000000000000000000000000000000000000
                        mem[ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 293] = mem[calldata.size + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 141 len 20]
                        mem[ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 325] = arg1
                        mem[ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 357] = arg3
                        mem[ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 389] = arg4
                        mem[ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 421] = 160
                        mem[ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 453] = arg5.length
                        mem[ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 485 len ceil32(arg5.length)] = arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256
                        if ceil32(arg5.length) > arg5.length:
                            mem[arg5.length + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 485] = 0
                        require ext_code.size(arg2)
                        call arg2.onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                             gas gas_remaining wei
                            args mem[calldata.size + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 141 len 20], address(arg1), arg3, arg4, Array(len=arg5.length, data=arg5[all])
                        if not ext_call.success:
                            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                        require return_data.size >= 32
                        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                        if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                            revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
    else:
        mem[ceil32(ceil32(arg5.length)) + 97] = calldata.size
        mem[ceil32(ceil32(arg5.length)) + 129 len calldata.size] = call.data[0 len calldata.size]
        if arg1 == mem[calldata.size + ceil32(ceil32(arg5.length)) + 109 len 20]:
            if msg.sender != this.address:
                if balanceOf[arg3][address(arg1)] < arg4:
                    revert with 0, 'ERC1155: insufficient balance for transfer'
                balanceOf[arg3][address(arg1)] -= arg4
                if balanceOf[arg3][arg2] > !arg4:
                    revert with 0, 17
                balanceOf[arg3][arg2] += arg4
                emit TransferSingle(arg3, arg4, msg.sender, arg1, arg2);
                if ext_code.size(arg2):
                    require ext_code.size(arg2)
                    call arg2.onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                         gas gas_remaining wei
                        args msg.sender, address(arg1), arg3, arg4, Array(len=arg5.length, data=arg5[all])
                    if not ext_call.success:
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    require return_data.size >= 32
                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                    if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                        revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
            else:
                mem[ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 129] = calldata.size
                mem[ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 161 len calldata.size] = call.data[0 len calldata.size]
                mem[ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 193] = arg3
                mem[ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 225] = 1
                mem[ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 257] = arg4
                if balanceOf[arg3][address(arg1)] < arg4:
                    revert with 0, 'ERC1155: insufficient balance for transfer'
                balanceOf[arg3][address(arg1)] -= arg4
                if balanceOf[arg3][arg2] > !arg4:
                    revert with 0, 17
                balanceOf[arg3][arg2] += arg4
                mem[ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 289] = arg3
                mem[ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 321] = arg4
                emit TransferSingle(arg3, arg4, mem[calldata.size + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 141 len 20], arg1, arg2);
                if ext_code.size(arg2):
                    mem[ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 289] = 0xf23a6e6100000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 293] = mem[calldata.size + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 141 len 20]
                    mem[ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 325] = arg1
                    mem[ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 357] = arg3
                    mem[ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 389] = arg4
                    mem[ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 421] = 160
                    mem[ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 453] = arg5.length
                    mem[ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 485 len ceil32(arg5.length)] = arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256
                    if ceil32(arg5.length) > arg5.length:
                        mem[arg5.length + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 485] = 0
                    require ext_code.size(arg2)
                    call arg2.onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                         gas gas_remaining wei
                        args mem[calldata.size + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 141 len 20], address(arg1), arg3, arg4, Array(len=arg5.length, data=arg5[all])
                    if not ext_call.success:
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    require return_data.size >= 32
                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                    if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                        revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
        else:
            if this.address == msg.sender:
                mem[ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 129] = calldata.size
                mem[ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 161 len calldata.size] = call.data[0 len calldata.size]
                if not stor1[address(arg1)][address(mem[calldata.size + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 129])]:
                    if bool(stor6[address(mem[calldata.size + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 129])]) != 1:
                        revert with 0, 'ERC1155: caller is not owner nor approved'
                if msg.sender != this.address:
                    if balanceOf[arg3][address(arg1)] < arg4:
                        revert with 0, 'ERC1155: insufficient balance for transfer'
                    balanceOf[arg3][address(arg1)] -= arg4
                    if balanceOf[arg3][arg2] > !arg4:
                        revert with 0, 17
                    balanceOf[arg3][arg2] += arg4
                    emit TransferSingle(arg3, arg4, msg.sender, arg1, arg2);
                    if ext_code.size(arg2):
                        require ext_code.size(arg2)
                        call arg2.onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                             gas gas_remaining wei
                            args msg.sender, address(arg1), arg3, arg4, Array(len=arg5.length, data=arg5[all])
                        if not ext_call.success:
                            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                        require return_data.size >= 32
                        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                        if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                            revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                else:
                    mem[ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 161] = calldata.size
                    mem[ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 193 len calldata.size] = call.data[0 len calldata.size]
                    if balanceOf[arg3][address(arg1)] < arg4:
                        revert with 0, 'ERC1155: insufficient balance for transfer'
                    balanceOf[arg3][address(arg1)] -= arg4
                    if balanceOf[arg3][arg2] > !arg4:
                        revert with 0, 17
                    balanceOf[arg3][arg2] += arg4
                    mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + 353] = arg4
                    emit TransferSingle(arg3, arg4, mem[calldata.size + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 173 len 20], arg1, arg2);
                    if ext_code.size(arg2):
                        mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + 357] = arg1
                        mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + 389] = arg3
                        mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + 421] = arg4
                        mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + 453] = 160
                        mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + 485] = arg5.length
                        mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + 517 len ceil32(arg5.length)] = arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256
                        if ceil32(arg5.length) > arg5.length:
                            mem[arg5.length + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + 517] = 0
                        require ext_code.size(arg2)
                        call arg2.onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                             gas gas_remaining wei
                            args mem[calldata.size + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 173 len 20], address(arg1), arg3, arg4, Array(len=arg5.length, data=arg5[all])
                        if not ext_call.success:
                            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                        require return_data.size >= 32
                        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                        if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                            revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
            else:
                if not stor1[address(arg1)][address(msg.sender)]:
                    if bool(stor6[address(msg.sender)]) != 1:
                        revert with 0, 'ERC1155: caller is not owner nor approved'
                if msg.sender != this.address:
                    if balanceOf[arg3][address(arg1)] < arg4:
                        revert with 0, 'ERC1155: insufficient balance for transfer'
                    balanceOf[arg3][address(arg1)] -= arg4
                    if balanceOf[arg3][arg2] > !arg4:
                        revert with 0, 17
                    balanceOf[arg3][arg2] += arg4
                    emit TransferSingle(arg3, arg4, msg.sender, arg1, arg2);
                    if ext_code.size(arg2):
                        require ext_code.size(arg2)
                        call arg2.onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                             gas gas_remaining wei
                            args msg.sender, address(arg1), arg3, arg4, Array(len=arg5.length, data=arg5[all])
                        if not ext_call.success:
                            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                        require return_data.size >= 32
                        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                        if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                            revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                else:
                    mem[ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 129] = calldata.size
                    mem[ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 161 len calldata.size] = call.data[0 len calldata.size]
                    mem[ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 193] = arg3
                    mem[ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 225] = 1
                    mem[ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 257] = arg4
                    if balanceOf[arg3][address(arg1)] < arg4:
                        revert with 0, 'ERC1155: insufficient balance for transfer'
                    balanceOf[arg3][address(arg1)] -= arg4
                    if balanceOf[arg3][arg2] > !arg4:
                        revert with 0, 17
                    balanceOf[arg3][arg2] += arg4
                    mem[ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 289] = arg3
                    mem[ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 321] = arg4
                    emit TransferSingle(arg3, arg4, mem[calldata.size + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 141 len 20], arg1, arg2);
                    if ext_code.size(arg2):
                        mem[ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 289] = 0xf23a6e6100000000000000000000000000000000000000000000000000000000
                        mem[ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 293] = mem[calldata.size + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 141 len 20]
                        mem[ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 325] = arg1
                        mem[ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 357] = arg3
                        mem[ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 389] = arg4
                        mem[ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 421] = 160
                        mem[ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 453] = arg5.length
                        mem[ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 485 len ceil32(arg5.length)] = arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256
                        if ceil32(arg5.length) > arg5.length:
                            mem[arg5.length + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 485] = 0
                        require ext_code.size(arg2)
                        call arg2.onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                             gas gas_remaining wei
                            args mem[calldata.size + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 141 len 20], address(arg1), arg3, arg4, Array(len=arg5.length, data=arg5[all])
                        if not ext_call.success:
                            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                        require return_data.size >= 32
                        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                        if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                            revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
}

function sub_93f7d6c7(?) {
    require calldata.size - 4 >= 96
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    if ('cd', 4).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 4).length) + 97 < 96 or ceil32(32 * ('cd', 4).length) + 97 > test266151307():
        revert with 0, 65
    mem[96] = ('cd', 4).length
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    idx = cd[4] + 36
    s = 128
    while idx < cd[4] + (32 * ('cd', 4).length) + 36:
        mem[s] = cd[idx]
        idx = idx + 32
        s = s + 32
        continue 
    require cd[36] == address(cd[36])
    require cd[68] <= test266151307()
    require cd[68] + 35 < calldata.size
    if ('cd', 68).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 68).length) + 98 < 97 or ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + 98 > test266151307():
        revert with 0, 65
    mem[ceil32(32 * ('cd', 4).length) + 97] = ('cd', 68).length
    require cd[68] + (32 * ('cd', 68).length) + 36 <= calldata.size
    idx = cd[68] + 36
    s = ceil32(32 * ('cd', 4).length) + 129
    while idx < cd[68] + (32 * ('cd', 68).length) + 36:
        mem[s] = cd[idx]
        idx = idx + 32
        s = s + 32
        continue 
    if msg.sender != this.address:
        if address(cd[36]) == msg.sender:
            idx = 0
            while idx < ('cd', 4).length:
                if idx >= ('cd', 4).length:
                    revert with 0, 50
                mem[0] = sub_0f699e80[mem[(32 * idx) + 128]]
                mem[32] = 11
                if bool(stor11[stor10[mem[(32 * idx) + 128]]]) != 1:
                    revert with 0, 'Type of token must be burnable'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if not address(cd[36]):
                revert with 0, 'ERC1155: burn from the zero address'
            if ('cd', 4).length != ('cd', 68).length:
                revert with 0, 'ERC1155: ids and amounts length mismatch'
            if msg.sender != this.address:
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + 98] = 0
                idx = 0
                while idx < ('cd', 4).length:
                    if idx >= ('cd', 4).length:
                        revert with 0, 50
                    if idx >= ('cd', 68).length:
                        revert with 0, 50
                    if balanceOf[mem[(32 * idx) + 128]][address(cd[36])] < mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]:
                        revert with 0, 'ERC1155: burn amount exceeds balance'
                    mem[0] = address(cd[36])
                    mem[32] = sha3(mem[(32 * idx) + 128], 0)
                    balanceOf[mem[(32 * idx) + 128]][address(cd[36])] -= mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                emit TransferBatch(Array(len=('cd', 4).length, data=mem[128 len 32 * ('cd', 4).length], ('cd', 68).length, mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * ('cd', 68).length]), (32 * ('cd', 4).length) + 96, msg.sender, address(cd[36]), 0);
            else:
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + 98] = calldata.size
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + 130 len calldata.size] = call.data[0 len calldata.size]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + calldata.size + 130] = 0
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + ceil32(calldata.size) + 130] = 0
                idx = 0
                while idx < ('cd', 4).length:
                    if idx >= ('cd', 4).length:
                        revert with 0, 50
                    if idx >= ('cd', 68).length:
                        revert with 0, 50
                    if balanceOf[mem[(32 * idx) + 128]][address(cd[36])] < mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]:
                        revert with 0, 'ERC1155: burn amount exceeds balance'
                    mem[0] = address(cd[36])
                    mem[32] = sha3(mem[(32 * idx) + 128], 0)
                    balanceOf[mem[(32 * idx) + 128]][address(cd[36])] -= mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                emit TransferBatch(Array(len=('cd', 4).length, data=mem[128 len 32 * ('cd', 4).length], ('cd', 68).length, mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * ('cd', 68).length]), (32 * ('cd', 4).length) + 96, mem[calldata.size + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + 110 len 20], address(cd[36]), 0);
        else:
            if msg.sender != this.address:
                if stor1[address(cd[36])][address(msg.sender)]:
                    idx = 0
                    while idx < ('cd', 4).length:
                        if idx >= ('cd', 4).length:
                            revert with 0, 50
                        mem[0] = sub_0f699e80[mem[(32 * idx) + 128]]
                        mem[32] = 11
                        if bool(stor11[stor10[mem[(32 * idx) + 128]]]) != 1:
                            revert with 0, 'Type of token must be burnable'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    if not address(cd[36]):
                        revert with 0, 'ERC1155: burn from the zero address'
                    if ('cd', 4).length != ('cd', 68).length:
                        revert with 0, 'ERC1155: ids and amounts length mismatch'
                    if msg.sender != this.address:
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + 98] = 0
                        idx = 0
                        while idx < ('cd', 4).length:
                            if idx >= ('cd', 4).length:
                                revert with 0, 50
                            if idx >= ('cd', 68).length:
                                revert with 0, 50
                            if balanceOf[mem[(32 * idx) + 128]][address(cd[36])] < mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]:
                                revert with 0, 'ERC1155: burn amount exceeds balance'
                            mem[0] = address(cd[36])
                            mem[32] = sha3(mem[(32 * idx) + 128], 0)
                            balanceOf[mem[(32 * idx) + 128]][address(cd[36])] -= mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        var79001 = ('cd', 68).length
                        emit TransferBatch(Array(len=('cd', 4).length, data=mem[128 len 32 * ('cd', 4).length], ('cd', 68).length, mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * ('cd', 68).length]), (32 * ('cd', 4).length) + 96, msg.sender, address(cd[36]), 0);
                    else:
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + 98] = calldata.size
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + 130 len calldata.size] = call.data[0 len calldata.size]
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + calldata.size + 130] = 0
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + ceil32(calldata.size) + 130] = 0
                        idx = 0
                        while idx < ('cd', 4).length:
                            if idx >= ('cd', 4).length:
                                revert with 0, 50
                            if idx >= ('cd', 68).length:
                                revert with 0, 50
                            if balanceOf[mem[(32 * idx) + 128]][address(cd[36])] < mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]:
                                revert with 0, 'ERC1155: burn amount exceeds balance'
                            mem[0] = address(cd[36])
                            mem[32] = sha3(mem[(32 * idx) + 128], 0)
                            balanceOf[mem[(32 * idx) + 128]][address(cd[36])] -= mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        var79001 = ('cd', 68).length
                        emit TransferBatch(Array(len=('cd', 4).length, data=mem[128 len 32 * ('cd', 4).length], ('cd', 68).length, mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * ('cd', 68).length]), (32 * ('cd', 4).length) + 96, mem[calldata.size + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + 110 len 20], address(cd[36]), 0);
                else:
                    if bool(stor6[address(msg.sender)]) != 1:
                        revert with 0, 'Caller is not owner nor approved'
                    idx = 0
                    while idx < ('cd', 4).length:
                        if idx >= ('cd', 4).length:
                            revert with 0, 50
                        mem[0] = sub_0f699e80[mem[(32 * idx) + 128]]
                        mem[32] = 11
                        if bool(stor11[stor10[mem[(32 * idx) + 128]]]) != 1:
                            revert with 0, 'Type of token must be burnable'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    if not address(cd[36]):
                        revert with 0, 'ERC1155: burn from the zero address'
                    if ('cd', 4).length != ('cd', 68).length:
                        revert with 0, 'ERC1155: ids and amounts length mismatch'
                    if msg.sender != this.address:
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + 98] = 0
                        idx = 0
                        while idx < ('cd', 4).length:
                            if idx >= ('cd', 4).length:
                                revert with 0, 50
                            if idx >= ('cd', 68).length:
                                revert with 0, 50
                            if balanceOf[mem[(32 * idx) + 128]][address(cd[36])] < mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]:
                                revert with 0, 'ERC1155: burn amount exceeds balance'
                            mem[0] = address(cd[36])
                            mem[32] = sha3(mem[(32 * idx) + 128], 0)
                            balanceOf[mem[(32 * idx) + 128]][address(cd[36])] -= mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        emit TransferBatch(Array(len=('cd', 4).length, data=mem[128 len 32 * ('cd', 4).length], ('cd', 68).length, mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * ('cd', 68).length]), (32 * ('cd', 4).length) + 96, msg.sender, address(cd[36]), 0);
                    else:
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + 98] = calldata.size
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + 130 len calldata.size] = call.data[0 len calldata.size]
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + calldata.size + 130] = 0
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + ceil32(calldata.size) + 130] = 0
                        idx = 0
                        while idx < ('cd', 4).length:
                            if idx >= ('cd', 4).length:
                                revert with 0, 50
                            if idx >= ('cd', 68).length:
                                revert with 0, 50
                            if balanceOf[mem[(32 * idx) + 128]][address(cd[36])] < mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]:
                                revert with 0, 'ERC1155: burn amount exceeds balance'
                            mem[0] = address(cd[36])
                            mem[32] = sha3(mem[(32 * idx) + 128], 0)
                            balanceOf[mem[(32 * idx) + 128]][address(cd[36])] -= mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        emit TransferBatch(Array(len=('cd', 4).length, data=mem[128 len 32 * ('cd', 4).length], ('cd', 68).length, mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * ('cd', 68).length]), (32 * ('cd', 4).length) + 96, mem[calldata.size + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + 110 len 20], address(cd[36]), 0);
            else:
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + 98] = calldata.size
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + 130 len calldata.size] = call.data[0 len calldata.size]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + calldata.size + 130] = 0
                if stor1[address(cd[36])][address(mem[calldata.size + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + 98])]:
                    idx = 0
                    while idx < ('cd', 4).length:
                        if idx >= ('cd', 4).length:
                            revert with 0, 50
                        mem[0] = sub_0f699e80[mem[(32 * idx) + 128]]
                        mem[32] = 11
                        if bool(stor11[stor10[mem[(32 * idx) + 128]]]) != 1:
                            revert with 0, 'Type of token must be burnable'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    if not address(cd[36]):
                        revert with 0, 'ERC1155: burn from the zero address'
                    if ('cd', 4).length != ('cd', 68).length:
                        revert with 0, 'ERC1155: ids and amounts length mismatch'
                    if msg.sender != this.address:
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + ceil32(calldata.size) + 130] = 0
                        idx = 0
                        while idx < ('cd', 4).length:
                            if idx >= ('cd', 4).length:
                                revert with 0, 50
                            if idx >= ('cd', 68).length:
                                revert with 0, 50
                            if balanceOf[mem[(32 * idx) + 128]][address(cd[36])] < mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]:
                                revert with 0, 'ERC1155: burn amount exceeds balance'
                            mem[0] = address(cd[36])
                            mem[32] = sha3(mem[(32 * idx) + 128], 0)
                            balanceOf[mem[(32 * idx) + 128]][address(cd[36])] -= mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        var79001 = ('cd', 68).length
                        emit TransferBatch(Array(len=('cd', 4).length, data=mem[128 len 32 * ('cd', 4).length], ('cd', 68).length, mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * ('cd', 68).length]), (32 * ('cd', 4).length) + 96, msg.sender, address(cd[36]), 0);
                    else:
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + ceil32(calldata.size) + 130] = calldata.size
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + ceil32(calldata.size) + 162 len calldata.size] = call.data[0 len calldata.size]
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + ceil32(calldata.size) + calldata.size + 162] = 0
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(calldata.size)) + 162] = 0
                        idx = 0
                        while idx < ('cd', 4).length:
                            if idx >= ('cd', 4).length:
                                revert with 0, 50
                            if idx >= ('cd', 68).length:
                                revert with 0, 50
                            if balanceOf[mem[(32 * idx) + 128]][address(cd[36])] < mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]:
                                revert with 0, 'ERC1155: burn amount exceeds balance'
                            mem[0] = address(cd[36])
                            mem[32] = sha3(mem[(32 * idx) + 128], 0)
                            balanceOf[mem[(32 * idx) + 128]][address(cd[36])] -= mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(calldata.size)) + 194] = 64
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(calldata.size)) + 258] = ('cd', 4).length
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(calldata.size)) + 290 len 32 * ('cd', 4).length] = mem[128 len 32 * ('cd', 4).length]
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(calldata.size)) + 226] = (32 * ('cd', 4).length) + 96
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(calldata.size)) + (32 * ('cd', 4).length) + 290] = ('cd', 68).length
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(calldata.size)) + (32 * ('cd', 4).length) + 322 len 32 * ('cd', 68).length] = mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * ('cd', 68).length]
                        var79001 = ('cd', 68).length
                        emit TransferBatch(Array(len=('cd', 4).length, data=mem[128 len 32 * ('cd', 4).length], ('cd', 68).length, mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * ('cd', 68).length]), (32 * ('cd', 4).length) + 96, mem[calldata.size + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + ceil32(calldata.size) + 142 len 20], address(cd[36]), 0);
                else:
                    if bool(stor6[address(mem[calldata.size + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + 98])]) != 1:
                        revert with 0, 'Caller is not owner nor approved'
                    idx = 0
                    while idx < ('cd', 4).length:
                        if idx >= ('cd', 4).length:
                            revert with 0, 50
                        mem[0] = sub_0f699e80[mem[(32 * idx) + 128]]
                        mem[32] = 11
                        if bool(stor11[stor10[mem[(32 * idx) + 128]]]) != 1:
                            revert with 0, 'Type of token must be burnable'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    if not address(cd[36]):
                        revert with 0, 'ERC1155: burn from the zero address'
                    if ('cd', 4).length != ('cd', 68).length:
                        revert with 0, 'ERC1155: ids and amounts length mismatch'
                    if msg.sender != this.address:
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + ceil32(calldata.size) + 130] = 0
                        idx = 0
                        while idx < ('cd', 4).length:
                            if idx >= ('cd', 4).length:
                                revert with 0, 50
                            if idx >= ('cd', 68).length:
                                revert with 0, 50
                            if balanceOf[mem[(32 * idx) + 128]][address(cd[36])] < mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]:
                                revert with 0, 'ERC1155: burn amount exceeds balance'
                            mem[0] = address(cd[36])
                            mem[32] = sha3(mem[(32 * idx) + 128], 0)
                            balanceOf[mem[(32 * idx) + 128]][address(cd[36])] -= mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        emit TransferBatch(Array(len=('cd', 4).length, data=mem[128 len 32 * ('cd', 4).length], ('cd', 68).length, mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * ('cd', 68).length]), (32 * ('cd', 4).length) + 96, msg.sender, address(cd[36]), 0);
                    else:
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + ceil32(calldata.size) + 130] = calldata.size
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + ceil32(calldata.size) + 162 len calldata.size] = call.data[0 len calldata.size]
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + ceil32(calldata.size) + calldata.size + 162] = 0
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(calldata.size)) + 162] = 0
                        idx = 0
                        while idx < ('cd', 4).length:
                            if idx >= ('cd', 4).length:
                                revert with 0, 50
                            if idx >= ('cd', 68).length:
                                revert with 0, 50
                            if balanceOf[mem[(32 * idx) + 128]][address(cd[36])] < mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]:
                                revert with 0, 'ERC1155: burn amount exceeds balance'
                            mem[0] = address(cd[36])
                            mem[32] = sha3(mem[(32 * idx) + 128], 0)
                            balanceOf[mem[(32 * idx) + 128]][address(cd[36])] -= mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(calldata.size)) + 194] = 64
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(calldata.size)) + 258] = ('cd', 4).length
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(calldata.size)) + 290 len 32 * ('cd', 4).length] = mem[128 len 32 * ('cd', 4).length]
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(calldata.size)) + 226] = (32 * ('cd', 4).length) + 96
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(calldata.size)) + (32 * ('cd', 4).length) + 290] = ('cd', 68).length
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(calldata.size)) + (32 * ('cd', 4).length) + 322 len 32 * ('cd', 68).length] = mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * ('cd', 68).length]
                        emit TransferBatch(Array(len=('cd', 4).length, data=mem[128 len 32 * ('cd', 4).length], ('cd', 68).length, mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * ('cd', 68).length]), (32 * ('cd', 4).length) + 96, mem[calldata.size + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + ceil32(calldata.size) + 142 len 20], address(cd[36]), 0);
    else:
        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + 98] = calldata.size
        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + 130 len calldata.size] = call.data[0 len calldata.size]
        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + calldata.size + 130] = 0
        if address(cd[36]) == mem[calldata.size + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + 110 len 20]:
            idx = 0
            while idx < ('cd', 4).length:
                if idx >= ('cd', 4).length:
                    revert with 0, 50
                mem[0] = sub_0f699e80[mem[(32 * idx) + 128]]
                mem[32] = 11
                if bool(stor11[stor10[mem[(32 * idx) + 128]]]) != 1:
                    revert with 0, 'Type of token must be burnable'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if not address(cd[36]):
                revert with 0, 'ERC1155: burn from the zero address'
            if ('cd', 4).length != ('cd', 68).length:
                revert with 0, 'ERC1155: ids and amounts length mismatch'
            if msg.sender != this.address:
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + ceil32(calldata.size) + 130] = 0
                idx = 0
                while idx < ('cd', 4).length:
                    if idx >= ('cd', 4).length:
                        revert with 0, 50
                    if idx >= ('cd', 68).length:
                        revert with 0, 50
                    if balanceOf[mem[(32 * idx) + 128]][address(cd[36])] < mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]:
                        revert with 0, 'ERC1155: burn amount exceeds balance'
                    mem[0] = address(cd[36])
                    mem[32] = sha3(mem[(32 * idx) + 128], 0)
                    balanceOf[mem[(32 * idx) + 128]][address(cd[36])] -= mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                emit TransferBatch(Array(len=('cd', 4).length, data=mem[128 len 32 * ('cd', 4).length], ('cd', 68).length, mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * ('cd', 68).length]), (32 * ('cd', 4).length) + 96, msg.sender, address(cd[36]), 0);
            else:
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + ceil32(calldata.size) + 130] = calldata.size
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + ceil32(calldata.size) + 162 len calldata.size] = call.data[0 len calldata.size]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + ceil32(calldata.size) + calldata.size + 162] = 0
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(calldata.size)) + 162] = 0
                idx = 0
                while idx < ('cd', 4).length:
                    if idx >= ('cd', 4).length:
                        revert with 0, 50
                    if idx >= ('cd', 68).length:
                        revert with 0, 50
                    if balanceOf[mem[(32 * idx) + 128]][address(cd[36])] < mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]:
                        revert with 0, 'ERC1155: burn amount exceeds balance'
                    mem[0] = address(cd[36])
                    mem[32] = sha3(mem[(32 * idx) + 128], 0)
                    balanceOf[mem[(32 * idx) + 128]][address(cd[36])] -= mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(calldata.size)) + 194] = 64
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(calldata.size)) + 258] = ('cd', 4).length
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(calldata.size)) + 290 len 32 * ('cd', 4).length] = mem[128 len 32 * ('cd', 4).length]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(calldata.size)) + 226] = (32 * ('cd', 4).length) + 96
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(calldata.size)) + (32 * ('cd', 4).length) + 290] = ('cd', 68).length
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(calldata.size)) + (32 * ('cd', 4).length) + 322 len 32 * ('cd', 68).length] = mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * ('cd', 68).length]
                emit TransferBatch(Array(len=('cd', 4).length, data=mem[128 len 32 * ('cd', 4).length], ('cd', 68).length, mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * ('cd', 68).length]), (32 * ('cd', 4).length) + 96, mem[calldata.size + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + ceil32(calldata.size) + 142 len 20], address(cd[36]), 0);
        else:
            if msg.sender != this.address:
                if stor1[address(cd[36])][address(msg.sender)]:
                    idx = 0
                    while idx < ('cd', 4).length:
                        if idx >= ('cd', 4).length:
                            revert with 0, 50
                        mem[0] = sub_0f699e80[mem[(32 * idx) + 128]]
                        mem[32] = 11
                        if bool(stor11[stor10[mem[(32 * idx) + 128]]]) != 1:
                            revert with 0, 'Type of token must be burnable'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    if not address(cd[36]):
                        revert with 0, 'ERC1155: burn from the zero address'
                    if ('cd', 4).length != ('cd', 68).length:
                        revert with 0, 'ERC1155: ids and amounts length mismatch'
                    if msg.sender != this.address:
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + ceil32(calldata.size) + 130] = 0
                        idx = 0
                        while idx < ('cd', 4).length:
                            if idx >= ('cd', 4).length:
                                revert with 0, 50
                            if idx >= ('cd', 68).length:
                                revert with 0, 50
                            if balanceOf[mem[(32 * idx) + 128]][address(cd[36])] < mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]:
                                revert with 0, 'ERC1155: burn amount exceeds balance'
                            mem[0] = address(cd[36])
                            mem[32] = sha3(mem[(32 * idx) + 128], 0)
                            balanceOf[mem[(32 * idx) + 128]][address(cd[36])] -= mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        var79001 = ('cd', 68).length
                        emit TransferBatch(Array(len=('cd', 4).length, data=mem[128 len 32 * ('cd', 4).length], ('cd', 68).length, mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * ('cd', 68).length]), (32 * ('cd', 4).length) + 96, msg.sender, address(cd[36]), 0);
                    else:
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + ceil32(calldata.size) + 130] = calldata.size
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + ceil32(calldata.size) + 162 len calldata.size] = call.data[0 len calldata.size]
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + ceil32(calldata.size) + calldata.size + 162] = 0
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(calldata.size)) + 162] = 0
                        idx = 0
                        while idx < ('cd', 4).length:
                            if idx >= ('cd', 4).length:
                                revert with 0, 50
                            if idx >= ('cd', 68).length:
                                revert with 0, 50
                            if balanceOf[mem[(32 * idx) + 128]][address(cd[36])] < mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]:
                                revert with 0, 'ERC1155: burn amount exceeds balance'
                            mem[0] = address(cd[36])
                            mem[32] = sha3(mem[(32 * idx) + 128], 0)
                            balanceOf[mem[(32 * idx) + 128]][address(cd[36])] -= mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(calldata.size)) + 194] = 64
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(calldata.size)) + 258] = ('cd', 4).length
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(calldata.size)) + 290 len 32 * ('cd', 4).length] = mem[128 len 32 * ('cd', 4).length]
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(calldata.size)) + 226] = (32 * ('cd', 4).length) + 96
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(calldata.size)) + (32 * ('cd', 4).length) + 290] = ('cd', 68).length
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(calldata.size)) + (32 * ('cd', 4).length) + 322 len 32 * ('cd', 68).length] = mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * ('cd', 68).length]
                        var79001 = ('cd', 68).length
                        emit TransferBatch(Array(len=('cd', 4).length, data=mem[128 len 32 * ('cd', 4).length], ('cd', 68).length, mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * ('cd', 68).length]), (32 * ('cd', 4).length) + 96, mem[calldata.size + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + ceil32(calldata.size) + 142 len 20], address(cd[36]), 0);
                else:
                    if bool(stor6[address(msg.sender)]) != 1:
                        revert with 0, 'Caller is not owner nor approved'
                    idx = 0
                    while idx < ('cd', 4).length:
                        if idx >= ('cd', 4).length:
                            revert with 0, 50
                        mem[0] = sub_0f699e80[mem[(32 * idx) + 128]]
                        mem[32] = 11
                        if bool(stor11[stor10[mem[(32 * idx) + 128]]]) != 1:
                            revert with 0, 'Type of token must be burnable'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    if not address(cd[36]):
                        revert with 0, 'ERC1155: burn from the zero address'
                    if ('cd', 4).length != ('cd', 68).length:
                        revert with 0, 'ERC1155: ids and amounts length mismatch'
                    if msg.sender != this.address:
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + ceil32(calldata.size) + 130] = 0
                        idx = 0
                        while idx < ('cd', 4).length:
                            if idx >= ('cd', 4).length:
                                revert with 0, 50
                            if idx >= ('cd', 68).length:
                                revert with 0, 50
                            if balanceOf[mem[(32 * idx) + 128]][address(cd[36])] < mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]:
                                revert with 0, 'ERC1155: burn amount exceeds balance'
                            mem[0] = address(cd[36])
                            mem[32] = sha3(mem[(32 * idx) + 128], 0)
                            balanceOf[mem[(32 * idx) + 128]][address(cd[36])] -= mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        emit TransferBatch(Array(len=('cd', 4).length, data=mem[128 len 32 * ('cd', 4).length], ('cd', 68).length, mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * ('cd', 68).length]), (32 * ('cd', 4).length) + 96, msg.sender, address(cd[36]), 0);
                    else:
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + ceil32(calldata.size) + 130] = calldata.size
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + ceil32(calldata.size) + 162 len calldata.size] = call.data[0 len calldata.size]
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + ceil32(calldata.size) + calldata.size + 162] = 0
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(calldata.size)) + 162] = 0
                        idx = 0
                        while idx < ('cd', 4).length:
                            if idx >= ('cd', 4).length:
                                revert with 0, 50
                            if idx >= ('cd', 68).length:
                                revert with 0, 50
                            if balanceOf[mem[(32 * idx) + 128]][address(cd[36])] < mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]:
                                revert with 0, 'ERC1155: burn amount exceeds balance'
                            mem[0] = address(cd[36])
                            mem[32] = sha3(mem[(32 * idx) + 128], 0)
                            balanceOf[mem[(32 * idx) + 128]][address(cd[36])] -= mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(calldata.size)) + 194] = 64
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(calldata.size)) + 258] = ('cd', 4).length
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(calldata.size)) + 290 len 32 * ('cd', 4).length] = mem[128 len 32 * ('cd', 4).length]
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(calldata.size)) + 226] = (32 * ('cd', 4).length) + 96
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(calldata.size)) + (32 * ('cd', 4).length) + 290] = ('cd', 68).length
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(calldata.size)) + (32 * ('cd', 4).length) + 322 len 32 * ('cd', 68).length] = mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * ('cd', 68).length]
                        emit TransferBatch(Array(len=('cd', 4).length, data=mem[128 len 32 * ('cd', 4).length], ('cd', 68).length, mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * ('cd', 68).length]), (32 * ('cd', 4).length) + 96, mem[calldata.size + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + ceil32(calldata.size) + 142 len 20], address(cd[36]), 0);
            else:
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + ceil32(calldata.size) + 130] = calldata.size
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + ceil32(calldata.size) + 162 len calldata.size] = call.data[0 len calldata.size]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + ceil32(calldata.size) + calldata.size + 162] = 0
                if stor1[address(cd[36])][address(mem[calldata.size + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + ceil32(calldata.size) + 130])]:
                    idx = 0
                    while idx < ('cd', 4).length:
                        if idx >= ('cd', 4).length:
                            revert with 0, 50
                        mem[0] = sub_0f699e80[mem[(32 * idx) + 128]]
                        mem[32] = 11
                        if bool(stor11[stor10[mem[(32 * idx) + 128]]]) != 1:
                            revert with 0, 'Type of token must be burnable'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    if not address(cd[36]):
                        revert with 0, 'ERC1155: burn from the zero address'
                    if ('cd', 4).length != ('cd', 68).length:
                        revert with 0, 'ERC1155: ids and amounts length mismatch'
                    if msg.sender != this.address:
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(calldata.size)) + 162] = 0
                        idx = 0
                        while idx < ('cd', 4).length:
                            if idx >= ('cd', 4).length:
                                revert with 0, 50
                            if idx >= ('cd', 68).length:
                                revert with 0, 50
                            if balanceOf[mem[(32 * idx) + 128]][address(cd[36])] < mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]:
                                revert with 0, 'ERC1155: burn amount exceeds balance'
                            mem[0] = address(cd[36])
                            mem[32] = sha3(mem[(32 * idx) + 128], 0)
                            balanceOf[mem[(32 * idx) + 128]][address(cd[36])] -= mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        var79001 = ('cd', 68).length
                        emit TransferBatch(Array(len=('cd', 4).length, data=mem[128 len 32 * ('cd', 4).length], ('cd', 68).length, mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * ('cd', 68).length]), (32 * ('cd', 4).length) + 96, msg.sender, address(cd[36]), 0);
                    else:
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(calldata.size)) + 162] = calldata.size
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(calldata.size)) + 194 len calldata.size] = call.data[0 len calldata.size]
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(calldata.size)) + calldata.size + 194] = 0
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(calldata.size)) + 194] = 0
                        idx = 0
                        while idx < ('cd', 4).length:
                            if idx >= ('cd', 4).length:
                                revert with 0, 50
                            if idx >= ('cd', 68).length:
                                revert with 0, 50
                            if balanceOf[mem[(32 * idx) + 128]][address(cd[36])] < mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]:
                                revert with 0, 'ERC1155: burn amount exceeds balance'
                            mem[0] = address(cd[36])
                            mem[32] = sha3(mem[(32 * idx) + 128], 0)
                            balanceOf[mem[(32 * idx) + 128]][address(cd[36])] -= mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(calldata.size)) + 322 len 32 * ('cd', 4).length] = mem[128 len 32 * ('cd', 4).length]
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(calldata.size)) + (32 * ('cd', 4).length) + 322] = ('cd', 68).length
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(calldata.size)) + (32 * ('cd', 4).length) + 354 len 32 * ('cd', 68).length] = mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * ('cd', 68).length]
                        var79001 = ('cd', 68).length
                        emit TransferBatch(Array(len=('cd', 4).length, data=mem[128 len 32 * ('cd', 4).length], ('cd', 68).length, mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * ('cd', 68).length]), (32 * ('cd', 4).length) + 96, mem[calldata.size + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(calldata.size)) + 174 len 20], address(cd[36]), 0);
                else:
                    if bool(stor6[address(mem[calldata.size + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + ceil32(calldata.size) + 130])]) != 1:
                        revert with 0, 'Caller is not owner nor approved'
                    idx = 0
                    while idx < ('cd', 4).length:
                        if idx >= ('cd', 4).length:
                            revert with 0, 50
                        mem[0] = sub_0f699e80[mem[(32 * idx) + 128]]
                        mem[32] = 11
                        if bool(stor11[stor10[mem[(32 * idx) + 128]]]) != 1:
                            revert with 0, 'Type of token must be burnable'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    if not address(cd[36]):
                        revert with 0, 'ERC1155: burn from the zero address'
                    if ('cd', 4).length != ('cd', 68).length:
                        revert with 0, 'ERC1155: ids and amounts length mismatch'
                    if msg.sender != this.address:
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(calldata.size)) + 162] = 0
                        idx = 0
                        while idx < ('cd', 4).length:
                            if idx >= ('cd', 4).length:
                                revert with 0, 50
                            if idx >= ('cd', 68).length:
                                revert with 0, 50
                            if balanceOf[mem[(32 * idx) + 128]][address(cd[36])] < mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]:
                                revert with 0, 'ERC1155: burn amount exceeds balance'
                            mem[0] = address(cd[36])
                            mem[32] = sha3(mem[(32 * idx) + 128], 0)
                            balanceOf[mem[(32 * idx) + 128]][address(cd[36])] -= mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        emit TransferBatch(Array(len=('cd', 4).length, data=mem[128 len 32 * ('cd', 4).length], ('cd', 68).length, mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * ('cd', 68).length]), (32 * ('cd', 4).length) + 96, msg.sender, address(cd[36]), 0);
                    else:
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(calldata.size)) + 162] = calldata.size
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(calldata.size)) + 194 len calldata.size] = call.data[0 len calldata.size]
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(calldata.size)) + calldata.size + 194] = 0
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(calldata.size)) + 194] = 0
                        idx = 0
                        while idx < ('cd', 4).length:
                            if idx >= ('cd', 4).length:
                                revert with 0, 50
                            if idx >= ('cd', 68).length:
                                revert with 0, 50
                            if balanceOf[mem[(32 * idx) + 128]][address(cd[36])] < mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]:
                                revert with 0, 'ERC1155: burn amount exceeds balance'
                            mem[0] = address(cd[36])
                            mem[32] = sha3(mem[(32 * idx) + 128], 0)
                            balanceOf[mem[(32 * idx) + 128]][address(cd[36])] -= mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(calldata.size)) + 322 len 32 * ('cd', 4).length] = mem[128 len 32 * ('cd', 4).length]
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(calldata.size)) + (32 * ('cd', 4).length) + 322] = ('cd', 68).length
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (4 * ceil32(calldata.size)) + (32 * ('cd', 4).length) + 354 len 32 * ('cd', 68).length] = mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * ('cd', 68).length]
                        emit TransferBatch(Array(len=('cd', 4).length, data=mem[128 len 32 * ('cd', 4).length], ('cd', 68).length, mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * ('cd', 68).length]), (32 * ('cd', 4).length) + 96, mem[calldata.size + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 68).length) + (2 * ceil32(calldata.size)) + 174 len 20], address(cd[36]), 0);
}

function sub_f44b8158(?) payable {
    mem[64] = 96
    require not msg.value
    require calldata.size - 4 >= 160
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    require ('cd', 4).length <= test266151307()
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    require cd[36] <= test266151307()
    require cd[36] + 35 < calldata.size
    require ('cd', 36).length <= test266151307()
    require cd[36] + (32 * ('cd', 36).length) + 36 <= calldata.size
    require cd[68] <= test266151307()
    require cd[68] + 35 < calldata.size
    require ('cd', 68).length <= test266151307()
    require cd[68] + (32 * ('cd', 68).length) + 36 <= calldata.size
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + (32 * ('cd', 100).length) + 36 <= calldata.size
    require cd[132] <= test266151307()
    require cd[132] + 35 < calldata.size
    require ('cd', 132).length <= test266151307()
    require cd[132] + (32 * ('cd', 132).length) + 36 <= calldata.size
    if msg.sender != this.address:
        mem[0] = msg.sender
        mem[32] = sha3(0, 2)
        if not uint8(roleAdmin[0][address(msg.sender)].field_0):
            mem[128 len 42] = call.data[calldata.size len 42]
            idx = 41
            s = address(msg.sender)
            while idx > 1:
                if s % 16 >= 16:
                    revert with 0, 50
                if idx >= 42:
                    revert with 0, 50
                mem[idx + 128 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                if not idx:
                    revert with 0, 17
                idx = idx - 1
                s = Mask(252, 0, s) * 0.0625
                continue 
            if msg.sender + 10240:
                revert with 0, 'Strings: hex length insufficient'
            mem[224 len 66] = call.data[calldata.size len 66]
            idx = 65
            while idx > 1:
                if idx >= 66:
                    revert with 0, 50
                mem[idx + 224 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                if not idx:
                    revert with 0, 17
                idx = idx - 1
                continue 
            revert with 0, 32, 148, 'AccessControl: account ', mem[160 len 42], 8297, mem[288 len 66], 0, 0 >> 928, 0
        if ('cd', 36).length != ('cd', 4).length:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Array arguments must have same length'
        if ('cd', 68).length != ('cd', 4).length:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Array arguments must have same length'
        if ('cd', 100).length != ('cd', 4).length:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Array arguments must have same length'
        if ('cd', 132).length != ('cd', 4).length:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Array arguments must have same length'
        idx = 0
        while idx < ('cd', 4).length:
            if idx >= ('cd', 36).length:
                revert with 0, 50
            if idx >= ('cd', 68).length:
                revert with 0, 50
            require cd[((32 * idx) + cd[68] + 36)] == bool(cd[((32 * idx) + cd[68] + 36)])
            if idx >= ('cd', 100).length:
                revert with 0, 50
            require cd[((32 * idx) + cd[100] + 36)] == bool(cd[((32 * idx) + cd[100] + 36)])
            if idx >= ('cd', 132).length:
                revert with 0, 50
            require cd[(cd[132] + (32 * idx) + 36)] < calldata.size + -cd[132] - 67
            require cd[(cd[132] + cd[(cd[132] + (32 * idx) + 36)] + 36)] <= test266151307()
            require cd[132] + cd[(cd[132] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[132] + cd[(cd[132] + (32 * idx) + 36)] + 36)]
            _185 = mem[64]
            mem[64] = mem[64] + ceil32(cd[(cd[132] + cd[(cd[132] + (32 * idx) + 36)] + 36)]) + 32
            mem[_185] = cd[(cd[132] + cd[(cd[132] + (32 * idx) + 36)] + 36)]
            mem[_185 + 32 len cd[(cd[132] + cd[(cd[132] + (32 * idx) + 36)] + 36)]] = call.data[cd[132] + cd[(cd[132] + (32 * idx) + 36)] + 68 len cd[(cd[132] + cd[(cd[132] + (32 * idx) + 36)] + 36)]]
            mem[_185 + cd[(cd[132] + cd[(cd[132] + (32 * idx) + 36)] + 36)] + 32] = 0
            if msg.sender != this.address:
                mem[0] = msg.sender
                mem[32] = sha3(0, 2)
                if uint8(roleAdmin[0][address(msg.sender)].field_0):
                    if stor13[cd[((32 * idx) + cd[4] + 36)]]:
                        revert with 0, 'Supplied typeId is already used'
                    if cd[((32 * idx) + cd[36] + 36)] <= 0:
                        revert with 0, 'max supply must be > 0'
                    sub_fc86b662[cd[((32 * idx) + cd[4] + 36)]] = cd[((32 * idx) + cd[36] + 36)]
                    stor12[cd[((32 * idx) + cd[4] + 36)]] = uint8(bool(cd[((32 * idx) + cd[68] + 36)]))
                    stor11[cd[((32 * idx) + cd[4] + 36)]] = uint8(bool(cd[((32 * idx) + cd[100] + 36)]))
                    stor13[cd[((32 * idx) + cd[4] + 36)]] = 1
                    if cd[((32 * idx) + cd[68] + 36)]:
                        sub_0f699e80[cd[((32 * idx) + cd[4] + 36)]] = cd[((32 * idx) + cd[4] + 36)]
                    mem[32] = 15
                    if bool(stor15[cd[((32 * idx) + cd[4] + 36)]].field_0):
                        if bool(stor15[cd[((32 * idx) + cd[4] + 36)]].field_0) == uint255(stor15[cd[((32 * idx) + cd[4] + 36)]].field_0) * 0.5 < 32:
                            revert with 0, 34
                        mem[0] = sha3(cd[((32 * idx) + cd[4] + 36)], 15)
                        if not cd[(cd[132] + cd[(cd[132] + (32 * idx) + 36)] + 36)]:
                            stor15[cd[((32 * idx) + cd[4] + 36)]].field_0 = 0
                            s = sha3(sha3(cd[((32 * idx) + cd[4] + 36)], 15))
                            while sha3(sha3(cd[((32 * idx) + cd[4] + 36)], 15)) + ((uint255(stor15[cd[((32 * idx) + cd[4] + 36)]].field_0) * 0.5) + 31 / 32) > s:
                                stor[s] = 0
                                s = s + 1
                                continue 
                        else:
                            stor15[cd[((32 * idx) + cd[4] + 36)]].field_0 = (2 * cd[(cd[132] + cd[(cd[132] + (32 * idx) + 36)] + 36)]) + 1
                            s = sha3(sha3(cd[((32 * idx) + cd[4] + 36)], 15))
                            t = _185 + 32
                            while _185 + cd[(cd[132] + cd[(cd[132] + (32 * idx) + 36)] + 36)] + 32 > t:
                                stor[s] = mem[t]
                                s = s + 1
                                t = t + 32
                                continue 
                            s = sha3(sha3(cd[((32 * idx) + cd[4] + 36)], 15)) + (Mask(251, 0, cd[(cd[132] + cd[(cd[132] + (32 * idx) + 36)] + 36)] + 31) >> 5)
                            while sha3(sha3(cd[((32 * idx) + cd[4] + 36)], 15)) + ((uint255(stor15[cd[((32 * idx) + cd[4] + 36)]].field_0) * 0.5) + 31 / 32) > s:
                                stor[s] = 0
                                s = s + 1
                                continue 
                    else:
                        if bool(stor15[cd[((32 * idx) + cd[4] + 36)]].field_0) == stor15[cd[((32 * idx) + cd[4] + 36)]].field_1 % 128 < 32:
                            revert with 0, 34
                        mem[0] = sha3(cd[((32 * idx) + cd[4] + 36)], 15)
                        if not cd[(cd[132] + cd[(cd[132] + (32 * idx) + 36)] + 36)]:
                            stor15[cd[((32 * idx) + cd[4] + 36)]].field_0 = 0
                            s = sha3(sha3(cd[((32 * idx) + cd[4] + 36)], 15))
                            while sha3(sha3(cd[((32 * idx) + cd[4] + 36)], 15)) + (stor15[cd[((32 * idx) + cd[4] + 36)]].field_1 % 128 + 31 / 32) > s:
                                stor[s] = 0
                                s = s + 1
                                continue 
                        else:
                            stor15[cd[((32 * idx) + cd[4] + 36)]].field_0 = (2 * cd[(cd[132] + cd[(cd[132] + (32 * idx) + 36)] + 36)]) + 1
                            s = sha3(sha3(cd[((32 * idx) + cd[4] + 36)], 15))
                            t = _185 + 32
                            while _185 + cd[(cd[132] + cd[(cd[132] + (32 * idx) + 36)] + 36)] + 32 > t:
                                stor[s] = mem[t]
                                s = s + 1
                                t = t + 32
                                continue 
                            s = sha3(sha3(cd[((32 * idx) + cd[4] + 36)], 15)) + (Mask(251, 0, cd[(cd[132] + cd[(cd[132] + (32 * idx) + 36)] + 36)] + 31) >> 5)
                            while sha3(sha3(cd[((32 * idx) + cd[4] + 36)], 15)) + (stor15[cd[((32 * idx) + cd[4] + 36)]].field_1 % 128 + 31 / 32) > s:
                                stor[s] = 0
                                s = s + 1
                                continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                _257 = mem[64]
                mem[mem[64]] = 42
                mem[64] = mem[64] + 96
                mem[_257 + 32 len 42] = call.data[calldata.size len 42]
                if 0 >= mem[_257]:
                    revert with 0, 50
                mem[_257 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                if 1 >= mem[_257]:
                    revert with 0, 50
                mem[_257 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                idx = 41
                s = address(msg.sender)
                while idx > 1:
                    if s % 16 >= 16:
                        revert with 0, 50
                    if idx >= mem[_257]:
                        revert with 0, 50
                    mem[idx + _257 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                    if not idx:
                        revert with 0, 17
                    idx = idx - 1
                    s = Mask(252, 0, s) * 0.0625
                    continue 
                if msg.sender + 10240:
                    revert with 0, 'Strings: hex length insufficient'
                _363 = mem[64]
                mem[mem[64]] = 66
                mem[64] = mem[64] + 128
                mem[_363 + 32 len 66] = call.data[calldata.size len 66]
                if 0 >= mem[_363]:
                    revert with 0, 50
                mem[_363 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                if 1 >= mem[_363]:
                    revert with 0, 50
                mem[_363 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                idx = 65
                while idx > 1:
                    if idx >= mem[_363]:
                        revert with 0, 50
                    mem[idx + _363 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                    if not idx:
                        revert with 0, 17
                    idx = idx - 1
                    continue 
                _429 = mem[64]
                mem[mem[64] + 32] = 'AccessControl: account '
                _437 = mem[_257]
                idx = 0
                while idx < _437:
                    mem[idx + _429 + 55] = mem[idx + _257 + 32]
                    idx = idx + 32
                    continue 
                mem[_429 + _437 + 55] = 0x206973206d697373696e6720726f6c6520000000000000000000000000000000
                if ceil32(_437) <= _437:
                    _597 = mem[_363]
                    idx = 0
                    while idx < _597:
                        mem[idx + _429 + _437 + 72] = mem[idx + _363 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_597) <= _597:
                        _749 = mem[64]
                        mem[mem[64]] = _597 + _429 + _437 + -mem[64] + 40
                        mem[64] = _597 + _429 + _437 + 72
                        mem[_597 + _429 + _437 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[_597 + _429 + _437 + 76] = 32
                        _781 = mem[_749]
                        mem[_597 + _429 + _437 + 108] = mem[_749]
                        idx = 0
                        while idx < _781:
                            mem[idx + _597 + _429 + _437 + 140] = mem[idx + _749 + 32]
                            idx = idx + 32
                            continue 
                        if ceil32(_781) > _781:
                            mem[_781 + _597 + _429 + _437 + 140] = 0
                        revert with 0, 32, mem[_597 + _429 + _437 + 108 len ceil32(_781) + 32]
                    mem[_597 + _429 + _437 + 72] = 0
                    _750 = mem[64]
                    mem[mem[64]] = _597 + _429 + _437 + -mem[64] + 40
                    mem[64] = _597 + _429 + _437 + 72
                    mem[_597 + _429 + _437 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[_597 + _429 + _437 + 76] = 32
                    _782 = mem[_750]
                    mem[_597 + _429 + _437 + 108] = mem[_750]
                    idx = 0
                    while idx < _782:
                        mem[idx + _597 + _429 + _437 + 140] = mem[idx + _750 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_782) > _782:
                        mem[_782 + _597 + _429 + _437 + 140] = 0
                    revert with 0, 32, mem[_597 + _429 + _437 + 108 len ceil32(_782) + 32]
                _598 = mem[_363]
                idx = 0
                while idx < _598:
                    mem[idx + _429 + _437 + 72] = mem[idx + _363 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_598) <= _598:
                    _751 = mem[64]
                    mem[mem[64]] = _598 + _429 + _437 + -mem[64] + 40
                    mem[64] = _598 + _429 + _437 + 72
                    mem[_598 + _429 + _437 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[_598 + _429 + _437 + 76] = 32
                    _783 = mem[_751]
                    mem[_598 + _429 + _437 + 108] = mem[_751]
                    idx = 0
                    while idx < _783:
                        mem[idx + _598 + _429 + _437 + 140] = mem[idx + _751 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_783) > _783:
                        mem[_783 + _598 + _429 + _437 + 140] = 0
                    revert with 0, 32, mem[_598 + _429 + _437 + 108 len ceil32(_783) + 32]
                mem[_598 + _429 + _437 + 72] = 0
                _752 = mem[64]
                mem[mem[64]] = _598 + _429 + _437 + -mem[64] + 40
                mem[64] = _598 + _429 + _437 + 72
                mem[_598 + _429 + _437 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[_598 + _429 + _437 + 76] = 32
                _784 = mem[_752]
                mem[_598 + _429 + _437 + 108] = mem[_752]
                idx = 0
                while idx < _784:
                    mem[idx + _598 + _429 + _437 + 140] = mem[idx + _752 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_784) > _784:
                    mem[_784 + _598 + _429 + _437 + 140] = 0
                revert with 0, 32, mem[_598 + _429 + _437 + 108 len ceil32(_784) + 32]
            _189 = mem[64]
            mem[64] = mem[64] + ceil32(calldata.size) + 32
            mem[_189] = calldata.size
            mem[_189 + 32 len calldata.size] = call.data[0 len calldata.size]
            mem[_189 + calldata.size + 32] = 0
            _190 = mem[calldata.size + _189]
            mem[0] = mem[calldata.size + _189 + 12 len 20]
            mem[32] = sha3(0, 2)
            if uint8(roleAdmin[0][address(_190)].field_0):
                if stor13[cd[((32 * idx) + cd[4] + 36)]]:
                    revert with 0, 'Supplied typeId is already used'
                if cd[((32 * idx) + cd[36] + 36)] <= 0:
                    revert with 0, 'max supply must be > 0'
                sub_fc86b662[cd[((32 * idx) + cd[4] + 36)]] = cd[((32 * idx) + cd[36] + 36)]
                stor12[cd[((32 * idx) + cd[4] + 36)]] = uint8(bool(cd[((32 * idx) + cd[68] + 36)]))
                stor11[cd[((32 * idx) + cd[4] + 36)]] = uint8(bool(cd[((32 * idx) + cd[100] + 36)]))
                stor13[cd[((32 * idx) + cd[4] + 36)]] = 1
                if cd[((32 * idx) + cd[68] + 36)]:
                    sub_0f699e80[cd[((32 * idx) + cd[4] + 36)]] = cd[((32 * idx) + cd[4] + 36)]
                mem[32] = 15
                if bool(stor15[cd[((32 * idx) + cd[4] + 36)]].field_0):
                    if bool(stor15[cd[((32 * idx) + cd[4] + 36)]].field_0) == uint255(stor15[cd[((32 * idx) + cd[4] + 36)]].field_0) * 0.5 < 32:
                        revert with 0, 34
                    mem[0] = sha3(cd[((32 * idx) + cd[4] + 36)], 15)
                    if not cd[(cd[132] + cd[(cd[132] + (32 * idx) + 36)] + 36)]:
                        stor15[cd[((32 * idx) + cd[4] + 36)]].field_0 = 0
                        s = sha3(sha3(cd[((32 * idx) + cd[4] + 36)], 15))
                        while sha3(sha3(cd[((32 * idx) + cd[4] + 36)], 15)) + ((uint255(stor15[cd[((32 * idx) + cd[4] + 36)]].field_0) * 0.5) + 31 / 32) > s:
                            stor[s] = 0
                            s = s + 1
                            continue 
                    else:
                        stor15[cd[((32 * idx) + cd[4] + 36)]].field_0 = (2 * cd[(cd[132] + cd[(cd[132] + (32 * idx) + 36)] + 36)]) + 1
                        s = sha3(sha3(cd[((32 * idx) + cd[4] + 36)], 15))
                        t = _185 + 32
                        while _185 + cd[(cd[132] + cd[(cd[132] + (32 * idx) + 36)] + 36)] + 32 > t:
                            stor[s] = mem[t]
                            s = s + 1
                            t = t + 32
                            continue 
                        s = sha3(sha3(cd[((32 * idx) + cd[4] + 36)], 15)) + (Mask(251, 0, cd[(cd[132] + cd[(cd[132] + (32 * idx) + 36)] + 36)] + 31) >> 5)
                        while sha3(sha3(cd[((32 * idx) + cd[4] + 36)], 15)) + ((uint255(stor15[cd[((32 * idx) + cd[4] + 36)]].field_0) * 0.5) + 31 / 32) > s:
                            stor[s] = 0
                            s = s + 1
                            continue 
                else:
                    if bool(stor15[cd[((32 * idx) + cd[4] + 36)]].field_0) == stor15[cd[((32 * idx) + cd[4] + 36)]].field_1 % 128 < 32:
                        revert with 0, 34
                    mem[0] = sha3(cd[((32 * idx) + cd[4] + 36)], 15)
                    if not cd[(cd[132] + cd[(cd[132] + (32 * idx) + 36)] + 36)]:
                        stor15[cd[((32 * idx) + cd[4] + 36)]].field_0 = 0
                        s = sha3(sha3(cd[((32 * idx) + cd[4] + 36)], 15))
                        while sha3(sha3(cd[((32 * idx) + cd[4] + 36)], 15)) + (stor15[cd[((32 * idx) + cd[4] + 36)]].field_1 % 128 + 31 / 32) > s:
                            stor[s] = 0
                            s = s + 1
                            continue 
                    else:
                        stor15[cd[((32 * idx) + cd[4] + 36)]].field_0 = (2 * cd[(cd[132] + cd[(cd[132] + (32 * idx) + 36)] + 36)]) + 1
                        s = sha3(sha3(cd[((32 * idx) + cd[4] + 36)], 15))
                        t = _185 + 32
                        while _185 + cd[(cd[132] + cd[(cd[132] + (32 * idx) + 36)] + 36)] + 32 > t:
                            stor[s] = mem[t]
                            s = s + 1
                            t = t + 32
                            continue 
                        s = sha3(sha3(cd[((32 * idx) + cd[4] + 36)], 15)) + (Mask(251, 0, cd[(cd[132] + cd[(cd[132] + (32 * idx) + 36)] + 36)] + 31) >> 5)
                        while sha3(sha3(cd[((32 * idx) + cd[4] + 36)], 15)) + (stor15[cd[((32 * idx) + cd[4] + 36)]].field_1 % 128 + 31 / 32) > s:
                            stor[s] = 0
                            s = s + 1
                            continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _258 = mem[64]
            mem[mem[64]] = 42
            mem[64] = mem[64] + 96
            mem[_258 + 32 len 42] = call.data[calldata.size len 42]
            if 0 >= mem[_258]:
                revert with 0, 50
            mem[_258 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
            if 1 >= mem[_258]:
                revert with 0, 50
            mem[_258 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
            idx = 41
            s = address(_190)
            while idx > 1:
                if s % 16 >= 16:
                    revert with 0, 50
                if idx >= mem[_258]:
                    revert with 0, 50
                mem[idx + _258 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                if not idx:
                    revert with 0, 17
                idx = idx - 1
                s = Mask(252, 0, s) * 0.0625
                continue 
            if address(_190) + 10240:
                revert with 0, 'Strings: hex length insufficient'
            _364 = mem[64]
            mem[mem[64]] = 66
            mem[64] = mem[64] + 128
            mem[_364 + 32 len 66] = call.data[calldata.size len 66]
            if 0 >= mem[_364]:
                revert with 0, 50
            mem[_364 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
            if 1 >= mem[_364]:
                revert with 0, 50
            mem[_364 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
            idx = 65
            while idx > 1:
                if idx >= mem[_364]:
                    revert with 0, 50
                mem[idx + _364 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                if not idx:
                    revert with 0, 17
                idx = idx - 1
                continue 
            _430 = mem[64]
            mem[mem[64] + 32] = 'AccessControl: account '
            _438 = mem[_258]
            idx = 0
            while idx < _438:
                mem[idx + _430 + 55] = mem[idx + _258 + 32]
                idx = idx + 32
                continue 
            mem[_430 + _438 + 55] = 0x206973206d697373696e6720726f6c6520000000000000000000000000000000
            if ceil32(_438) <= _438:
                _599 = mem[_364]
                idx = 0
                while idx < _599:
                    mem[idx + _430 + _438 + 72] = mem[idx + _364 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_599) <= _599:
                    _753 = mem[64]
                    mem[mem[64]] = _599 + _430 + _438 + -mem[64] + 40
                    mem[64] = _599 + _430 + _438 + 72
                    mem[_599 + _430 + _438 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[_599 + _430 + _438 + 76] = 32
                    _785 = mem[_753]
                    mem[_599 + _430 + _438 + 108] = mem[_753]
                    idx = 0
                    while idx < _785:
                        mem[idx + _599 + _430 + _438 + 140] = mem[idx + _753 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_785) > _785:
                        mem[_785 + _599 + _430 + _438 + 140] = 0
                    revert with 0, 32, mem[_599 + _430 + _438 + 108 len ceil32(_785) + 32]
                mem[_599 + _430 + _438 + 72] = 0
                _754 = mem[64]
                mem[mem[64]] = _599 + _430 + _438 + -mem[64] + 40
                mem[64] = _599 + _430 + _438 + 72
                mem[_599 + _430 + _438 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[_599 + _430 + _438 + 76] = 32
                _786 = mem[_754]
                mem[_599 + _430 + _438 + 108] = mem[_754]
                idx = 0
                while idx < _786:
                    mem[idx + _599 + _430 + _438 + 140] = mem[idx + _754 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_786) > _786:
                    mem[_786 + _599 + _430 + _438 + 140] = 0
                revert with 0, 32, mem[_599 + _430 + _438 + 108 len ceil32(_786) + 32]
            _600 = mem[_364]
            idx = 0
            while idx < _600:
                mem[idx + _430 + _438 + 72] = mem[idx + _364 + 32]
                idx = idx + 32
                continue 
            if ceil32(_600) <= _600:
                _755 = mem[64]
                mem[mem[64]] = _600 + _430 + _438 + -mem[64] + 40
                mem[64] = _600 + _430 + _438 + 72
                mem[_600 + _430 + _438 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[_600 + _430 + _438 + 76] = 32
                _787 = mem[_755]
                mem[_600 + _430 + _438 + 108] = mem[_755]
                idx = 0
                while idx < _787:
                    mem[idx + _600 + _430 + _438 + 140] = mem[idx + _755 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_787) > _787:
                    mem[_787 + _600 + _430 + _438 + 140] = 0
                revert with 0, 32, mem[_600 + _430 + _438 + 108 len ceil32(_787) + 32]
            mem[_600 + _430 + _438 + 72] = 0
            _756 = mem[64]
            mem[mem[64]] = _600 + _430 + _438 + -mem[64] + 40
            mem[64] = _600 + _430 + _438 + 72
            mem[_600 + _430 + _438 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[_600 + _430 + _438 + 76] = 32
            _788 = mem[_756]
            mem[_600 + _430 + _438 + 108] = mem[_756]
            idx = 0
            while idx < _788:
                mem[idx + _600 + _430 + _438 + 140] = mem[idx + _756 + 32]
                idx = idx + 32
                continue 
            if ceil32(_788) > _788:
                mem[_788 + _600 + _430 + _438 + 140] = 0
            revert with 0, 32, mem[_600 + _430 + _438 + 108 len ceil32(_788) + 32]
        _169 = mem[64]
        mem[mem[64]] = 160
        mem[mem[64] + 160] = ('cd', 4).length
        require ('cd', 4).length <= 0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
        mem[mem[64] + 192 len 32 * ('cd', 4).length] = call.data[cd[4] + 36 len 32 * ('cd', 4).length]
        mem[mem[64] + 32] = (32 * ('cd', 4).length) + 192
        mem[mem[64] + (32 * ('cd', 4).length) + 192] = ('cd', 36).length
        require ('cd', 36).length <= 0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
        mem[mem[64] + (32 * ('cd', 4).length) + 224 len 32 * ('cd', 36).length] = call.data[cd[36] + 36 len 32 * ('cd', 36).length]
        mem[mem[64] + 64] = (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 224
        mem[mem[64] + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 224] = ('cd', 68).length
        idx = 0
        s = cd[68] + 36
        t = mem[64] + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 256
        while idx < ('cd', 68).length:
            require cd[s] == bool(cd[s])
            mem[t] = bool(cd[s])
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[mem[64] + 96] = (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 256
        mem[mem[64] + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 256] = ('cd', 100).length
        idx = 0
        s = cd[100] + 36
        t = mem[64] + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 288
        while idx < ('cd', 100).length:
            require cd[s] == bool(cd[s])
            mem[t] = bool(cd[s])
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[_169 + 128] = (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + (32 * ('cd', 100).length) + 288
        mem[_169 + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + (32 * ('cd', 100).length) + 288] = ('cd', 132).length
        idx = 0
        s = cd[132] + 36
        t = _169 + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + (32 * ('cd', 100).length) + (32 * ('cd', 132).length) + 320
        u = _169 + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + (32 * ('cd', 100).length) + 320
        while idx < ('cd', 132).length:
            mem[u] = t + -_169 + -(32 * ('cd', 4).length) + -(32 * ('cd', 36).length) + -(32 * ('cd', 68).length) + -(32 * ('cd', 100).length) - 320
            require cd[s] < calldata.size + -cd[132] - 67
            require cd[(cd[132] + cd[s] + 36)] <= test266151307()
            require cd[132] + 36 <= calldata.size - cd[(cd[132] + cd[s] + 36)]
            mem[t] = cd[(cd[132] + cd[s] + 36)]
            mem[t + 32 len cd[(cd[132] + cd[s] + 36)]] = call.data[cd[132] + cd[s] + 68 len cd[(cd[132] + cd[s] + 36)]]
            mem[cd[(cd[132] + cd[s] + 36)] + t + 32] = 0
            idx = idx + 1
            s = s + 32
            t = t + ceil32(cd[(cd[132] + cd[s] + 36)]) + 32
            u = u + 32
            continue 
        emit 0x33bdc44e: mem[mem[64] len _169 + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + (32 * ('cd', 100).length) + (32 * ('cd', 132).length) + (32 * ('cd', 132).length) + -mem[64] + 320]
    else:
        mem[64] = ceil32(calldata.size) + 128
        mem[96] = calldata.size
        mem[128 len calldata.size] = call.data[0 len calldata.size]
        mem[calldata.size + 128] = 0
        mem[0] = mem[calldata.size + 108 len 20]
        mem[32] = sha3(0, 2)
        if not uint8(roleAdmin[0][address(mem[calldata.size + 96])].field_0):
            mem[ceil32(calldata.size) + 160 len 42] = call.data[calldata.size len 42]
            idx = 41
            s = mem[calldata.size + 108 len 20]
            while idx > 1:
                if s % 16 >= 16:
                    revert with 0, 50
                if idx >= 42:
                    revert with 0, 50
                mem[idx + ceil32(calldata.size) + 160 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                if not idx:
                    revert with 0, 17
                idx = idx - 1
                s = Mask(252, 0, s) * 0.0625
                continue 
            if mem[calldata.size + 108 len 20] + 10240:
                revert with 0, 'Strings: hex length insufficient'
            mem[ceil32(calldata.size) + 256 len 66] = call.data[calldata.size len 66]
            idx = 65
            while idx > 1:
                if idx >= 66:
                    revert with 0, 50
                mem[idx + ceil32(calldata.size) + 256 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                if not idx:
                    revert with 0, 17
                idx = idx - 1
                continue 
            revert with 0, 
                        32,
                        148,
                        'AccessControl: account ', mem[ceil32(calldata.size) + 192 len 42], 8297, mem[ceil32(calldata.size) + 320 len 66], 0, 0 >> 928,
                        0
        if ('cd', 36).length != ('cd', 4).length:
            revert with 0, 'Array arguments must have same length'
        if ('cd', 68).length != ('cd', 4).length:
            revert with 0, 'Array arguments must have same length'
        if ('cd', 100).length != ('cd', 4).length:
            revert with 0, 'Array arguments must have same length'
        if ('cd', 132).length != ('cd', 4).length:
            revert with 0, 'Array arguments must have same length'
        idx = 0
        while idx < ('cd', 4).length:
            if idx >= ('cd', 36).length:
                revert with 0, 50
            if idx >= ('cd', 68).length:
                revert with 0, 50
            require cd[((32 * idx) + cd[68] + 36)] == bool(cd[((32 * idx) + cd[68] + 36)])
            if idx >= ('cd', 100).length:
                revert with 0, 50
            require cd[((32 * idx) + cd[100] + 36)] == bool(cd[((32 * idx) + cd[100] + 36)])
            if idx >= ('cd', 132).length:
                revert with 0, 50
            require cd[(cd[132] + (32 * idx) + 36)] < calldata.size + -cd[132] - 67
            require cd[(cd[132] + cd[(cd[132] + (32 * idx) + 36)] + 36)] <= test266151307()
            require cd[132] + cd[(cd[132] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[132] + cd[(cd[132] + (32 * idx) + 36)] + 36)]
            _186 = mem[64]
            mem[64] = mem[64] + ceil32(cd[(cd[132] + cd[(cd[132] + (32 * idx) + 36)] + 36)]) + 32
            mem[_186] = cd[(cd[132] + cd[(cd[132] + (32 * idx) + 36)] + 36)]
            mem[_186 + 32 len cd[(cd[132] + cd[(cd[132] + (32 * idx) + 36)] + 36)]] = call.data[cd[132] + cd[(cd[132] + (32 * idx) + 36)] + 68 len cd[(cd[132] + cd[(cd[132] + (32 * idx) + 36)] + 36)]]
            mem[_186 + cd[(cd[132] + cd[(cd[132] + (32 * idx) + 36)] + 36)] + 32] = 0
            if msg.sender != this.address:
                mem[0] = msg.sender
                mem[32] = sha3(0, 2)
                if uint8(roleAdmin[0][address(msg.sender)].field_0):
                    if stor13[cd[((32 * idx) + cd[4] + 36)]]:
                        revert with 0, 'Supplied typeId is already used'
                    if cd[((32 * idx) + cd[36] + 36)] <= 0:
                        revert with 0, 'max supply must be > 0'
                    sub_fc86b662[cd[((32 * idx) + cd[4] + 36)]] = cd[((32 * idx) + cd[36] + 36)]
                    stor12[cd[((32 * idx) + cd[4] + 36)]] = uint8(bool(cd[((32 * idx) + cd[68] + 36)]))
                    stor11[cd[((32 * idx) + cd[4] + 36)]] = uint8(bool(cd[((32 * idx) + cd[100] + 36)]))
                    stor13[cd[((32 * idx) + cd[4] + 36)]] = 1
                    if cd[((32 * idx) + cd[68] + 36)]:
                        sub_0f699e80[cd[((32 * idx) + cd[4] + 36)]] = cd[((32 * idx) + cd[4] + 36)]
                    mem[32] = 15
                    if bool(stor15[cd[((32 * idx) + cd[4] + 36)]].field_0):
                        if bool(stor15[cd[((32 * idx) + cd[4] + 36)]].field_0) == uint255(stor15[cd[((32 * idx) + cd[4] + 36)]].field_0) * 0.5 < 32:
                            revert with 0, 34
                        mem[0] = sha3(cd[((32 * idx) + cd[4] + 36)], 15)
                        if not cd[(cd[132] + cd[(cd[132] + (32 * idx) + 36)] + 36)]:
                            stor15[cd[((32 * idx) + cd[4] + 36)]].field_0 = 0
                            s = sha3(sha3(cd[((32 * idx) + cd[4] + 36)], 15))
                            while sha3(sha3(cd[((32 * idx) + cd[4] + 36)], 15)) + ((uint255(stor15[cd[((32 * idx) + cd[4] + 36)]].field_0) * 0.5) + 31 / 32) > s:
                                stor[s] = 0
                                s = s + 1
                                continue 
                        else:
                            stor15[cd[((32 * idx) + cd[4] + 36)]].field_0 = (2 * cd[(cd[132] + cd[(cd[132] + (32 * idx) + 36)] + 36)]) + 1
                            s = sha3(sha3(cd[((32 * idx) + cd[4] + 36)], 15))
                            t = _186 + 32
                            while _186 + cd[(cd[132] + cd[(cd[132] + (32 * idx) + 36)] + 36)] + 32 > t:
                                stor[s] = mem[t]
                                s = s + 1
                                t = t + 32
                                continue 
                            s = sha3(sha3(cd[((32 * idx) + cd[4] + 36)], 15)) + (Mask(251, 0, cd[(cd[132] + cd[(cd[132] + (32 * idx) + 36)] + 36)] + 31) >> 5)
                            while sha3(sha3(cd[((32 * idx) + cd[4] + 36)], 15)) + ((uint255(stor15[cd[((32 * idx) + cd[4] + 36)]].field_0) * 0.5) + 31 / 32) > s:
                                stor[s] = 0
                                s = s + 1
                                continue 
                    else:
                        if bool(stor15[cd[((32 * idx) + cd[4] + 36)]].field_0) == stor15[cd[((32 * idx) + cd[4] + 36)]].field_1 % 128 < 32:
                            revert with 0, 34
                        mem[0] = sha3(cd[((32 * idx) + cd[4] + 36)], 15)
                        if not cd[(cd[132] + cd[(cd[132] + (32 * idx) + 36)] + 36)]:
                            stor15[cd[((32 * idx) + cd[4] + 36)]].field_0 = 0
                            s = sha3(sha3(cd[((32 * idx) + cd[4] + 36)], 15))
                            while sha3(sha3(cd[((32 * idx) + cd[4] + 36)], 15)) + (stor15[cd[((32 * idx) + cd[4] + 36)]].field_1 % 128 + 31 / 32) > s:
                                stor[s] = 0
                                s = s + 1
                                continue 
                        else:
                            stor15[cd[((32 * idx) + cd[4] + 36)]].field_0 = (2 * cd[(cd[132] + cd[(cd[132] + (32 * idx) + 36)] + 36)]) + 1
                            s = sha3(sha3(cd[((32 * idx) + cd[4] + 36)], 15))
                            t = _186 + 32
                            while _186 + cd[(cd[132] + cd[(cd[132] + (32 * idx) + 36)] + 36)] + 32 > t:
                                stor[s] = mem[t]
                                s = s + 1
                                t = t + 32
                                continue 
                            s = sha3(sha3(cd[((32 * idx) + cd[4] + 36)], 15)) + (Mask(251, 0, cd[(cd[132] + cd[(cd[132] + (32 * idx) + 36)] + 36)] + 31) >> 5)
                            while sha3(sha3(cd[((32 * idx) + cd[4] + 36)], 15)) + (stor15[cd[((32 * idx) + cd[4] + 36)]].field_1 % 128 + 31 / 32) > s:
                                stor[s] = 0
                                s = s + 1
                                continue 
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                _259 = mem[64]
                mem[mem[64]] = 42
                mem[64] = mem[64] + 96
                mem[_259 + 32 len 42] = call.data[calldata.size len 42]
                if 0 >= mem[_259]:
                    revert with 0, 50
                mem[_259 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                if 1 >= mem[_259]:
                    revert with 0, 50
                mem[_259 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                idx = 41
                s = address(msg.sender)
                while idx > 1:
                    if s % 16 >= 16:
                        revert with 0, 50
                    if idx >= mem[_259]:
                        revert with 0, 50
                    mem[idx + _259 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                    if not idx:
                        revert with 0, 17
                    idx = idx - 1
                    s = Mask(252, 0, s) * 0.0625
                    continue 
                if msg.sender + 10240:
                    revert with 0, 'Strings: hex length insufficient'
                _365 = mem[64]
                mem[mem[64]] = 66
                mem[64] = mem[64] + 128
                mem[_365 + 32 len 66] = call.data[calldata.size len 66]
                if 0 >= mem[_365]:
                    revert with 0, 50
                mem[_365 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                if 1 >= mem[_365]:
                    revert with 0, 50
                mem[_365 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                idx = 65
                while idx > 1:
                    if idx >= mem[_365]:
                        revert with 0, 50
                    mem[idx + _365 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                    if not idx:
                        revert with 0, 17
                    idx = idx - 1
                    continue 
                _433 = mem[64]
                mem[mem[64] + 32] = 'AccessControl: account '
                _439 = mem[_259]
                idx = 0
                while idx < _439:
                    mem[idx + _433 + 55] = mem[idx + _259 + 32]
                    idx = idx + 32
                    continue 
                mem[_433 + _439 + 55] = 0x206973206d697373696e6720726f6c6520000000000000000000000000000000
                if ceil32(_439) <= _439:
                    _601 = mem[_365]
                    idx = 0
                    while idx < _601:
                        mem[idx + _433 + _439 + 72] = mem[idx + _365 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_601) <= _601:
                        _757 = mem[64]
                        mem[mem[64]] = _601 + _433 + _439 + -mem[64] + 40
                        mem[64] = _601 + _433 + _439 + 72
                        mem[_601 + _433 + _439 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[_601 + _433 + _439 + 76] = 32
                        _789 = mem[_757]
                        mem[_601 + _433 + _439 + 108] = mem[_757]
                        idx = 0
                        while idx < _789:
                            mem[idx + _601 + _433 + _439 + 140] = mem[idx + _757 + 32]
                            idx = idx + 32
                            continue 
                        if ceil32(_789) > _789:
                            mem[_789 + _601 + _433 + _439 + 140] = 0
                        revert with 0, 32, mem[_601 + _433 + _439 + 108 len ceil32(_789) + 32]
                    mem[_601 + _433 + _439 + 72] = 0
                    _758 = mem[64]
                    mem[mem[64]] = _601 + _433 + _439 + -mem[64] + 40
                    mem[64] = _601 + _433 + _439 + 72
                    mem[_601 + _433 + _439 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[_601 + _433 + _439 + 76] = 32
                    _790 = mem[_758]
                    mem[_601 + _433 + _439 + 108] = mem[_758]
                    idx = 0
                    while idx < _790:
                        mem[idx + _601 + _433 + _439 + 140] = mem[idx + _758 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_790) > _790:
                        mem[_790 + _601 + _433 + _439 + 140] = 0
                    revert with 0, 32, mem[_601 + _433 + _439 + 108 len ceil32(_790) + 32]
                _602 = mem[_365]
                idx = 0
                while idx < _602:
                    mem[idx + _433 + _439 + 72] = mem[idx + _365 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_602) <= _602:
                    _759 = mem[64]
                    mem[mem[64]] = _602 + _433 + _439 + -mem[64] + 40
                    mem[64] = _602 + _433 + _439 + 72
                    mem[_602 + _433 + _439 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[_602 + _433 + _439 + 76] = 32
                    _791 = mem[_759]
                    mem[_602 + _433 + _439 + 108] = mem[_759]
                    idx = 0
                    while idx < _791:
                        mem[idx + _602 + _433 + _439 + 140] = mem[idx + _759 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_791) > _791:
                        mem[_791 + _602 + _433 + _439 + 140] = 0
                    revert with 0, 32, mem[_602 + _433 + _439 + 108 len ceil32(_791) + 32]
                mem[_602 + _433 + _439 + 72] = 0
                _760 = mem[64]
                mem[mem[64]] = _602 + _433 + _439 + -mem[64] + 40
                mem[64] = _602 + _433 + _439 + 72
                mem[_602 + _433 + _439 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[_602 + _433 + _439 + 76] = 32
                _792 = mem[_760]
                mem[_602 + _433 + _439 + 108] = mem[_760]
                idx = 0
                while idx < _792:
                    mem[idx + _602 + _433 + _439 + 140] = mem[idx + _760 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_792) > _792:
                    mem[_792 + _602 + _433 + _439 + 140] = 0
                revert with 0, 32, mem[_602 + _433 + _439 + 108 len ceil32(_792) + 32]
            _191 = mem[64]
            mem[64] = mem[64] + ceil32(calldata.size) + 32
            mem[_191] = calldata.size
            mem[_191 + 32 len calldata.size] = call.data[0 len calldata.size]
            mem[_191 + calldata.size + 32] = 0
            _192 = mem[calldata.size + _191]
            mem[0] = mem[calldata.size + _191 + 12 len 20]
            mem[32] = sha3(0, 2)
            if uint8(roleAdmin[0][address(_192)].field_0):
                if stor13[cd[((32 * idx) + cd[4] + 36)]]:
                    revert with 0, 'Supplied typeId is already used'
                if cd[((32 * idx) + cd[36] + 36)] <= 0:
                    revert with 0, 'max supply must be > 0'
                sub_fc86b662[cd[((32 * idx) + cd[4] + 36)]] = cd[((32 * idx) + cd[36] + 36)]
                stor12[cd[((32 * idx) + cd[4] + 36)]] = uint8(bool(cd[((32 * idx) + cd[68] + 36)]))
                stor11[cd[((32 * idx) + cd[4] + 36)]] = uint8(bool(cd[((32 * idx) + cd[100] + 36)]))
                stor13[cd[((32 * idx) + cd[4] + 36)]] = 1
                if cd[((32 * idx) + cd[68] + 36)]:
                    sub_0f699e80[cd[((32 * idx) + cd[4] + 36)]] = cd[((32 * idx) + cd[4] + 36)]
                mem[32] = 15
                if bool(stor15[cd[((32 * idx) + cd[4] + 36)]].field_0):
                    if bool(stor15[cd[((32 * idx) + cd[4] + 36)]].field_0) == uint255(stor15[cd[((32 * idx) + cd[4] + 36)]].field_0) * 0.5 < 32:
                        revert with 0, 34
                    mem[0] = sha3(cd[((32 * idx) + cd[4] + 36)], 15)
                    if not cd[(cd[132] + cd[(cd[132] + (32 * idx) + 36)] + 36)]:
                        stor15[cd[((32 * idx) + cd[4] + 36)]].field_0 = 0
                        s = sha3(sha3(cd[((32 * idx) + cd[4] + 36)], 15))
                        while sha3(sha3(cd[((32 * idx) + cd[4] + 36)], 15)) + ((uint255(stor15[cd[((32 * idx) + cd[4] + 36)]].field_0) * 0.5) + 31 / 32) > s:
                            stor[s] = 0
                            s = s + 1
                            continue 
                    else:
                        stor15[cd[((32 * idx) + cd[4] + 36)]].field_0 = (2 * cd[(cd[132] + cd[(cd[132] + (32 * idx) + 36)] + 36)]) + 1
                        s = sha3(sha3(cd[((32 * idx) + cd[4] + 36)], 15))
                        t = _186 + 32
                        while _186 + cd[(cd[132] + cd[(cd[132] + (32 * idx) + 36)] + 36)] + 32 > t:
                            stor[s] = mem[t]
                            s = s + 1
                            t = t + 32
                            continue 
                        s = sha3(sha3(cd[((32 * idx) + cd[4] + 36)], 15)) + (Mask(251, 0, cd[(cd[132] + cd[(cd[132] + (32 * idx) + 36)] + 36)] + 31) >> 5)
                        while sha3(sha3(cd[((32 * idx) + cd[4] + 36)], 15)) + ((uint255(stor15[cd[((32 * idx) + cd[4] + 36)]].field_0) * 0.5) + 31 / 32) > s:
                            stor[s] = 0
                            s = s + 1
                            continue 
                else:
                    if bool(stor15[cd[((32 * idx) + cd[4] + 36)]].field_0) == stor15[cd[((32 * idx) + cd[4] + 36)]].field_1 % 128 < 32:
                        revert with 0, 34
                    mem[0] = sha3(cd[((32 * idx) + cd[4] + 36)], 15)
                    if not cd[(cd[132] + cd[(cd[132] + (32 * idx) + 36)] + 36)]:
                        stor15[cd[((32 * idx) + cd[4] + 36)]].field_0 = 0
                        s = sha3(sha3(cd[((32 * idx) + cd[4] + 36)], 15))
                        while sha3(sha3(cd[((32 * idx) + cd[4] + 36)], 15)) + (stor15[cd[((32 * idx) + cd[4] + 36)]].field_1 % 128 + 31 / 32) > s:
                            stor[s] = 0
                            s = s + 1
                            continue 
                    else:
                        stor15[cd[((32 * idx) + cd[4] + 36)]].field_0 = (2 * cd[(cd[132] + cd[(cd[132] + (32 * idx) + 36)] + 36)]) + 1
                        s = sha3(sha3(cd[((32 * idx) + cd[4] + 36)], 15))
                        t = _186 + 32
                        while _186 + cd[(cd[132] + cd[(cd[132] + (32 * idx) + 36)] + 36)] + 32 > t:
                            stor[s] = mem[t]
                            s = s + 1
                            t = t + 32
                            continue 
                        s = sha3(sha3(cd[((32 * idx) + cd[4] + 36)], 15)) + (Mask(251, 0, cd[(cd[132] + cd[(cd[132] + (32 * idx) + 36)] + 36)] + 31) >> 5)
                        while sha3(sha3(cd[((32 * idx) + cd[4] + 36)], 15)) + (stor15[cd[((32 * idx) + cd[4] + 36)]].field_1 % 128 + 31 / 32) > s:
                            stor[s] = 0
                            s = s + 1
                            continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _260 = mem[64]
            mem[mem[64]] = 42
            mem[64] = mem[64] + 96
            mem[_260 + 32 len 42] = call.data[calldata.size len 42]
            if 0 >= mem[_260]:
                revert with 0, 50
            mem[_260 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
            if 1 >= mem[_260]:
                revert with 0, 50
            mem[_260 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
            idx = 41
            s = address(_192)
            while idx > 1:
                if s % 16 >= 16:
                    revert with 0, 50
                if idx >= mem[_260]:
                    revert with 0, 50
                mem[idx + _260 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                if not idx:
                    revert with 0, 17
                idx = idx - 1
                s = Mask(252, 0, s) * 0.0625
                continue 
            if address(_192) + 10240:
                revert with 0, 'Strings: hex length insufficient'
            _366 = mem[64]
            mem[mem[64]] = 66
            mem[64] = mem[64] + 128
            mem[_366 + 32 len 66] = call.data[calldata.size len 66]
            if 0 >= mem[_366]:
                revert with 0, 50
            mem[_366 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
            if 1 >= mem[_366]:
                revert with 0, 50
            mem[_366 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
            idx = 65
            while idx > 1:
                if idx >= mem[_366]:
                    revert with 0, 50
                mem[idx + _366 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                if not idx:
                    revert with 0, 17
                idx = idx - 1
                continue 
            _434 = mem[64]
            mem[mem[64] + 32] = 'AccessControl: account '
            _440 = mem[_260]
            idx = 0
            while idx < _440:
                mem[idx + _434 + 55] = mem[idx + _260 + 32]
                idx = idx + 32
                continue 
            mem[_434 + _440 + 55] = 0x206973206d697373696e6720726f6c6520000000000000000000000000000000
            if ceil32(_440) <= _440:
                _603 = mem[_366]
                idx = 0
                while idx < _603:
                    mem[idx + _434 + _440 + 72] = mem[idx + _366 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_603) <= _603:
                    _761 = mem[64]
                    mem[mem[64]] = _603 + _434 + _440 + -mem[64] + 40
                    mem[64] = _603 + _434 + _440 + 72
                    mem[_603 + _434 + _440 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[_603 + _434 + _440 + 76] = 32
                    _793 = mem[_761]
                    mem[_603 + _434 + _440 + 108] = mem[_761]
                    idx = 0
                    while idx < _793:
                        mem[idx + _603 + _434 + _440 + 140] = mem[idx + _761 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_793) > _793:
                        mem[_793 + _603 + _434 + _440 + 140] = 0
                    revert with 0, 32, mem[_603 + _434 + _440 + 108 len ceil32(_793) + 32]
                mem[_603 + _434 + _440 + 72] = 0
                _762 = mem[64]
                mem[mem[64]] = _603 + _434 + _440 + -mem[64] + 40
                mem[64] = _603 + _434 + _440 + 72
                mem[_603 + _434 + _440 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[_603 + _434 + _440 + 76] = 32
                _794 = mem[_762]
                mem[_603 + _434 + _440 + 108] = mem[_762]
                idx = 0
                while idx < _794:
                    mem[idx + _603 + _434 + _440 + 140] = mem[idx + _762 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_794) > _794:
                    mem[_794 + _603 + _434 + _440 + 140] = 0
                revert with 0, 32, mem[_603 + _434 + _440 + 108 len ceil32(_794) + 32]
            _604 = mem[_366]
            idx = 0
            while idx < _604:
                mem[idx + _434 + _440 + 72] = mem[idx + _366 + 32]
                idx = idx + 32
                continue 
            if ceil32(_604) <= _604:
                _763 = mem[64]
                mem[mem[64]] = _604 + _434 + _440 + -mem[64] + 40
                mem[64] = _604 + _434 + _440 + 72
                mem[_604 + _434 + _440 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[_604 + _434 + _440 + 76] = 32
                _795 = mem[_763]
                mem[_604 + _434 + _440 + 108] = mem[_763]
                idx = 0
                while idx < _795:
                    mem[idx + _604 + _434 + _440 + 140] = mem[idx + _763 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_795) > _795:
                    mem[_795 + _604 + _434 + _440 + 140] = 0
                revert with 0, 32, mem[_604 + _434 + _440 + 108 len ceil32(_795) + 32]
            mem[_604 + _434 + _440 + 72] = 0
            _764 = mem[64]
            mem[mem[64]] = _604 + _434 + _440 + -mem[64] + 40
            mem[64] = _604 + _434 + _440 + 72
            mem[_604 + _434 + _440 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[_604 + _434 + _440 + 76] = 32
            _796 = mem[_764]
            mem[_604 + _434 + _440 + 108] = mem[_764]
            idx = 0
            while idx < _796:
                mem[idx + _604 + _434 + _440 + 140] = mem[idx + _764 + 32]
                idx = idx + 32
                continue 
            if ceil32(_796) > _796:
                mem[_796 + _604 + _434 + _440 + 140] = 0
            revert with 0, 32, mem[_604 + _434 + _440 + 108 len ceil32(_796) + 32]
        _170 = mem[64]
        mem[mem[64]] = 160
        mem[mem[64] + 160] = ('cd', 4).length
        require ('cd', 4).length <= 0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
        mem[mem[64] + 192 len 32 * ('cd', 4).length] = call.data[cd[4] + 36 len 32 * ('cd', 4).length]
        mem[mem[64] + 32] = (32 * ('cd', 4).length) + 192
        mem[mem[64] + (32 * ('cd', 4).length) + 192] = ('cd', 36).length
        require ('cd', 36).length <= 0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
        mem[mem[64] + (32 * ('cd', 4).length) + 224 len 32 * ('cd', 36).length] = call.data[cd[36] + 36 len 32 * ('cd', 36).length]
        mem[mem[64] + 64] = (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 224
        mem[mem[64] + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 224] = ('cd', 68).length
        idx = 0
        s = cd[68] + 36
        t = mem[64] + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 256
        while idx < ('cd', 68).length:
            require cd[s] == bool(cd[s])
            mem[t] = bool(cd[s])
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[mem[64] + 96] = (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 256
        mem[mem[64] + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 256] = ('cd', 100).length
        idx = 0
        s = cd[100] + 36
        t = mem[64] + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + 288
        while idx < ('cd', 100).length:
            require cd[s] == bool(cd[s])
            mem[t] = bool(cd[s])
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[_170 + 128] = (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + (32 * ('cd', 100).length) + 288
        mem[_170 + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + (32 * ('cd', 100).length) + 288] = ('cd', 132).length
        idx = 0
        s = cd[132] + 36
        t = _170 + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + (32 * ('cd', 100).length) + (32 * ('cd', 132).length) + 320
        u = _170 + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + (32 * ('cd', 100).length) + 320
        while idx < ('cd', 132).length:
            mem[u] = t + -_170 + -(32 * ('cd', 4).length) + -(32 * ('cd', 36).length) + -(32 * ('cd', 68).length) + -(32 * ('cd', 100).length) - 320
            require cd[s] < calldata.size + -cd[132] - 67
            require cd[(cd[132] + cd[s] + 36)] <= test266151307()
            require cd[132] + 36 <= calldata.size - cd[(cd[132] + cd[s] + 36)]
            mem[t] = cd[(cd[132] + cd[s] + 36)]
            mem[t + 32 len cd[(cd[132] + cd[s] + 36)]] = call.data[cd[132] + cd[s] + 68 len cd[(cd[132] + cd[s] + 36)]]
            mem[cd[(cd[132] + cd[s] + 36)] + t + 32] = 0
            idx = idx + 1
            s = s + 32
            t = t + ceil32(cd[(cd[132] + cd[s] + 36)]) + 32
            u = u + 32
            continue 
        emit 0x33bdc44e: mem[mem[64] len _170 + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + (32 * ('cd', 100).length) + (32 * ('cd', 132).length) + (32 * ('cd', 132).length) + -mem[64] + 320]
}

function sub_bd378c71(?) payable {
    mem[64] = 96
    require not msg.value
    require calldata.size - 4 >= 96
    require cd[36] <= test266151307()
    require cd[36] + 35 < calldata.size
    require ('cd', 36).length <= test266151307()
    require cd[36] + (32 * ('cd', 36).length) + 36 <= calldata.size
    require cd[68] <= test266151307()
    require cd[68] + 35 < calldata.size
    require ('cd', 68).length <= test266151307()
    require cd[68] + (32 * ('cd', 68).length) + 36 <= calldata.size
    if msg.sender != this.address:
        mem[0] = msg.sender
        mem[32] = sha3(0, 2)
        if not uint8(roleAdmin[0][address(msg.sender)].field_0):
            mem[128 len 42] = call.data[calldata.size len 42]
            idx = 41
            s = address(msg.sender)
            while idx > 1:
                if s % 16 >= 16:
                    revert with 0, 50
                if idx >= 42:
                    revert with 0, 50
                mem[idx + 128 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                if not idx:
                    revert with 0, 17
                idx = idx - 1
                s = Mask(252, 0, s) * 0.0625
                continue 
            if msg.sender + 10240:
                revert with 0, 'Strings: hex length insufficient'
            mem[224 len 66] = call.data[calldata.size len 66]
            idx = 65
            while idx > 1:
                if idx >= 66:
                    revert with 0, 50
                mem[idx + 224 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                if not idx:
                    revert with 0, 17
                idx = idx - 1
                continue 
            revert with 0, 32, 148, 'AccessControl: account ', mem[160 len 42], 8297, mem[288 len 66], 0, 0 >> 928, 0
        if ('cd', 68).length != ('cd', 36).length:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'number of ids must equal number of accounts'
        idx = 0
        while idx < ('cd', 36).length:
            if idx >= ('cd', 68).length:
                revert with 0, 50
            require cd[((32 * idx) + cd[68] + 36)] == address(cd[((32 * idx) + cd[68] + 36)])
            if msg.sender != this.address:
                mem[0] = msg.sender
                mem[32] = sha3(0, 2)
                if not uint8(roleAdmin[0][address(msg.sender)].field_0):
                    _707 = mem[64]
                    mem[mem[64]] = 42
                    mem[64] = mem[64] + 96
                    mem[_707 + 32 len 42] = call.data[calldata.size len 42]
                    if 0 >= mem[_707]:
                        revert with 0, 50
                    mem[_707 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                    if 1 >= mem[_707]:
                        revert with 0, 50
                    mem[_707 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                    idx = 41
                    s = address(msg.sender)
                    while idx > 1:
                        if s % 16 >= 16:
                            revert with 0, 50
                        if idx >= mem[_707]:
                            revert with 0, 50
                        mem[idx + _707 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                        if not idx:
                            revert with 0, 17
                        idx = idx - 1
                        s = Mask(252, 0, s) * 0.0625
                        continue 
                    if msg.sender + 10240:
                        revert with 0, 'Strings: hex length insufficient'
                    _1427 = mem[64]
                    mem[mem[64]] = 66
                    mem[64] = mem[64] + 128
                    mem[_1427 + 32 len 66] = call.data[calldata.size len 66]
                    if 0 >= mem[_1427]:
                        revert with 0, 50
                    mem[_1427 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                    if 1 >= mem[_1427]:
                        revert with 0, 50
                    mem[_1427 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                    idx = 65
                    while idx > 1:
                        if idx >= mem[_1427]:
                            revert with 0, 50
                        mem[idx + _1427 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                        if not idx:
                            revert with 0, 17
                        idx = idx - 1
                        continue 
                    _1893 = mem[64]
                    mem[mem[64] + 32] = 'AccessControl: account '
                    _1901 = mem[_707]
                    idx = 0
                    while idx < _1901:
                        mem[idx + _1893 + 55] = mem[idx + _707 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1893 + _1901 + 55] = 0x206973206d697373696e6720726f6c6520000000000000000000000000000000
                    if ceil32(_1901) <= _1901:
                        _2089 = mem[_1427]
                        idx = 0
                        while idx < _2089:
                            mem[idx + _1893 + _1901 + 72] = mem[idx + _1427 + 32]
                            idx = idx + 32
                            continue 
                        if ceil32(_2089) <= _2089:
                            _2241 = mem[64]
                            mem[mem[64]] = _2089 + _1893 + _1901 + -mem[64] + 40
                            mem[64] = _2089 + _1893 + _1901 + 72
                            mem[_2089 + _1893 + _1901 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_2089 + _1893 + _1901 + 76] = 32
                            _2273 = mem[_2241]
                            mem[_2089 + _1893 + _1901 + 108] = mem[_2241]
                            idx = 0
                            while idx < _2273:
                                mem[idx + _2089 + _1893 + _1901 + 140] = mem[idx + _2241 + 32]
                                idx = idx + 32
                                continue 
                            if ceil32(_2273) > _2273:
                                mem[_2273 + _2089 + _1893 + _1901 + 140] = 0
                            revert with 0, 32, mem[_2089 + _1893 + _1901 + 108 len ceil32(_2273) + 32]
                        mem[_2089 + _1893 + _1901 + 72] = 0
                        _2242 = mem[64]
                        mem[mem[64]] = _2089 + _1893 + _1901 + -mem[64] + 40
                        mem[64] = _2089 + _1893 + _1901 + 72
                        mem[_2089 + _1893 + _1901 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[_2089 + _1893 + _1901 + 76] = 32
                        _2274 = mem[_2242]
                        mem[_2089 + _1893 + _1901 + 108] = mem[_2242]
                        idx = 0
                        while idx < _2274:
                            mem[idx + _2089 + _1893 + _1901 + 140] = mem[idx + _2242 + 32]
                            idx = idx + 32
                            continue 
                        if ceil32(_2274) > _2274:
                            mem[_2274 + _2089 + _1893 + _1901 + 140] = 0
                        revert with 0, 32, mem[_2089 + _1893 + _1901 + 108 len ceil32(_2274) + 32]
                    _2090 = mem[_1427]
                    idx = 0
                    while idx < _2090:
                        mem[idx + _1893 + _1901 + 72] = mem[idx + _1427 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_2090) <= _2090:
                        _2243 = mem[64]
                        mem[mem[64]] = _2090 + _1893 + _1901 + -mem[64] + 40
                        mem[64] = _2090 + _1893 + _1901 + 72
                        mem[_2090 + _1893 + _1901 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[_2090 + _1893 + _1901 + 76] = 32
                        _2275 = mem[_2243]
                        mem[_2090 + _1893 + _1901 + 108] = mem[_2243]
                        idx = 0
                        while idx < _2275:
                            mem[idx + _2090 + _1893 + _1901 + 140] = mem[idx + _2243 + 32]
                            idx = idx + 32
                            continue 
                        if ceil32(_2275) > _2275:
                            mem[_2275 + _2090 + _1893 + _1901 + 140] = 0
                        revert with 0, 32, mem[_2090 + _1893 + _1901 + 108 len ceil32(_2275) + 32]
                    mem[_2090 + _1893 + _1901 + 72] = 0
                    _2244 = mem[64]
                    mem[mem[64]] = _2090 + _1893 + _1901 + -mem[64] + 40
                    mem[64] = _2090 + _1893 + _1901 + 72
                    mem[_2090 + _1893 + _1901 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[_2090 + _1893 + _1901 + 76] = 32
                    _2276 = mem[_2244]
                    mem[_2090 + _1893 + _1901 + 108] = mem[_2244]
                    idx = 0
                    while idx < _2276:
                        mem[idx + _2090 + _1893 + _1901 + 140] = mem[idx + _2244 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_2276) > _2276:
                        mem[_2276 + _2090 + _1893 + _1901 + 140] = 0
                    revert with 0, 32, mem[_2090 + _1893 + _1901 + 108 len ceil32(_2276) + 32]
                require cd[((32 * idx) + cd[36] + 36)] > 0
                if sub_79920951[cd[4]] > -2:
                    revert with 0, 17
                if sub_79920951[cd[4]] + 1 > sub_fc86b662[cd[4]]:
                    revert with 0, 'Minting would exceed the max number of items for given type'
                if stor13[cd[((32 * idx) + cd[36] + 36)]]:
                    revert with 0, 'Supplied id is already used'
                if stor12[cd[4]]:
                    revert with 0, 'Given type is fungible'
                stor13[cd[((32 * idx) + cd[36] + 36)]] = 1
                if sub_79920951[cd[4]] > -2:
                    revert with 0, 17
                sub_79920951[cd[4]]++
                sub_0f699e80[cd[((32 * idx) + cd[36] + 36)]] = cd[4]
                mem[32] = 14
                mintNumber[cd[((32 * idx) + cd[36] + 36)]] = sub_79920951[cd[4]]
                _769 = mem[64]
                mem[mem[64]] = 0
                if not address(cd[((32 * idx) + cd[68] + 36)]):
                    revert with 0, 'ERC1155: mint to the zero address'
                if msg.sender != this.address:
                    mem[mem[64] + 32] = 1
                    mem[64] = mem[64] + 96
                    mem[_769 + 64] = cd[((32 * idx) + cd[36] + 36)]
                    mem[_769 + 96] = 1
                    mem[64] = _769 + 160
                    mem[_769 + 128] = 1
                    mem[0] = address(cd[((32 * idx) + cd[68] + 36)])
                    mem[32] = sha3(cd[((32 * idx) + cd[36] + 36)], 0)
                    if balanceOf[cd[((32 * idx) + cd[36] + 36)]][address(cd[((32 * idx) + cd[68] + 36)])] > -2:
                        revert with 0, 17
                    balanceOf[cd[((32 * idx) + cd[36] + 36)]][address(cd[((32 * idx) + cd[68] + 36)])]++
                    mem[_769 + 160] = cd[((32 * idx) + cd[36] + 36)]
                    mem[_769 + 192] = 1
                    emit TransferSingle(cd[((32 * idx) + cd[36] + 36)], 1, msg.sender, 0, address(cd[((32 * idx) + cd[68] + 36)]));
                    if ext_code.size(address(cd[((32 * idx) + cd[68] + 36)])):
                        mem[_769 + 160] = 0xf23a6e6100000000000000000000000000000000000000000000000000000000
                        mem[_769 + 164] = msg.sender
                        mem[_769 + 196] = 0
                        mem[_769 + 228] = cd[((32 * idx) + cd[36] + 36)]
                        mem[_769 + 260] = 1
                        mem[_769 + 292] = 160
                        mem[_769 + 324] = mem[_769]
                        s = 0
                        while s < mem[_769]:
                            mem[s + _769 + 356] = mem[s + _769 + 32]
                            s = s + 32
                            continue 
                        if ceil32(mem[_769]) > mem[_769]:
                            mem[mem[_769] + _769 + 356] = 0
                        require ext_code.size(address(cd[((32 * idx) + cd[68] + 36)]))
                        call address(cd[((32 * idx) + cd[68] + 36)]).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                             gas gas_remaining wei
                            args msg.sender, 0, cd[((32 * idx) + cd[36] + 36)], 1, 160, mem[_769], mem[_769 + 356 len ceil32(mem[_769])]
                        mem[_769 + 160] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                        mem[64] = _769 + ceil32(return_data.size) + 160
                        require return_data.size >= 32
                        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                        if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                            revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                else:
                    mem[64] = mem[64] + ceil32(calldata.size) + 64
                    mem[_769 + 32] = calldata.size
                    mem[_769 + 64 len calldata.size] = call.data[0 len calldata.size]
                    mem[_769 + calldata.size + 64] = 0
                    _786 = mem[calldata.size + _769 + 32]
                    mem[_769 + ceil32(calldata.size) + 64] = 1
                    mem[_769 + ceil32(calldata.size) + 96] = cd[((32 * idx) + cd[36] + 36)]
                    mem[_769 + ceil32(calldata.size) + 128] = 1
                    mem[64] = _769 + ceil32(calldata.size) + 192
                    mem[_769 + ceil32(calldata.size) + 160] = 1
                    mem[0] = address(cd[((32 * idx) + cd[68] + 36)])
                    mem[32] = sha3(cd[((32 * idx) + cd[36] + 36)], 0)
                    if balanceOf[cd[((32 * idx) + cd[36] + 36)]][address(cd[((32 * idx) + cd[68] + 36)])] > -2:
                        revert with 0, 17
                    balanceOf[cd[((32 * idx) + cd[36] + 36)]][address(cd[((32 * idx) + cd[68] + 36)])]++
                    mem[_769 + ceil32(calldata.size) + 192] = cd[((32 * idx) + cd[36] + 36)]
                    mem[_769 + ceil32(calldata.size) + 224] = 1
                    emit TransferSingle(cd[((32 * idx) + cd[36] + 36)], 1, address(_786), 0, address(cd[((32 * idx) + cd[68] + 36)]));
                    if ext_code.size(address(cd[((32 * idx) + cd[68] + 36)])):
                        mem[_769 + ceil32(calldata.size) + 192] = 0xf23a6e6100000000000000000000000000000000000000000000000000000000
                        mem[_769 + ceil32(calldata.size) + 196] = address(_786)
                        mem[_769 + ceil32(calldata.size) + 228] = 0
                        mem[_769 + ceil32(calldata.size) + 260] = cd[((32 * idx) + cd[36] + 36)]
                        mem[_769 + ceil32(calldata.size) + 292] = 1
                        mem[_769 + ceil32(calldata.size) + 324] = 160
                        mem[_769 + ceil32(calldata.size) + 356] = mem[_769]
                        s = 0
                        while s < mem[_769]:
                            mem[s + _769 + ceil32(calldata.size) + 388] = mem[s + _769 + 32]
                            s = s + 32
                            continue 
                        if ceil32(mem[_769]) > mem[_769]:
                            mem[mem[_769] + _769 + ceil32(calldata.size) + 388] = 0
                        require ext_code.size(address(cd[((32 * idx) + cd[68] + 36)]))
                        call address(cd[((32 * idx) + cd[68] + 36)]).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                             gas gas_remaining wei
                            args address(_786), 0, cd[((32 * idx) + cd[36] + 36)], 1, 160, mem[_769], mem[_769 + ceil32(calldata.size) + 388 len ceil32(mem[_769])]
                        mem[_769 + ceil32(calldata.size) + 192] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                        mem[64] = _769 + ceil32(calldata.size) + ceil32(return_data.size) + 192
                        require return_data.size >= 32
                        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                        if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                            revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
            else:
                _679 = mem[64]
                mem[64] = mem[64] + ceil32(calldata.size) + 32
                mem[_679] = calldata.size
                mem[_679 + 32 len calldata.size] = call.data[0 len calldata.size]
                mem[_679 + calldata.size + 32] = 0
                _680 = mem[calldata.size + _679]
                mem[0] = mem[calldata.size + _679 + 12 len 20]
                mem[32] = sha3(0, 2)
                if not uint8(roleAdmin[0][address(_680)].field_0):
                    _710 = mem[64]
                    mem[mem[64]] = 42
                    mem[64] = mem[64] + 96
                    mem[_710 + 32 len 42] = call.data[calldata.size len 42]
                    if 0 >= mem[_710]:
                        revert with 0, 50
                    mem[_710 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                    if 1 >= mem[_710]:
                        revert with 0, 50
                    mem[_710 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                    idx = 41
                    s = address(_680)
                    while idx > 1:
                        if s % 16 >= 16:
                            revert with 0, 50
                        if idx >= mem[_710]:
                            revert with 0, 50
                        mem[idx + _710 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                        if not idx:
                            revert with 0, 17
                        idx = idx - 1
                        s = Mask(252, 0, s) * 0.0625
                        continue 
                    if address(_680) + 10240:
                        revert with 0, 'Strings: hex length insufficient'
                    _1428 = mem[64]
                    mem[mem[64]] = 66
                    mem[64] = mem[64] + 128
                    mem[_1428 + 32 len 66] = call.data[calldata.size len 66]
                    if 0 >= mem[_1428]:
                        revert with 0, 50
                    mem[_1428 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                    if 1 >= mem[_1428]:
                        revert with 0, 50
                    mem[_1428 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                    idx = 65
                    while idx > 1:
                        if idx >= mem[_1428]:
                            revert with 0, 50
                        mem[idx + _1428 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                        if not idx:
                            revert with 0, 17
                        idx = idx - 1
                        continue 
                    _1894 = mem[64]
                    mem[mem[64] + 32] = 'AccessControl: account '
                    _1902 = mem[_710]
                    idx = 0
                    while idx < _1902:
                        mem[idx + _1894 + 55] = mem[idx + _710 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1894 + _1902 + 55] = 0x206973206d697373696e6720726f6c6520000000000000000000000000000000
                    if ceil32(_1902) <= _1902:
                        _2091 = mem[_1428]
                        idx = 0
                        while idx < _2091:
                            mem[idx + _1894 + _1902 + 72] = mem[idx + _1428 + 32]
                            idx = idx + 32
                            continue 
                        if ceil32(_2091) <= _2091:
                            _2245 = mem[64]
                            mem[mem[64]] = _2091 + _1894 + _1902 + -mem[64] + 40
                            mem[64] = _2091 + _1894 + _1902 + 72
                            mem[_2091 + _1894 + _1902 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_2091 + _1894 + _1902 + 76] = 32
                            _2277 = mem[_2245]
                            mem[_2091 + _1894 + _1902 + 108] = mem[_2245]
                            idx = 0
                            while idx < _2277:
                                mem[idx + _2091 + _1894 + _1902 + 140] = mem[idx + _2245 + 32]
                                idx = idx + 32
                                continue 
                            if ceil32(_2277) > _2277:
                                mem[_2277 + _2091 + _1894 + _1902 + 140] = 0
                            revert with 0, 32, mem[_2091 + _1894 + _1902 + 108 len ceil32(_2277) + 32]
                        mem[_2091 + _1894 + _1902 + 72] = 0
                        _2246 = mem[64]
                        mem[mem[64]] = _2091 + _1894 + _1902 + -mem[64] + 40
                        mem[64] = _2091 + _1894 + _1902 + 72
                        mem[_2091 + _1894 + _1902 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[_2091 + _1894 + _1902 + 76] = 32
                        _2278 = mem[_2246]
                        mem[_2091 + _1894 + _1902 + 108] = mem[_2246]
                        idx = 0
                        while idx < _2278:
                            mem[idx + _2091 + _1894 + _1902 + 140] = mem[idx + _2246 + 32]
                            idx = idx + 32
                            continue 
                        if ceil32(_2278) > _2278:
                            mem[_2278 + _2091 + _1894 + _1902 + 140] = 0
                        revert with 0, 32, mem[_2091 + _1894 + _1902 + 108 len ceil32(_2278) + 32]
                    _2092 = mem[_1428]
                    idx = 0
                    while idx < _2092:
                        mem[idx + _1894 + _1902 + 72] = mem[idx + _1428 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_2092) <= _2092:
                        _2247 = mem[64]
                        mem[mem[64]] = _2092 + _1894 + _1902 + -mem[64] + 40
                        mem[64] = _2092 + _1894 + _1902 + 72
                        mem[_2092 + _1894 + _1902 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[_2092 + _1894 + _1902 + 76] = 32
                        _2279 = mem[_2247]
                        mem[_2092 + _1894 + _1902 + 108] = mem[_2247]
                        idx = 0
                        while idx < _2279:
                            mem[idx + _2092 + _1894 + _1902 + 140] = mem[idx + _2247 + 32]
                            idx = idx + 32
                            continue 
                        if ceil32(_2279) > _2279:
                            mem[_2279 + _2092 + _1894 + _1902 + 140] = 0
                        revert with 0, 32, mem[_2092 + _1894 + _1902 + 108 len ceil32(_2279) + 32]
                    mem[_2092 + _1894 + _1902 + 72] = 0
                    _2248 = mem[64]
                    mem[mem[64]] = _2092 + _1894 + _1902 + -mem[64] + 40
                    mem[64] = _2092 + _1894 + _1902 + 72
                    mem[_2092 + _1894 + _1902 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[_2092 + _1894 + _1902 + 76] = 32
                    _2280 = mem[_2248]
                    mem[_2092 + _1894 + _1902 + 108] = mem[_2248]
                    idx = 0
                    while idx < _2280:
                        mem[idx + _2092 + _1894 + _1902 + 140] = mem[idx + _2248 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_2280) > _2280:
                        mem[_2280 + _2092 + _1894 + _1902 + 140] = 0
                    revert with 0, 32, mem[_2092 + _1894 + _1902 + 108 len ceil32(_2280) + 32]
                require cd[((32 * idx) + cd[36] + 36)] > 0
                if sub_79920951[cd[4]] > -2:
                    revert with 0, 17
                if sub_79920951[cd[4]] + 1 > sub_fc86b662[cd[4]]:
                    revert with 0, 'Minting would exceed the max number of items for given type'
                if stor13[cd[((32 * idx) + cd[36] + 36)]]:
                    revert with 0, 'Supplied id is already used'
                if stor12[cd[4]]:
                    revert with 0, 'Given type is fungible'
                stor13[cd[((32 * idx) + cd[36] + 36)]] = 1
                if sub_79920951[cd[4]] > -2:
                    revert with 0, 17
                sub_79920951[cd[4]]++
                sub_0f699e80[cd[((32 * idx) + cd[36] + 36)]] = cd[4]
                mem[32] = 14
                mintNumber[cd[((32 * idx) + cd[36] + 36)]] = sub_79920951[cd[4]]
                _770 = mem[64]
                mem[mem[64]] = 0
                if not address(cd[((32 * idx) + cd[68] + 36)]):
                    revert with 0, 'ERC1155: mint to the zero address'
                if msg.sender != this.address:
                    mem[mem[64] + 32] = 1
                    mem[64] = mem[64] + 96
                    mem[_770 + 64] = cd[((32 * idx) + cd[36] + 36)]
                    mem[_770 + 96] = 1
                    mem[64] = _770 + 160
                    mem[_770 + 128] = 1
                    mem[0] = address(cd[((32 * idx) + cd[68] + 36)])
                    mem[32] = sha3(cd[((32 * idx) + cd[36] + 36)], 0)
                    if balanceOf[cd[((32 * idx) + cd[36] + 36)]][address(cd[((32 * idx) + cd[68] + 36)])] > -2:
                        revert with 0, 17
                    balanceOf[cd[((32 * idx) + cd[36] + 36)]][address(cd[((32 * idx) + cd[68] + 36)])]++
                    mem[_770 + 160] = cd[((32 * idx) + cd[36] + 36)]
                    mem[_770 + 192] = 1
                    emit TransferSingle(cd[((32 * idx) + cd[36] + 36)], 1, msg.sender, 0, address(cd[((32 * idx) + cd[68] + 36)]));
                    if ext_code.size(address(cd[((32 * idx) + cd[68] + 36)])):
                        mem[_770 + 160] = 0xf23a6e6100000000000000000000000000000000000000000000000000000000
                        mem[_770 + 164] = msg.sender
                        mem[_770 + 196] = 0
                        mem[_770 + 228] = cd[((32 * idx) + cd[36] + 36)]
                        mem[_770 + 260] = 1
                        mem[_770 + 292] = 160
                        mem[_770 + 324] = mem[_770]
                        s = 0
                        while s < mem[_770]:
                            mem[s + _770 + 356] = mem[s + _770 + 32]
                            s = s + 32
                            continue 
                        if ceil32(mem[_770]) > mem[_770]:
                            mem[mem[_770] + _770 + 356] = 0
                        require ext_code.size(address(cd[((32 * idx) + cd[68] + 36)]))
                        call address(cd[((32 * idx) + cd[68] + 36)]).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                             gas gas_remaining wei
                            args msg.sender, 0, cd[((32 * idx) + cd[36] + 36)], 1, 160, mem[_770], mem[_770 + 356 len ceil32(mem[_770])]
                        mem[_770 + 160] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                        mem[64] = _770 + ceil32(return_data.size) + 160
                        require return_data.size >= 32
                        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                        if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                            revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                else:
                    mem[64] = mem[64] + ceil32(calldata.size) + 64
                    mem[_770 + 32] = calldata.size
                    mem[_770 + 64 len calldata.size] = call.data[0 len calldata.size]
                    mem[_770 + calldata.size + 64] = 0
                    _788 = mem[calldata.size + _770 + 32]
                    mem[_770 + ceil32(calldata.size) + 64] = 1
                    mem[_770 + ceil32(calldata.size) + 96] = cd[((32 * idx) + cd[36] + 36)]
                    mem[_770 + ceil32(calldata.size) + 128] = 1
                    mem[64] = _770 + ceil32(calldata.size) + 192
                    mem[_770 + ceil32(calldata.size) + 160] = 1
                    mem[0] = address(cd[((32 * idx) + cd[68] + 36)])
                    mem[32] = sha3(cd[((32 * idx) + cd[36] + 36)], 0)
                    if balanceOf[cd[((32 * idx) + cd[36] + 36)]][address(cd[((32 * idx) + cd[68] + 36)])] > -2:
                        revert with 0, 17
                    balanceOf[cd[((32 * idx) + cd[36] + 36)]][address(cd[((32 * idx) + cd[68] + 36)])]++
                    mem[_770 + ceil32(calldata.size) + 192] = cd[((32 * idx) + cd[36] + 36)]
                    mem[_770 + ceil32(calldata.size) + 224] = 1
                    emit TransferSingle(cd[((32 * idx) + cd[36] + 36)], 1, address(_788), 0, address(cd[((32 * idx) + cd[68] + 36)]));
                    if ext_code.size(address(cd[((32 * idx) + cd[68] + 36)])):
                        mem[_770 + ceil32(calldata.size) + 192] = 0xf23a6e6100000000000000000000000000000000000000000000000000000000
                        mem[_770 + ceil32(calldata.size) + 196] = address(_788)
                        mem[_770 + ceil32(calldata.size) + 228] = 0
                        mem[_770 + ceil32(calldata.size) + 260] = cd[((32 * idx) + cd[36] + 36)]
                        mem[_770 + ceil32(calldata.size) + 292] = 1
                        mem[_770 + ceil32(calldata.size) + 324] = 160
                        mem[_770 + ceil32(calldata.size) + 356] = mem[_770]
                        s = 0
                        while s < mem[_770]:
                            mem[s + _770 + ceil32(calldata.size) + 388] = mem[s + _770 + 32]
                            s = s + 32
                            continue 
                        if ceil32(mem[_770]) > mem[_770]:
                            mem[mem[_770] + _770 + ceil32(calldata.size) + 388] = 0
                        require ext_code.size(address(cd[((32 * idx) + cd[68] + 36)]))
                        call address(cd[((32 * idx) + cd[68] + 36)]).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                             gas gas_remaining wei
                            args address(_788), 0, cd[((32 * idx) + cd[36] + 36)], 1, 160, mem[_770], mem[_770 + ceil32(calldata.size) + 388 len ceil32(mem[_770])]
                        mem[_770 + ceil32(calldata.size) + 192] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                        mem[64] = _770 + ceil32(calldata.size) + ceil32(return_data.size) + 192
                        require return_data.size >= 32
                        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                        if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                            revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _667 = mem[64]
        mem[mem[64]] = cd[4]
        mem[mem[64] + 32] = 96
        mem[mem[64] + 96] = ('cd', 36).length
        require ('cd', 36).length <= 0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
        mem[mem[64] + 128 len 32 * ('cd', 36).length] = call.data[cd[36] + 36 len 32 * ('cd', 36).length]
        mem[mem[64] + 64] = (32 * ('cd', 36).length) + 128
        mem[_667 + (32 * ('cd', 36).length) + 128] = ('cd', 68).length
        idx = 0
        s = cd[68] + 36
        t = _667 + (32 * ('cd', 36).length) + 160
        while idx < ('cd', 68).length:
            require cd[s] == address(cd[s])
            mem[t] = address(cd[s])
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        emit 0x16a6af95: mem[mem[64] len _667 + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + -mem[64] + 160]
    else:
        mem[64] = ceil32(calldata.size) + 128
        mem[96] = calldata.size
        mem[128 len calldata.size] = call.data[0 len calldata.size]
        mem[calldata.size + 128] = 0
        mem[0] = mem[calldata.size + 108 len 20]
        mem[32] = sha3(0, 2)
        if not uint8(roleAdmin[0][address(mem[calldata.size + 96])].field_0):
            mem[ceil32(calldata.size) + 160 len 42] = call.data[calldata.size len 42]
            idx = 41
            s = mem[calldata.size + 108 len 20]
            while idx > 1:
                if s % 16 >= 16:
                    revert with 0, 50
                if idx >= 42:
                    revert with 0, 50
                mem[idx + ceil32(calldata.size) + 160 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                if not idx:
                    revert with 0, 17
                idx = idx - 1
                s = Mask(252, 0, s) * 0.0625
                continue 
            if mem[calldata.size + 108 len 20] + 10240:
                revert with 0, 'Strings: hex length insufficient'
            mem[ceil32(calldata.size) + 256 len 66] = call.data[calldata.size len 66]
            idx = 65
            while idx > 1:
                if idx >= 66:
                    revert with 0, 50
                mem[idx + ceil32(calldata.size) + 256 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                if not idx:
                    revert with 0, 17
                idx = idx - 1
                continue 
            revert with 0, 
                        32,
                        148,
                        'AccessControl: account ', mem[ceil32(calldata.size) + 192 len 42], 8297, mem[ceil32(calldata.size) + 320 len 66], 0, 0 >> 928,
                        0
        if ('cd', 68).length != ('cd', 36).length:
            revert with 0, 'number of ids must equal number of accounts'
        idx = 0
        while idx < ('cd', 36).length:
            if idx >= ('cd', 68).length:
                revert with 0, 50
            require cd[((32 * idx) + cd[68] + 36)] == address(cd[((32 * idx) + cd[68] + 36)])
            if msg.sender != this.address:
                mem[0] = msg.sender
                mem[32] = sha3(0, 2)
                if not uint8(roleAdmin[0][address(msg.sender)].field_0):
                    _713 = mem[64]
                    mem[mem[64]] = 42
                    mem[64] = mem[64] + 96
                    mem[_713 + 32 len 42] = call.data[calldata.size len 42]
                    if 0 >= mem[_713]:
                        revert with 0, 50
                    mem[_713 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                    if 1 >= mem[_713]:
                        revert with 0, 50
                    mem[_713 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                    idx = 41
                    s = address(msg.sender)
                    while idx > 1:
                        if s % 16 >= 16:
                            revert with 0, 50
                        if idx >= mem[_713]:
                            revert with 0, 50
                        mem[idx + _713 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                        if not idx:
                            revert with 0, 17
                        idx = idx - 1
                        s = Mask(252, 0, s) * 0.0625
                        continue 
                    if msg.sender + 10240:
                        revert with 0, 'Strings: hex length insufficient'
                    _1429 = mem[64]
                    mem[mem[64]] = 66
                    mem[64] = mem[64] + 128
                    mem[_1429 + 32 len 66] = call.data[calldata.size len 66]
                    if 0 >= mem[_1429]:
                        revert with 0, 50
                    mem[_1429 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                    if 1 >= mem[_1429]:
                        revert with 0, 50
                    mem[_1429 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                    idx = 65
                    while idx > 1:
                        if idx >= mem[_1429]:
                            revert with 0, 50
                        mem[idx + _1429 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                        if not idx:
                            revert with 0, 17
                        idx = idx - 1
                        continue 
                    _1897 = mem[64]
                    mem[mem[64] + 32] = 'AccessControl: account '
                    _1903 = mem[_713]
                    idx = 0
                    while idx < _1903:
                        mem[idx + _1897 + 55] = mem[idx + _713 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1897 + _1903 + 55] = 0x206973206d697373696e6720726f6c6520000000000000000000000000000000
                    if ceil32(_1903) <= _1903:
                        _2093 = mem[_1429]
                        idx = 0
                        while idx < _2093:
                            mem[idx + _1897 + _1903 + 72] = mem[idx + _1429 + 32]
                            idx = idx + 32
                            continue 
                        if ceil32(_2093) <= _2093:
                            _2249 = mem[64]
                            mem[mem[64]] = _2093 + _1897 + _1903 + -mem[64] + 40
                            mem[64] = _2093 + _1897 + _1903 + 72
                            mem[_2093 + _1897 + _1903 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_2093 + _1897 + _1903 + 76] = 32
                            _2281 = mem[_2249]
                            mem[_2093 + _1897 + _1903 + 108] = mem[_2249]
                            idx = 0
                            while idx < _2281:
                                mem[idx + _2093 + _1897 + _1903 + 140] = mem[idx + _2249 + 32]
                                idx = idx + 32
                                continue 
                            if ceil32(_2281) > _2281:
                                mem[_2281 + _2093 + _1897 + _1903 + 140] = 0
                            revert with 0, 32, mem[_2093 + _1897 + _1903 + 108 len ceil32(_2281) + 32]
                        mem[_2093 + _1897 + _1903 + 72] = 0
                        _2250 = mem[64]
                        mem[mem[64]] = _2093 + _1897 + _1903 + -mem[64] + 40
                        mem[64] = _2093 + _1897 + _1903 + 72
                        mem[_2093 + _1897 + _1903 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[_2093 + _1897 + _1903 + 76] = 32
                        _2282 = mem[_2250]
                        mem[_2093 + _1897 + _1903 + 108] = mem[_2250]
                        idx = 0
                        while idx < _2282:
                            mem[idx + _2093 + _1897 + _1903 + 140] = mem[idx + _2250 + 32]
                            idx = idx + 32
                            continue 
                        if ceil32(_2282) > _2282:
                            mem[_2282 + _2093 + _1897 + _1903 + 140] = 0
                        revert with 0, 32, mem[_2093 + _1897 + _1903 + 108 len ceil32(_2282) + 32]
                    _2094 = mem[_1429]
                    idx = 0
                    while idx < _2094:
                        mem[idx + _1897 + _1903 + 72] = mem[idx + _1429 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_2094) <= _2094:
                        _2251 = mem[64]
                        mem[mem[64]] = _2094 + _1897 + _1903 + -mem[64] + 40
                        mem[64] = _2094 + _1897 + _1903 + 72
                        mem[_2094 + _1897 + _1903 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[_2094 + _1897 + _1903 + 76] = 32
                        _2283 = mem[_2251]
                        mem[_2094 + _1897 + _1903 + 108] = mem[_2251]
                        idx = 0
                        while idx < _2283:
                            mem[idx + _2094 + _1897 + _1903 + 140] = mem[idx + _2251 + 32]
                            idx = idx + 32
                            continue 
                        if ceil32(_2283) > _2283:
                            mem[_2283 + _2094 + _1897 + _1903 + 140] = 0
                        revert with 0, 32, mem[_2094 + _1897 + _1903 + 108 len ceil32(_2283) + 32]
                    mem[_2094 + _1897 + _1903 + 72] = 0
                    _2252 = mem[64]
                    mem[mem[64]] = _2094 + _1897 + _1903 + -mem[64] + 40
                    mem[64] = _2094 + _1897 + _1903 + 72
                    mem[_2094 + _1897 + _1903 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[_2094 + _1897 + _1903 + 76] = 32
                    _2284 = mem[_2252]
                    mem[_2094 + _1897 + _1903 + 108] = mem[_2252]
                    idx = 0
                    while idx < _2284:
                        mem[idx + _2094 + _1897 + _1903 + 140] = mem[idx + _2252 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_2284) > _2284:
                        mem[_2284 + _2094 + _1897 + _1903 + 140] = 0
                    revert with 0, 32, mem[_2094 + _1897 + _1903 + 108 len ceil32(_2284) + 32]
                require cd[((32 * idx) + cd[36] + 36)] > 0
                if sub_79920951[cd[4]] > -2:
                    revert with 0, 17
                if sub_79920951[cd[4]] + 1 > sub_fc86b662[cd[4]]:
                    revert with 0, 'Minting would exceed the max number of items for given type'
                if stor13[cd[((32 * idx) + cd[36] + 36)]]:
                    revert with 0, 'Supplied id is already used'
                if stor12[cd[4]]:
                    revert with 0, 'Given type is fungible'
                stor13[cd[((32 * idx) + cd[36] + 36)]] = 1
                if sub_79920951[cd[4]] > -2:
                    revert with 0, 17
                sub_79920951[cd[4]]++
                sub_0f699e80[cd[((32 * idx) + cd[36] + 36)]] = cd[4]
                mem[32] = 14
                mintNumber[cd[((32 * idx) + cd[36] + 36)]] = sub_79920951[cd[4]]
                _771 = mem[64]
                mem[mem[64]] = 0
                if not address(cd[((32 * idx) + cd[68] + 36)]):
                    revert with 0, 'ERC1155: mint to the zero address'
                if msg.sender != this.address:
                    mem[mem[64] + 32] = 1
                    mem[64] = mem[64] + 96
                    mem[_771 + 64] = cd[((32 * idx) + cd[36] + 36)]
                    mem[_771 + 96] = 1
                    mem[64] = _771 + 160
                    mem[_771 + 128] = 1
                    mem[0] = address(cd[((32 * idx) + cd[68] + 36)])
                    mem[32] = sha3(cd[((32 * idx) + cd[36] + 36)], 0)
                    if balanceOf[cd[((32 * idx) + cd[36] + 36)]][address(cd[((32 * idx) + cd[68] + 36)])] > -2:
                        revert with 0, 17
                    balanceOf[cd[((32 * idx) + cd[36] + 36)]][address(cd[((32 * idx) + cd[68] + 36)])]++
                    mem[_771 + 160] = cd[((32 * idx) + cd[36] + 36)]
                    mem[_771 + 192] = 1
                    emit TransferSingle(cd[((32 * idx) + cd[36] + 36)], 1, msg.sender, 0, address(cd[((32 * idx) + cd[68] + 36)]));
                    if ext_code.size(address(cd[((32 * idx) + cd[68] + 36)])):
                        mem[_771 + 160] = 0xf23a6e6100000000000000000000000000000000000000000000000000000000
                        mem[_771 + 164] = msg.sender
                        mem[_771 + 196] = 0
                        mem[_771 + 228] = cd[((32 * idx) + cd[36] + 36)]
                        mem[_771 + 260] = 1
                        mem[_771 + 292] = 160
                        mem[_771 + 324] = mem[_771]
                        s = 0
                        while s < mem[_771]:
                            mem[s + _771 + 356] = mem[s + _771 + 32]
                            s = s + 32
                            continue 
                        if ceil32(mem[_771]) > mem[_771]:
                            mem[mem[_771] + _771 + 356] = 0
                        require ext_code.size(address(cd[((32 * idx) + cd[68] + 36)]))
                        call address(cd[((32 * idx) + cd[68] + 36)]).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                             gas gas_remaining wei
                            args msg.sender, 0, cd[((32 * idx) + cd[36] + 36)], 1, 160, mem[_771], mem[_771 + 356 len ceil32(mem[_771])]
                        mem[_771 + 160] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                        mem[64] = _771 + ceil32(return_data.size) + 160
                        require return_data.size >= 32
                        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                        if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                            revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                else:
                    mem[64] = mem[64] + ceil32(calldata.size) + 64
                    mem[_771 + 32] = calldata.size
                    mem[_771 + 64 len calldata.size] = call.data[0 len calldata.size]
                    mem[_771 + calldata.size + 64] = 0
                    _790 = mem[calldata.size + _771 + 32]
                    mem[_771 + ceil32(calldata.size) + 64] = 1
                    mem[_771 + ceil32(calldata.size) + 96] = cd[((32 * idx) + cd[36] + 36)]
                    mem[_771 + ceil32(calldata.size) + 128] = 1
                    mem[64] = _771 + ceil32(calldata.size) + 192
                    mem[_771 + ceil32(calldata.size) + 160] = 1
                    mem[0] = address(cd[((32 * idx) + cd[68] + 36)])
                    mem[32] = sha3(cd[((32 * idx) + cd[36] + 36)], 0)
                    if balanceOf[cd[((32 * idx) + cd[36] + 36)]][address(cd[((32 * idx) + cd[68] + 36)])] > -2:
                        revert with 0, 17
                    balanceOf[cd[((32 * idx) + cd[36] + 36)]][address(cd[((32 * idx) + cd[68] + 36)])]++
                    mem[_771 + ceil32(calldata.size) + 192] = cd[((32 * idx) + cd[36] + 36)]
                    mem[_771 + ceil32(calldata.size) + 224] = 1
                    emit TransferSingle(cd[((32 * idx) + cd[36] + 36)], 1, address(_790), 0, address(cd[((32 * idx) + cd[68] + 36)]));
                    if ext_code.size(address(cd[((32 * idx) + cd[68] + 36)])):
                        mem[_771 + ceil32(calldata.size) + 192] = 0xf23a6e6100000000000000000000000000000000000000000000000000000000
                        mem[_771 + ceil32(calldata.size) + 196] = address(_790)
                        mem[_771 + ceil32(calldata.size) + 228] = 0
                        mem[_771 + ceil32(calldata.size) + 260] = cd[((32 * idx) + cd[36] + 36)]
                        mem[_771 + ceil32(calldata.size) + 292] = 1
                        mem[_771 + ceil32(calldata.size) + 324] = 160
                        mem[_771 + ceil32(calldata.size) + 356] = mem[_771]
                        s = 0
                        while s < mem[_771]:
                            mem[s + _771 + ceil32(calldata.size) + 388] = mem[s + _771 + 32]
                            s = s + 32
                            continue 
                        if ceil32(mem[_771]) > mem[_771]:
                            mem[mem[_771] + _771 + ceil32(calldata.size) + 388] = 0
                        require ext_code.size(address(cd[((32 * idx) + cd[68] + 36)]))
                        call address(cd[((32 * idx) + cd[68] + 36)]).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                             gas gas_remaining wei
                            args address(_790), 0, cd[((32 * idx) + cd[36] + 36)], 1, 160, mem[_771], mem[_771 + ceil32(calldata.size) + 388 len ceil32(mem[_771])]
                        mem[_771 + ceil32(calldata.size) + 192] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                        mem[64] = _771 + ceil32(calldata.size) + ceil32(return_data.size) + 192
                        require return_data.size >= 32
                        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                        if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                            revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
            else:
                _682 = mem[64]
                mem[64] = mem[64] + ceil32(calldata.size) + 32
                mem[_682] = calldata.size
                mem[_682 + 32 len calldata.size] = call.data[0 len calldata.size]
                mem[_682 + calldata.size + 32] = 0
                _683 = mem[calldata.size + _682]
                mem[0] = mem[calldata.size + _682 + 12 len 20]
                mem[32] = sha3(0, 2)
                if not uint8(roleAdmin[0][address(_683)].field_0):
                    _716 = mem[64]
                    mem[mem[64]] = 42
                    mem[64] = mem[64] + 96
                    mem[_716 + 32 len 42] = call.data[calldata.size len 42]
                    if 0 >= mem[_716]:
                        revert with 0, 50
                    mem[_716 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                    if 1 >= mem[_716]:
                        revert with 0, 50
                    mem[_716 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                    idx = 41
                    s = address(_683)
                    while idx > 1:
                        if s % 16 >= 16:
                            revert with 0, 50
                        if idx >= mem[_716]:
                            revert with 0, 50
                        mem[idx + _716 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                        if not idx:
                            revert with 0, 17
                        idx = idx - 1
                        s = Mask(252, 0, s) * 0.0625
                        continue 
                    if address(_683) + 10240:
                        revert with 0, 'Strings: hex length insufficient'
                    _1430 = mem[64]
                    mem[mem[64]] = 66
                    mem[64] = mem[64] + 128
                    mem[_1430 + 32 len 66] = call.data[calldata.size len 66]
                    if 0 >= mem[_1430]:
                        revert with 0, 50
                    mem[_1430 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                    if 1 >= mem[_1430]:
                        revert with 0, 50
                    mem[_1430 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                    idx = 65
                    while idx > 1:
                        if idx >= mem[_1430]:
                            revert with 0, 50
                        mem[idx + _1430 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                        if not idx:
                            revert with 0, 17
                        idx = idx - 1
                        continue 
                    _1898 = mem[64]
                    mem[mem[64] + 32] = 'AccessControl: account '
                    _1904 = mem[_716]
                    idx = 0
                    while idx < _1904:
                        mem[idx + _1898 + 55] = mem[idx + _716 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1898 + _1904 + 55] = 0x206973206d697373696e6720726f6c6520000000000000000000000000000000
                    if ceil32(_1904) <= _1904:
                        _2095 = mem[_1430]
                        idx = 0
                        while idx < _2095:
                            mem[idx + _1898 + _1904 + 72] = mem[idx + _1430 + 32]
                            idx = idx + 32
                            continue 
                        if ceil32(_2095) <= _2095:
                            _2253 = mem[64]
                            mem[mem[64]] = _2095 + _1898 + _1904 + -mem[64] + 40
                            mem[64] = _2095 + _1898 + _1904 + 72
                            mem[_2095 + _1898 + _1904 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_2095 + _1898 + _1904 + 76] = 32
                            _2285 = mem[_2253]
                            mem[_2095 + _1898 + _1904 + 108] = mem[_2253]
                            idx = 0
                            while idx < _2285:
                                mem[idx + _2095 + _1898 + _1904 + 140] = mem[idx + _2253 + 32]
                                idx = idx + 32
                                continue 
                            if ceil32(_2285) > _2285:
                                mem[_2285 + _2095 + _1898 + _1904 + 140] = 0
                            revert with 0, 32, mem[_2095 + _1898 + _1904 + 108 len ceil32(_2285) + 32]
                        mem[_2095 + _1898 + _1904 + 72] = 0
                        _2254 = mem[64]
                        mem[mem[64]] = _2095 + _1898 + _1904 + -mem[64] + 40
                        mem[64] = _2095 + _1898 + _1904 + 72
                        mem[_2095 + _1898 + _1904 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[_2095 + _1898 + _1904 + 76] = 32
                        _2286 = mem[_2254]
                        mem[_2095 + _1898 + _1904 + 108] = mem[_2254]
                        idx = 0
                        while idx < _2286:
                            mem[idx + _2095 + _1898 + _1904 + 140] = mem[idx + _2254 + 32]
                            idx = idx + 32
                            continue 
                        if ceil32(_2286) > _2286:
                            mem[_2286 + _2095 + _1898 + _1904 + 140] = 0
                        revert with 0, 32, mem[_2095 + _1898 + _1904 + 108 len ceil32(_2286) + 32]
                    _2096 = mem[_1430]
                    idx = 0
                    while idx < _2096:
                        mem[idx + _1898 + _1904 + 72] = mem[idx + _1430 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_2096) <= _2096:
                        _2255 = mem[64]
                        mem[mem[64]] = _2096 + _1898 + _1904 + -mem[64] + 40
                        mem[64] = _2096 + _1898 + _1904 + 72
                        mem[_2096 + _1898 + _1904 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[_2096 + _1898 + _1904 + 76] = 32
                        _2287 = mem[_2255]
                        mem[_2096 + _1898 + _1904 + 108] = mem[_2255]
                        idx = 0
                        while idx < _2287:
                            mem[idx + _2096 + _1898 + _1904 + 140] = mem[idx + _2255 + 32]
                            idx = idx + 32
                            continue 
                        if ceil32(_2287) > _2287:
                            mem[_2287 + _2096 + _1898 + _1904 + 140] = 0
                        revert with 0, 32, mem[_2096 + _1898 + _1904 + 108 len ceil32(_2287) + 32]
                    mem[_2096 + _1898 + _1904 + 72] = 0
                    _2256 = mem[64]
                    mem[mem[64]] = _2096 + _1898 + _1904 + -mem[64] + 40
                    mem[64] = _2096 + _1898 + _1904 + 72
                    mem[_2096 + _1898 + _1904 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[_2096 + _1898 + _1904 + 76] = 32
                    _2288 = mem[_2256]
                    mem[_2096 + _1898 + _1904 + 108] = mem[_2256]
                    idx = 0
                    while idx < _2288:
                        mem[idx + _2096 + _1898 + _1904 + 140] = mem[idx + _2256 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_2288) > _2288:
                        mem[_2288 + _2096 + _1898 + _1904 + 140] = 0
                    revert with 0, 32, mem[_2096 + _1898 + _1904 + 108 len ceil32(_2288) + 32]
                require cd[((32 * idx) + cd[36] + 36)] > 0
                if sub_79920951[cd[4]] > -2:
                    revert with 0, 17
                if sub_79920951[cd[4]] + 1 > sub_fc86b662[cd[4]]:
                    revert with 0, 'Minting would exceed the max number of items for given type'
                if stor13[cd[((32 * idx) + cd[36] + 36)]]:
                    revert with 0, 'Supplied id is already used'
                if stor12[cd[4]]:
                    revert with 0, 'Given type is fungible'
                stor13[cd[((32 * idx) + cd[36] + 36)]] = 1
                if sub_79920951[cd[4]] > -2:
                    revert with 0, 17
                sub_79920951[cd[4]]++
                sub_0f699e80[cd[((32 * idx) + cd[36] + 36)]] = cd[4]
                mem[32] = 14
                mintNumber[cd[((32 * idx) + cd[36] + 36)]] = sub_79920951[cd[4]]
                _772 = mem[64]
                mem[mem[64]] = 0
                if not address(cd[((32 * idx) + cd[68] + 36)]):
                    revert with 0, 'ERC1155: mint to the zero address'
                if msg.sender != this.address:
                    mem[mem[64] + 32] = 1
                    mem[64] = mem[64] + 96
                    mem[_772 + 64] = cd[((32 * idx) + cd[36] + 36)]
                    mem[_772 + 96] = 1
                    mem[64] = _772 + 160
                    mem[_772 + 128] = 1
                    mem[0] = address(cd[((32 * idx) + cd[68] + 36)])
                    mem[32] = sha3(cd[((32 * idx) + cd[36] + 36)], 0)
                    if balanceOf[cd[((32 * idx) + cd[36] + 36)]][address(cd[((32 * idx) + cd[68] + 36)])] > -2:
                        revert with 0, 17
                    balanceOf[cd[((32 * idx) + cd[36] + 36)]][address(cd[((32 * idx) + cd[68] + 36)])]++
                    mem[_772 + 160] = cd[((32 * idx) + cd[36] + 36)]
                    mem[_772 + 192] = 1
                    emit TransferSingle(cd[((32 * idx) + cd[36] + 36)], 1, msg.sender, 0, address(cd[((32 * idx) + cd[68] + 36)]));
                    if ext_code.size(address(cd[((32 * idx) + cd[68] + 36)])):
                        mem[_772 + 160] = 0xf23a6e6100000000000000000000000000000000000000000000000000000000
                        mem[_772 + 164] = msg.sender
                        mem[_772 + 196] = 0
                        mem[_772 + 228] = cd[((32 * idx) + cd[36] + 36)]
                        mem[_772 + 260] = 1
                        mem[_772 + 292] = 160
                        mem[_772 + 324] = mem[_772]
                        s = 0
                        while s < mem[_772]:
                            mem[s + _772 + 356] = mem[s + _772 + 32]
                            s = s + 32
                            continue 
                        if ceil32(mem[_772]) > mem[_772]:
                            mem[mem[_772] + _772 + 356] = 0
                        require ext_code.size(address(cd[((32 * idx) + cd[68] + 36)]))
                        call address(cd[((32 * idx) + cd[68] + 36)]).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                             gas gas_remaining wei
                            args msg.sender, 0, cd[((32 * idx) + cd[36] + 36)], 1, 160, mem[_772], mem[_772 + 356 len ceil32(mem[_772])]
                        mem[_772 + 160] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                        mem[64] = _772 + ceil32(return_data.size) + 160
                        require return_data.size >= 32
                        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                        if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                            revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                else:
                    mem[64] = mem[64] + ceil32(calldata.size) + 64
                    mem[_772 + 32] = calldata.size
                    mem[_772 + 64 len calldata.size] = call.data[0 len calldata.size]
                    mem[_772 + calldata.size + 64] = 0
                    _792 = mem[calldata.size + _772 + 32]
                    mem[_772 + ceil32(calldata.size) + 64] = 1
                    mem[_772 + ceil32(calldata.size) + 96] = cd[((32 * idx) + cd[36] + 36)]
                    mem[_772 + ceil32(calldata.size) + 128] = 1
                    mem[64] = _772 + ceil32(calldata.size) + 192
                    mem[_772 + ceil32(calldata.size) + 160] = 1
                    mem[0] = address(cd[((32 * idx) + cd[68] + 36)])
                    mem[32] = sha3(cd[((32 * idx) + cd[36] + 36)], 0)
                    if balanceOf[cd[((32 * idx) + cd[36] + 36)]][address(cd[((32 * idx) + cd[68] + 36)])] > -2:
                        revert with 0, 17
                    balanceOf[cd[((32 * idx) + cd[36] + 36)]][address(cd[((32 * idx) + cd[68] + 36)])]++
                    mem[_772 + ceil32(calldata.size) + 192] = cd[((32 * idx) + cd[36] + 36)]
                    mem[_772 + ceil32(calldata.size) + 224] = 1
                    emit TransferSingle(cd[((32 * idx) + cd[36] + 36)], 1, address(_792), 0, address(cd[((32 * idx) + cd[68] + 36)]));
                    if ext_code.size(address(cd[((32 * idx) + cd[68] + 36)])):
                        mem[_772 + ceil32(calldata.size) + 192] = 0xf23a6e6100000000000000000000000000000000000000000000000000000000
                        mem[_772 + ceil32(calldata.size) + 196] = address(_792)
                        mem[_772 + ceil32(calldata.size) + 228] = 0
                        mem[_772 + ceil32(calldata.size) + 260] = cd[((32 * idx) + cd[36] + 36)]
                        mem[_772 + ceil32(calldata.size) + 292] = 1
                        mem[_772 + ceil32(calldata.size) + 324] = 160
                        mem[_772 + ceil32(calldata.size) + 356] = mem[_772]
                        s = 0
                        while s < mem[_772]:
                            mem[s + _772 + ceil32(calldata.size) + 388] = mem[s + _772 + 32]
                            s = s + 32
                            continue 
                        if ceil32(mem[_772]) > mem[_772]:
                            mem[mem[_772] + _772 + ceil32(calldata.size) + 388] = 0
                        require ext_code.size(address(cd[((32 * idx) + cd[68] + 36)]))
                        call address(cd[((32 * idx) + cd[68] + 36)]).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                             gas gas_remaining wei
                            args address(_792), 0, cd[((32 * idx) + cd[36] + 36)], 1, 160, mem[_772], mem[_772 + ceil32(calldata.size) + 388 len ceil32(mem[_772])]
                        mem[_772 + ceil32(calldata.size) + 192] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                        mem[64] = _772 + ceil32(calldata.size) + ceil32(return_data.size) + 192
                        require return_data.size >= 32
                        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                        if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                            revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _668 = mem[64]
        mem[mem[64]] = cd[4]
        mem[mem[64] + 32] = 96
        mem[mem[64] + 96] = ('cd', 36).length
        require ('cd', 36).length <= 0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
        mem[mem[64] + 128 len 32 * ('cd', 36).length] = call.data[cd[36] + 36 len 32 * ('cd', 36).length]
        mem[mem[64] + 64] = (32 * ('cd', 36).length) + 128
        mem[_668 + (32 * ('cd', 36).length) + 128] = ('cd', 68).length
        idx = 0
        s = cd[68] + 36
        t = _668 + (32 * ('cd', 36).length) + 160
        while idx < ('cd', 68).length:
            require cd[s] == address(cd[s])
            mem[t] = address(cd[s])
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        emit 0x16a6af95: mem[mem[64] len _668 + (32 * ('cd', 36).length) + (32 * ('cd', 68).length) + -mem[64] + 160]
}

function deposit(address arg1, bytes arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 <= test266151307()
    require arg2 + 35 < calldata.size
    require arg2.length <= test266151307()
    require arg2 + arg2.length + 36 <= calldata.size
    if msg.sender != this.address:
        mem[0] = msg.sender
        if not uint8(roleAdmin[0x8f4f2da22e8ac8f11e15f9fc141cddbb5deea8800186560abb6e68c5496619a9][address(msg.sender)].field_0):
            mem[128 len 42] = call.data[calldata.size len 42]
            idx = 41
            s = address(msg.sender)
            while idx > 1:
                if s % 16 >= 16:
                    revert with 0, 50
                if idx >= 42:
                    revert with 0, 50
                mem[idx + 128 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                if not idx:
                    revert with 0, 17
                idx = idx - 1
                s = Mask(252, 0, s) * 0.0625
                continue 
            if msg.sender + 10240:
                revert with 0, 'Strings: hex length insufficient'
            mem[224 len 66] = call.data[calldata.size len 66]
            idx = 65
            s = 0x8f4f2da22e8ac8f11e15f9fc141cddbb5deea8800186560abb6e68c5496619a9
            while idx > 1:
                if s % 16 >= 16:
                    revert with 0, 50
                if idx >= 66:
                    revert with 0, 50
                mem[idx + 224 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                if not idx:
                    revert with 0, 17
                idx = idx - 1
                s = Mask(252, 0, s) * 0.0625
                continue 
            revert with 0, 32, 148, 'AccessControl: account ', mem[160 len 42], 8297, mem[288 len 66], 0, 0 >> 928, 0
        require arg2.length >= 96
        require cd[(arg2 + 36)] <= test266151307()
        require arg2 + cd[(arg2 + 36)] + 67 < arg2 + arg2.length + 36
        if cd[(arg2 + cd[(arg2 + 36)] + 36)] > test266151307():
            revert with 0, 65
        if ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 97 < 96 or ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 97 > test266151307():
            revert with 0, 65
        mem[96] = cd[(arg2 + cd[(arg2 + 36)] + 36)]
        require cd[(arg2 + 36)] + (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 68 <= arg2.length + 36
        idx = arg2 + cd[(arg2 + 36)] + 68
        s = 128
        while idx < arg2 + cd[(arg2 + 36)] + (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 68:
            mem[s] = cd[idx]
            idx = idx + 32
            s = s + 32
            continue 
        require cd[(arg2 + 68)] <= test266151307()
        require arg2 + cd[(arg2 + 68)] + 67 < arg2 + arg2.length + 36
        if cd[(arg2 + cd[(arg2 + 68)] + 36)] > test266151307():
            revert with 0, 65
        if ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + 98 < 97 or ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + 98 > test266151307():
            revert with 0, 65
        mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 97] = cd[(arg2 + cd[(arg2 + 68)] + 36)]
        require cd[(arg2 + 68)] + (32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + 68 <= arg2.length + 36
        idx = arg2 + cd[(arg2 + 68)] + 68
        s = ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 129
        while idx < arg2 + cd[(arg2 + 68)] + (32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + 68:
            mem[s] = cd[idx]
            idx = idx + 32
            s = s + 32
            continue 
        require cd[(arg2 + 100)] <= test266151307()
        require arg2 + cd[(arg2 + 100)] + 67 < arg2 + arg2.length + 36
        if cd[(arg2 + cd[(arg2 + 100)] + 36)] > test266151307():
            revert with 0, 65
        if ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 99 < 98 or ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 99 > test266151307():
            revert with 0, 65
        mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + 98] = cd[(arg2 + cd[(arg2 + 100)] + 36)]
        require cd[(arg2 + 100)] + cd[(arg2 + cd[(arg2 + 100)] + 36)] + 68 <= arg2.length + 36
        mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + 130 len cd[(arg2 + cd[(arg2 + 100)] + 36)]] = call.data[arg2 + cd[(arg2 + 100)] + 68 len cd[(arg2 + cd[(arg2 + 100)] + 36)]]
        mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + cd[(arg2 + cd[(arg2 + 100)] + 36)] + 130] = 0
        if not arg1:
            revert with 0, 'ChildMintableERC1155: INVALID_DEPOSIT_USER'
        if cd[(arg2 + cd[(arg2 + 36)] + 36)] != cd[(arg2 + cd[(arg2 + 68)] + 36)]:
            revert with 0, 'ERC1155: ids and amounts length mismatch'
        if msg.sender != this.address:
            idx = 0
            while idx < cd[(arg2 + cd[(arg2 + 36)] + 36)]:
                if idx >= cd[(arg2 + cd[(arg2 + 68)] + 36)]:
                    revert with 0, 50
                if idx >= cd[(arg2 + cd[(arg2 + 36)] + 36)]:
                    revert with 0, 50
                mem[0] = arg1
                mem[32] = sha3(mem[(32 * idx) + 128], 0)
                if balanceOf[mem[(32 * idx) + 128]][address(arg1)] > !mem[(32 * idx) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 129]:
                    revert with 0, 17
                balanceOf[mem[(32 * idx) + 128]][address(arg1)] += mem[(32 * idx) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 129]
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 99] = 64
            mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 195 len 32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]] = mem[128 len 32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]]
            mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 195] = cd[(arg2 + cd[(arg2 + 68)] + 36)]
            mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 227 len 32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]] = mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 129 len 32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]]
            emit TransferBatch(Array(len=cd[(arg2 + cd[(arg2 + 36)] + 36)], data=mem[128 len 32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]], cd[(arg2 + cd[(arg2 + 68)] + 36)], mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 129 len 32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]]), (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 96, msg.sender, 0, arg1);
            if not ext_code.size(arg1):
            mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 99] = 0xbc197c8100000000000000000000000000000000000000000000000000000000
            mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 103] = msg.sender
            mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 135] = 0
            mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 167] = 160
            mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 263] = cd[(arg2 + cd[(arg2 + 36)] + 36)]
            mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 295 len 32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]] = mem[128 len 32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]]
            mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 199] = (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 192
            mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 295] = cd[(arg2 + cd[(arg2 + 68)] + 36)]
            mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 327 len 32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]] = mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 129 len 32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]]
            mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 231] = (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + (32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + 224
            mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + (32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + 327] = cd[(arg2 + cd[(arg2 + 100)] + 36)]
            mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + (32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + 359 len ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])] = call.data[arg2 + cd[(arg2 + 100)] + 68 len cd[(arg2 + cd[(arg2 + 100)] + 36)]], Mask(8 * ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)]) - cd[(arg2 + cd[(arg2 + 100)] + 36)], -(8 * ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)]) + -ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 27) + 256, msg.sender) >> -(8 * ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)]) + -ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 27) + 256
            if ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)]) <= cd[(arg2 + cd[(arg2 + 100)] + 36)]:
                require ext_code.size(arg1)
                call arg1.onERC1155BatchReceived(address rg1, address rg2, uint256[] rg3, uint256[] rg4, bytes rg5) with:
                     gas gas_remaining wei
                    args msg.sender, 0, 160, (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 192, (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + (32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + 224, cd[(arg2 + cd[(arg2 + 36)] + 36)], mem[128 len 32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]], cd[(arg2 + cd[(arg2 + 68)] + 36)], mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 129 len 32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]], cd[(arg2 + cd[(arg2 + 100)] + 36)], call.data[arg2 + cd[(arg2 + 100)] + 68 len cd[(arg2 + cd[(arg2 + 100)] + 36)]], Mask(8 * ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)]) - cd[(arg2 + cd[(arg2 + 100)] + 36)], -(8 * ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)]) + -ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 27) + 256, msg.sender) >> -(8 * ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)]) + -ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 27) + 256
                mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 99] = ext_call.return_data[0]
                if ext_call.success:
                    require return_data.size >= 32
                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                    if Mask(32, 224, ext_call.return_data[0]) != 0xbc197c8100000000000000000000000000000000000000000000000000000000:
                        revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                if return_data.size <= 3:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                mem[0 len 4] = ext_call.return_data[0 len 4]
                if uint32(mem[4 len 28]) >> 224 != Error(string rg1):
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if return_data.size < 68:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 99 len return_data.size - 4] = ext_call.return_data[4 len return_data.size - 4]
                if ext_call.return_data[0] > test266151307() or ext_call.return_data[0] + 36 > return_data.size:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 99] > test266151307():
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if ext_call.return_data[0] + mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 99] + 32 > return_data.size - 4:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if floor32(ext_call.return_data[0] + mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 99] + 31) + 100 < 99 or ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + floor32(ext_call.return_data[0] + mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 99] + 31) + 100 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + floor32(ext_call.return_data[0] + mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 99] + 31) + 100
                if not ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 99:
                    mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + floor32(ext_call.return_data[0] + mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 99] + 31) + 100] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    revert with mem[mem[64] len 4], 'ERC1155: transfer to non ERC1155Receiver implementer'
                _2663 = ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + floor32(ext_call.return_data[0] + mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 99] + 31) + 100
                mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + floor32(ext_call.return_data[0] + mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 99] + 31) + 100] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                _2679 = mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 99]
                mem[mem[64] + 36] = mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 99]
                mem[mem[64] + 68 len ceil32(_2679)] = mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 131 len ceil32(_2679)]
                if ceil32(_2679) <= _2679:
                    revert with mem[mem[64] len 4], 32, mem[mem[64] + 36 len ceil32(_2679) + 32]
                mem[_2679 + mem[64] + 68] = 0
                revert with memory
                  from mem[64]
                   len ceil32(_2679) + _2663 + -mem[64] + 68
            mem[cd[(arg2 + cd[(arg2 + 100)] + 36)] + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + (32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + 359] = 0
            require ext_code.size(arg1)
            call arg1.onERC1155BatchReceived(address rg1, address rg2, uint256[] rg3, uint256[] rg4, bytes rg5) with:
                 gas gas_remaining wei
                args msg.sender, 0, 160, (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 192, (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + (32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + 224, cd[(arg2 + cd[(arg2 + 36)] + 36)], mem[128 len 32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]], cd[(arg2 + cd[(arg2 + 68)] + 36)], mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 129 len 32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]], cd[(arg2 + cd[(arg2 + 100)] + 36)], call.data[arg2 + cd[(arg2 + 100)] + 68 len cd[(arg2 + cd[(arg2 + 100)] + 36)]], Mask(8 * ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)]) - cd[(arg2 + cd[(arg2 + 100)] + 36)], -(8 * ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)]) + -ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 27) + 256, msg.sender) >> -(8 * ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)]) + -ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 27) + 256
            mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 99] = ext_call.return_data[0]
            if ext_call.success:
                require return_data.size >= 32
                require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                if Mask(32, 224, ext_call.return_data[0]) != 0xbc197c8100000000000000000000000000000000000000000000000000000000:
                    revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
            if return_data.size <= 3:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            mem[0 len 4] = ext_call.return_data[0 len 4]
            if uint32(mem[4 len 28]) >> 224 != Error(string rg1):
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if return_data.size < 68:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 99 len return_data.size - 4] = ext_call.return_data[4 len return_data.size - 4]
            if ext_call.return_data[0] > test266151307() or ext_call.return_data[0] + 36 > return_data.size:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 99] > test266151307():
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if ext_call.return_data[0] + mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 99] + 32 > return_data.size - 4:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if floor32(ext_call.return_data[0] + mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 99] + 31) + 100 < 99 or ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + floor32(ext_call.return_data[0] + mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 99] + 31) + 100 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + floor32(ext_call.return_data[0] + mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 99] + 31) + 100
            if not ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 99:
                mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + floor32(ext_call.return_data[0] + mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 99] + 31) + 100] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                revert with mem[mem[64] len 4], 'ERC1155: transfer to non ERC1155Receiver implementer'
            _2664 = ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + floor32(ext_call.return_data[0] + mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 99] + 31) + 100
            mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + floor32(ext_call.return_data[0] + mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 99] + 31) + 100] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            _2681 = mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 99]
            mem[mem[64] + 36] = mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 99]
            mem[mem[64] + 68 len ceil32(_2681)] = mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 131 len ceil32(_2681)]
            if ceil32(_2681) <= _2681:
                revert with mem[mem[64] len 4], 32, mem[mem[64] + 36 len ceil32(_2681) + 32]
            mem[_2681 + mem[64] + 68] = 0
            revert with memory
              from mem[64]
               len ceil32(_2681) + _2664 + -mem[64] + 68
        mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 99] = calldata.size
        mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 131 len calldata.size] = call.data[0 len calldata.size]
        mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + calldata.size + 131] = 0
        idx = 0
        while idx < cd[(arg2 + cd[(arg2 + 36)] + 36)]:
            if idx >= cd[(arg2 + cd[(arg2 + 68)] + 36)]:
                revert with 0, 50
            if idx >= cd[(arg2 + cd[(arg2 + 36)] + 36)]:
                revert with 0, 50
            mem[0] = arg1
            mem[32] = sha3(mem[(32 * idx) + 128], 0)
            if balanceOf[mem[(32 * idx) + 128]][address(arg1)] > !mem[(32 * idx) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 129]:
                revert with 0, 17
            balanceOf[mem[(32 * idx) + 128]][address(arg1)] += mem[(32 * idx) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 129]
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + 227 len 32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]] = mem[128 len 32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]]
        mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 227] = cd[(arg2 + cd[(arg2 + 68)] + 36)]
        mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 259 len 32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]] = mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 129 len 32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]]
        emit TransferBatch(Array(len=cd[(arg2 + cd[(arg2 + 36)] + 36)], data=mem[128 len 32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]], cd[(arg2 + cd[(arg2 + 68)] + 36)], mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 129 len 32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]]), (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 96, mem[calldata.size + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 111 len 20], 0, arg1);
        if not ext_code.size(arg1):
        mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + 135] = mem[calldata.size + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 111 len 20]
        mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + 167] = 0
        mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + 199] = 160
        mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + 295] = cd[(arg2 + cd[(arg2 + 36)] + 36)]
        mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + 327 len 32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]] = mem[128 len 32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]]
        mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + 231] = (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 192
        mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 327] = cd[(arg2 + cd[(arg2 + 68)] + 36)]
        mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 359 len 32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]] = mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 129 len 32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]]
        mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + 263] = (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + (32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + 224
        mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + (32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + 359] = cd[(arg2 + cd[(arg2 + 100)] + 36)]
        mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + (32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + 391 len ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])] = call.data[arg2 + cd[(arg2 + 100)] + 68 len cd[(arg2 + cd[(arg2 + 100)] + 36)]], Mask(8 * ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)]) - cd[(arg2 + cd[(arg2 + 100)] + 36)], -(8 * ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)]) + -ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 31) + 256, calldata.size) >> -(8 * ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)]) + -ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 31) + 256
        if ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)]) <= cd[(arg2 + cd[(arg2 + 100)] + 36)]:
            require ext_code.size(arg1)
            call arg1.onERC1155BatchReceived(address rg1, address rg2, uint256[] rg3, uint256[] rg4, bytes rg5) with:
                 gas gas_remaining wei
                args address(mem[calldata.size + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 99]), 0, 160, (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 192, (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + (32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + 224, cd[(arg2 + cd[(arg2 + 36)] + 36)], mem[128 len 32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]], cd[(arg2 + cd[(arg2 + 68)] + 36)], mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 129 len 32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]], cd[(arg2 + cd[(arg2 + 100)] + 36)], call.data[arg2 + cd[(arg2 + 100)] + 68 len cd[(arg2 + cd[(arg2 + 100)] + 36)]], Mask(8 * ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)]) - cd[(arg2 + cd[(arg2 + 100)] + 36)], -(8 * ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)]) + -ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 31) + 256, calldata.size) >> -(8 * ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)]) + -ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 31) + 256
            mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + 131] = ext_call.return_data[0]
            if ext_call.success:
                require return_data.size >= 32
                require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                if Mask(32, 224, ext_call.return_data[0]) != 0xbc197c8100000000000000000000000000000000000000000000000000000000:
                    revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
            if return_data.size <= 3:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            mem[0 len 4] = ext_call.return_data[0 len 4]
            if uint32(mem[4 len 28]) >> 224 != Error(string rg1):
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if return_data.size < 68:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + 131 len return_data.size - 4] = ext_call.return_data[4 len return_data.size - 4]
            if ext_call.return_data[0] > test266151307() or ext_call.return_data[0] + 36 > return_data.size:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + ext_call.return_data[0] + 131] > test266151307():
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if ext_call.return_data[0] + mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 32 > return_data.size - 4:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if floor32(ext_call.return_data[0] + mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132 < 131 or ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132
            if not ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + ext_call.return_data[0] + 131:
                mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                revert with mem[mem[64] len 4], 'ERC1155: transfer to non ERC1155Receiver implementer'
            _2665 = ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132
            mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            _2683 = mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + ext_call.return_data[0] + 131]
            mem[mem[64] + 36] = mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + ext_call.return_data[0] + 131]
            mem[mem[64] + 68 len ceil32(_2683)] = mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + ext_call.return_data[0] + 163 len ceil32(_2683)]
            if ceil32(_2683) <= _2683:
                revert with mem[mem[64] len 4], 32, mem[mem[64] + 36 len ceil32(_2683) + 32]
            mem[_2683 + mem[64] + 68] = 0
            revert with memory
              from mem[64]
               len ceil32(_2683) + _2665 + -mem[64] + 68
        mem[cd[(arg2 + cd[(arg2 + 100)] + 36)] + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + (32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + 391] = 0
        require ext_code.size(arg1)
        call arg1.onERC1155BatchReceived(address rg1, address rg2, uint256[] rg3, uint256[] rg4, bytes rg5) with:
             gas gas_remaining wei
            args address(mem[calldata.size + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 99]), 0, 160, (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 192, (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + (32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + 224, cd[(arg2 + cd[(arg2 + 36)] + 36)], mem[128 len 32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]], cd[(arg2 + cd[(arg2 + 68)] + 36)], mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 129 len 32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]], cd[(arg2 + cd[(arg2 + 100)] + 36)], call.data[arg2 + cd[(arg2 + 100)] + 68 len cd[(arg2 + cd[(arg2 + 100)] + 36)]], Mask(8 * ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)]) - cd[(arg2 + cd[(arg2 + 100)] + 36)], -(8 * ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)]) + -ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 31) + 256, calldata.size) >> -(8 * ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)]) + -ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 31) + 256
        mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + 131] = ext_call.return_data[0]
        if ext_call.success:
            require return_data.size >= 32
            require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
            if Mask(32, 224, ext_call.return_data[0]) != 0xbc197c8100000000000000000000000000000000000000000000000000000000:
                revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
        if return_data.size <= 3:
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        mem[0 len 4] = ext_call.return_data[0 len 4]
        if uint32(mem[4 len 28]) >> 224 != Error(string rg1):
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        if return_data.size < 68:
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + 131 len return_data.size - 4] = ext_call.return_data[4 len return_data.size - 4]
        if ext_call.return_data[0] > test266151307() or ext_call.return_data[0] + 36 > return_data.size:
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        if mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + ext_call.return_data[0] + 131] > test266151307():
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        if ext_call.return_data[0] + mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 32 > return_data.size - 4:
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        if floor32(ext_call.return_data[0] + mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132 < 131 or ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132 > test266151307():
            revert with 0, 65
        mem[64] = ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132
        if not ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + ext_call.return_data[0] + 131:
            mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            revert with mem[mem[64] len 4], 'ERC1155: transfer to non ERC1155Receiver implementer'
        _2666 = ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132
        mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        _2685 = mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + ext_call.return_data[0] + 131]
        mem[mem[64] + 36] = mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + ext_call.return_data[0] + 131]
        mem[mem[64] + 68 len ceil32(_2685)] = mem[ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ceil32(calldata.size) + ext_call.return_data[0] + 163 len ceil32(_2685)]
        if ceil32(_2685) <= _2685:
            revert with mem[mem[64] len 4], 32, mem[mem[64] + 36 len ceil32(_2685) + 32]
        mem[_2685 + mem[64] + 68] = 0
        revert with memory
          from mem[64]
           len ceil32(_2685) + _2666 + -mem[64] + 68
    mem[96] = calldata.size
    mem[128 len calldata.size] = call.data[0 len calldata.size]
    mem[calldata.size + 128] = 0
    mem[0] = mem[calldata.size + 108 len 20]
    if not uint8(roleAdmin[0x8f4f2da22e8ac8f11e15f9fc141cddbb5deea8800186560abb6e68c5496619a9][address(mem[calldata.size + 96])].field_0):
        mem[ceil32(calldata.size) + 160 len 42] = call.data[calldata.size len 42]
        idx = 41
        s = mem[calldata.size + 108 len 20]
        while idx > 1:
            if s % 16 >= 16:
                revert with 0, 50
            if idx >= 42:
                revert with 0, 50
            mem[idx + ceil32(calldata.size) + 160 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
            if not idx:
                revert with 0, 17
            idx = idx - 1
            s = Mask(252, 0, s) * 0.0625
            continue 
        if mem[calldata.size + 108 len 20] + 10240:
            revert with 0, 'Strings: hex length insufficient'
        mem[ceil32(calldata.size) + 256 len 66] = call.data[calldata.size len 66]
        idx = 65
        s = 0x8f4f2da22e8ac8f11e15f9fc141cddbb5deea8800186560abb6e68c5496619a9
        while idx > 1:
            if s % 16 >= 16:
                revert with 0, 50
            if idx >= 66:
                revert with 0, 50
            mem[idx + ceil32(calldata.size) + 256 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
            if not idx:
                revert with 0, 17
            idx = idx - 1
            s = Mask(252, 0, s) * 0.0625
            continue 
        revert with 0, 
                    32,
                    148,
                    'AccessControl: account ', mem[ceil32(calldata.size) + 192 len 42], 8297, mem[ceil32(calldata.size) + 320 len 66], 0, 0 >> 928,
                    0
    require arg2.length >= 96
    require cd[(arg2 + 36)] <= test266151307()
    require arg2 + cd[(arg2 + 36)] + 67 < arg2 + arg2.length + 36
    if cd[(arg2 + cd[(arg2 + 36)] + 36)] > test266151307():
        revert with 0, 65
    if ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 129 < 128 or ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 129 > test266151307():
        revert with 0, 65
    mem[ceil32(calldata.size) + 128] = cd[(arg2 + cd[(arg2 + 36)] + 36)]
    require cd[(arg2 + 36)] + (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 68 <= arg2.length + 36
    idx = arg2 + cd[(arg2 + 36)] + 68
    s = ceil32(calldata.size) + 160
    while idx < arg2 + cd[(arg2 + 36)] + (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 68:
        mem[s] = cd[idx]
        idx = idx + 32
        s = s + 32
        continue 
    require cd[(arg2 + 68)] <= test266151307()
    require arg2 + cd[(arg2 + 68)] + 67 < arg2 + arg2.length + 36
    if cd[(arg2 + cd[(arg2 + 68)] + 36)] > test266151307():
        revert with 0, 65
    if ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + 130 < 129 or ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + 130 > test266151307():
        revert with 0, 65
    mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 129] = cd[(arg2 + cd[(arg2 + 68)] + 36)]
    require cd[(arg2 + 68)] + (32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + 68 <= arg2.length + 36
    idx = arg2 + cd[(arg2 + 68)] + 68
    s = ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 161
    while idx < arg2 + cd[(arg2 + 68)] + (32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + 68:
        mem[s] = cd[idx]
        idx = idx + 32
        s = s + 32
        continue 
    require cd[(arg2 + 100)] <= test266151307()
    require arg2 + cd[(arg2 + 100)] + 67 < arg2 + arg2.length + 36
    if cd[(arg2 + cd[(arg2 + 100)] + 36)] > test266151307():
        revert with 0, 65
    if ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 131 < 130 or ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 131 > test266151307():
        revert with 0, 65
    mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + 130] = cd[(arg2 + cd[(arg2 + 100)] + 36)]
    require cd[(arg2 + 100)] + cd[(arg2 + cd[(arg2 + 100)] + 36)] + 68 <= arg2.length + 36
    mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + 162 len cd[(arg2 + cd[(arg2 + 100)] + 36)]] = call.data[arg2 + cd[(arg2 + 100)] + 68 len cd[(arg2 + cd[(arg2 + 100)] + 36)]]
    mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + cd[(arg2 + cd[(arg2 + 100)] + 36)] + 162] = 0
    if not arg1:
        revert with 0, 'ChildMintableERC1155: INVALID_DEPOSIT_USER'
    if cd[(arg2 + cd[(arg2 + 36)] + 36)] != cd[(arg2 + cd[(arg2 + 68)] + 36)]:
        revert with 0, 'ERC1155: ids and amounts length mismatch'
    if msg.sender != this.address:
        idx = 0
        while idx < cd[(arg2 + cd[(arg2 + 36)] + 36)]:
            if idx >= cd[(arg2 + cd[(arg2 + 68)] + 36)]:
                revert with 0, 50
            if idx >= cd[(arg2 + cd[(arg2 + 36)] + 36)]:
                revert with 0, 50
            mem[0] = arg1
            mem[32] = sha3(mem[(32 * idx) + ceil32(calldata.size) + 160], 0)
            if balanceOf[mem[(32 * idx) + ceil32(calldata.size) + 160]][address(arg1)] > !mem[(32 * idx) + ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 161]:
                revert with 0, 17
            balanceOf[mem[(32 * idx) + ceil32(calldata.size) + 160]][address(arg1)] += mem[(32 * idx) + ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 161]
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 131] = 64
        mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 227 len 32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]] = mem[ceil32(calldata.size) + 160 len 32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]]
        mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 227] = cd[(arg2 + cd[(arg2 + 68)] + 36)]
        mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 259 len 32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]] = mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 161 len 32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]]
        emit TransferBatch(Array(len=cd[(arg2 + cd[(arg2 + 36)] + 36)], data=mem[ceil32(calldata.size) + 160 len 32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]], cd[(arg2 + cd[(arg2 + 68)] + 36)], mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 161 len 32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]]), (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 96, msg.sender, 0, arg1);
        if not ext_code.size(arg1):
        mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 131] = 0xbc197c8100000000000000000000000000000000000000000000000000000000
        mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 135] = msg.sender
        mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 167] = 0
        mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 199] = 160
        mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 295] = cd[(arg2 + cd[(arg2 + 36)] + 36)]
        mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 327 len 32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]] = mem[ceil32(calldata.size) + 160 len 32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]]
        mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 231] = (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 192
        mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 327] = cd[(arg2 + cd[(arg2 + 68)] + 36)]
        mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 359 len 32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]] = mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 161 len 32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]]
        mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 263] = (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + (32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + 224
        mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + (32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + 359] = cd[(arg2 + cd[(arg2 + 100)] + 36)]
        mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + (32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + 391 len ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])] = call.data[arg2 + cd[(arg2 + 100)] + 68 len cd[(arg2 + cd[(arg2 + 100)] + 36)]], Mask(8 * ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)]) - cd[(arg2 + cd[(arg2 + 100)] + 36)], -(8 * ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)]) + -ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 27) + 256, msg.sender) >> -(8 * ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)]) + -ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 27) + 256
        if ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)]) <= cd[(arg2 + cd[(arg2 + 100)] + 36)]:
            require ext_code.size(arg1)
            call arg1.onERC1155BatchReceived(address rg1, address rg2, uint256[] rg3, uint256[] rg4, bytes rg5) with:
                 gas gas_remaining wei
                args msg.sender, 0, 160, (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 192, (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + (32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + 224, cd[(arg2 + cd[(arg2 + 36)] + 36)], mem[ceil32(calldata.size) + 160 len 32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]], cd[(arg2 + cd[(arg2 + 68)] + 36)], mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 161 len 32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]], cd[(arg2 + cd[(arg2 + 100)] + 36)], call.data[arg2 + cd[(arg2 + 100)] + 68 len cd[(arg2 + cd[(arg2 + 100)] + 36)]], Mask(8 * ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)]) - cd[(arg2 + cd[(arg2 + 100)] + 36)], -(8 * ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)]) + -ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 27) + 256, msg.sender) >> -(8 * ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)]) + -ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 27) + 256
            mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 131] = ext_call.return_data[0]
            if ext_call.success:
                require return_data.size >= 32
                require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                if Mask(32, 224, ext_call.return_data[0]) != 0xbc197c8100000000000000000000000000000000000000000000000000000000:
                    revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
            if return_data.size <= 3:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            mem[0 len 4] = ext_call.return_data[0 len 4]
            if uint32(mem[4 len 28]) >> 224 != Error(string rg1):
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if return_data.size < 68:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 131 len return_data.size - 4] = ext_call.return_data[4 len return_data.size - 4]
            if ext_call.return_data[0] > test266151307() or ext_call.return_data[0] + 36 > return_data.size:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 131] > test266151307():
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if ext_call.return_data[0] + mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 131] + 32 > return_data.size - 4:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if floor32(ext_call.return_data[0] + mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 131] + 31) + 132 < 131 or ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + floor32(ext_call.return_data[0] + mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 131] + 31) + 132 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + floor32(ext_call.return_data[0] + mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 131] + 31) + 132
            if not ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 131:
                mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + floor32(ext_call.return_data[0] + mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 131] + 31) + 132] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                revert with mem[mem[64] len 4], 'ERC1155: transfer to non ERC1155Receiver implementer'
            _2667 = ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + floor32(ext_call.return_data[0] + mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 131] + 31) + 132
            mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + floor32(ext_call.return_data[0] + mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 131] + 31) + 132] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            _2687 = mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 131]
            mem[mem[64] + 36] = mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 131]
            mem[mem[64] + 68 len ceil32(_2687)] = mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 163 len ceil32(_2687)]
            if ceil32(_2687) <= _2687:
                revert with mem[mem[64] len 4], 32, mem[mem[64] + 36 len ceil32(_2687) + 32]
            mem[_2687 + mem[64] + 68] = 0
            revert with memory
              from mem[64]
               len ceil32(_2687) + _2667 + -mem[64] + 68
        mem[cd[(arg2 + cd[(arg2 + 100)] + 36)] + ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + (32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + 391] = 0
        require ext_code.size(arg1)
        call arg1.onERC1155BatchReceived(address rg1, address rg2, uint256[] rg3, uint256[] rg4, bytes rg5) with:
             gas gas_remaining wei
            args msg.sender, 0, 160, (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 192, (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + (32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + 224, cd[(arg2 + cd[(arg2 + 36)] + 36)], mem[ceil32(calldata.size) + 160 len 32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]], cd[(arg2 + cd[(arg2 + 68)] + 36)], mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 161 len 32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]], cd[(arg2 + cd[(arg2 + 100)] + 36)], call.data[arg2 + cd[(arg2 + 100)] + 68 len cd[(arg2 + cd[(arg2 + 100)] + 36)]], Mask(8 * ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)]) - cd[(arg2 + cd[(arg2 + 100)] + 36)], -(8 * ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)]) + -ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 27) + 256, msg.sender) >> -(8 * ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)]) + -ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 27) + 256
        mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 131] = ext_call.return_data[0]
        if ext_call.success:
            require return_data.size >= 32
            require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
            if Mask(32, 224, ext_call.return_data[0]) != 0xbc197c8100000000000000000000000000000000000000000000000000000000:
                revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
        if return_data.size <= 3:
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        mem[0 len 4] = ext_call.return_data[0 len 4]
        if uint32(mem[4 len 28]) >> 224 != Error(string rg1):
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        if return_data.size < 68:
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 131 len return_data.size - 4] = ext_call.return_data[4 len return_data.size - 4]
        if ext_call.return_data[0] > test266151307() or ext_call.return_data[0] + 36 > return_data.size:
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        if mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 131] > test266151307():
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        if ext_call.return_data[0] + mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 131] + 32 > return_data.size - 4:
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        if floor32(ext_call.return_data[0] + mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 131] + 31) + 132 < 131 or ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + floor32(ext_call.return_data[0] + mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 131] + 31) + 132 > test266151307():
            revert with 0, 65
        mem[64] = ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + floor32(ext_call.return_data[0] + mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 131] + 31) + 132
        if not ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 131:
            mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + floor32(ext_call.return_data[0] + mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 131] + 31) + 132] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            revert with mem[mem[64] len 4], 'ERC1155: transfer to non ERC1155Receiver implementer'
        _2668 = ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + floor32(ext_call.return_data[0] + mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 131] + 31) + 132
        mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + floor32(ext_call.return_data[0] + mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 131] + 31) + 132] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        _2689 = mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 131]
        mem[mem[64] + 36] = mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 131]
        mem[mem[64] + 68 len ceil32(_2689)] = mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 163 len ceil32(_2689)]
        if ceil32(_2689) <= _2689:
            revert with mem[mem[64] len 4], 32, mem[mem[64] + 36 len ceil32(_2689) + 32]
        mem[_2689 + mem[64] + 68] = 0
        revert with memory
          from mem[64]
           len ceil32(_2689) + _2668 + -mem[64] + 68
    mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 131] = calldata.size
    mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 163 len calldata.size] = call.data[0 len calldata.size]
    mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + calldata.size + 163] = 0
    idx = 0
    while idx < cd[(arg2 + cd[(arg2 + 36)] + 36)]:
        if idx >= cd[(arg2 + cd[(arg2 + 68)] + 36)]:
            revert with 0, 50
        if idx >= cd[(arg2 + cd[(arg2 + 36)] + 36)]:
            revert with 0, 50
        mem[0] = arg1
        mem[32] = sha3(mem[(32 * idx) + ceil32(calldata.size) + 160], 0)
        if balanceOf[mem[(32 * idx) + ceil32(calldata.size) + 160]][address(arg1)] > !mem[(32 * idx) + ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 161]:
            revert with 0, 17
        balanceOf[mem[(32 * idx) + ceil32(calldata.size) + 160]][address(arg1)] += mem[(32 * idx) + ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 161]
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
    mem[(2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 163] = 64
    mem[(2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 227] = cd[(arg2 + cd[(arg2 + 36)] + 36)]
    mem[(2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 259 len 32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]] = mem[ceil32(calldata.size) + 160 len 32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]]
    mem[(2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 195] = (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 96
    mem[(2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 259] = cd[(arg2 + cd[(arg2 + 68)] + 36)]
    mem[(2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 291 len 32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]] = mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 161 len 32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]]
    emit TransferBatch(Array(len=cd[(arg2 + cd[(arg2 + 36)] + 36)], data=mem[ceil32(calldata.size) + 160 len 32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]], cd[(arg2 + cd[(arg2 + 68)] + 36)], mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 161 len 32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]]), (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 96, mem[calldata.size + ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 143 len 20], 0, arg1);
    if not ext_code.size(arg1):
    mem[(2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 163] = 0xbc197c8100000000000000000000000000000000000000000000000000000000
    mem[(2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 167] = mem[calldata.size + ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 143 len 20]
    mem[(2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 199] = 0
    mem[(2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 231] = 160
    mem[(2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 327] = cd[(arg2 + cd[(arg2 + 36)] + 36)]
    mem[(2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 359 len 32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]] = mem[ceil32(calldata.size) + 160 len 32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]]
    mem[(2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 263] = (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 192
    mem[(2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 359] = cd[(arg2 + cd[(arg2 + 68)] + 36)]
    mem[(2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 391 len 32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]] = mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 161 len 32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]]
    mem[(2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 295] = (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + (32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + 224
    mem[(2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + (32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + 391] = cd[(arg2 + cd[(arg2 + 100)] + 36)]
    mem[(2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + (32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + 423 len ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])] = call.data[arg2 + cd[(arg2 + 100)] + 68 len cd[(arg2 + cd[(arg2 + 100)] + 36)]], Mask(8 * ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)]) - cd[(arg2 + cd[(arg2 + 100)] + 36)], -(8 * ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)]) + -ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 31) + 256, calldata.size) >> -(8 * ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)]) + -ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 31) + 256
    if ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)]) <= cd[(arg2 + cd[(arg2 + 100)] + 36)]:
        require ext_code.size(arg1)
        call arg1.onERC1155BatchReceived(address rg1, address rg2, uint256[] rg3, uint256[] rg4, bytes rg5) with:
             gas gas_remaining wei
            args address(mem[calldata.size + ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 131]), 0, 160, (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 192, (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + (32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + 224, cd[(arg2 + cd[(arg2 + 36)] + 36)], mem[ceil32(calldata.size) + 160 len 32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]], cd[(arg2 + cd[(arg2 + 68)] + 36)], mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 161 len 32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]], cd[(arg2 + cd[(arg2 + 100)] + 36)], call.data[arg2 + cd[(arg2 + 100)] + 68 len cd[(arg2 + cd[(arg2 + 100)] + 36)]], Mask(8 * ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)]) - cd[(arg2 + cd[(arg2 + 100)] + 36)], -(8 * ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)]) + -ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 31) + 256, calldata.size) >> -(8 * ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)]) + -ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 31) + 256
        mem[(2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 163] = ext_call.return_data[0]
        if ext_call.success:
            require return_data.size >= 32
            require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
            if Mask(32, 224, ext_call.return_data[0]) != 0xbc197c8100000000000000000000000000000000000000000000000000000000:
                revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
        if return_data.size <= 3:
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        mem[0 len 4] = ext_call.return_data[0 len 4]
        if uint32(mem[4 len 28]) >> 224 != Error(string rg1):
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        if return_data.size < 68:
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        mem[(2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 163 len return_data.size - 4] = ext_call.return_data[4 len return_data.size - 4]
        if ext_call.return_data[0] > test266151307() or ext_call.return_data[0] + 36 > return_data.size:
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        if mem[(2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 163] > test266151307():
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        if ext_call.return_data[0] + mem[(2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 163] + 32 > return_data.size - 4:
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        if floor32(ext_call.return_data[0] + mem[(2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 163] + 31) + 164 < 163 or (2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + floor32(ext_call.return_data[0] + mem[(2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 163] + 31) + 164 > test266151307():
            revert with 0, 65
        mem[64] = (2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + floor32(ext_call.return_data[0] + mem[(2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 163] + 31) + 164
        if not (2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 163:
            mem[(2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + floor32(ext_call.return_data[0] + mem[(2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 163] + 31) + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            revert with mem[mem[64] len 4], 'ERC1155: transfer to non ERC1155Receiver implementer'
        _2669 = (2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + floor32(ext_call.return_data[0] + mem[(2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 163] + 31) + 164
        mem[(2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + floor32(ext_call.return_data[0] + mem[(2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 163] + 31) + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        _2691 = mem[(2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 163]
        mem[mem[64] + 36] = mem[(2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 163]
        mem[mem[64] + 68 len ceil32(_2691)] = mem[(2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 195 len ceil32(_2691)]
        if ceil32(_2691) <= _2691:
            revert with mem[mem[64] len 4], 32, mem[mem[64] + 36 len ceil32(_2691) + 32]
        mem[_2691 + mem[64] + 68] = 0
        revert with memory
          from mem[64]
           len ceil32(_2691) + _2669 + -mem[64] + 68
    mem[cd[(arg2 + cd[(arg2 + 100)] + 36)] + (2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + (32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + 423] = 0
    require ext_code.size(arg1)
    call arg1.onERC1155BatchReceived(address rg1, address rg2, uint256[] rg3, uint256[] rg4, bytes rg5) with:
         gas gas_remaining wei
        args address(mem[calldata.size + ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 131]), 0, 160, (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 192, (32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + (32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + 224, cd[(arg2 + cd[(arg2 + 36)] + 36)], mem[ceil32(calldata.size) + 160 len 32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]], cd[(arg2 + cd[(arg2 + 68)] + 36)], mem[ceil32(calldata.size) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + 161 len 32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]], cd[(arg2 + cd[(arg2 + 100)] + 36)], call.data[arg2 + cd[(arg2 + 100)] + 68 len cd[(arg2 + cd[(arg2 + 100)] + 36)]], Mask(8 * ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)]) - cd[(arg2 + cd[(arg2 + 100)] + 36)], -(8 * ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)]) + -ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 31) + 256, calldata.size) >> -(8 * ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)]) + -ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 31) + 256
    mem[(2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 163] = ext_call.return_data[0]
    if ext_call.success:
        require return_data.size >= 32
        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
        if Mask(32, 224, ext_call.return_data[0]) != 0xbc197c8100000000000000000000000000000000000000000000000000000000:
            revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
    if return_data.size <= 3:
        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
    mem[0 len 4] = ext_call.return_data[0 len 4]
    if uint32(mem[4 len 28]) >> 224 != Error(string rg1):
        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
    if return_data.size < 68:
        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
    mem[(2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + 163 len return_data.size - 4] = ext_call.return_data[4 len return_data.size - 4]
    if ext_call.return_data[0] > test266151307() or ext_call.return_data[0] + 36 > return_data.size:
        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
    if mem[(2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 163] > test266151307():
        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
    if ext_call.return_data[0] + mem[(2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 163] + 32 > return_data.size - 4:
        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
    if floor32(ext_call.return_data[0] + mem[(2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 163] + 31) + 164 < 163 or (2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + floor32(ext_call.return_data[0] + mem[(2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 163] + 31) + 164 > test266151307():
        revert with 0, 65
    mem[64] = (2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + floor32(ext_call.return_data[0] + mem[(2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 163] + 31) + 164
    if not (2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 163:
        mem[(2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + floor32(ext_call.return_data[0] + mem[(2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 163] + 31) + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        revert with mem[mem[64] len 4], 'ERC1155: transfer to non ERC1155Receiver implementer'
    _2670 = (2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + floor32(ext_call.return_data[0] + mem[(2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 163] + 31) + 164
    mem[(2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + floor32(ext_call.return_data[0] + mem[(2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 163] + 31) + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
    mem[mem[64] + 4] = 32
    _2693 = mem[(2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 163]
    mem[mem[64] + 36] = mem[(2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 163]
    mem[mem[64] + 68 len ceil32(_2693)] = mem[(2 * ceil32(calldata.size)) + ceil32(32 * cd[(arg2 + cd[(arg2 + 36)] + 36)]) + ceil32(32 * cd[(arg2 + cd[(arg2 + 68)] + 36)]) + ceil32(ceil32(cd[(arg2 + cd[(arg2 + 100)] + 36)])) + ext_call.return_data[0] + 195 len ceil32(_2693)]
    if ceil32(_2693) <= _2693:
        revert with mem[mem[64] len 4], 32, mem[mem[64] + 36 len ceil32(_2693) + 32]
    mem[_2693 + mem[64] + 68] = 0
    revert with memory
      from mem[64]
       len ceil32(_2693) + _2670 + -mem[64] + 68
}

function safeBatchTransferFrom(address arg1, address arg2, uint256[] arg3, uint256[] arg4, bytes arg5) {
    require calldata.size - 4 >= 160
    require arg1 == arg1
    require arg2 == arg2
    require arg3 <= test266151307()
    require arg3 + 35 < calldata.size
    if arg3.length > test266151307():
        revert with 0, 65
    if ceil32(32 * arg3.length) + 97 < 96 or ceil32(32 * arg3.length) + 97 > test266151307():
        revert with 0, 65
    mem[96] = arg3.length
    require arg3 + (32 * arg3.length) + 36 <= calldata.size
    idx = arg3 + 36
    s = 128
    while idx < arg3 + (32 * arg3.length) + 36:
        mem[s] = cd[idx]
        idx = idx + 32
        s = s + 32
        continue 
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    if arg4.length > test266151307():
        revert with 0, 65
    if ceil32(32 * arg4.length) + 98 < 97 or ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + 98 > test266151307():
        revert with 0, 65
    mem[ceil32(32 * arg3.length) + 97] = arg4.length
    require arg4 + (32 * arg4.length) + 36 <= calldata.size
    idx = arg4 + 36
    s = ceil32(32 * arg3.length) + 129
    while idx < arg4 + (32 * arg4.length) + 36:
        mem[s] = cd[idx]
        idx = idx + 32
        s = s + 32
        continue 
    require arg5 <= test266151307()
    require arg5 + 35 < calldata.size
    if arg5.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg5.length)) + 99 < 98 or ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 99 > test266151307():
        revert with 0, 65
    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + 98] = arg5.length
    require arg5 + arg5.length + 36 <= calldata.size
    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + 130 len arg5.length] = arg5[all]
    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + arg5.length + 130] = 0
    if arg3.length != arg4.length:
        revert with 0, 'ERC1155: ids and amounts length mismatch'
    if not arg2:
        revert with 0, 'ERC1155: transfer to the zero address'
    if msg.sender != this.address:
        if arg1 == msg.sender:
            if msg.sender != this.address:
                idx = 0
                while idx < arg3.length:
                    if idx >= arg3.length:
                        revert with 0, 50
                    if idx >= arg4.length:
                        revert with 0, 50
                    if balanceOf[mem[(32 * idx) + 128]][address(arg1)] < mem[(32 * idx) + ceil32(32 * arg3.length) + 129]:
                        revert with 0, 'ERC1155: insufficient balance for transfer'
                    balanceOf[mem[(32 * idx) + 128]][address(arg1)] -= mem[(32 * idx) + ceil32(32 * arg3.length) + 129]
                    mem[0] = arg2
                    mem[32] = sha3(mem[(32 * idx) + 128], 0)
                    if balanceOf[mem[(32 * idx) + 128]][address(arg2)] > !mem[(32 * idx) + ceil32(32 * arg3.length) + 129]:
                        revert with 0, 17
                    balanceOf[mem[(32 * idx) + 128]][address(arg2)] += mem[(32 * idx) + ceil32(32 * arg3.length) + 129]
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 99] = 64
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 195 len 32 * arg3.length] = mem[128 len 32 * arg3.length]
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (32 * arg3.length) + 195] = arg4.length
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (32 * arg3.length) + 227 len 32 * arg4.length] = mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]
                emit TransferBatch(Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]), (32 * arg3.length) + 96, msg.sender, arg1, arg2);
                if not ext_code.size(arg2):
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 99] = 0xbc197c8100000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 103] = msg.sender
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 135] = arg1
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 167] = 160
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 263] = arg3.length
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 295 len 32 * arg3.length] = mem[128 len 32 * arg3.length]
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 199] = (32 * arg3.length) + 192
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (32 * arg3.length) + 295] = arg4.length
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (32 * arg3.length) + 327 len 32 * arg4.length] = mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 231] = (32 * arg3.length) + (32 * arg4.length) + 224
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (32 * arg3.length) + (32 * arg4.length) + 327] = arg5.length
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (32 * arg3.length) + (32 * arg4.length) + 359 len ceil32(arg5.length)] = arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 27) + 256, msg.sender) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 27) + 256
                if ceil32(arg5.length) <= arg5.length:
                    require ext_code.size(arg2)
                    call arg2.onERC1155BatchReceived(address rg1, address rg2, uint256[] rg3, uint256[] rg4, bytes rg5) with:
                         gas gas_remaining wei
                        args msg.sender, address(arg1), Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length], arg5.length, arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 27) + 256, msg.sender) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 27) + 256), (32 * arg3.length) + 192, (32 * arg3.length) + (32 * arg4.length) + 224
                    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 99] = ext_call.return_data[0]
                    if ext_call.success:
                        require return_data.size >= 32
                        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                        if Mask(32, 224, ext_call.return_data[0]) != 0xbc197c8100000000000000000000000000000000000000000000000000000000:
                            revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                    if return_data.size <= 3:
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    mem[0 len 4] = ext_call.return_data[0 len 4]
                    if uint32(mem[4 len 28]) >> 224 != Error(string rg1):
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    if return_data.size < 68:
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 99 len return_data.size - 4] = ext_call.return_data[4 len return_data.size - 4]
                    if ext_call.return_data[0] > test266151307() or ext_call.return_data[0] + 36 > return_data.size:
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    if mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99] > test266151307():
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    if ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99] + 32 > return_data.size - 4:
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    if floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99] + 31) + 100 < 99 or ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99] + 31) + 100 > test266151307():
                        revert with 0, 65
                    mem[64] = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99] + 31) + 100
                    if not ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99:
                        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99] + 31) + 100] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        revert with mem[mem[64] len 4], 'ERC1155: transfer to non ERC1155Receiver implementer'
                    _12623 = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99] + 31) + 100
                    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99] + 31) + 100] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    _12703 = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99]
                    mem[mem[64] + 36] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99]
                    mem[mem[64] + 68 len ceil32(_12703)] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 131 len ceil32(_12703)]
                    if ceil32(_12703) <= _12703:
                        revert with mem[mem[64] len 4], 32, mem[mem[64] + 36 len ceil32(_12703) + 32]
                    mem[_12703 + mem[64] + 68] = 0
                    revert with memory
                      from mem[64]
                       len ceil32(_12703) + _12623 + -mem[64] + 68
                mem[arg5.length + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (32 * arg3.length) + (32 * arg4.length) + 359] = 0
                require ext_code.size(arg2)
                call arg2.onERC1155BatchReceived(address rg1, address rg2, uint256[] rg3, uint256[] rg4, bytes rg5) with:
                     gas gas_remaining wei
                    args msg.sender, address(arg1), Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length], arg5.length, arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 27) + 256, msg.sender) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 27) + 256), (32 * arg3.length) + 192, (32 * arg3.length) + (32 * arg4.length) + 224
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 99] = ext_call.return_data[0]
                if ext_call.success:
                    require return_data.size >= 32
                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                    if Mask(32, 224, ext_call.return_data[0]) != 0xbc197c8100000000000000000000000000000000000000000000000000000000:
                        revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                if return_data.size <= 3:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                mem[0 len 4] = ext_call.return_data[0 len 4]
                if uint32(mem[4 len 28]) >> 224 != Error(string rg1):
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if return_data.size < 68:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 99 len return_data.size - 4] = ext_call.return_data[4 len return_data.size - 4]
                if ext_call.return_data[0] > test266151307() or ext_call.return_data[0] + 36 > return_data.size:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99] > test266151307():
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99] + 32 > return_data.size - 4:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99] + 31) + 100 < 99 or ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99] + 31) + 100 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99] + 31) + 100
                if not ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99:
                    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99] + 31) + 100] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    revert with mem[mem[64] len 4], 'ERC1155: transfer to non ERC1155Receiver implementer'
                _12624 = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99] + 31) + 100
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99] + 31) + 100] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                _12705 = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99]
                mem[mem[64] + 36] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99]
                mem[mem[64] + 68 len ceil32(_12705)] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 131 len ceil32(_12705)]
                if ceil32(_12705) <= _12705:
                    revert with mem[mem[64] len 4], 32, mem[mem[64] + 36 len ceil32(_12705) + 32]
                mem[_12705 + mem[64] + 68] = 0
                revert with memory
                  from mem[64]
                   len ceil32(_12705) + _12624 + -mem[64] + 68
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 99] = calldata.size
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 131 len calldata.size] = call.data[0 len calldata.size]
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + calldata.size + 131] = 0
            idx = 0
            while idx < arg3.length:
                if idx >= arg3.length:
                    revert with 0, 50
                if idx >= arg4.length:
                    revert with 0, 50
                if balanceOf[mem[(32 * idx) + 128]][address(arg1)] < mem[(32 * idx) + ceil32(32 * arg3.length) + 129]:
                    revert with 0, 'ERC1155: insufficient balance for transfer'
                balanceOf[mem[(32 * idx) + 128]][address(arg1)] -= mem[(32 * idx) + ceil32(32 * arg3.length) + 129]
                mem[0] = arg2
                mem[32] = sha3(mem[(32 * idx) + 128], 0)
                if balanceOf[mem[(32 * idx) + 128]][address(arg2)] > !mem[(32 * idx) + ceil32(32 * arg3.length) + 129]:
                    revert with 0, 17
                balanceOf[mem[(32 * idx) + 128]][address(arg2)] += mem[(32 * idx) + ceil32(32 * arg3.length) + 129]
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 227 len 32 * arg3.length] = mem[128 len 32 * arg3.length]
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + 227] = arg4.length
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + 259 len 32 * arg4.length] = mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]
            emit TransferBatch(Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]), (32 * arg3.length) + 96, mem[calldata.size + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 111 len 20], arg1, arg2);
            if not ext_code.size(arg2):
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 135] = mem[calldata.size + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 111 len 20]
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 167] = arg1
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 199] = 160
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 295] = arg3.length
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 327 len 32 * arg3.length] = mem[128 len 32 * arg3.length]
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 231] = (32 * arg3.length) + 192
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + 327] = arg4.length
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + 359 len 32 * arg4.length] = mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 263] = (32 * arg3.length) + (32 * arg4.length) + 224
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + (32 * arg4.length) + 359] = arg5.length
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + (32 * arg4.length) + 391 len ceil32(arg5.length)] = arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256
            if ceil32(arg5.length) <= arg5.length:
                require ext_code.size(arg2)
                call arg2.onERC1155BatchReceived(address rg1, address rg2, uint256[] rg3, uint256[] rg4, bytes rg5) with:
                     gas gas_remaining wei
                    args address(mem[calldata.size + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 99]), address(arg1), Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length], arg5.length, arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256), (32 * arg3.length) + 192, (32 * arg3.length) + (32 * arg4.length) + 224
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 131] = ext_call.return_data[0]
                if ext_call.success:
                    require return_data.size >= 32
                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                    if Mask(32, 224, ext_call.return_data[0]) != 0xbc197c8100000000000000000000000000000000000000000000000000000000:
                        revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                if return_data.size <= 3:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                mem[0 len 4] = ext_call.return_data[0 len 4]
                if uint32(mem[4 len 28]) >> 224 != Error(string rg1):
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if return_data.size < 68:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 131 len return_data.size - 4] = ext_call.return_data[4 len return_data.size - 4]
                if ext_call.return_data[0] > test266151307() or ext_call.return_data[0] + 36 > return_data.size:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] > test266151307():
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 32 > return_data.size - 4:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132 < 131 or ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132
                if not ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131:
                    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    revert with mem[mem[64] len 4], 'ERC1155: transfer to non ERC1155Receiver implementer'
                _12625 = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                _12707 = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131]
                mem[mem[64] + 36] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131]
                mem[mem[64] + 68 len ceil32(_12707)] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 163 len ceil32(_12707)]
                if ceil32(_12707) <= _12707:
                    revert with mem[mem[64] len 4], 32, mem[mem[64] + 36 len ceil32(_12707) + 32]
                mem[_12707 + mem[64] + 68] = 0
                revert with memory
                  from mem[64]
                   len ceil32(_12707) + _12625 + -mem[64] + 68
            mem[arg5.length + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + (32 * arg4.length) + 391] = 0
            require ext_code.size(arg2)
            call arg2.onERC1155BatchReceived(address rg1, address rg2, uint256[] rg3, uint256[] rg4, bytes rg5) with:
                 gas gas_remaining wei
                args address(mem[calldata.size + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 99]), address(arg1), Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length], arg5.length, arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256), (32 * arg3.length) + 192, (32 * arg3.length) + (32 * arg4.length) + 224
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 131] = ext_call.return_data[0]
            if ext_call.success:
                require return_data.size >= 32
                require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                if Mask(32, 224, ext_call.return_data[0]) != 0xbc197c8100000000000000000000000000000000000000000000000000000000:
                    revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
            if return_data.size <= 3:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            mem[0 len 4] = ext_call.return_data[0 len 4]
            if uint32(mem[4 len 28]) >> 224 != Error(string rg1):
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if return_data.size < 68:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 131 len return_data.size - 4] = ext_call.return_data[4 len return_data.size - 4]
            if ext_call.return_data[0] > test266151307() or ext_call.return_data[0] + 36 > return_data.size:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] > test266151307():
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 32 > return_data.size - 4:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132 < 131 or ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132
            if not ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131:
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                revert with mem[mem[64] len 4], 'ERC1155: transfer to non ERC1155Receiver implementer'
            _12626 = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            _12709 = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131]
            mem[mem[64] + 36] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131]
            mem[mem[64] + 68 len ceil32(_12709)] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 163 len ceil32(_12709)]
            if ceil32(_12709) <= _12709:
                revert with mem[mem[64] len 4], 32, mem[mem[64] + 36 len ceil32(_12709) + 32]
            mem[_12709 + mem[64] + 68] = 0
            revert with memory
              from mem[64]
               len ceil32(_12709) + _12626 + -mem[64] + 68
        if msg.sender != this.address:
            mem[0] = msg.sender
            if stor1[address(arg1)][address(msg.sender)]:
                if msg.sender != this.address:
                    idx = 0
                    while idx < arg3.length:
                        if idx >= arg3.length:
                            revert with 0, 50
                        if idx >= arg4.length:
                            revert with 0, 50
                        if balanceOf[mem[(32 * idx) + 128]][address(arg1)] < mem[(32 * idx) + ceil32(32 * arg3.length) + 129]:
                            revert with 0, 'ERC1155: insufficient balance for transfer'
                        balanceOf[mem[(32 * idx) + 128]][address(arg1)] -= mem[(32 * idx) + ceil32(32 * arg3.length) + 129]
                        mem[0] = arg2
                        mem[32] = sha3(mem[(32 * idx) + 128], 0)
                        if balanceOf[mem[(32 * idx) + 128]][address(arg2)] > !mem[(32 * idx) + ceil32(32 * arg3.length) + 129]:
                            revert with 0, 17
                        balanceOf[mem[(32 * idx) + 128]][address(arg2)] += mem[(32 * idx) + ceil32(32 * arg3.length) + 129]
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 99] = 64
                    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 195 len 32 * arg3.length] = mem[128 len 32 * arg3.length]
                    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (32 * arg3.length) + 195] = arg4.length
                    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (32 * arg3.length) + 227 len 32 * arg4.length] = mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]
                    emit TransferBatch(Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]), (32 * arg3.length) + 96, msg.sender, arg1, arg2);
                    if not ext_code.size(arg2):
                    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 99] = 0xbc197c8100000000000000000000000000000000000000000000000000000000
                    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 103] = msg.sender
                    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 135] = arg1
                    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 167] = 160
                    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 263] = arg3.length
                    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 295 len 32 * arg3.length] = mem[128 len 32 * arg3.length]
                    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 199] = (32 * arg3.length) + 192
                    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (32 * arg3.length) + 295] = arg4.length
                    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (32 * arg3.length) + 327 len 32 * arg4.length] = mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]
                    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 231] = (32 * arg3.length) + (32 * arg4.length) + 224
                    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (32 * arg3.length) + (32 * arg4.length) + 327] = arg5.length
                    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (32 * arg3.length) + (32 * arg4.length) + 359 len ceil32(arg5.length)] = arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 27) + 256, msg.sender) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 27) + 256
                    if ceil32(arg5.length) <= arg5.length:
                        require ext_code.size(arg2)
                        call arg2.onERC1155BatchReceived(address rg1, address rg2, uint256[] rg3, uint256[] rg4, bytes rg5) with:
                             gas gas_remaining wei
                            args msg.sender, address(arg1), Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length], arg5.length, arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 27) + 256, msg.sender) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 27) + 256), (32 * arg3.length) + 192, (32 * arg3.length) + (32 * arg4.length) + 224
                        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 99] = ext_call.return_data[0]
                        if ext_call.success:
                            require return_data.size >= 32
                            require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                            if Mask(32, 224, ext_call.return_data[0]) != 0xbc197c8100000000000000000000000000000000000000000000000000000000:
                                revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                        if return_data.size <= 3:
                            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                        mem[0 len 4] = ext_call.return_data[0 len 4]
                        if uint32(mem[4 len 28]) >> 224 != Error(string rg1):
                            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                        if return_data.size < 68:
                            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 99 len return_data.size - 4] = ext_call.return_data[4 len return_data.size - 4]
                        if ext_call.return_data[0] > test266151307() or ext_call.return_data[0] + 36 > return_data.size:
                            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                        if mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99] > test266151307():
                            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                        if ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99] + 32 > return_data.size - 4:
                            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                        if floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99] + 31) + 100 < 99 or ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99] + 31) + 100 > test266151307():
                            revert with 0, 65
                        mem[64] = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99] + 31) + 100
                        if not ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99:
                            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99] + 31) + 100] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            revert with mem[mem[64] len 4], 'ERC1155: transfer to non ERC1155Receiver implementer'
                        _12627 = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99] + 31) + 100
                        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99] + 31) + 100] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        _12711 = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99]
                        mem[mem[64] + 36] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99]
                        mem[mem[64] + 68 len ceil32(_12711)] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 131 len ceil32(_12711)]
                        if ceil32(_12711) <= _12711:
                            revert with mem[mem[64] len 4], 32, mem[mem[64] + 36 len ceil32(_12711) + 32]
                        mem[_12711 + mem[64] + 68] = 0
                        revert with memory
                          from mem[64]
                           len ceil32(_12711) + _12627 + -mem[64] + 68
                    mem[arg5.length + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (32 * arg3.length) + (32 * arg4.length) + 359] = 0
                    require ext_code.size(arg2)
                    call arg2.onERC1155BatchReceived(address rg1, address rg2, uint256[] rg3, uint256[] rg4, bytes rg5) with:
                         gas gas_remaining wei
                        args msg.sender, address(arg1), Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length], arg5.length, arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 27) + 256, msg.sender) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 27) + 256), (32 * arg3.length) + 192, (32 * arg3.length) + (32 * arg4.length) + 224
                    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 99] = ext_call.return_data[0]
                    if ext_call.success:
                        require return_data.size >= 32
                        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                        if Mask(32, 224, ext_call.return_data[0]) != 0xbc197c8100000000000000000000000000000000000000000000000000000000:
                            revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                    if return_data.size <= 3:
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    mem[0 len 4] = ext_call.return_data[0 len 4]
                    if uint32(mem[4 len 28]) >> 224 != Error(string rg1):
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    if return_data.size < 68:
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 99 len return_data.size - 4] = ext_call.return_data[4 len return_data.size - 4]
                    if ext_call.return_data[0] > test266151307() or ext_call.return_data[0] + 36 > return_data.size:
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    if mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99] > test266151307():
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    if ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99] + 32 > return_data.size - 4:
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    if floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99] + 31) + 100 < 99 or ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99] + 31) + 100 > test266151307():
                        revert with 0, 65
                    mem[64] = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99] + 31) + 100
                    if not ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99:
                        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99] + 31) + 100] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        revert with mem[mem[64] len 4], 'ERC1155: transfer to non ERC1155Receiver implementer'
                    _12628 = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99] + 31) + 100
                    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99] + 31) + 100] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    _12713 = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99]
                    mem[mem[64] + 36] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99]
                    mem[mem[64] + 68 len ceil32(_12713)] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 131 len ceil32(_12713)]
                    if ceil32(_12713) <= _12713:
                        revert with mem[mem[64] len 4], 32, mem[mem[64] + 36 len ceil32(_12713) + 32]
                    mem[_12713 + mem[64] + 68] = 0
                    revert with memory
                      from mem[64]
                       len ceil32(_12713) + _12628 + -mem[64] + 68
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 99] = calldata.size
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 131 len calldata.size] = call.data[0 len calldata.size]
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + calldata.size + 131] = 0
                idx = 0
                while idx < arg3.length:
                    if idx >= arg3.length:
                        revert with 0, 50
                    if idx >= arg4.length:
                        revert with 0, 50
                    if balanceOf[mem[(32 * idx) + 128]][address(arg1)] < mem[(32 * idx) + ceil32(32 * arg3.length) + 129]:
                        revert with 0, 'ERC1155: insufficient balance for transfer'
                    balanceOf[mem[(32 * idx) + 128]][address(arg1)] -= mem[(32 * idx) + ceil32(32 * arg3.length) + 129]
                    mem[0] = arg2
                    mem[32] = sha3(mem[(32 * idx) + 128], 0)
                    if balanceOf[mem[(32 * idx) + 128]][address(arg2)] > !mem[(32 * idx) + ceil32(32 * arg3.length) + 129]:
                        revert with 0, 17
                    balanceOf[mem[(32 * idx) + 128]][address(arg2)] += mem[(32 * idx) + ceil32(32 * arg3.length) + 129]
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 227 len 32 * arg3.length] = mem[128 len 32 * arg3.length]
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + 227] = arg4.length
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + 259 len 32 * arg4.length] = mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]
                emit TransferBatch(Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]), (32 * arg3.length) + 96, mem[calldata.size + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 111 len 20], arg1, arg2);
                if not ext_code.size(arg2):
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 135] = mem[calldata.size + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 111 len 20]
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 167] = arg1
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 199] = 160
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 295] = arg3.length
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 327 len 32 * arg3.length] = mem[128 len 32 * arg3.length]
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 231] = (32 * arg3.length) + 192
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + 327] = arg4.length
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + 359 len 32 * arg4.length] = mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 263] = (32 * arg3.length) + (32 * arg4.length) + 224
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + (32 * arg4.length) + 359] = arg5.length
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + (32 * arg4.length) + 391 len ceil32(arg5.length)] = arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256
                if ceil32(arg5.length) <= arg5.length:
                    require ext_code.size(arg2)
                    call arg2.onERC1155BatchReceived(address rg1, address rg2, uint256[] rg3, uint256[] rg4, bytes rg5) with:
                         gas gas_remaining wei
                        args address(mem[calldata.size + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 99]), address(arg1), Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length], arg5.length, arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256), (32 * arg3.length) + 192, (32 * arg3.length) + (32 * arg4.length) + 224
                    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 131] = ext_call.return_data[0]
                    if ext_call.success:
                        require return_data.size >= 32
                        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                        if Mask(32, 224, ext_call.return_data[0]) != 0xbc197c8100000000000000000000000000000000000000000000000000000000:
                            revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                    if return_data.size <= 3:
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    mem[0 len 4] = ext_call.return_data[0 len 4]
                    if uint32(mem[4 len 28]) >> 224 != Error(string rg1):
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    if return_data.size < 68:
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 131 len return_data.size - 4] = ext_call.return_data[4 len return_data.size - 4]
                    if ext_call.return_data[0] > test266151307() or ext_call.return_data[0] + 36 > return_data.size:
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    if mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] > test266151307():
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    if ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 32 > return_data.size - 4:
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    if floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132 < 131 or ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132 > test266151307():
                        revert with 0, 65
                    mem[64] = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132
                    if not ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131:
                        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        revert with mem[mem[64] len 4], 'ERC1155: transfer to non ERC1155Receiver implementer'
                    _12629 = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132
                    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    _12715 = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131]
                    mem[mem[64] + 36] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131]
                    mem[mem[64] + 68 len ceil32(_12715)] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 163 len ceil32(_12715)]
                    if ceil32(_12715) <= _12715:
                        revert with mem[mem[64] len 4], 32, mem[mem[64] + 36 len ceil32(_12715) + 32]
                    mem[_12715 + mem[64] + 68] = 0
                    revert with memory
                      from mem[64]
                       len ceil32(_12715) + _12629 + -mem[64] + 68
                mem[arg5.length + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + (32 * arg4.length) + 391] = 0
                require ext_code.size(arg2)
                call arg2.onERC1155BatchReceived(address rg1, address rg2, uint256[] rg3, uint256[] rg4, bytes rg5) with:
                     gas gas_remaining wei
                    args address(mem[calldata.size + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 99]), address(arg1), Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length], arg5.length, arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256), (32 * arg3.length) + 192, (32 * arg3.length) + (32 * arg4.length) + 224
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 131] = ext_call.return_data[0]
                if ext_call.success:
                    require return_data.size >= 32
                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                    if Mask(32, 224, ext_call.return_data[0]) != 0xbc197c8100000000000000000000000000000000000000000000000000000000:
                        revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                if return_data.size <= 3:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                mem[0 len 4] = ext_call.return_data[0 len 4]
                if uint32(mem[4 len 28]) >> 224 != Error(string rg1):
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if return_data.size < 68:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 131 len return_data.size - 4] = ext_call.return_data[4 len return_data.size - 4]
                if ext_call.return_data[0] > test266151307() or ext_call.return_data[0] + 36 > return_data.size:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] > test266151307():
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 32 > return_data.size - 4:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132 < 131 or ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132
                if not ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131:
                    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    revert with mem[mem[64] len 4], 'ERC1155: transfer to non ERC1155Receiver implementer'
                _12630 = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                _12717 = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131]
                mem[mem[64] + 36] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131]
                mem[mem[64] + 68 len ceil32(_12717)] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 163 len ceil32(_12717)]
                if ceil32(_12717) <= _12717:
                    revert with mem[mem[64] len 4], 32, mem[mem[64] + 36 len ceil32(_12717) + 32]
                mem[_12717 + mem[64] + 68] = 0
                revert with memory
                  from mem[64]
                   len ceil32(_12717) + _12630 + -mem[64] + 68
            mem[0] = msg.sender
            if bool(stor6[address(msg.sender)]) != 1:
                revert with 0, 'ERC1155: transfer caller is not owner nor approved'
            if msg.sender != this.address:
                idx = 0
                while idx < arg3.length:
                    if idx >= arg3.length:
                        revert with 0, 50
                    if idx >= arg4.length:
                        revert with 0, 50
                    if balanceOf[mem[(32 * idx) + 128]][address(arg1)] < mem[(32 * idx) + ceil32(32 * arg3.length) + 129]:
                        revert with 0, 'ERC1155: insufficient balance for transfer'
                    balanceOf[mem[(32 * idx) + 128]][address(arg1)] -= mem[(32 * idx) + ceil32(32 * arg3.length) + 129]
                    mem[0] = arg2
                    mem[32] = sha3(mem[(32 * idx) + 128], 0)
                    if balanceOf[mem[(32 * idx) + 128]][address(arg2)] > !mem[(32 * idx) + ceil32(32 * arg3.length) + 129]:
                        revert with 0, 17
                    balanceOf[mem[(32 * idx) + 128]][address(arg2)] += mem[(32 * idx) + ceil32(32 * arg3.length) + 129]
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 99] = 64
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 195 len 32 * arg3.length] = mem[128 len 32 * arg3.length]
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (32 * arg3.length) + 195] = arg4.length
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (32 * arg3.length) + 227 len 32 * arg4.length] = mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]
                emit TransferBatch(Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]), (32 * arg3.length) + 96, msg.sender, arg1, arg2);
                if not ext_code.size(arg2):
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 99] = 0xbc197c8100000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 103] = msg.sender
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 135] = arg1
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 167] = 160
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 263] = arg3.length
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 295 len 32 * arg3.length] = mem[128 len 32 * arg3.length]
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 199] = (32 * arg3.length) + 192
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (32 * arg3.length) + 295] = arg4.length
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (32 * arg3.length) + 327 len 32 * arg4.length] = mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 231] = (32 * arg3.length) + (32 * arg4.length) + 224
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (32 * arg3.length) + (32 * arg4.length) + 327] = arg5.length
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (32 * arg3.length) + (32 * arg4.length) + 359 len ceil32(arg5.length)] = arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 27) + 256, msg.sender) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 27) + 256
                if ceil32(arg5.length) <= arg5.length:
                    require ext_code.size(arg2)
                    call arg2.onERC1155BatchReceived(address rg1, address rg2, uint256[] rg3, uint256[] rg4, bytes rg5) with:
                         gas gas_remaining wei
                        args msg.sender, address(arg1), Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length], arg5.length, arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 27) + 256, msg.sender) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 27) + 256), (32 * arg3.length) + 192, (32 * arg3.length) + (32 * arg4.length) + 224
                    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 99] = ext_call.return_data[0]
                    if ext_call.success:
                        require return_data.size >= 32
                        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                        if Mask(32, 224, ext_call.return_data[0]) != 0xbc197c8100000000000000000000000000000000000000000000000000000000:
                            revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                    if return_data.size <= 3:
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    mem[0 len 4] = ext_call.return_data[0 len 4]
                    if uint32(mem[4 len 28]) >> 224 != Error(string rg1):
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    if return_data.size < 68:
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 99 len return_data.size - 4] = ext_call.return_data[4 len return_data.size - 4]
                    if ext_call.return_data[0] > test266151307() or ext_call.return_data[0] + 36 > return_data.size:
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    if mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99] > test266151307():
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    if ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99] + 32 > return_data.size - 4:
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    if floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99] + 31) + 100 < 99 or ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99] + 31) + 100 > test266151307():
                        revert with 0, 65
                    mem[64] = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99] + 31) + 100
                    if not ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99:
                        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99] + 31) + 100] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        revert with mem[mem[64] len 4], 'ERC1155: transfer to non ERC1155Receiver implementer'
                    _12631 = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99] + 31) + 100
                    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99] + 31) + 100] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    _12719 = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99]
                    mem[mem[64] + 36] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99]
                    mem[mem[64] + 68 len ceil32(_12719)] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 131 len ceil32(_12719)]
                    if ceil32(_12719) <= _12719:
                        revert with mem[mem[64] len 4], 32, mem[mem[64] + 36 len ceil32(_12719) + 32]
                    mem[_12719 + mem[64] + 68] = 0
                    revert with memory
                      from mem[64]
                       len ceil32(_12719) + _12631 + -mem[64] + 68
                mem[arg5.length + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (32 * arg3.length) + (32 * arg4.length) + 359] = 0
                require ext_code.size(arg2)
                call arg2.onERC1155BatchReceived(address rg1, address rg2, uint256[] rg3, uint256[] rg4, bytes rg5) with:
                     gas gas_remaining wei
                    args msg.sender, address(arg1), Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length], arg5.length, arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 27) + 256, msg.sender) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 27) + 256), (32 * arg3.length) + 192, (32 * arg3.length) + (32 * arg4.length) + 224
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 99] = ext_call.return_data[0]
                if ext_call.success:
                    require return_data.size >= 32
                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                    if Mask(32, 224, ext_call.return_data[0]) != 0xbc197c8100000000000000000000000000000000000000000000000000000000:
                        revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                if return_data.size <= 3:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                mem[0 len 4] = ext_call.return_data[0 len 4]
                if uint32(mem[4 len 28]) >> 224 != Error(string rg1):
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if return_data.size < 68:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 99 len return_data.size - 4] = ext_call.return_data[4 len return_data.size - 4]
                if ext_call.return_data[0] > test266151307() or ext_call.return_data[0] + 36 > return_data.size:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99] > test266151307():
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99] + 32 > return_data.size - 4:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99] + 31) + 100 < 99 or ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99] + 31) + 100 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99] + 31) + 100
                if not ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99:
                    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99] + 31) + 100] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    revert with mem[mem[64] len 4], 'ERC1155: transfer to non ERC1155Receiver implementer'
                _12632 = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99] + 31) + 100
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99] + 31) + 100] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                _12721 = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99]
                mem[mem[64] + 36] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 99]
                mem[mem[64] + 68 len ceil32(_12721)] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ext_call.return_data[0] + 131 len ceil32(_12721)]
                if ceil32(_12721) <= _12721:
                    revert with mem[mem[64] len 4], 32, mem[mem[64] + 36 len ceil32(_12721) + 32]
                mem[_12721 + mem[64] + 68] = 0
                revert with memory
                  from mem[64]
                   len ceil32(_12721) + _12632 + -mem[64] + 68
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 99] = calldata.size
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 131 len calldata.size] = call.data[0 len calldata.size]
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + calldata.size + 131] = 0
            idx = 0
            while idx < arg3.length:
                if idx >= arg3.length:
                    revert with 0, 50
                if idx >= arg4.length:
                    revert with 0, 50
                if balanceOf[mem[(32 * idx) + 128]][address(arg1)] < mem[(32 * idx) + ceil32(32 * arg3.length) + 129]:
                    revert with 0, 'ERC1155: insufficient balance for transfer'
                balanceOf[mem[(32 * idx) + 128]][address(arg1)] -= mem[(32 * idx) + ceil32(32 * arg3.length) + 129]
                mem[0] = arg2
                mem[32] = sha3(mem[(32 * idx) + 128], 0)
                if balanceOf[mem[(32 * idx) + 128]][address(arg2)] > !mem[(32 * idx) + ceil32(32 * arg3.length) + 129]:
                    revert with 0, 17
                balanceOf[mem[(32 * idx) + 128]][address(arg2)] += mem[(32 * idx) + ceil32(32 * arg3.length) + 129]
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 227 len 32 * arg3.length] = mem[128 len 32 * arg3.length]
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + 227] = arg4.length
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + 259 len 32 * arg4.length] = mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]
            emit TransferBatch(Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]), (32 * arg3.length) + 96, mem[calldata.size + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 111 len 20], arg1, arg2);
            if not ext_code.size(arg2):
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 135] = mem[calldata.size + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 111 len 20]
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 167] = arg1
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 199] = 160
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 295] = arg3.length
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 327 len 32 * arg3.length] = mem[128 len 32 * arg3.length]
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 231] = (32 * arg3.length) + 192
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + 327] = arg4.length
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + 359 len 32 * arg4.length] = mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 263] = (32 * arg3.length) + (32 * arg4.length) + 224
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + (32 * arg4.length) + 359] = arg5.length
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + (32 * arg4.length) + 391 len ceil32(arg5.length)] = arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256
            if ceil32(arg5.length) <= arg5.length:
                require ext_code.size(arg2)
                call arg2.onERC1155BatchReceived(address rg1, address rg2, uint256[] rg3, uint256[] rg4, bytes rg5) with:
                     gas gas_remaining wei
                    args address(mem[calldata.size + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 99]), address(arg1), Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length], arg5.length, arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256), (32 * arg3.length) + 192, (32 * arg3.length) + (32 * arg4.length) + 224
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 131] = ext_call.return_data[0]
                if ext_call.success:
                    require return_data.size >= 32
                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                    if Mask(32, 224, ext_call.return_data[0]) != 0xbc197c8100000000000000000000000000000000000000000000000000000000:
                        revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                if return_data.size <= 3:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                mem[0 len 4] = ext_call.return_data[0 len 4]
                if uint32(mem[4 len 28]) >> 224 != Error(string rg1):
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if return_data.size < 68:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 131 len return_data.size - 4] = ext_call.return_data[4 len return_data.size - 4]
                if ext_call.return_data[0] > test266151307() or ext_call.return_data[0] + 36 > return_data.size:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] > test266151307():
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 32 > return_data.size - 4:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132 < 131 or ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132
                if not ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131:
                    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    revert with mem[mem[64] len 4], 'ERC1155: transfer to non ERC1155Receiver implementer'
                _12633 = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                _12723 = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131]
                mem[mem[64] + 36] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131]
                mem[mem[64] + 68 len ceil32(_12723)] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 163 len ceil32(_12723)]
                if ceil32(_12723) <= _12723:
                    revert with mem[mem[64] len 4], 32, mem[mem[64] + 36 len ceil32(_12723) + 32]
                mem[_12723 + mem[64] + 68] = 0
                revert with memory
                  from mem[64]
                   len ceil32(_12723) + _12633 + -mem[64] + 68
            mem[arg5.length + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + (32 * arg4.length) + 391] = 0
            require ext_code.size(arg2)
            call arg2.onERC1155BatchReceived(address rg1, address rg2, uint256[] rg3, uint256[] rg4, bytes rg5) with:
                 gas gas_remaining wei
                args address(mem[calldata.size + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 99]), address(arg1), Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length], arg5.length, arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256), (32 * arg3.length) + 192, (32 * arg3.length) + (32 * arg4.length) + 224
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 131] = ext_call.return_data[0]
            if ext_call.success:
                require return_data.size >= 32
                require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                if Mask(32, 224, ext_call.return_data[0]) != 0xbc197c8100000000000000000000000000000000000000000000000000000000:
                    revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
            if return_data.size <= 3:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            mem[0 len 4] = ext_call.return_data[0 len 4]
            if uint32(mem[4 len 28]) >> 224 != Error(string rg1):
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if return_data.size < 68:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 131 len return_data.size - 4] = ext_call.return_data[4 len return_data.size - 4]
            if ext_call.return_data[0] > test266151307() or ext_call.return_data[0] + 36 > return_data.size:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] > test266151307():
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 32 > return_data.size - 4:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132 < 131 or ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132
            if not ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131:
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                revert with mem[mem[64] len 4], 'ERC1155: transfer to non ERC1155Receiver implementer'
            _12634 = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            _12725 = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131]
            mem[mem[64] + 36] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131]
            mem[mem[64] + 68 len ceil32(_12725)] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 163 len ceil32(_12725)]
            if ceil32(_12725) <= _12725:
                revert with mem[mem[64] len 4], 32, mem[mem[64] + 36 len ceil32(_12725) + 32]
            mem[_12725 + mem[64] + 68] = 0
            revert with memory
              from mem[64]
               len ceil32(_12725) + _12634 + -mem[64] + 68
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 99] = calldata.size
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 131 len calldata.size] = call.data[0 len calldata.size]
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + calldata.size + 131] = 0
        mem[0] = mem[calldata.size + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 111 len 20]
        if stor1[address(arg1)][address(mem[calldata.size + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 99])]:
            if msg.sender != this.address:
                idx = 0
                while idx < arg3.length:
                    if idx >= arg3.length:
                        revert with 0, 50
                    if idx >= arg4.length:
                        revert with 0, 50
                    if balanceOf[mem[(32 * idx) + 128]][address(arg1)] < mem[(32 * idx) + ceil32(32 * arg3.length) + 129]:
                        revert with 0, 'ERC1155: insufficient balance for transfer'
                    balanceOf[mem[(32 * idx) + 128]][address(arg1)] -= mem[(32 * idx) + ceil32(32 * arg3.length) + 129]
                    mem[0] = arg2
                    mem[32] = sha3(mem[(32 * idx) + 128], 0)
                    if balanceOf[mem[(32 * idx) + 128]][address(arg2)] > !mem[(32 * idx) + ceil32(32 * arg3.length) + 129]:
                        revert with 0, 17
                    balanceOf[mem[(32 * idx) + 128]][address(arg2)] += mem[(32 * idx) + ceil32(32 * arg3.length) + 129]
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 227 len 32 * arg3.length] = mem[128 len 32 * arg3.length]
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + 227] = arg4.length
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + 259 len 32 * arg4.length] = mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]
                emit TransferBatch(Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]), (32 * arg3.length) + 96, msg.sender, arg1, arg2);
                if not ext_code.size(arg2):
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 135] = msg.sender
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 167] = arg1
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 199] = 160
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 295] = arg3.length
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 327 len 32 * arg3.length] = mem[128 len 32 * arg3.length]
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 231] = (32 * arg3.length) + 192
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + 327] = arg4.length
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + 359 len 32 * arg4.length] = mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 263] = (32 * arg3.length) + (32 * arg4.length) + 224
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + (32 * arg4.length) + 359] = arg5.length
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + (32 * arg4.length) + 391 len ceil32(arg5.length)] = arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256
                if ceil32(arg5.length) <= arg5.length:
                    require ext_code.size(arg2)
                    call arg2.onERC1155BatchReceived(address rg1, address rg2, uint256[] rg3, uint256[] rg4, bytes rg5) with:
                         gas gas_remaining wei
                        args msg.sender, address(arg1), Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length], arg5.length, arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256), (32 * arg3.length) + 192, (32 * arg3.length) + (32 * arg4.length) + 224
                    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 131] = ext_call.return_data[0]
                    if ext_call.success:
                        require return_data.size >= 32
                        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                        if Mask(32, 224, ext_call.return_data[0]) != 0xbc197c8100000000000000000000000000000000000000000000000000000000:
                            revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                    if return_data.size <= 3:
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    mem[0 len 4] = ext_call.return_data[0 len 4]
                    if uint32(mem[4 len 28]) >> 224 != Error(string rg1):
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    if return_data.size < 68:
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 131 len return_data.size - 4] = ext_call.return_data[4 len return_data.size - 4]
                    if ext_call.return_data[0] > test266151307() or ext_call.return_data[0] + 36 > return_data.size:
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    if mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] > test266151307():
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    if ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 32 > return_data.size - 4:
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    if floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132 < 131 or ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132 > test266151307():
                        revert with 0, 65
                    mem[64] = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132
                    if not ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131:
                        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        revert with mem[mem[64] len 4], 'ERC1155: transfer to non ERC1155Receiver implementer'
                    _12635 = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132
                    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    _12727 = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131]
                    mem[mem[64] + 36] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131]
                    mem[mem[64] + 68 len ceil32(_12727)] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 163 len ceil32(_12727)]
                    if ceil32(_12727) <= _12727:
                        revert with mem[mem[64] len 4], 32, mem[mem[64] + 36 len ceil32(_12727) + 32]
                    mem[_12727 + mem[64] + 68] = 0
                    revert with memory
                      from mem[64]
                       len ceil32(_12727) + _12635 + -mem[64] + 68
                mem[arg5.length + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + (32 * arg4.length) + 391] = 0
                require ext_code.size(arg2)
                call arg2.onERC1155BatchReceived(address rg1, address rg2, uint256[] rg3, uint256[] rg4, bytes rg5) with:
                     gas gas_remaining wei
                    args msg.sender, address(arg1), Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length], arg5.length, arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256), (32 * arg3.length) + 192, (32 * arg3.length) + (32 * arg4.length) + 224
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 131] = ext_call.return_data[0]
                if ext_call.success:
                    require return_data.size >= 32
                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                    if Mask(32, 224, ext_call.return_data[0]) != 0xbc197c8100000000000000000000000000000000000000000000000000000000:
                        revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                if return_data.size <= 3:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                mem[0 len 4] = ext_call.return_data[0 len 4]
                if uint32(mem[4 len 28]) >> 224 != Error(string rg1):
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if return_data.size < 68:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 131 len return_data.size - 4] = ext_call.return_data[4 len return_data.size - 4]
                if ext_call.return_data[0] > test266151307() or ext_call.return_data[0] + 36 > return_data.size:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] > test266151307():
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 32 > return_data.size - 4:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132 < 131 or ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132
                if not ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131:
                    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    revert with mem[mem[64] len 4], 'ERC1155: transfer to non ERC1155Receiver implementer'
                _12636 = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                _12729 = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131]
                mem[mem[64] + 36] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131]
                mem[mem[64] + 68 len ceil32(_12729)] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 163 len ceil32(_12729)]
                if ceil32(_12729) <= _12729:
                    revert with mem[mem[64] len 4], 32, mem[mem[64] + 36 len ceil32(_12729) + 32]
                mem[_12729 + mem[64] + 68] = 0
                revert with memory
                  from mem[64]
                   len ceil32(_12729) + _12636 + -mem[64] + 68
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 131] = calldata.size
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 163 len calldata.size] = call.data[0 len calldata.size]
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + calldata.size + 163] = 0
            idx = 0
            while idx < arg3.length:
                if idx >= arg3.length:
                    revert with 0, 50
                if idx >= arg4.length:
                    revert with 0, 50
                if balanceOf[mem[(32 * idx) + 128]][address(arg1)] < mem[(32 * idx) + ceil32(32 * arg3.length) + 129]:
                    revert with 0, 'ERC1155: insufficient balance for transfer'
                balanceOf[mem[(32 * idx) + 128]][address(arg1)] -= mem[(32 * idx) + ceil32(32 * arg3.length) + 129]
                mem[0] = arg2
                mem[32] = sha3(mem[(32 * idx) + 128], 0)
                if balanceOf[mem[(32 * idx) + 128]][address(arg2)] > !mem[(32 * idx) + ceil32(32 * arg3.length) + 129]:
                    revert with 0, 17
                balanceOf[mem[(32 * idx) + 128]][address(arg2)] += mem[(32 * idx) + ceil32(32 * arg3.length) + 129]
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 227] = arg3.length
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 259 len 32 * arg3.length] = mem[128 len 32 * arg3.length]
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 195] = (32 * arg3.length) + 96
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + (32 * arg3.length) + 259] = arg4.length
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + (32 * arg3.length) + 291 len 32 * arg4.length] = mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]
            emit TransferBatch(Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]), (32 * arg3.length) + 96, mem[calldata.size + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 143 len 20], arg1, arg2);
            if not ext_code.size(arg2):
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 167] = mem[calldata.size + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 143 len 20]
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 199] = arg1
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 231] = 160
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 327] = arg3.length
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 359 len 32 * arg3.length] = mem[128 len 32 * arg3.length]
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 263] = (32 * arg3.length) + 192
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + (32 * arg3.length) + 359] = arg4.length
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + (32 * arg3.length) + 391 len 32 * arg4.length] = mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 295] = (32 * arg3.length) + (32 * arg4.length) + 224
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + (32 * arg3.length) + (32 * arg4.length) + 391] = arg5.length
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + (32 * arg3.length) + (32 * arg4.length) + 423 len ceil32(arg5.length)] = arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256
            if ceil32(arg5.length) <= arg5.length:
                require ext_code.size(arg2)
                call arg2.onERC1155BatchReceived(address rg1, address rg2, uint256[] rg3, uint256[] rg4, bytes rg5) with:
                     gas gas_remaining wei
                    args address(mem[calldata.size + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 131]), address(arg1), Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length], arg5.length, arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256), (32 * arg3.length) + 192, (32 * arg3.length) + (32 * arg4.length) + 224
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 163] = ext_call.return_data[0]
                if ext_call.success:
                    require return_data.size >= 32
                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                    if Mask(32, 224, ext_call.return_data[0]) != 0xbc197c8100000000000000000000000000000000000000000000000000000000:
                        revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                if return_data.size <= 3:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                mem[0 len 4] = ext_call.return_data[0 len 4]
                if uint32(mem[4 len 28]) >> 224 != Error(string rg1):
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if return_data.size < 68:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 163 len return_data.size - 4] = ext_call.return_data[4 len return_data.size - 4]
                if ext_call.return_data[0] > test266151307() or ext_call.return_data[0] + 36 > return_data.size:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] > test266151307():
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 32 > return_data.size - 4:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164 < 163 or ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164
                if not ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163:
                    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    revert with mem[mem[64] len 4], 'ERC1155: transfer to non ERC1155Receiver implementer'
                _12637 = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                _12731 = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163]
                mem[mem[64] + 36] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163]
                mem[mem[64] + 68 len ceil32(_12731)] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 195 len ceil32(_12731)]
                if ceil32(_12731) <= _12731:
                    revert with mem[mem[64] len 4], 32, mem[mem[64] + 36 len ceil32(_12731) + 32]
                mem[_12731 + mem[64] + 68] = 0
                revert with memory
                  from mem[64]
                   len ceil32(_12731) + _12637 + -mem[64] + 68
            mem[arg5.length + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + (32 * arg3.length) + (32 * arg4.length) + 423] = 0
            require ext_code.size(arg2)
            call arg2.onERC1155BatchReceived(address rg1, address rg2, uint256[] rg3, uint256[] rg4, bytes rg5) with:
                 gas gas_remaining wei
                args address(mem[calldata.size + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 131]), address(arg1), Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length], arg5.length, arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256), (32 * arg3.length) + 192, (32 * arg3.length) + (32 * arg4.length) + 224
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 163] = ext_call.return_data[0]
            if ext_call.success:
                require return_data.size >= 32
                require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                if Mask(32, 224, ext_call.return_data[0]) != 0xbc197c8100000000000000000000000000000000000000000000000000000000:
                    revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
            if return_data.size <= 3:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            mem[0 len 4] = ext_call.return_data[0 len 4]
            if uint32(mem[4 len 28]) >> 224 != Error(string rg1):
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if return_data.size < 68:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 163 len return_data.size - 4] = ext_call.return_data[4 len return_data.size - 4]
            if ext_call.return_data[0] > test266151307() or ext_call.return_data[0] + 36 > return_data.size:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] > test266151307():
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 32 > return_data.size - 4:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164 < 163 or ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164
            if not ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163:
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                revert with mem[mem[64] len 4], 'ERC1155: transfer to non ERC1155Receiver implementer'
            _12638 = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            _12733 = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163]
            mem[mem[64] + 36] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163]
            mem[mem[64] + 68 len ceil32(_12733)] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 195 len ceil32(_12733)]
            if ceil32(_12733) <= _12733:
                revert with mem[mem[64] len 4], 32, mem[mem[64] + 36 len ceil32(_12733) + 32]
            mem[_12733 + mem[64] + 68] = 0
            revert with memory
              from mem[64]
               len ceil32(_12733) + _12638 + -mem[64] + 68
        mem[0] = mem[calldata.size + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 111 len 20]
        if bool(stor6[address(mem[calldata.size + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 99])]) != 1:
            revert with 0, 'ERC1155: transfer caller is not owner nor approved'
        if msg.sender != this.address:
            idx = 0
            while idx < arg3.length:
                if idx >= arg3.length:
                    revert with 0, 50
                if idx >= arg4.length:
                    revert with 0, 50
                if balanceOf[mem[(32 * idx) + 128]][address(arg1)] < mem[(32 * idx) + ceil32(32 * arg3.length) + 129]:
                    revert with 0, 'ERC1155: insufficient balance for transfer'
                balanceOf[mem[(32 * idx) + 128]][address(arg1)] -= mem[(32 * idx) + ceil32(32 * arg3.length) + 129]
                mem[0] = arg2
                mem[32] = sha3(mem[(32 * idx) + 128], 0)
                if balanceOf[mem[(32 * idx) + 128]][address(arg2)] > !mem[(32 * idx) + ceil32(32 * arg3.length) + 129]:
                    revert with 0, 17
                balanceOf[mem[(32 * idx) + 128]][address(arg2)] += mem[(32 * idx) + ceil32(32 * arg3.length) + 129]
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 227 len 32 * arg3.length] = mem[128 len 32 * arg3.length]
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + 227] = arg4.length
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + 259 len 32 * arg4.length] = mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]
            emit TransferBatch(Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]), (32 * arg3.length) + 96, msg.sender, arg1, arg2);
            if not ext_code.size(arg2):
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 135] = msg.sender
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 167] = arg1
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 199] = 160
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 295] = arg3.length
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 327 len 32 * arg3.length] = mem[128 len 32 * arg3.length]
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 231] = (32 * arg3.length) + 192
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + 327] = arg4.length
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + 359 len 32 * arg4.length] = mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 263] = (32 * arg3.length) + (32 * arg4.length) + 224
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + (32 * arg4.length) + 359] = arg5.length
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + (32 * arg4.length) + 391 len ceil32(arg5.length)] = arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256
            if ceil32(arg5.length) <= arg5.length:
                require ext_code.size(arg2)
                call arg2.onERC1155BatchReceived(address rg1, address rg2, uint256[] rg3, uint256[] rg4, bytes rg5) with:
                     gas gas_remaining wei
                    args msg.sender, address(arg1), Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length], arg5.length, arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256), (32 * arg3.length) + 192, (32 * arg3.length) + (32 * arg4.length) + 224
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 131] = ext_call.return_data[0]
                if ext_call.success:
                    require return_data.size >= 32
                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                    if Mask(32, 224, ext_call.return_data[0]) != 0xbc197c8100000000000000000000000000000000000000000000000000000000:
                        revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                if return_data.size <= 3:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                mem[0 len 4] = ext_call.return_data[0 len 4]
                if uint32(mem[4 len 28]) >> 224 != Error(string rg1):
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if return_data.size < 68:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 131 len return_data.size - 4] = ext_call.return_data[4 len return_data.size - 4]
                if ext_call.return_data[0] > test266151307() or ext_call.return_data[0] + 36 > return_data.size:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] > test266151307():
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 32 > return_data.size - 4:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132 < 131 or ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132
                if not ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131:
                    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    revert with mem[mem[64] len 4], 'ERC1155: transfer to non ERC1155Receiver implementer'
                _12639 = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                _12735 = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131]
                mem[mem[64] + 36] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131]
                mem[mem[64] + 68 len ceil32(_12735)] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 163 len ceil32(_12735)]
                if ceil32(_12735) <= _12735:
                    revert with mem[mem[64] len 4], 32, mem[mem[64] + 36 len ceil32(_12735) + 32]
                mem[_12735 + mem[64] + 68] = 0
                revert with memory
                  from mem[64]
                   len ceil32(_12735) + _12639 + -mem[64] + 68
            mem[arg5.length + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + (32 * arg4.length) + 391] = 0
            require ext_code.size(arg2)
            call arg2.onERC1155BatchReceived(address rg1, address rg2, uint256[] rg3, uint256[] rg4, bytes rg5) with:
                 gas gas_remaining wei
                args msg.sender, address(arg1), Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length], arg5.length, arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256), (32 * arg3.length) + 192, (32 * arg3.length) + (32 * arg4.length) + 224
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 131] = ext_call.return_data[0]
            if ext_call.success:
                require return_data.size >= 32
                require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                if Mask(32, 224, ext_call.return_data[0]) != 0xbc197c8100000000000000000000000000000000000000000000000000000000:
                    revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
            if return_data.size <= 3:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            mem[0 len 4] = ext_call.return_data[0 len 4]
            if uint32(mem[4 len 28]) >> 224 != Error(string rg1):
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if return_data.size < 68:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 131 len return_data.size - 4] = ext_call.return_data[4 len return_data.size - 4]
            if ext_call.return_data[0] > test266151307() or ext_call.return_data[0] + 36 > return_data.size:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] > test266151307():
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 32 > return_data.size - 4:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132 < 131 or ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132
            if not ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131:
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                revert with mem[mem[64] len 4], 'ERC1155: transfer to non ERC1155Receiver implementer'
            _12640 = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            _12737 = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131]
            mem[mem[64] + 36] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131]
            mem[mem[64] + 68 len ceil32(_12737)] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 163 len ceil32(_12737)]
            if ceil32(_12737) <= _12737:
                revert with mem[mem[64] len 4], 32, mem[mem[64] + 36 len ceil32(_12737) + 32]
            mem[_12737 + mem[64] + 68] = 0
            revert with memory
              from mem[64]
               len ceil32(_12737) + _12640 + -mem[64] + 68
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 131] = calldata.size
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 163 len calldata.size] = call.data[0 len calldata.size]
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + calldata.size + 163] = 0
        idx = 0
        while idx < arg3.length:
            if idx >= arg3.length:
                revert with 0, 50
            if idx >= arg4.length:
                revert with 0, 50
            if balanceOf[mem[(32 * idx) + 128]][address(arg1)] < mem[(32 * idx) + ceil32(32 * arg3.length) + 129]:
                revert with 0, 'ERC1155: insufficient balance for transfer'
            balanceOf[mem[(32 * idx) + 128]][address(arg1)] -= mem[(32 * idx) + ceil32(32 * arg3.length) + 129]
            mem[0] = arg2
            mem[32] = sha3(mem[(32 * idx) + 128], 0)
            if balanceOf[mem[(32 * idx) + 128]][address(arg2)] > !mem[(32 * idx) + ceil32(32 * arg3.length) + 129]:
                revert with 0, 17
            balanceOf[mem[(32 * idx) + 128]][address(arg2)] += mem[(32 * idx) + ceil32(32 * arg3.length) + 129]
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 227] = arg3.length
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 259 len 32 * arg3.length] = mem[128 len 32 * arg3.length]
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 195] = (32 * arg3.length) + 96
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + (32 * arg3.length) + 259] = arg4.length
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + (32 * arg3.length) + 291 len 32 * arg4.length] = mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]
        emit TransferBatch(Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]), (32 * arg3.length) + 96, mem[calldata.size + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 143 len 20], arg1, arg2);
        if not ext_code.size(arg2):
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 167] = mem[calldata.size + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 143 len 20]
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 199] = arg1
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 231] = 160
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 327] = arg3.length
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 359 len 32 * arg3.length] = mem[128 len 32 * arg3.length]
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 263] = (32 * arg3.length) + 192
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + (32 * arg3.length) + 359] = arg4.length
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + (32 * arg3.length) + 391 len 32 * arg4.length] = mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 295] = (32 * arg3.length) + (32 * arg4.length) + 224
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + (32 * arg3.length) + (32 * arg4.length) + 391] = arg5.length
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + (32 * arg3.length) + (32 * arg4.length) + 423 len ceil32(arg5.length)] = arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256
        if ceil32(arg5.length) <= arg5.length:
            require ext_code.size(arg2)
            call arg2.onERC1155BatchReceived(address rg1, address rg2, uint256[] rg3, uint256[] rg4, bytes rg5) with:
                 gas gas_remaining wei
                args address(mem[calldata.size + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 131]), address(arg1), Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length], arg5.length, arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256), (32 * arg3.length) + 192, (32 * arg3.length) + (32 * arg4.length) + 224
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 163] = ext_call.return_data[0]
            if ext_call.success:
                require return_data.size >= 32
                require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                if Mask(32, 224, ext_call.return_data[0]) != 0xbc197c8100000000000000000000000000000000000000000000000000000000:
                    revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
            if return_data.size <= 3:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            mem[0 len 4] = ext_call.return_data[0 len 4]
            if uint32(mem[4 len 28]) >> 224 != Error(string rg1):
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if return_data.size < 68:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 163 len return_data.size - 4] = ext_call.return_data[4 len return_data.size - 4]
            if ext_call.return_data[0] > test266151307() or ext_call.return_data[0] + 36 > return_data.size:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] > test266151307():
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 32 > return_data.size - 4:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164 < 163 or ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164
            if not ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163:
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                revert with mem[mem[64] len 4], 'ERC1155: transfer to non ERC1155Receiver implementer'
            _12641 = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            _12739 = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163]
            mem[mem[64] + 36] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163]
            mem[mem[64] + 68 len ceil32(_12739)] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 195 len ceil32(_12739)]
            if ceil32(_12739) <= _12739:
                revert with mem[mem[64] len 4], 32, mem[mem[64] + 36 len ceil32(_12739) + 32]
            mem[_12739 + mem[64] + 68] = 0
            revert with memory
              from mem[64]
               len ceil32(_12739) + _12641 + -mem[64] + 68
        mem[arg5.length + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + (32 * arg3.length) + (32 * arg4.length) + 423] = 0
        require ext_code.size(arg2)
        call arg2.onERC1155BatchReceived(address rg1, address rg2, uint256[] rg3, uint256[] rg4, bytes rg5) with:
             gas gas_remaining wei
            args address(mem[calldata.size + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 131]), address(arg1), Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length], arg5.length, arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256), (32 * arg3.length) + 192, (32 * arg3.length) + (32 * arg4.length) + 224
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 163] = ext_call.return_data[0]
        if ext_call.success:
            require return_data.size >= 32
            require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
            if Mask(32, 224, ext_call.return_data[0]) != 0xbc197c8100000000000000000000000000000000000000000000000000000000:
                revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
        if return_data.size <= 3:
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        mem[0 len 4] = ext_call.return_data[0 len 4]
        if uint32(mem[4 len 28]) >> 224 != Error(string rg1):
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        if return_data.size < 68:
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 163 len return_data.size - 4] = ext_call.return_data[4 len return_data.size - 4]
        if ext_call.return_data[0] > test266151307() or ext_call.return_data[0] + 36 > return_data.size:
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        if mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] > test266151307():
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        if ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 32 > return_data.size - 4:
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        if floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164 < 163 or ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164 > test266151307():
            revert with 0, 65
        mem[64] = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164
        if not ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163:
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            revert with mem[mem[64] len 4], 'ERC1155: transfer to non ERC1155Receiver implementer'
        _12642 = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        _12741 = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163]
        mem[mem[64] + 36] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163]
        mem[mem[64] + 68 len ceil32(_12741)] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 195 len ceil32(_12741)]
        if ceil32(_12741) <= _12741:
            revert with mem[mem[64] len 4], 32, mem[mem[64] + 36 len ceil32(_12741) + 32]
        mem[_12741 + mem[64] + 68] = 0
        revert with memory
          from mem[64]
           len ceil32(_12741) + _12642 + -mem[64] + 68
    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 99] = calldata.size
    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 131 len calldata.size] = call.data[0 len calldata.size]
    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + calldata.size + 131] = 0
    if arg1 == mem[calldata.size + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + 111 len 20]:
        if msg.sender != this.address:
            idx = 0
            while idx < arg3.length:
                if idx >= arg3.length:
                    revert with 0, 50
                if idx >= arg4.length:
                    revert with 0, 50
                if balanceOf[mem[(32 * idx) + 128]][address(arg1)] < mem[(32 * idx) + ceil32(32 * arg3.length) + 129]:
                    revert with 0, 'ERC1155: insufficient balance for transfer'
                balanceOf[mem[(32 * idx) + 128]][address(arg1)] -= mem[(32 * idx) + ceil32(32 * arg3.length) + 129]
                mem[0] = arg2
                mem[32] = sha3(mem[(32 * idx) + 128], 0)
                if balanceOf[mem[(32 * idx) + 128]][address(arg2)] > !mem[(32 * idx) + ceil32(32 * arg3.length) + 129]:
                    revert with 0, 17
                balanceOf[mem[(32 * idx) + 128]][address(arg2)] += mem[(32 * idx) + ceil32(32 * arg3.length) + 129]
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 227 len 32 * arg3.length] = mem[128 len 32 * arg3.length]
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + 227] = arg4.length
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + 259 len 32 * arg4.length] = mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]
            emit TransferBatch(Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]), (32 * arg3.length) + 96, msg.sender, arg1, arg2);
            if not ext_code.size(arg2):
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 135] = msg.sender
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 167] = arg1
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 199] = 160
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 295] = arg3.length
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 327 len 32 * arg3.length] = mem[128 len 32 * arg3.length]
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 231] = (32 * arg3.length) + 192
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + 327] = arg4.length
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + 359 len 32 * arg4.length] = mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 263] = (32 * arg3.length) + (32 * arg4.length) + 224
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + (32 * arg4.length) + 359] = arg5.length
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + (32 * arg4.length) + 391 len ceil32(arg5.length)] = arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256
            if ceil32(arg5.length) <= arg5.length:
                require ext_code.size(arg2)
                call arg2.onERC1155BatchReceived(address rg1, address rg2, uint256[] rg3, uint256[] rg4, bytes rg5) with:
                     gas gas_remaining wei
                    args msg.sender, address(arg1), Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length], arg5.length, arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256), (32 * arg3.length) + 192, (32 * arg3.length) + (32 * arg4.length) + 224
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 131] = ext_call.return_data[0]
                if ext_call.success:
                    require return_data.size >= 32
                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                    if Mask(32, 224, ext_call.return_data[0]) != 0xbc197c8100000000000000000000000000000000000000000000000000000000:
                        revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                if return_data.size <= 3:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                mem[0 len 4] = ext_call.return_data[0 len 4]
                if uint32(mem[4 len 28]) >> 224 != Error(string rg1):
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if return_data.size < 68:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 131 len return_data.size - 4] = ext_call.return_data[4 len return_data.size - 4]
                if ext_call.return_data[0] > test266151307() or ext_call.return_data[0] + 36 > return_data.size:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] > test266151307():
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 32 > return_data.size - 4:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132 < 131 or ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132
                if not ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131:
                    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    revert with mem[mem[64] len 4], 'ERC1155: transfer to non ERC1155Receiver implementer'
                _12643 = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                _12743 = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131]
                mem[mem[64] + 36] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131]
                mem[mem[64] + 68 len ceil32(_12743)] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 163 len ceil32(_12743)]
                if ceil32(_12743) <= _12743:
                    revert with mem[mem[64] len 4], 32, mem[mem[64] + 36 len ceil32(_12743) + 32]
                mem[_12743 + mem[64] + 68] = 0
                revert with memory
                  from mem[64]
                   len ceil32(_12743) + _12643 + -mem[64] + 68
            mem[arg5.length + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + (32 * arg4.length) + 391] = 0
            require ext_code.size(arg2)
            call arg2.onERC1155BatchReceived(address rg1, address rg2, uint256[] rg3, uint256[] rg4, bytes rg5) with:
                 gas gas_remaining wei
                args msg.sender, address(arg1), Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length], arg5.length, arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256), (32 * arg3.length) + 192, (32 * arg3.length) + (32 * arg4.length) + 224
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 131] = ext_call.return_data[0]
            if ext_call.success:
                require return_data.size >= 32
                require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                if Mask(32, 224, ext_call.return_data[0]) != 0xbc197c8100000000000000000000000000000000000000000000000000000000:
                    revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
            if return_data.size <= 3:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            mem[0 len 4] = ext_call.return_data[0 len 4]
            if uint32(mem[4 len 28]) >> 224 != Error(string rg1):
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if return_data.size < 68:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 131 len return_data.size - 4] = ext_call.return_data[4 len return_data.size - 4]
            if ext_call.return_data[0] > test266151307() or ext_call.return_data[0] + 36 > return_data.size:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] > test266151307():
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 32 > return_data.size - 4:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132 < 131 or ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132
            if not ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131:
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                revert with mem[mem[64] len 4], 'ERC1155: transfer to non ERC1155Receiver implementer'
            _12644 = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            _12745 = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131]
            mem[mem[64] + 36] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131]
            mem[mem[64] + 68 len ceil32(_12745)] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 163 len ceil32(_12745)]
            if ceil32(_12745) <= _12745:
                revert with mem[mem[64] len 4], 32, mem[mem[64] + 36 len ceil32(_12745) + 32]
            mem[_12745 + mem[64] + 68] = 0
            revert with memory
              from mem[64]
               len ceil32(_12745) + _12644 + -mem[64] + 68
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 131] = calldata.size
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 163 len calldata.size] = call.data[0 len calldata.size]
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + calldata.size + 163] = 0
        idx = 0
        while idx < arg3.length:
            if idx >= arg3.length:
                revert with 0, 50
            if idx >= arg4.length:
                revert with 0, 50
            if balanceOf[mem[(32 * idx) + 128]][address(arg1)] < mem[(32 * idx) + ceil32(32 * arg3.length) + 129]:
                revert with 0, 'ERC1155: insufficient balance for transfer'
            balanceOf[mem[(32 * idx) + 128]][address(arg1)] -= mem[(32 * idx) + ceil32(32 * arg3.length) + 129]
            mem[0] = arg2
            mem[32] = sha3(mem[(32 * idx) + 128], 0)
            if balanceOf[mem[(32 * idx) + 128]][address(arg2)] > !mem[(32 * idx) + ceil32(32 * arg3.length) + 129]:
                revert with 0, 17
            balanceOf[mem[(32 * idx) + 128]][address(arg2)] += mem[(32 * idx) + ceil32(32 * arg3.length) + 129]
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 227] = arg3.length
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 259 len 32 * arg3.length] = mem[128 len 32 * arg3.length]
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 195] = (32 * arg3.length) + 96
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + (32 * arg3.length) + 259] = arg4.length
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + (32 * arg3.length) + 291 len 32 * arg4.length] = mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]
        emit TransferBatch(Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]), (32 * arg3.length) + 96, mem[calldata.size + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 143 len 20], arg1, arg2);
        if not ext_code.size(arg2):
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 167] = mem[calldata.size + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 143 len 20]
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 199] = arg1
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 231] = 160
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 327] = arg3.length
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 359 len 32 * arg3.length] = mem[128 len 32 * arg3.length]
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 263] = (32 * arg3.length) + 192
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + (32 * arg3.length) + 359] = arg4.length
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + (32 * arg3.length) + 391 len 32 * arg4.length] = mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 295] = (32 * arg3.length) + (32 * arg4.length) + 224
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + (32 * arg3.length) + (32 * arg4.length) + 391] = arg5.length
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + (32 * arg3.length) + (32 * arg4.length) + 423 len ceil32(arg5.length)] = arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256
        if ceil32(arg5.length) <= arg5.length:
            require ext_code.size(arg2)
            call arg2.onERC1155BatchReceived(address rg1, address rg2, uint256[] rg3, uint256[] rg4, bytes rg5) with:
                 gas gas_remaining wei
                args address(mem[calldata.size + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 131]), address(arg1), Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length], arg5.length, arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256), (32 * arg3.length) + 192, (32 * arg3.length) + (32 * arg4.length) + 224
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 163] = ext_call.return_data[0]
            if ext_call.success:
                require return_data.size >= 32
                require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                if Mask(32, 224, ext_call.return_data[0]) != 0xbc197c8100000000000000000000000000000000000000000000000000000000:
                    revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
            if return_data.size <= 3:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            mem[0 len 4] = ext_call.return_data[0 len 4]
            if uint32(mem[4 len 28]) >> 224 != Error(string rg1):
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if return_data.size < 68:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 163 len return_data.size - 4] = ext_call.return_data[4 len return_data.size - 4]
            if ext_call.return_data[0] > test266151307() or ext_call.return_data[0] + 36 > return_data.size:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] > test266151307():
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 32 > return_data.size - 4:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164 < 163 or ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164
            if not ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163:
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                revert with mem[mem[64] len 4], 'ERC1155: transfer to non ERC1155Receiver implementer'
            _12645 = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            _12747 = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163]
            mem[mem[64] + 36] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163]
            mem[mem[64] + 68 len ceil32(_12747)] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 195 len ceil32(_12747)]
            if ceil32(_12747) <= _12747:
                revert with mem[mem[64] len 4], 32, mem[mem[64] + 36 len ceil32(_12747) + 32]
            mem[_12747 + mem[64] + 68] = 0
            revert with memory
              from mem[64]
               len ceil32(_12747) + _12645 + -mem[64] + 68
        mem[arg5.length + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + (32 * arg3.length) + (32 * arg4.length) + 423] = 0
        require ext_code.size(arg2)
        call arg2.onERC1155BatchReceived(address rg1, address rg2, uint256[] rg3, uint256[] rg4, bytes rg5) with:
             gas gas_remaining wei
            args address(mem[calldata.size + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 131]), address(arg1), Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length], arg5.length, arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256), (32 * arg3.length) + 192, (32 * arg3.length) + (32 * arg4.length) + 224
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 163] = ext_call.return_data[0]
        if ext_call.success:
            require return_data.size >= 32
            require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
            if Mask(32, 224, ext_call.return_data[0]) != 0xbc197c8100000000000000000000000000000000000000000000000000000000:
                revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
        if return_data.size <= 3:
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        mem[0 len 4] = ext_call.return_data[0 len 4]
        if uint32(mem[4 len 28]) >> 224 != Error(string rg1):
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        if return_data.size < 68:
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 163 len return_data.size - 4] = ext_call.return_data[4 len return_data.size - 4]
        if ext_call.return_data[0] > test266151307() or ext_call.return_data[0] + 36 > return_data.size:
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        if mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] > test266151307():
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        if ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 32 > return_data.size - 4:
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        if floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164 < 163 or ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164 > test266151307():
            revert with 0, 65
        mem[64] = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164
        if not ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163:
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            revert with mem[mem[64] len 4], 'ERC1155: transfer to non ERC1155Receiver implementer'
        _12646 = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        _12749 = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163]
        mem[mem[64] + 36] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163]
        mem[mem[64] + 68 len ceil32(_12749)] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 195 len ceil32(_12749)]
        if ceil32(_12749) <= _12749:
            revert with mem[mem[64] len 4], 32, mem[mem[64] + 36 len ceil32(_12749) + 32]
        mem[_12749 + mem[64] + 68] = 0
        revert with memory
          from mem[64]
           len ceil32(_12749) + _12646 + -mem[64] + 68
    if msg.sender != this.address:
        mem[0] = msg.sender
        if stor1[address(arg1)][address(msg.sender)]:
            if msg.sender != this.address:
                idx = 0
                while idx < arg3.length:
                    if idx >= arg3.length:
                        revert with 0, 50
                    if idx >= arg4.length:
                        revert with 0, 50
                    if balanceOf[mem[(32 * idx) + 128]][address(arg1)] < mem[(32 * idx) + ceil32(32 * arg3.length) + 129]:
                        revert with 0, 'ERC1155: insufficient balance for transfer'
                    balanceOf[mem[(32 * idx) + 128]][address(arg1)] -= mem[(32 * idx) + ceil32(32 * arg3.length) + 129]
                    mem[0] = arg2
                    mem[32] = sha3(mem[(32 * idx) + 128], 0)
                    if balanceOf[mem[(32 * idx) + 128]][address(arg2)] > !mem[(32 * idx) + ceil32(32 * arg3.length) + 129]:
                        revert with 0, 17
                    balanceOf[mem[(32 * idx) + 128]][address(arg2)] += mem[(32 * idx) + ceil32(32 * arg3.length) + 129]
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 227 len 32 * arg3.length] = mem[128 len 32 * arg3.length]
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + 227] = arg4.length
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + 259 len 32 * arg4.length] = mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]
                emit TransferBatch(Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]), (32 * arg3.length) + 96, msg.sender, arg1, arg2);
                if not ext_code.size(arg2):
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 135] = msg.sender
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 167] = arg1
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 199] = 160
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 295] = arg3.length
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 327 len 32 * arg3.length] = mem[128 len 32 * arg3.length]
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 231] = (32 * arg3.length) + 192
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + 327] = arg4.length
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + 359 len 32 * arg4.length] = mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 263] = (32 * arg3.length) + (32 * arg4.length) + 224
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + (32 * arg4.length) + 359] = arg5.length
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + (32 * arg4.length) + 391 len ceil32(arg5.length)] = arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256
                if ceil32(arg5.length) <= arg5.length:
                    require ext_code.size(arg2)
                    call arg2.onERC1155BatchReceived(address rg1, address rg2, uint256[] rg3, uint256[] rg4, bytes rg5) with:
                         gas gas_remaining wei
                        args msg.sender, address(arg1), Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length], arg5.length, arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256), (32 * arg3.length) + 192, (32 * arg3.length) + (32 * arg4.length) + 224
                    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 131] = ext_call.return_data[0]
                    if ext_call.success:
                        require return_data.size >= 32
                        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                        if Mask(32, 224, ext_call.return_data[0]) != 0xbc197c8100000000000000000000000000000000000000000000000000000000:
                            revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                    if return_data.size <= 3:
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    mem[0 len 4] = ext_call.return_data[0 len 4]
                    if uint32(mem[4 len 28]) >> 224 != Error(string rg1):
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    if return_data.size < 68:
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 131 len return_data.size - 4] = ext_call.return_data[4 len return_data.size - 4]
                    if ext_call.return_data[0] > test266151307() or ext_call.return_data[0] + 36 > return_data.size:
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    if mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] > test266151307():
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    if ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 32 > return_data.size - 4:
                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                    if floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132 < 131 or ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132 > test266151307():
                        revert with 0, 65
                    mem[64] = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132
                    if not ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131:
                        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        revert with mem[mem[64] len 4], 'ERC1155: transfer to non ERC1155Receiver implementer'
                    _12647 = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132
                    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    _12751 = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131]
                    mem[mem[64] + 36] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131]
                    mem[mem[64] + 68 len ceil32(_12751)] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 163 len ceil32(_12751)]
                    if ceil32(_12751) <= _12751:
                        revert with mem[mem[64] len 4], 32, mem[mem[64] + 36 len ceil32(_12751) + 32]
                    mem[_12751 + mem[64] + 68] = 0
                    revert with memory
                      from mem[64]
                       len ceil32(_12751) + _12647 + -mem[64] + 68
                mem[arg5.length + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + (32 * arg4.length) + 391] = 0
                require ext_code.size(arg2)
                call arg2.onERC1155BatchReceived(address rg1, address rg2, uint256[] rg3, uint256[] rg4, bytes rg5) with:
                     gas gas_remaining wei
                    args msg.sender, address(arg1), Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length], arg5.length, arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256), (32 * arg3.length) + 192, (32 * arg3.length) + (32 * arg4.length) + 224
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 131] = ext_call.return_data[0]
                if ext_call.success:
                    require return_data.size >= 32
                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                    if Mask(32, 224, ext_call.return_data[0]) != 0xbc197c8100000000000000000000000000000000000000000000000000000000:
                        revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                if return_data.size <= 3:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                mem[0 len 4] = ext_call.return_data[0 len 4]
                if uint32(mem[4 len 28]) >> 224 != Error(string rg1):
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if return_data.size < 68:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 131 len return_data.size - 4] = ext_call.return_data[4 len return_data.size - 4]
                if ext_call.return_data[0] > test266151307() or ext_call.return_data[0] + 36 > return_data.size:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] > test266151307():
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 32 > return_data.size - 4:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132 < 131 or ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132
                if not ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131:
                    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    revert with mem[mem[64] len 4], 'ERC1155: transfer to non ERC1155Receiver implementer'
                _12648 = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                _12753 = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131]
                mem[mem[64] + 36] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131]
                mem[mem[64] + 68 len ceil32(_12753)] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 163 len ceil32(_12753)]
                if ceil32(_12753) <= _12753:
                    revert with mem[mem[64] len 4], 32, mem[mem[64] + 36 len ceil32(_12753) + 32]
                mem[_12753 + mem[64] + 68] = 0
                revert with memory
                  from mem[64]
                   len ceil32(_12753) + _12648 + -mem[64] + 68
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 131] = calldata.size
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 163 len calldata.size] = call.data[0 len calldata.size]
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + calldata.size + 163] = 0
            idx = 0
            while idx < arg3.length:
                if idx >= arg3.length:
                    revert with 0, 50
                if idx >= arg4.length:
                    revert with 0, 50
                if balanceOf[mem[(32 * idx) + 128]][address(arg1)] < mem[(32 * idx) + ceil32(32 * arg3.length) + 129]:
                    revert with 0, 'ERC1155: insufficient balance for transfer'
                balanceOf[mem[(32 * idx) + 128]][address(arg1)] -= mem[(32 * idx) + ceil32(32 * arg3.length) + 129]
                mem[0] = arg2
                mem[32] = sha3(mem[(32 * idx) + 128], 0)
                if balanceOf[mem[(32 * idx) + 128]][address(arg2)] > !mem[(32 * idx) + ceil32(32 * arg3.length) + 129]:
                    revert with 0, 17
                balanceOf[mem[(32 * idx) + 128]][address(arg2)] += mem[(32 * idx) + ceil32(32 * arg3.length) + 129]
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 227] = arg3.length
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 259 len 32 * arg3.length] = mem[128 len 32 * arg3.length]
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 195] = (32 * arg3.length) + 96
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + (32 * arg3.length) + 259] = arg4.length
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + (32 * arg3.length) + 291 len 32 * arg4.length] = mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]
            emit TransferBatch(Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]), (32 * arg3.length) + 96, mem[calldata.size + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 143 len 20], arg1, arg2);
            if not ext_code.size(arg2):
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 167] = mem[calldata.size + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 143 len 20]
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 199] = arg1
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 231] = 160
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 327] = arg3.length
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 359 len 32 * arg3.length] = mem[128 len 32 * arg3.length]
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 263] = (32 * arg3.length) + 192
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + (32 * arg3.length) + 359] = arg4.length
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + (32 * arg3.length) + 391 len 32 * arg4.length] = mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 295] = (32 * arg3.length) + (32 * arg4.length) + 224
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + (32 * arg3.length) + (32 * arg4.length) + 391] = arg5.length
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + (32 * arg3.length) + (32 * arg4.length) + 423 len ceil32(arg5.length)] = arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256
            if ceil32(arg5.length) <= arg5.length:
                require ext_code.size(arg2)
                call arg2.onERC1155BatchReceived(address rg1, address rg2, uint256[] rg3, uint256[] rg4, bytes rg5) with:
                     gas gas_remaining wei
                    args address(mem[calldata.size + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 131]), address(arg1), Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length], arg5.length, arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256), (32 * arg3.length) + 192, (32 * arg3.length) + (32 * arg4.length) + 224
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 163] = ext_call.return_data[0]
                if ext_call.success:
                    require return_data.size >= 32
                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                    if Mask(32, 224, ext_call.return_data[0]) != 0xbc197c8100000000000000000000000000000000000000000000000000000000:
                        revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                if return_data.size <= 3:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                mem[0 len 4] = ext_call.return_data[0 len 4]
                if uint32(mem[4 len 28]) >> 224 != Error(string rg1):
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if return_data.size < 68:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 163 len return_data.size - 4] = ext_call.return_data[4 len return_data.size - 4]
                if ext_call.return_data[0] > test266151307() or ext_call.return_data[0] + 36 > return_data.size:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] > test266151307():
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 32 > return_data.size - 4:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164 < 163 or ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164
                if not ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163:
                    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    revert with mem[mem[64] len 4], 'ERC1155: transfer to non ERC1155Receiver implementer'
                _12649 = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                _12755 = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163]
                mem[mem[64] + 36] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163]
                mem[mem[64] + 68 len ceil32(_12755)] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 195 len ceil32(_12755)]
                if ceil32(_12755) <= _12755:
                    revert with mem[mem[64] len 4], 32, mem[mem[64] + 36 len ceil32(_12755) + 32]
                mem[_12755 + mem[64] + 68] = 0
                revert with memory
                  from mem[64]
                   len ceil32(_12755) + _12649 + -mem[64] + 68
            mem[arg5.length + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + (32 * arg3.length) + (32 * arg4.length) + 423] = 0
            require ext_code.size(arg2)
            call arg2.onERC1155BatchReceived(address rg1, address rg2, uint256[] rg3, uint256[] rg4, bytes rg5) with:
                 gas gas_remaining wei
                args address(mem[calldata.size + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 131]), address(arg1), Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length], arg5.length, arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256), (32 * arg3.length) + 192, (32 * arg3.length) + (32 * arg4.length) + 224
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 163] = ext_call.return_data[0]
            if ext_call.success:
                require return_data.size >= 32
                require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                if Mask(32, 224, ext_call.return_data[0]) != 0xbc197c8100000000000000000000000000000000000000000000000000000000:
                    revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
            if return_data.size <= 3:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            mem[0 len 4] = ext_call.return_data[0 len 4]
            if uint32(mem[4 len 28]) >> 224 != Error(string rg1):
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if return_data.size < 68:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 163 len return_data.size - 4] = ext_call.return_data[4 len return_data.size - 4]
            if ext_call.return_data[0] > test266151307() or ext_call.return_data[0] + 36 > return_data.size:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] > test266151307():
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 32 > return_data.size - 4:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164 < 163 or ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164
            if not ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163:
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                revert with mem[mem[64] len 4], 'ERC1155: transfer to non ERC1155Receiver implementer'
            _12650 = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            _12757 = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163]
            mem[mem[64] + 36] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163]
            mem[mem[64] + 68 len ceil32(_12757)] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 195 len ceil32(_12757)]
            if ceil32(_12757) <= _12757:
                revert with mem[mem[64] len 4], 32, mem[mem[64] + 36 len ceil32(_12757) + 32]
            mem[_12757 + mem[64] + 68] = 0
            revert with memory
              from mem[64]
               len ceil32(_12757) + _12650 + -mem[64] + 68
        mem[0] = msg.sender
        if bool(stor6[address(msg.sender)]) != 1:
            revert with 0, 'ERC1155: transfer caller is not owner nor approved'
        if msg.sender != this.address:
            idx = 0
            while idx < arg3.length:
                if idx >= arg3.length:
                    revert with 0, 50
                if idx >= arg4.length:
                    revert with 0, 50
                if balanceOf[mem[(32 * idx) + 128]][address(arg1)] < mem[(32 * idx) + ceil32(32 * arg3.length) + 129]:
                    revert with 0, 'ERC1155: insufficient balance for transfer'
                balanceOf[mem[(32 * idx) + 128]][address(arg1)] -= mem[(32 * idx) + ceil32(32 * arg3.length) + 129]
                mem[0] = arg2
                mem[32] = sha3(mem[(32 * idx) + 128], 0)
                if balanceOf[mem[(32 * idx) + 128]][address(arg2)] > !mem[(32 * idx) + ceil32(32 * arg3.length) + 129]:
                    revert with 0, 17
                balanceOf[mem[(32 * idx) + 128]][address(arg2)] += mem[(32 * idx) + ceil32(32 * arg3.length) + 129]
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 227 len 32 * arg3.length] = mem[128 len 32 * arg3.length]
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + 227] = arg4.length
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + 259 len 32 * arg4.length] = mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]
            emit TransferBatch(Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]), (32 * arg3.length) + 96, msg.sender, arg1, arg2);
            if not ext_code.size(arg2):
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 135] = msg.sender
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 167] = arg1
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 199] = 160
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 295] = arg3.length
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 327 len 32 * arg3.length] = mem[128 len 32 * arg3.length]
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 231] = (32 * arg3.length) + 192
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + 327] = arg4.length
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + 359 len 32 * arg4.length] = mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 263] = (32 * arg3.length) + (32 * arg4.length) + 224
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + (32 * arg4.length) + 359] = arg5.length
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + (32 * arg4.length) + 391 len ceil32(arg5.length)] = arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256
            if ceil32(arg5.length) <= arg5.length:
                require ext_code.size(arg2)
                call arg2.onERC1155BatchReceived(address rg1, address rg2, uint256[] rg3, uint256[] rg4, bytes rg5) with:
                     gas gas_remaining wei
                    args msg.sender, address(arg1), Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length], arg5.length, arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256), (32 * arg3.length) + 192, (32 * arg3.length) + (32 * arg4.length) + 224
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 131] = ext_call.return_data[0]
                if ext_call.success:
                    require return_data.size >= 32
                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                    if Mask(32, 224, ext_call.return_data[0]) != 0xbc197c8100000000000000000000000000000000000000000000000000000000:
                        revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                if return_data.size <= 3:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                mem[0 len 4] = ext_call.return_data[0 len 4]
                if uint32(mem[4 len 28]) >> 224 != Error(string rg1):
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if return_data.size < 68:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 131 len return_data.size - 4] = ext_call.return_data[4 len return_data.size - 4]
                if ext_call.return_data[0] > test266151307() or ext_call.return_data[0] + 36 > return_data.size:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] > test266151307():
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 32 > return_data.size - 4:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132 < 131 or ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132
                if not ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131:
                    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    revert with mem[mem[64] len 4], 'ERC1155: transfer to non ERC1155Receiver implementer'
                _12651 = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                _12759 = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131]
                mem[mem[64] + 36] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131]
                mem[mem[64] + 68 len ceil32(_12759)] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 163 len ceil32(_12759)]
                if ceil32(_12759) <= _12759:
                    revert with mem[mem[64] len 4], 32, mem[mem[64] + 36 len ceil32(_12759) + 32]
                mem[_12759 + mem[64] + 68] = 0
                revert with memory
                  from mem[64]
                   len ceil32(_12759) + _12651 + -mem[64] + 68
            mem[arg5.length + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + (32 * arg3.length) + (32 * arg4.length) + 391] = 0
            require ext_code.size(arg2)
            call arg2.onERC1155BatchReceived(address rg1, address rg2, uint256[] rg3, uint256[] rg4, bytes rg5) with:
                 gas gas_remaining wei
                args msg.sender, address(arg1), Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length], arg5.length, arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256), (32 * arg3.length) + 192, (32 * arg3.length) + (32 * arg4.length) + 224
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 131] = ext_call.return_data[0]
            if ext_call.success:
                require return_data.size >= 32
                require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                if Mask(32, 224, ext_call.return_data[0]) != 0xbc197c8100000000000000000000000000000000000000000000000000000000:
                    revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
            if return_data.size <= 3:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            mem[0 len 4] = ext_call.return_data[0 len 4]
            if uint32(mem[4 len 28]) >> 224 != Error(string rg1):
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if return_data.size < 68:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 131 len return_data.size - 4] = ext_call.return_data[4 len return_data.size - 4]
            if ext_call.return_data[0] > test266151307() or ext_call.return_data[0] + 36 > return_data.size:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] > test266151307():
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 32 > return_data.size - 4:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132 < 131 or ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132
            if not ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131:
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                revert with mem[mem[64] len 4], 'ERC1155: transfer to non ERC1155Receiver implementer'
            _12652 = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131] + 31) + 132] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            _12761 = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131]
            mem[mem[64] + 36] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 131]
            mem[mem[64] + 68 len ceil32(_12761)] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + ext_call.return_data[0] + 163 len ceil32(_12761)]
            if ceil32(_12761) <= _12761:
                revert with mem[mem[64] len 4], 32, mem[mem[64] + 36 len ceil32(_12761) + 32]
            mem[_12761 + mem[64] + 68] = 0
            revert with memory
              from mem[64]
               len ceil32(_12761) + _12652 + -mem[64] + 68
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 131] = calldata.size
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 163 len calldata.size] = call.data[0 len calldata.size]
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + calldata.size + 163] = 0
        idx = 0
        while idx < arg3.length:
            if idx >= arg3.length:
                revert with 0, 50
            if idx >= arg4.length:
                revert with 0, 50
            if balanceOf[mem[(32 * idx) + 128]][address(arg1)] < mem[(32 * idx) + ceil32(32 * arg3.length) + 129]:
                revert with 0, 'ERC1155: insufficient balance for transfer'
            balanceOf[mem[(32 * idx) + 128]][address(arg1)] -= mem[(32 * idx) + ceil32(32 * arg3.length) + 129]
            mem[0] = arg2
            mem[32] = sha3(mem[(32 * idx) + 128], 0)
            if balanceOf[mem[(32 * idx) + 128]][address(arg2)] > !mem[(32 * idx) + ceil32(32 * arg3.length) + 129]:
                revert with 0, 17
            balanceOf[mem[(32 * idx) + 128]][address(arg2)] += mem[(32 * idx) + ceil32(32 * arg3.length) + 129]
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 227] = arg3.length
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 259 len 32 * arg3.length] = mem[128 len 32 * arg3.length]
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 195] = (32 * arg3.length) + 96
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + (32 * arg3.length) + 259] = arg4.length
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + (32 * arg3.length) + 291 len 32 * arg4.length] = mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]
        emit TransferBatch(Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]), (32 * arg3.length) + 96, mem[calldata.size + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 143 len 20], arg1, arg2);
        if not ext_code.size(arg2):
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 167] = mem[calldata.size + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 143 len 20]
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 199] = arg1
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 231] = 160
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 327] = arg3.length
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 359 len 32 * arg3.length] = mem[128 len 32 * arg3.length]
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 263] = (32 * arg3.length) + 192
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + (32 * arg3.length) + 359] = arg4.length
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + (32 * arg3.length) + 391 len 32 * arg4.length] = mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 295] = (32 * arg3.length) + (32 * arg4.length) + 224
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + (32 * arg3.length) + (32 * arg4.length) + 391] = arg5.length
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + (32 * arg3.length) + (32 * arg4.length) + 423 len ceil32(arg5.length)] = arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256
        if ceil32(arg5.length) <= arg5.length:
            require ext_code.size(arg2)
            call arg2.onERC1155BatchReceived(address rg1, address rg2, uint256[] rg3, uint256[] rg4, bytes rg5) with:
                 gas gas_remaining wei
                args address(mem[calldata.size + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 131]), address(arg1), Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length], arg5.length, arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256), (32 * arg3.length) + 192, (32 * arg3.length) + (32 * arg4.length) + 224
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 163] = ext_call.return_data[0]
            if ext_call.success:
                require return_data.size >= 32
                require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                if Mask(32, 224, ext_call.return_data[0]) != 0xbc197c8100000000000000000000000000000000000000000000000000000000:
                    revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
            if return_data.size <= 3:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            mem[0 len 4] = ext_call.return_data[0 len 4]
            if uint32(mem[4 len 28]) >> 224 != Error(string rg1):
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if return_data.size < 68:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 163 len return_data.size - 4] = ext_call.return_data[4 len return_data.size - 4]
            if ext_call.return_data[0] > test266151307() or ext_call.return_data[0] + 36 > return_data.size:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] > test266151307():
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 32 > return_data.size - 4:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164 < 163 or ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164
            if not ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163:
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                revert with mem[mem[64] len 4], 'ERC1155: transfer to non ERC1155Receiver implementer'
            _12653 = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            _12763 = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163]
            mem[mem[64] + 36] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163]
            mem[mem[64] + 68 len ceil32(_12763)] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 195 len ceil32(_12763)]
            if ceil32(_12763) <= _12763:
                revert with mem[mem[64] len 4], 32, mem[mem[64] + 36 len ceil32(_12763) + 32]
            mem[_12763 + mem[64] + 68] = 0
            revert with memory
              from mem[64]
               len ceil32(_12763) + _12653 + -mem[64] + 68
        mem[arg5.length + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + (32 * arg3.length) + (32 * arg4.length) + 423] = 0
        require ext_code.size(arg2)
        call arg2.onERC1155BatchReceived(address rg1, address rg2, uint256[] rg3, uint256[] rg4, bytes rg5) with:
             gas gas_remaining wei
            args address(mem[calldata.size + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 131]), address(arg1), Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length], arg5.length, arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256), (32 * arg3.length) + 192, (32 * arg3.length) + (32 * arg4.length) + 224
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 163] = ext_call.return_data[0]
        if ext_call.success:
            require return_data.size >= 32
            require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
            if Mask(32, 224, ext_call.return_data[0]) != 0xbc197c8100000000000000000000000000000000000000000000000000000000:
                revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
        if return_data.size <= 3:
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        mem[0 len 4] = ext_call.return_data[0 len 4]
        if uint32(mem[4 len 28]) >> 224 != Error(string rg1):
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        if return_data.size < 68:
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 163 len return_data.size - 4] = ext_call.return_data[4 len return_data.size - 4]
        if ext_call.return_data[0] > test266151307() or ext_call.return_data[0] + 36 > return_data.size:
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        if mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] > test266151307():
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        if ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 32 > return_data.size - 4:
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        if floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164 < 163 or ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164 > test266151307():
            revert with 0, 65
        mem[64] = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164
        if not ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163:
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            revert with mem[mem[64] len 4], 'ERC1155: transfer to non ERC1155Receiver implementer'
        _12654 = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        _12765 = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163]
        mem[mem[64] + 36] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163]
        mem[mem[64] + 68 len ceil32(_12765)] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 195 len ceil32(_12765)]
        if ceil32(_12765) <= _12765:
            revert with mem[mem[64] len 4], 32, mem[mem[64] + 36 len ceil32(_12765) + 32]
        mem[_12765 + mem[64] + 68] = 0
        revert with memory
          from mem[64]
           len ceil32(_12765) + _12654 + -mem[64] + 68
    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 131] = calldata.size
    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 163 len calldata.size] = call.data[0 len calldata.size]
    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + calldata.size + 163] = 0
    mem[0] = mem[calldata.size + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 143 len 20]
    if stor1[address(arg1)][address(mem[calldata.size + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 131])]:
        if msg.sender != this.address:
            idx = 0
            while idx < arg3.length:
                if idx >= arg3.length:
                    revert with 0, 50
                if idx >= arg4.length:
                    revert with 0, 50
                if balanceOf[mem[(32 * idx) + 128]][address(arg1)] < mem[(32 * idx) + ceil32(32 * arg3.length) + 129]:
                    revert with 0, 'ERC1155: insufficient balance for transfer'
                balanceOf[mem[(32 * idx) + 128]][address(arg1)] -= mem[(32 * idx) + ceil32(32 * arg3.length) + 129]
                mem[0] = arg2
                mem[32] = sha3(mem[(32 * idx) + 128], 0)
                if balanceOf[mem[(32 * idx) + 128]][address(arg2)] > !mem[(32 * idx) + ceil32(32 * arg3.length) + 129]:
                    revert with 0, 17
                balanceOf[mem[(32 * idx) + 128]][address(arg2)] += mem[(32 * idx) + ceil32(32 * arg3.length) + 129]
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 259 len 32 * arg3.length] = mem[128 len 32 * arg3.length]
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + (32 * arg3.length) + 259] = arg4.length
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + (32 * arg3.length) + 291 len 32 * arg4.length] = mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]
            emit TransferBatch(Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]), (32 * arg3.length) + 96, msg.sender, arg1, arg2);
            if not ext_code.size(arg2):
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 167] = msg.sender
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 199] = arg1
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 231] = 160
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 327] = arg3.length
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 359 len 32 * arg3.length] = mem[128 len 32 * arg3.length]
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 263] = (32 * arg3.length) + 192
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + (32 * arg3.length) + 359] = arg4.length
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + (32 * arg3.length) + 391 len 32 * arg4.length] = mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 295] = (32 * arg3.length) + (32 * arg4.length) + 224
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + (32 * arg3.length) + (32 * arg4.length) + 391] = arg5.length
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + (32 * arg3.length) + (32 * arg4.length) + 423 len ceil32(arg5.length)] = arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256
            if ceil32(arg5.length) <= arg5.length:
                require ext_code.size(arg2)
                call arg2.onERC1155BatchReceived(address rg1, address rg2, uint256[] rg3, uint256[] rg4, bytes rg5) with:
                     gas gas_remaining wei
                    args msg.sender, address(arg1), Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length], arg5.length, arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256), (32 * arg3.length) + 192, (32 * arg3.length) + (32 * arg4.length) + 224
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 163] = ext_call.return_data[0]
                if ext_call.success:
                    require return_data.size >= 32
                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                    if Mask(32, 224, ext_call.return_data[0]) != 0xbc197c8100000000000000000000000000000000000000000000000000000000:
                        revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                if return_data.size <= 3:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                mem[0 len 4] = ext_call.return_data[0 len 4]
                if uint32(mem[4 len 28]) >> 224 != Error(string rg1):
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if return_data.size < 68:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 163 len return_data.size - 4] = ext_call.return_data[4 len return_data.size - 4]
                if ext_call.return_data[0] > test266151307() or ext_call.return_data[0] + 36 > return_data.size:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] > test266151307():
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 32 > return_data.size - 4:
                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                if floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164 < 163 or ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164
                if not ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163:
                    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    revert with mem[mem[64] len 4], 'ERC1155: transfer to non ERC1155Receiver implementer'
                _12655 = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                _12767 = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163]
                mem[mem[64] + 36] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163]
                mem[mem[64] + 68 len ceil32(_12767)] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 195 len ceil32(_12767)]
                if ceil32(_12767) <= _12767:
                    revert with mem[mem[64] len 4], 32, mem[mem[64] + 36 len ceil32(_12767) + 32]
                mem[_12767 + mem[64] + 68] = 0
                revert with memory
                  from mem[64]
                   len ceil32(_12767) + _12655 + -mem[64] + 68
            mem[arg5.length + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + (32 * arg3.length) + (32 * arg4.length) + 423] = 0
            require ext_code.size(arg2)
            call arg2.onERC1155BatchReceived(address rg1, address rg2, uint256[] rg3, uint256[] rg4, bytes rg5) with:
                 gas gas_remaining wei
                args msg.sender, address(arg1), Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length], arg5.length, arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256), (32 * arg3.length) + 192, (32 * arg3.length) + (32 * arg4.length) + 224
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 163] = ext_call.return_data[0]
            if ext_call.success:
                require return_data.size >= 32
                require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                if Mask(32, 224, ext_call.return_data[0]) != 0xbc197c8100000000000000000000000000000000000000000000000000000000:
                    revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
            if return_data.size <= 3:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            mem[0 len 4] = ext_call.return_data[0 len 4]
            if uint32(mem[4 len 28]) >> 224 != Error(string rg1):
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if return_data.size < 68:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 163 len return_data.size - 4] = ext_call.return_data[4 len return_data.size - 4]
            if ext_call.return_data[0] > test266151307() or ext_call.return_data[0] + 36 > return_data.size:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] > test266151307():
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 32 > return_data.size - 4:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164 < 163 or ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164
            if not ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163:
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                revert with mem[mem[64] len 4], 'ERC1155: transfer to non ERC1155Receiver implementer'
            _12656 = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            _12769 = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163]
            mem[mem[64] + 36] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163]
            mem[mem[64] + 68 len ceil32(_12769)] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 195 len ceil32(_12769)]
            if ceil32(_12769) <= _12769:
                revert with mem[mem[64] len 4], 32, mem[mem[64] + 36 len ceil32(_12769) + 32]
            mem[_12769 + mem[64] + 68] = 0
            revert with memory
              from mem[64]
               len ceil32(_12769) + _12656 + -mem[64] + 68
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 163] = calldata.size
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 195 len calldata.size] = call.data[0 len calldata.size]
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + calldata.size + 195] = 0
        idx = 0
        while idx < arg3.length:
            if idx >= arg3.length:
                revert with 0, 50
            if idx >= arg4.length:
                revert with 0, 50
            if balanceOf[mem[(32 * idx) + 128]][address(arg1)] < mem[(32 * idx) + ceil32(32 * arg3.length) + 129]:
                revert with 0, 'ERC1155: insufficient balance for transfer'
            balanceOf[mem[(32 * idx) + 128]][address(arg1)] -= mem[(32 * idx) + ceil32(32 * arg3.length) + 129]
            mem[0] = arg2
            mem[32] = sha3(mem[(32 * idx) + 128], 0)
            if balanceOf[mem[(32 * idx) + 128]][address(arg2)] > !mem[(32 * idx) + ceil32(32 * arg3.length) + 129]:
                revert with 0, 17
            balanceOf[mem[(32 * idx) + 128]][address(arg2)] += mem[(32 * idx) + ceil32(32 * arg3.length) + 129]
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + 291 len 32 * arg3.length] = mem[128 len 32 * arg3.length]
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + (32 * arg3.length) + 291] = arg4.length
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + (32 * arg3.length) + 323 len 32 * arg4.length] = mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]
        emit TransferBatch(Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]), (32 * arg3.length) + 96, mem[calldata.size + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 175 len 20], arg1, arg2);
        if not ext_code.size(arg2):
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + 199] = mem[calldata.size + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 175 len 20]
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + 231] = arg1
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + 263] = 160
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + 359] = arg3.length
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + 391 len 32 * arg3.length] = mem[128 len 32 * arg3.length]
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + 295] = (32 * arg3.length) + 192
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + (32 * arg3.length) + 391] = arg4.length
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + (32 * arg3.length) + 423 len 32 * arg4.length] = mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + 327] = (32 * arg3.length) + (32 * arg4.length) + 224
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + (32 * arg3.length) + (32 * arg4.length) + 423] = arg5.length
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + (32 * arg3.length) + (32 * arg4.length) + 455 len ceil32(arg5.length)] = arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256
        if ceil32(arg5.length) <= arg5.length:
            require ext_code.size(arg2)
            call arg2.onERC1155BatchReceived(address rg1, address rg2, uint256[] rg3, uint256[] rg4, bytes rg5) with:
                 gas gas_remaining wei
                args address(mem[calldata.size + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 163]), address(arg1), Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length], arg5.length, arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256), (32 * arg3.length) + 192, (32 * arg3.length) + (32 * arg4.length) + 224
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + 195] = ext_call.return_data[0]
            if ext_call.success:
                require return_data.size >= 32
                require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                if Mask(32, 224, ext_call.return_data[0]) != 0xbc197c8100000000000000000000000000000000000000000000000000000000:
                    revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
            if return_data.size <= 3:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            mem[0 len 4] = ext_call.return_data[0 len 4]
            if uint32(mem[4 len 28]) >> 224 != Error(string rg1):
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if return_data.size < 68:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + 195 len return_data.size - 4] = ext_call.return_data[4 len return_data.size - 4]
            if ext_call.return_data[0] > test266151307() or ext_call.return_data[0] + 36 > return_data.size:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + ext_call.return_data[0] + 195] > test266151307():
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + ext_call.return_data[0] + 195] + 32 > return_data.size - 4:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + ext_call.return_data[0] + 195] + 31) + 196 < 195 or ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + ext_call.return_data[0] + 195] + 31) + 196 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + ext_call.return_data[0] + 195] + 31) + 196
            if not ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + ext_call.return_data[0] + 195:
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + ext_call.return_data[0] + 195] + 31) + 196] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                revert with mem[mem[64] len 4], 'ERC1155: transfer to non ERC1155Receiver implementer'
            _12657 = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + ext_call.return_data[0] + 195] + 31) + 196
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + ext_call.return_data[0] + 195] + 31) + 196] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            _12771 = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + ext_call.return_data[0] + 195]
            mem[mem[64] + 36] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + ext_call.return_data[0] + 195]
            mem[mem[64] + 68 len ceil32(_12771)] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + ext_call.return_data[0] + 227 len ceil32(_12771)]
            if ceil32(_12771) <= _12771:
                revert with mem[mem[64] len 4], 32, mem[mem[64] + 36 len ceil32(_12771) + 32]
            mem[_12771 + mem[64] + 68] = 0
            revert with memory
              from mem[64]
               len ceil32(_12771) + _12657 + -mem[64] + 68
        mem[arg5.length + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + (32 * arg3.length) + (32 * arg4.length) + 455] = 0
        require ext_code.size(arg2)
        call arg2.onERC1155BatchReceived(address rg1, address rg2, uint256[] rg3, uint256[] rg4, bytes rg5) with:
             gas gas_remaining wei
            args address(mem[calldata.size + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 163]), address(arg1), Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length], arg5.length, arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256), (32 * arg3.length) + 192, (32 * arg3.length) + (32 * arg4.length) + 224
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + 195] = ext_call.return_data[0]
        if ext_call.success:
            require return_data.size >= 32
            require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
            if Mask(32, 224, ext_call.return_data[0]) != 0xbc197c8100000000000000000000000000000000000000000000000000000000:
                revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
        if return_data.size <= 3:
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        mem[0 len 4] = ext_call.return_data[0 len 4]
        if uint32(mem[4 len 28]) >> 224 != Error(string rg1):
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        if return_data.size < 68:
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + 195 len return_data.size - 4] = ext_call.return_data[4 len return_data.size - 4]
        if ext_call.return_data[0] > test266151307() or ext_call.return_data[0] + 36 > return_data.size:
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        if mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + ext_call.return_data[0] + 195] > test266151307():
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        if ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + ext_call.return_data[0] + 195] + 32 > return_data.size - 4:
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        if floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + ext_call.return_data[0] + 195] + 31) + 196 < 195 or ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + ext_call.return_data[0] + 195] + 31) + 196 > test266151307():
            revert with 0, 65
        mem[64] = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + ext_call.return_data[0] + 195] + 31) + 196
        if not ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + ext_call.return_data[0] + 195:
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + ext_call.return_data[0] + 195] + 31) + 196] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            revert with mem[mem[64] len 4], 'ERC1155: transfer to non ERC1155Receiver implementer'
        _12658 = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + ext_call.return_data[0] + 195] + 31) + 196
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + ext_call.return_data[0] + 195] + 31) + 196] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        _12773 = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + ext_call.return_data[0] + 195]
        mem[mem[64] + 36] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + ext_call.return_data[0] + 195]
        mem[mem[64] + 68 len ceil32(_12773)] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + ext_call.return_data[0] + 227 len ceil32(_12773)]
        if ceil32(_12773) <= _12773:
            revert with mem[mem[64] len 4], 32, mem[mem[64] + 36 len ceil32(_12773) + 32]
        mem[_12773 + mem[64] + 68] = 0
        revert with memory
          from mem[64]
           len ceil32(_12773) + _12658 + -mem[64] + 68
    mem[0] = mem[calldata.size + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 143 len 20]
    if bool(stor6[address(mem[calldata.size + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + ceil32(calldata.size) + 131])]) != 1:
        revert with 0, 'ERC1155: transfer caller is not owner nor approved'
    if msg.sender != this.address:
        idx = 0
        while idx < arg3.length:
            if idx >= arg3.length:
                revert with 0, 50
            if idx >= arg4.length:
                revert with 0, 50
            if balanceOf[mem[(32 * idx) + 128]][address(arg1)] < mem[(32 * idx) + ceil32(32 * arg3.length) + 129]:
                revert with 0, 'ERC1155: insufficient balance for transfer'
            balanceOf[mem[(32 * idx) + 128]][address(arg1)] -= mem[(32 * idx) + ceil32(32 * arg3.length) + 129]
            mem[0] = arg2
            mem[32] = sha3(mem[(32 * idx) + 128], 0)
            if balanceOf[mem[(32 * idx) + 128]][address(arg2)] > !mem[(32 * idx) + ceil32(32 * arg3.length) + 129]:
                revert with 0, 17
            balanceOf[mem[(32 * idx) + 128]][address(arg2)] += mem[(32 * idx) + ceil32(32 * arg3.length) + 129]
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 259 len 32 * arg3.length] = mem[128 len 32 * arg3.length]
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + (32 * arg3.length) + 259] = arg4.length
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + (32 * arg3.length) + 291 len 32 * arg4.length] = mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]
        emit TransferBatch(Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]), (32 * arg3.length) + 96, msg.sender, arg1, arg2);
        if not ext_code.size(arg2):
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 167] = msg.sender
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 199] = arg1
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 231] = 160
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 327] = arg3.length
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 359 len 32 * arg3.length] = mem[128 len 32 * arg3.length]
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 263] = (32 * arg3.length) + 192
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + (32 * arg3.length) + 359] = arg4.length
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + (32 * arg3.length) + 391 len 32 * arg4.length] = mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 295] = (32 * arg3.length) + (32 * arg4.length) + 224
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + (32 * arg3.length) + (32 * arg4.length) + 391] = arg5.length
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + (32 * arg3.length) + (32 * arg4.length) + 423 len ceil32(arg5.length)] = arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256
        if ceil32(arg5.length) <= arg5.length:
            require ext_code.size(arg2)
            call arg2.onERC1155BatchReceived(address rg1, address rg2, uint256[] rg3, uint256[] rg4, bytes rg5) with:
                 gas gas_remaining wei
                args msg.sender, address(arg1), Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length], arg5.length, arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256), (32 * arg3.length) + 192, (32 * arg3.length) + (32 * arg4.length) + 224
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 163] = ext_call.return_data[0]
            if ext_call.success:
                require return_data.size >= 32
                require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                if Mask(32, 224, ext_call.return_data[0]) != 0xbc197c8100000000000000000000000000000000000000000000000000000000:
                    revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
            if return_data.size <= 3:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            mem[0 len 4] = ext_call.return_data[0 len 4]
            if uint32(mem[4 len 28]) >> 224 != Error(string rg1):
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if return_data.size < 68:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 163 len return_data.size - 4] = ext_call.return_data[4 len return_data.size - 4]
            if ext_call.return_data[0] > test266151307() or ext_call.return_data[0] + 36 > return_data.size:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] > test266151307():
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 32 > return_data.size - 4:
                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
            if floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164 < 163 or ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164
            if not ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163:
                mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                revert with mem[mem[64] len 4], 'ERC1155: transfer to non ERC1155Receiver implementer'
            _12659 = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            _12775 = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163]
            mem[mem[64] + 36] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163]
            mem[mem[64] + 68 len ceil32(_12775)] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 195 len ceil32(_12775)]
            if ceil32(_12775) <= _12775:
                revert with mem[mem[64] len 4], 32, mem[mem[64] + 36 len ceil32(_12775) + 32]
            mem[_12775 + mem[64] + 68] = 0
            revert with memory
              from mem[64]
               len ceil32(_12775) + _12659 + -mem[64] + 68
        mem[arg5.length + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + (32 * arg3.length) + (32 * arg4.length) + 423] = 0
        require ext_code.size(arg2)
        call arg2.onERC1155BatchReceived(address rg1, address rg2, uint256[] rg3, uint256[] rg4, bytes rg5) with:
             gas gas_remaining wei
            args msg.sender, address(arg1), Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length], arg5.length, arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256), (32 * arg3.length) + 192, (32 * arg3.length) + (32 * arg4.length) + 224
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 163] = ext_call.return_data[0]
        if ext_call.success:
            require return_data.size >= 32
            require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
            if Mask(32, 224, ext_call.return_data[0]) != 0xbc197c8100000000000000000000000000000000000000000000000000000000:
                revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
        if return_data.size <= 3:
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        mem[0 len 4] = ext_call.return_data[0 len 4]
        if uint32(mem[4 len 28]) >> 224 != Error(string rg1):
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        if return_data.size < 68:
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 163 len return_data.size - 4] = ext_call.return_data[4 len return_data.size - 4]
        if ext_call.return_data[0] > test266151307() or ext_call.return_data[0] + 36 > return_data.size:
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        if mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] > test266151307():
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        if ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 32 > return_data.size - 4:
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        if floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164 < 163 or ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164 > test266151307():
            revert with 0, 65
        mem[64] = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164
        if not ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163:
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            revert with mem[mem[64] len 4], 'ERC1155: transfer to non ERC1155Receiver implementer'
        _12660 = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163] + 31) + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        _12777 = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163]
        mem[mem[64] + 36] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 163]
        mem[mem[64] + 68 len ceil32(_12777)] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + ext_call.return_data[0] + 195 len ceil32(_12777)]
        if ceil32(_12777) <= _12777:
            revert with mem[mem[64] len 4], 32, mem[mem[64] + 36 len ceil32(_12777) + 32]
        mem[_12777 + mem[64] + 68] = 0
        revert with memory
          from mem[64]
           len ceil32(_12777) + _12660 + -mem[64] + 68
    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 163] = calldata.size
    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 195 len calldata.size] = call.data[0 len calldata.size]
    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + calldata.size + 195] = 0
    idx = 0
    while idx < arg3.length:
        if idx >= arg3.length:
            revert with 0, 50
        if idx >= arg4.length:
            revert with 0, 50
        if balanceOf[mem[(32 * idx) + 128]][address(arg1)] < mem[(32 * idx) + ceil32(32 * arg3.length) + 129]:
            revert with 0, 'ERC1155: insufficient balance for transfer'
        balanceOf[mem[(32 * idx) + 128]][address(arg1)] -= mem[(32 * idx) + ceil32(32 * arg3.length) + 129]
        mem[0] = arg2
        mem[32] = sha3(mem[(32 * idx) + 128], 0)
        if balanceOf[mem[(32 * idx) + 128]][address(arg2)] > !mem[(32 * idx) + ceil32(32 * arg3.length) + 129]:
            revert with 0, 17
        balanceOf[mem[(32 * idx) + 128]][address(arg2)] += mem[(32 * idx) + ceil32(32 * arg3.length) + 129]
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + 291 len 32 * arg3.length] = mem[128 len 32 * arg3.length]
    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + (32 * arg3.length) + 291] = arg4.length
    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + (32 * arg3.length) + 323 len 32 * arg4.length] = mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]
    emit TransferBatch(Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]), (32 * arg3.length) + 96, mem[calldata.size + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 175 len 20], arg1, arg2);
    if not ext_code.size(arg2):
    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + 199] = mem[calldata.size + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 175 len 20]
    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + 231] = arg1
    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + 263] = 160
    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + 359] = arg3.length
    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + 391 len 32 * arg3.length] = mem[128 len 32 * arg3.length]
    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + 295] = (32 * arg3.length) + 192
    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + (32 * arg3.length) + 391] = arg4.length
    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + (32 * arg3.length) + 423 len 32 * arg4.length] = mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length]
    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + 327] = (32 * arg3.length) + (32 * arg4.length) + 224
    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + (32 * arg3.length) + (32 * arg4.length) + 423] = arg5.length
    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + (32 * arg3.length) + (32 * arg4.length) + 455 len ceil32(arg5.length)] = arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256
    if ceil32(arg5.length) <= arg5.length:
        require ext_code.size(arg2)
        call arg2.onERC1155BatchReceived(address rg1, address rg2, uint256[] rg3, uint256[] rg4, bytes rg5) with:
             gas gas_remaining wei
            args address(mem[calldata.size + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 163]), address(arg1), Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length], arg5.length, arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256), (32 * arg3.length) + 192, (32 * arg3.length) + (32 * arg4.length) + 224
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + 195] = ext_call.return_data[0]
        if ext_call.success:
            require return_data.size >= 32
            require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
            if Mask(32, 224, ext_call.return_data[0]) != 0xbc197c8100000000000000000000000000000000000000000000000000000000:
                revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
        if return_data.size <= 3:
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        mem[0 len 4] = ext_call.return_data[0 len 4]
        if uint32(mem[4 len 28]) >> 224 != Error(string rg1):
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        if return_data.size < 68:
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + 195 len return_data.size - 4] = ext_call.return_data[4 len return_data.size - 4]
        if ext_call.return_data[0] > test266151307() or ext_call.return_data[0] + 36 > return_data.size:
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        if mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + ext_call.return_data[0] + 195] > test266151307():
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        if ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + ext_call.return_data[0] + 195] + 32 > return_data.size - 4:
            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
        if floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + ext_call.return_data[0] + 195] + 31) + 196 < 195 or ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + ext_call.return_data[0] + 195] + 31) + 196 > test266151307():
            revert with 0, 65
        mem[64] = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + ext_call.return_data[0] + 195] + 31) + 196
        if not ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + ext_call.return_data[0] + 195:
            mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + ext_call.return_data[0] + 195] + 31) + 196] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            revert with mem[mem[64] len 4], 'ERC1155: transfer to non ERC1155Receiver implementer'
        _12661 = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + ext_call.return_data[0] + 195] + 31) + 196
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + ext_call.return_data[0] + 195] + 31) + 196] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        _12779 = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + ext_call.return_data[0] + 195]
        mem[mem[64] + 36] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + ext_call.return_data[0] + 195]
        mem[mem[64] + 68 len ceil32(_12779)] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + ext_call.return_data[0] + 227 len ceil32(_12779)]
        if ceil32(_12779) <= _12779:
            revert with mem[mem[64] len 4], 32, mem[mem[64] + 36 len ceil32(_12779) + 32]
        mem[_12779 + mem[64] + 68] = 0
        revert with memory
          from mem[64]
           len ceil32(_12779) + _12661 + -mem[64] + 68
    mem[arg5.length + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + (32 * arg3.length) + (32 * arg4.length) + 455] = 0
    require ext_code.size(arg2)
    call arg2.onERC1155BatchReceived(address rg1, address rg2, uint256[] rg3, uint256[] rg4, bytes rg5) with:
         gas gas_remaining wei
        args address(mem[calldata.size + ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (2 * ceil32(calldata.size)) + 163]), address(arg1), Array(len=arg3.length, data=mem[128 len 32 * arg3.length], arg4.length, mem[ceil32(32 * arg3.length) + 129 len 32 * arg4.length], arg5.length, arg5[all], Mask(8 * ceil32(arg5.length) - arg5.length, -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256, calldata.size) >> -(8 * ceil32(arg5.length) + -ceil32(ceil32(arg5.length)) + 31) + 256), (32 * arg3.length) + 192, (32 * arg3.length) + (32 * arg4.length) + 224
    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + 195] = ext_call.return_data[0]
    if ext_call.success:
        require return_data.size >= 32
        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
        if Mask(32, 224, ext_call.return_data[0]) != 0xbc197c8100000000000000000000000000000000000000000000000000000000:
            revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
    if return_data.size <= 3:
        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
    mem[0 len 4] = ext_call.return_data[0 len 4]
    if uint32(mem[4 len 28]) >> 224 != Error(string rg1):
        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
    if return_data.size < 68:
        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + 195 len return_data.size - 4] = ext_call.return_data[4 len return_data.size - 4]
    if ext_call.return_data[0] > test266151307() or ext_call.return_data[0] + 36 > return_data.size:
        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
    if mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + ext_call.return_data[0] + 195] > test266151307():
        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
    if ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + ext_call.return_data[0] + 195] + 32 > return_data.size - 4:
        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
    if floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + ext_call.return_data[0] + 195] + 31) + 196 < 195 or ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + ext_call.return_data[0] + 195] + 31) + 196 > test266151307():
        revert with 0, 65
    mem[64] = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + ext_call.return_data[0] + 195] + 31) + 196
    if not ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + ext_call.return_data[0] + 195:
        mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + ext_call.return_data[0] + 195] + 31) + 196] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        revert with mem[mem[64] len 4], 'ERC1155: transfer to non ERC1155Receiver implementer'
    _12662 = ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + ext_call.return_data[0] + 195] + 31) + 196
    mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + floor32(ext_call.return_data[0] + mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + ext_call.return_data[0] + 195] + 31) + 196] = 0x8c379a000000000000000000000000000000000000000000000000000000000
    mem[mem[64] + 4] = 32
    _12781 = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + ext_call.return_data[0] + 195]
    mem[mem[64] + 36] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + ext_call.return_data[0] + 195]
    mem[mem[64] + 68 len ceil32(_12781)] = mem[ceil32(32 * arg3.length) + ceil32(32 * arg4.length) + ceil32(ceil32(arg5.length)) + (4 * ceil32(calldata.size)) + ext_call.return_data[0] + 227 len ceil32(_12781)]
    if ceil32(_12781) <= _12781:
        revert with mem[mem[64] len 4], 32, mem[mem[64] + 36 len ceil32(_12781) + 32]
    mem[_12781 + mem[64] + 68] = 0
    revert with memory
      from mem[64]
       len ceil32(_12781) + _12662 + -mem[64] + 68
}

function sub_f09d4db0(?) payable {
    mem[64] = 96
    require not msg.value
    require calldata.size - 4 >= 32
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    require ('cd', 4).length <= test266151307()
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    if msg.sender != this.address:
        mem[0] = msg.sender
        mem[32] = sha3(0, 2)
        if uint8(roleAdmin[0][address(msg.sender)].field_0):
            idx = 0
            while idx < ('cd', 4).length:
                require cd[(cd[4] + (32 * idx) + 36)] < calldata.size + -cd[4] - 163
                mem[0] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                mem[32] = 12
                if bool(stor12[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]]) != 1:
                    require cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] < calldata.size + -cd[(cd[4] + (32 * idx) + 36)] + -cd[4] - 67
                    require cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 36)] <= test266151307()
                    require cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68 <= calldata.size - (32 * cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 36)])
                    require cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] < calldata.size + -cd[(cd[4] + (32 * idx) + 36)] + -cd[4] - 67
                    require cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 36)] <= test266151307()
                    require cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68 <= calldata.size - (32 * cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 36)])
                    if msg.sender != this.address:
                        mem[0] = msg.sender
                        mem[32] = sha3(0, 2)
                        if uint8(roleAdmin[0][address(msg.sender)].field_0):
                            if cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 36)] != cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 36)]:
                                revert with 0, 'number of ids must equal number of accounts'
                            s = 0
                            while s < cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 36)]:
                                if s >= cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 36)]:
                                    revert with 0, 50
                                require cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)] == address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])
                                if msg.sender != this.address:
                                    mem[0] = msg.sender
                                    mem[32] = sha3(0, 2)
                                    if not uint8(roleAdmin[0][address(msg.sender)].field_0):
                                        _5523 = mem[64]
                                        mem[mem[64]] = 42
                                        mem[64] = mem[64] + 96
                                        mem[_5523 + 32 len 42] = call.data[calldata.size len 42]
                                        if 0 >= mem[_5523]:
                                            revert with 0, 50
                                        mem[_5523 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                                        if 1 >= mem[_5523]:
                                            revert with 0, 50
                                        mem[_5523 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                                        idx = 41
                                        s = address(msg.sender)
                                        while idx > 1:
                                            if s % 16 >= 16:
                                                revert with 0, 50
                                            if idx >= mem[_5523]:
                                                revert with 0, 50
                                            mem[idx + _5523 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                                            if not idx:
                                                revert with 0, 17
                                            idx = idx - 1
                                            s = Mask(252, 0, s) * 0.0625
                                            continue 
                                        if msg.sender + 10240:
                                            revert with 0, 'Strings: hex length insufficient'
                                        _8379 = mem[64]
                                        mem[mem[64]] = 66
                                        mem[64] = mem[64] + 128
                                        mem[_8379 + 32 len 66] = call.data[calldata.size len 66]
                                        if 0 >= mem[_8379]:
                                            revert with 0, 50
                                        mem[_8379 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                                        if 1 >= mem[_8379]:
                                            revert with 0, 50
                                        mem[_8379 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                                        idx = 65
                                        while idx > 1:
                                            if idx >= mem[_8379]:
                                                revert with 0, 50
                                            mem[idx + _8379 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                                            if not idx:
                                                revert with 0, 17
                                            idx = idx - 1
                                            continue 
                                        _10279 = mem[64]
                                        mem[mem[64] + 32] = 'AccessControl: account '
                                        _10311 = mem[_5523]
                                        idx = 0
                                        while idx < _10311:
                                            mem[idx + _10279 + 55] = mem[idx + _5523 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_10279 + _10311 + 55] = 0x206973206d697373696e6720726f6c6520000000000000000000000000000000
                                        if ceil32(_10311) <= _10311:
                                            _11111 = mem[_8379]
                                            idx = 0
                                            while idx < _11111:
                                                mem[idx + _10279 + _10311 + 72] = mem[idx + _8379 + 32]
                                                idx = idx + 32
                                                continue 
                                            if ceil32(_11111) <= _11111:
                                                _11735 = mem[64]
                                                mem[mem[64]] = _11111 + _10279 + _10311 + -mem[64] + 40
                                                mem[64] = _11111 + _10279 + _10311 + 72
                                                mem[_11111 + _10279 + _10311 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_11111 + _10279 + _10311 + 76] = 32
                                                _11863 = mem[_11735]
                                                mem[_11111 + _10279 + _10311 + 108] = mem[_11735]
                                                idx = 0
                                                while idx < _11863:
                                                    mem[idx + _11111 + _10279 + _10311 + 140] = mem[idx + _11735 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                if ceil32(_11863) > _11863:
                                                    mem[_11863 + _11111 + _10279 + _10311 + 140] = 0
                                                revert with 0, 32, mem[_11111 + _10279 + _10311 + 108 len ceil32(_11863) + 32]
                                            mem[_11111 + _10279 + _10311 + 72] = 0
                                            _11736 = mem[64]
                                            mem[mem[64]] = _11111 + _10279 + _10311 + -mem[64] + 40
                                            mem[64] = _11111 + _10279 + _10311 + 72
                                            mem[_11111 + _10279 + _10311 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_11111 + _10279 + _10311 + 76] = 32
                                            _11864 = mem[_11736]
                                            mem[_11111 + _10279 + _10311 + 108] = mem[_11736]
                                            idx = 0
                                            while idx < _11864:
                                                mem[idx + _11111 + _10279 + _10311 + 140] = mem[idx + _11736 + 32]
                                                idx = idx + 32
                                                continue 
                                            if ceil32(_11864) > _11864:
                                                mem[_11864 + _11111 + _10279 + _10311 + 140] = 0
                                            revert with 0, 32, mem[_11111 + _10279 + _10311 + 108 len ceil32(_11864) + 32]
                                        _11112 = mem[_8379]
                                        idx = 0
                                        while idx < _11112:
                                            mem[idx + _10279 + _10311 + 72] = mem[idx + _8379 + 32]
                                            idx = idx + 32
                                            continue 
                                        if ceil32(_11112) <= _11112:
                                            _11737 = mem[64]
                                            mem[mem[64]] = _11112 + _10279 + _10311 + -mem[64] + 40
                                            mem[64] = _11112 + _10279 + _10311 + 72
                                            mem[_11112 + _10279 + _10311 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_11112 + _10279 + _10311 + 76] = 32
                                            _11865 = mem[_11737]
                                            mem[_11112 + _10279 + _10311 + 108] = mem[_11737]
                                            idx = 0
                                            while idx < _11865:
                                                mem[idx + _11112 + _10279 + _10311 + 140] = mem[idx + _11737 + 32]
                                                idx = idx + 32
                                                continue 
                                            if ceil32(_11865) > _11865:
                                                mem[_11865 + _11112 + _10279 + _10311 + 140] = 0
                                            revert with 0, 32, mem[_11112 + _10279 + _10311 + 108 len ceil32(_11865) + 32]
                                        mem[_11112 + _10279 + _10311 + 72] = 0
                                        _11738 = mem[64]
                                        mem[mem[64]] = _11112 + _10279 + _10311 + -mem[64] + 40
                                        mem[64] = _11112 + _10279 + _10311 + 72
                                        mem[_11112 + _10279 + _10311 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[_11112 + _10279 + _10311 + 76] = 32
                                        _11866 = mem[_11738]
                                        mem[_11112 + _10279 + _10311 + 108] = mem[_11738]
                                        idx = 0
                                        while idx < _11866:
                                            mem[idx + _11112 + _10279 + _10311 + 140] = mem[idx + _11738 + 32]
                                            idx = idx + 32
                                            continue 
                                        if ceil32(_11866) > _11866:
                                            mem[_11866 + _11112 + _10279 + _10311 + 140] = 0
                                        revert with 0, 32, mem[_11112 + _10279 + _10311 + 108 len ceil32(_11866) + 32]
                                    require cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)] > 0
                                    if sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] > -2:
                                        revert with 0, 17
                                    if sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] + 1 > sub_fc86b662[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]]:
                                        revert with 0, 'Minting would exceed the max number of items for given type'
                                    if stor13[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]]:
                                        revert with 0, 'Supplied id is already used'
                                    if stor12[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]]:
                                        revert with 0, 'Given type is fungible'
                                    stor13[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]] = 1
                                    if sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] > -2:
                                        revert with 0, 17
                                    sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]]++
                                    sub_0f699e80[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                                    mem[32] = 14
                                    mintNumber[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]] = sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]]
                                    _5729 = mem[64]
                                    mem[mem[64]] = 0
                                    if not address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]):
                                        revert with 0, 'ERC1155: mint to the zero address'
                                    if msg.sender != this.address:
                                        mem[mem[64] + 32] = 1
                                        mem[64] = mem[64] + 96
                                        mem[_5729 + 64] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]
                                        mem[_5729 + 96] = 1
                                        mem[64] = _5729 + 160
                                        mem[_5729 + 128] = 1
                                        mem[0] = address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])
                                        mem[32] = sha3(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)], 0)
                                        if balanceOf[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])] > -2:
                                            revert with 0, 17
                                        balanceOf[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])]++
                                        mem[_5729 + 160] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]
                                        mem[_5729 + 192] = 1
                                        emit TransferSingle(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)], 1, msg.sender, 0, address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]));
                                        if ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])):
                                            mem[_5729 + 160] = 0xf23a6e6100000000000000000000000000000000000000000000000000000000
                                            mem[_5729 + 164] = msg.sender
                                            mem[_5729 + 196] = 0
                                            mem[_5729 + 228] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]
                                            mem[_5729 + 260] = 1
                                            mem[_5729 + 292] = 160
                                            mem[_5729 + 324] = mem[_5729]
                                            t = 0
                                            while t < mem[_5729]:
                                                mem[t + _5729 + 356] = mem[t + _5729 + 32]
                                                t = t + 32
                                                continue 
                                            if ceil32(mem[_5729]) > mem[_5729]:
                                                mem[mem[_5729] + _5729 + 356] = 0
                                            require ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]))
                                            call address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)], 1, 160, mem[_5729], mem[_5729 + 356 len ceil32(mem[_5729])]
                                            mem[_5729 + 160] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                                            mem[64] = _5729 + ceil32(return_data.size) + 160
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                                            if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                                    else:
                                        mem[64] = mem[64] + ceil32(calldata.size) + 64
                                        mem[_5729 + 32] = calldata.size
                                        mem[_5729 + 64 len calldata.size] = call.data[0 len calldata.size]
                                        mem[_5729 + calldata.size + 64] = 0
                                        _5794 = mem[calldata.size + _5729 + 32]
                                        mem[_5729 + ceil32(calldata.size) + 64] = 1
                                        mem[_5729 + ceil32(calldata.size) + 96] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]
                                        mem[_5729 + ceil32(calldata.size) + 128] = 1
                                        mem[64] = _5729 + ceil32(calldata.size) + 192
                                        mem[_5729 + ceil32(calldata.size) + 160] = 1
                                        mem[0] = address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])
                                        mem[32] = sha3(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)], 0)
                                        if balanceOf[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])] > -2:
                                            revert with 0, 17
                                        balanceOf[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])]++
                                        mem[_5729 + ceil32(calldata.size) + 192] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]
                                        mem[_5729 + ceil32(calldata.size) + 224] = 1
                                        emit TransferSingle(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)], 1, address(_5794), 0, address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]));
                                        if ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])):
                                            mem[_5729 + ceil32(calldata.size) + 192] = 0xf23a6e6100000000000000000000000000000000000000000000000000000000
                                            mem[_5729 + ceil32(calldata.size) + 196] = address(_5794)
                                            mem[_5729 + ceil32(calldata.size) + 228] = 0
                                            mem[_5729 + ceil32(calldata.size) + 260] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]
                                            mem[_5729 + ceil32(calldata.size) + 292] = 1
                                            mem[_5729 + ceil32(calldata.size) + 324] = 160
                                            mem[_5729 + ceil32(calldata.size) + 356] = mem[_5729]
                                            t = 0
                                            while t < mem[_5729]:
                                                mem[t + _5729 + ceil32(calldata.size) + 388] = mem[t + _5729 + 32]
                                                t = t + 32
                                                continue 
                                            if ceil32(mem[_5729]) > mem[_5729]:
                                                mem[mem[_5729] + _5729 + ceil32(calldata.size) + 388] = 0
                                            require ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]))
                                            call address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                                                 gas gas_remaining wei
                                                args address(_5794), 0, cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)], 1, 160, mem[_5729], mem[_5729 + ceil32(calldata.size) + 388 len ceil32(mem[_5729])]
                                            mem[_5729 + ceil32(calldata.size) + 192] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                                            mem[64] = _5729 + ceil32(calldata.size) + ceil32(return_data.size) + 192
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                                            if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                                else:
                                    _5361 = mem[64]
                                    mem[64] = mem[64] + ceil32(calldata.size) + 32
                                    mem[_5361] = calldata.size
                                    mem[_5361 + 32 len calldata.size] = call.data[0 len calldata.size]
                                    mem[_5361 + calldata.size + 32] = 0
                                    _5362 = mem[calldata.size + _5361]
                                    mem[0] = mem[calldata.size + _5361 + 12 len 20]
                                    mem[32] = sha3(0, 2)
                                    if not uint8(roleAdmin[0][address(_5362)].field_0):
                                        _5526 = mem[64]
                                        mem[mem[64]] = 42
                                        mem[64] = mem[64] + 96
                                        mem[_5526 + 32 len 42] = call.data[calldata.size len 42]
                                        if 0 >= mem[_5526]:
                                            revert with 0, 50
                                        mem[_5526 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                                        if 1 >= mem[_5526]:
                                            revert with 0, 50
                                        mem[_5526 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                                        idx = 41
                                        s = address(_5362)
                                        while idx > 1:
                                            if s % 16 >= 16:
                                                revert with 0, 50
                                            if idx >= mem[_5526]:
                                                revert with 0, 50
                                            mem[idx + _5526 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                                            if not idx:
                                                revert with 0, 17
                                            idx = idx - 1
                                            s = Mask(252, 0, s) * 0.0625
                                            continue 
                                        if address(_5362) + 10240:
                                            revert with 0, 'Strings: hex length insufficient'
                                        _8380 = mem[64]
                                        mem[mem[64]] = 66
                                        mem[64] = mem[64] + 128
                                        mem[_8380 + 32 len 66] = call.data[calldata.size len 66]
                                        if 0 >= mem[_8380]:
                                            revert with 0, 50
                                        mem[_8380 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                                        if 1 >= mem[_8380]:
                                            revert with 0, 50
                                        mem[_8380 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                                        idx = 65
                                        while idx > 1:
                                            if idx >= mem[_8380]:
                                                revert with 0, 50
                                            mem[idx + _8380 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                                            if not idx:
                                                revert with 0, 17
                                            idx = idx - 1
                                            continue 
                                        _10280 = mem[64]
                                        mem[mem[64] + 32] = 'AccessControl: account '
                                        _10312 = mem[_5526]
                                        idx = 0
                                        while idx < _10312:
                                            mem[idx + _10280 + 55] = mem[idx + _5526 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_10280 + _10312 + 55] = 0x206973206d697373696e6720726f6c6520000000000000000000000000000000
                                        if ceil32(_10312) <= _10312:
                                            _11113 = mem[_8380]
                                            idx = 0
                                            while idx < _11113:
                                                mem[idx + _10280 + _10312 + 72] = mem[idx + _8380 + 32]
                                                idx = idx + 32
                                                continue 
                                            if ceil32(_11113) <= _11113:
                                                _11739 = mem[64]
                                                mem[mem[64]] = _11113 + _10280 + _10312 + -mem[64] + 40
                                                mem[64] = _11113 + _10280 + _10312 + 72
                                                mem[_11113 + _10280 + _10312 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_11113 + _10280 + _10312 + 76] = 32
                                                _11867 = mem[_11739]
                                                mem[_11113 + _10280 + _10312 + 108] = mem[_11739]
                                                idx = 0
                                                while idx < _11867:
                                                    mem[idx + _11113 + _10280 + _10312 + 140] = mem[idx + _11739 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                if ceil32(_11867) > _11867:
                                                    mem[_11867 + _11113 + _10280 + _10312 + 140] = 0
                                                revert with 0, 32, mem[_11113 + _10280 + _10312 + 108 len ceil32(_11867) + 32]
                                            mem[_11113 + _10280 + _10312 + 72] = 0
                                            _11740 = mem[64]
                                            mem[mem[64]] = _11113 + _10280 + _10312 + -mem[64] + 40
                                            mem[64] = _11113 + _10280 + _10312 + 72
                                            mem[_11113 + _10280 + _10312 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_11113 + _10280 + _10312 + 76] = 32
                                            _11868 = mem[_11740]
                                            mem[_11113 + _10280 + _10312 + 108] = mem[_11740]
                                            idx = 0
                                            while idx < _11868:
                                                mem[idx + _11113 + _10280 + _10312 + 140] = mem[idx + _11740 + 32]
                                                idx = idx + 32
                                                continue 
                                            if ceil32(_11868) > _11868:
                                                mem[_11868 + _11113 + _10280 + _10312 + 140] = 0
                                            revert with 0, 32, mem[_11113 + _10280 + _10312 + 108 len ceil32(_11868) + 32]
                                        _11114 = mem[_8380]
                                        idx = 0
                                        while idx < _11114:
                                            mem[idx + _10280 + _10312 + 72] = mem[idx + _8380 + 32]
                                            idx = idx + 32
                                            continue 
                                        if ceil32(_11114) <= _11114:
                                            _11741 = mem[64]
                                            mem[mem[64]] = _11114 + _10280 + _10312 + -mem[64] + 40
                                            mem[64] = _11114 + _10280 + _10312 + 72
                                            mem[_11114 + _10280 + _10312 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_11114 + _10280 + _10312 + 76] = 32
                                            _11869 = mem[_11741]
                                            mem[_11114 + _10280 + _10312 + 108] = mem[_11741]
                                            idx = 0
                                            while idx < _11869:
                                                mem[idx + _11114 + _10280 + _10312 + 140] = mem[idx + _11741 + 32]
                                                idx = idx + 32
                                                continue 
                                            if ceil32(_11869) > _11869:
                                                mem[_11869 + _11114 + _10280 + _10312 + 140] = 0
                                            revert with 0, 32, mem[_11114 + _10280 + _10312 + 108 len ceil32(_11869) + 32]
                                        mem[_11114 + _10280 + _10312 + 72] = 0
                                        _11742 = mem[64]
                                        mem[mem[64]] = _11114 + _10280 + _10312 + -mem[64] + 40
                                        mem[64] = _11114 + _10280 + _10312 + 72
                                        mem[_11114 + _10280 + _10312 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[_11114 + _10280 + _10312 + 76] = 32
                                        _11870 = mem[_11742]
                                        mem[_11114 + _10280 + _10312 + 108] = mem[_11742]
                                        idx = 0
                                        while idx < _11870:
                                            mem[idx + _11114 + _10280 + _10312 + 140] = mem[idx + _11742 + 32]
                                            idx = idx + 32
                                            continue 
                                        if ceil32(_11870) > _11870:
                                            mem[_11870 + _11114 + _10280 + _10312 + 140] = 0
                                        revert with 0, 32, mem[_11114 + _10280 + _10312 + 108 len ceil32(_11870) + 32]
                                    require cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)] > 0
                                    if sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] > -2:
                                        revert with 0, 17
                                    if sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] + 1 > sub_fc86b662[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]]:
                                        revert with 0, 'Minting would exceed the max number of items for given type'
                                    if stor13[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]]:
                                        revert with 0, 'Supplied id is already used'
                                    if stor12[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]]:
                                        revert with 0, 'Given type is fungible'
                                    stor13[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]] = 1
                                    if sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] > -2:
                                        revert with 0, 17
                                    sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]]++
                                    sub_0f699e80[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                                    mem[32] = 14
                                    mintNumber[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]] = sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]]
                                    _5730 = mem[64]
                                    mem[mem[64]] = 0
                                    if not address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]):
                                        revert with 0, 'ERC1155: mint to the zero address'
                                    if msg.sender != this.address:
                                        mem[mem[64] + 32] = 1
                                        mem[64] = mem[64] + 96
                                        mem[_5730 + 64] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]
                                        mem[_5730 + 96] = 1
                                        mem[64] = _5730 + 160
                                        mem[_5730 + 128] = 1
                                        mem[0] = address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])
                                        mem[32] = sha3(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)], 0)
                                        if balanceOf[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])] > -2:
                                            revert with 0, 17
                                        balanceOf[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])]++
                                        mem[_5730 + 160] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]
                                        mem[_5730 + 192] = 1
                                        emit TransferSingle(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)], 1, msg.sender, 0, address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]));
                                        if ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])):
                                            mem[_5730 + 160] = 0xf23a6e6100000000000000000000000000000000000000000000000000000000
                                            mem[_5730 + 164] = msg.sender
                                            mem[_5730 + 196] = 0
                                            mem[_5730 + 228] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]
                                            mem[_5730 + 260] = 1
                                            mem[_5730 + 292] = 160
                                            mem[_5730 + 324] = mem[_5730]
                                            t = 0
                                            while t < mem[_5730]:
                                                mem[t + _5730 + 356] = mem[t + _5730 + 32]
                                                t = t + 32
                                                continue 
                                            if ceil32(mem[_5730]) > mem[_5730]:
                                                mem[mem[_5730] + _5730 + 356] = 0
                                            require ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]))
                                            call address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)], 1, 160, mem[_5730], mem[_5730 + 356 len ceil32(mem[_5730])]
                                            mem[_5730 + 160] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                                            mem[64] = _5730 + ceil32(return_data.size) + 160
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                                            if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                                    else:
                                        mem[64] = mem[64] + ceil32(calldata.size) + 64
                                        mem[_5730 + 32] = calldata.size
                                        mem[_5730 + 64 len calldata.size] = call.data[0 len calldata.size]
                                        mem[_5730 + calldata.size + 64] = 0
                                        _5796 = mem[calldata.size + _5730 + 32]
                                        mem[_5730 + ceil32(calldata.size) + 64] = 1
                                        mem[_5730 + ceil32(calldata.size) + 96] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]
                                        mem[_5730 + ceil32(calldata.size) + 128] = 1
                                        mem[64] = _5730 + ceil32(calldata.size) + 192
                                        mem[_5730 + ceil32(calldata.size) + 160] = 1
                                        mem[0] = address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])
                                        mem[32] = sha3(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)], 0)
                                        if balanceOf[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])] > -2:
                                            revert with 0, 17
                                        balanceOf[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])]++
                                        mem[_5730 + ceil32(calldata.size) + 192] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]
                                        mem[_5730 + ceil32(calldata.size) + 224] = 1
                                        emit TransferSingle(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)], 1, address(_5796), 0, address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]));
                                        if ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])):
                                            mem[_5730 + ceil32(calldata.size) + 192] = 0xf23a6e6100000000000000000000000000000000000000000000000000000000
                                            mem[_5730 + ceil32(calldata.size) + 196] = address(_5796)
                                            mem[_5730 + ceil32(calldata.size) + 228] = 0
                                            mem[_5730 + ceil32(calldata.size) + 260] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]
                                            mem[_5730 + ceil32(calldata.size) + 292] = 1
                                            mem[_5730 + ceil32(calldata.size) + 324] = 160
                                            mem[_5730 + ceil32(calldata.size) + 356] = mem[_5730]
                                            t = 0
                                            while t < mem[_5730]:
                                                mem[t + _5730 + ceil32(calldata.size) + 388] = mem[t + _5730 + 32]
                                                t = t + 32
                                                continue 
                                            if ceil32(mem[_5730]) > mem[_5730]:
                                                mem[mem[_5730] + _5730 + ceil32(calldata.size) + 388] = 0
                                            require ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]))
                                            call address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                                                 gas gas_remaining wei
                                                args address(_5796), 0, cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)], 1, 160, mem[_5730], mem[_5730 + ceil32(calldata.size) + 388 len ceil32(mem[_5730])]
                                            mem[_5730 + ceil32(calldata.size) + 192] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                                            mem[64] = _5730 + ceil32(calldata.size) + ceil32(return_data.size) + 192
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                                            if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                                if s == -1:
                                    revert with 0, 17
                                s = s + 1
                                continue 
                            _5297 = mem[64]
                            mem[mem[64]] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                            mem[mem[64] + 32] = 96
                            mem[mem[64] + 96] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 36)]
                            require cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 36)] <= 0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
                            mem[mem[64] + 128 len 32 * cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 36)]] = call.data[cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68 len 32 * cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 36)]]
                            mem[mem[64] + 64] = (32 * cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 36)]) + 128
                            mem[_5297 + (32 * cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 36)]) + 128] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 36)]
                            s = 0
                            t = cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68
                            u = _5297 + (32 * cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 36)]) + 160
                            while s < cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 36)]:
                                require cd[t] == address(cd[t])
                                mem[u] = address(cd[t])
                                s = s + 1
                                t = t + 32
                                u = u + 32
                                continue 
                            emit 0x16a6af95: mem[mem[64] len u - mem[64]]
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        _2713 = mem[64]
                        mem[mem[64]] = 42
                        mem[64] = mem[64] + 96
                        mem[_2713 + 32 len 42] = call.data[calldata.size len 42]
                        if 0 >= mem[_2713]:
                            revert with 0, 50
                        mem[_2713 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                        if 1 >= mem[_2713]:
                            revert with 0, 50
                        mem[_2713 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                        idx = 41
                        s = address(msg.sender)
                        while idx > 1:
                            if s % 16 >= 16:
                                revert with 0, 50
                            if idx >= mem[_2713]:
                                revert with 0, 50
                            mem[idx + _2713 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                            if not idx:
                                revert with 0, 17
                            idx = idx - 1
                            s = Mask(252, 0, s) * 0.0625
                            continue 
                        if msg.sender + 10240:
                            revert with 0, 'Strings: hex length insufficient'
                        _5349 = mem[64]
                        mem[mem[64]] = 66
                        mem[64] = mem[64] + 128
                        mem[_5349 + 32 len 66] = call.data[calldata.size len 66]
                        if 0 >= mem[_5349]:
                            revert with 0, 50
                        mem[_5349 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                        if 1 >= mem[_5349]:
                            revert with 0, 50
                        mem[_5349 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                        idx = 65
                        while idx > 1:
                            if idx >= mem[_5349]:
                                revert with 0, 50
                            mem[idx + _5349 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                            if not idx:
                                revert with 0, 17
                            idx = idx - 1
                            continue 
                        _8046 = mem[64]
                        mem[mem[64] + 32] = 'AccessControl: account '
                        _8075 = mem[_2713]
                        idx = 0
                        while idx < _8075:
                            mem[idx + _8046 + 55] = mem[idx + _2713 + 32]
                            idx = idx + 32
                            continue 
                        mem[_8046 + _8075 + 55] = 0x206973206d697373696e6720726f6c6520000000000000000000000000000000
                        if ceil32(_8075) <= _8075:
                            _10281 = mem[_5349]
                            idx = 0
                            while idx < _10281:
                                mem[idx + _8046 + _8075 + 72] = mem[idx + _5349 + 32]
                                idx = idx + 32
                                continue 
                            if ceil32(_10281) <= _10281:
                                _11143 = mem[64]
                                mem[mem[64]] = _10281 + _8046 + _8075 + -mem[64] + 40
                                mem[64] = _10281 + _8046 + _8075 + 72
                                mem[_10281 + _8046 + _8075 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_10281 + _8046 + _8075 + 76] = 32
                                _11195 = mem[_11143]
                                mem[_10281 + _8046 + _8075 + 108] = mem[_11143]
                                idx = 0
                                while idx < _11195:
                                    mem[idx + _10281 + _8046 + _8075 + 140] = mem[idx + _11143 + 32]
                                    idx = idx + 32
                                    continue 
                                if ceil32(_11195) > _11195:
                                    mem[_11195 + _10281 + _8046 + _8075 + 140] = 0
                                revert with 0, 32, mem[_10281 + _8046 + _8075 + 108 len ceil32(_11195) + 32]
                            mem[_10281 + _8046 + _8075 + 72] = 0
                            _11144 = mem[64]
                            mem[mem[64]] = _10281 + _8046 + _8075 + -mem[64] + 40
                            mem[64] = _10281 + _8046 + _8075 + 72
                            mem[_10281 + _8046 + _8075 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_10281 + _8046 + _8075 + 76] = 32
                            _11196 = mem[_11144]
                            mem[_10281 + _8046 + _8075 + 108] = mem[_11144]
                            idx = 0
                            while idx < _11196:
                                mem[idx + _10281 + _8046 + _8075 + 140] = mem[idx + _11144 + 32]
                                idx = idx + 32
                                continue 
                            if ceil32(_11196) > _11196:
                                mem[_11196 + _10281 + _8046 + _8075 + 140] = 0
                            revert with 0, 32, mem[_10281 + _8046 + _8075 + 108 len ceil32(_11196) + 32]
                        _10282 = mem[_5349]
                        idx = 0
                        while idx < _10282:
                            mem[idx + _8046 + _8075 + 72] = mem[idx + _5349 + 32]
                            idx = idx + 32
                            continue 
                        if ceil32(_10282) <= _10282:
                            _11145 = mem[64]
                            mem[mem[64]] = _10282 + _8046 + _8075 + -mem[64] + 40
                            mem[64] = _10282 + _8046 + _8075 + 72
                            mem[_10282 + _8046 + _8075 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_10282 + _8046 + _8075 + 76] = 32
                            _11197 = mem[_11145]
                            mem[_10282 + _8046 + _8075 + 108] = mem[_11145]
                            idx = 0
                            while idx < _11197:
                                mem[idx + _10282 + _8046 + _8075 + 140] = mem[idx + _11145 + 32]
                                idx = idx + 32
                                continue 
                            if ceil32(_11197) > _11197:
                                mem[_11197 + _10282 + _8046 + _8075 + 140] = 0
                            revert with 0, 32, mem[_10282 + _8046 + _8075 + 108 len ceil32(_11197) + 32]
                        mem[_10282 + _8046 + _8075 + 72] = 0
                        _11146 = mem[64]
                        mem[mem[64]] = _10282 + _8046 + _8075 + -mem[64] + 40
                        mem[64] = _10282 + _8046 + _8075 + 72
                        mem[_10282 + _8046 + _8075 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[_10282 + _8046 + _8075 + 76] = 32
                        _11198 = mem[_11146]
                        mem[_10282 + _8046 + _8075 + 108] = mem[_11146]
                        idx = 0
                        while idx < _11198:
                            mem[idx + _10282 + _8046 + _8075 + 140] = mem[idx + _11146 + 32]
                            idx = idx + 32
                            continue 
                        if ceil32(_11198) > _11198:
                            mem[_11198 + _10282 + _8046 + _8075 + 140] = 0
                        revert with 0, 32, mem[_10282 + _8046 + _8075 + 108 len ceil32(_11198) + 32]
                    _2663 = mem[64]
                    mem[64] = mem[64] + ceil32(calldata.size) + 32
                    mem[_2663] = calldata.size
                    mem[_2663 + 32 len calldata.size] = call.data[0 len calldata.size]
                    mem[_2663 + calldata.size + 32] = 0
                    _2664 = mem[calldata.size + _2663]
                    mem[0] = mem[calldata.size + _2663 + 12 len 20]
                    mem[32] = sha3(0, 2)
                    if uint8(roleAdmin[0][address(_2664)].field_0):
                        if cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 36)] != cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 36)]:
                            revert with 0, 'number of ids must equal number of accounts'
                        s = 0
                        while s < cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 36)]:
                            if s >= cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 36)]:
                                revert with 0, 50
                            require cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)] == address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])
                            if msg.sender != this.address:
                                mem[0] = msg.sender
                                mem[32] = sha3(0, 2)
                                if not uint8(roleAdmin[0][address(msg.sender)].field_0):
                                    _5529 = mem[64]
                                    mem[mem[64]] = 42
                                    mem[64] = mem[64] + 96
                                    mem[_5529 + 32 len 42] = call.data[calldata.size len 42]
                                    if 0 >= mem[_5529]:
                                        revert with 0, 50
                                    mem[_5529 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                                    if 1 >= mem[_5529]:
                                        revert with 0, 50
                                    mem[_5529 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                                    idx = 41
                                    s = address(msg.sender)
                                    while idx > 1:
                                        if s % 16 >= 16:
                                            revert with 0, 50
                                        if idx >= mem[_5529]:
                                            revert with 0, 50
                                        mem[idx + _5529 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                                        if not idx:
                                            revert with 0, 17
                                        idx = idx - 1
                                        s = Mask(252, 0, s) * 0.0625
                                        continue 
                                    if msg.sender + 10240:
                                        revert with 0, 'Strings: hex length insufficient'
                                    _8381 = mem[64]
                                    mem[mem[64]] = 66
                                    mem[64] = mem[64] + 128
                                    mem[_8381 + 32 len 66] = call.data[calldata.size len 66]
                                    if 0 >= mem[_8381]:
                                        revert with 0, 50
                                    mem[_8381 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                                    if 1 >= mem[_8381]:
                                        revert with 0, 50
                                    mem[_8381 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                                    idx = 65
                                    while idx > 1:
                                        if idx >= mem[_8381]:
                                            revert with 0, 50
                                        mem[idx + _8381 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                                        if not idx:
                                            revert with 0, 17
                                        idx = idx - 1
                                        continue 
                                    _10283 = mem[64]
                                    mem[mem[64] + 32] = 'AccessControl: account '
                                    _10313 = mem[_5529]
                                    idx = 0
                                    while idx < _10313:
                                        mem[idx + _10283 + 55] = mem[idx + _5529 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_10283 + _10313 + 55] = 0x206973206d697373696e6720726f6c6520000000000000000000000000000000
                                    if ceil32(_10313) <= _10313:
                                        _11115 = mem[_8381]
                                        idx = 0
                                        while idx < _11115:
                                            mem[idx + _10283 + _10313 + 72] = mem[idx + _8381 + 32]
                                            idx = idx + 32
                                            continue 
                                        if ceil32(_11115) <= _11115:
                                            _11743 = mem[64]
                                            mem[mem[64]] = _11115 + _10283 + _10313 + -mem[64] + 40
                                            mem[64] = _11115 + _10283 + _10313 + 72
                                            mem[_11115 + _10283 + _10313 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_11115 + _10283 + _10313 + 76] = 32
                                            _11871 = mem[_11743]
                                            mem[_11115 + _10283 + _10313 + 108] = mem[_11743]
                                            idx = 0
                                            while idx < _11871:
                                                mem[idx + _11115 + _10283 + _10313 + 140] = mem[idx + _11743 + 32]
                                                idx = idx + 32
                                                continue 
                                            if ceil32(_11871) > _11871:
                                                mem[_11871 + _11115 + _10283 + _10313 + 140] = 0
                                            revert with 0, 32, mem[_11115 + _10283 + _10313 + 108 len ceil32(_11871) + 32]
                                        mem[_11115 + _10283 + _10313 + 72] = 0
                                        _11744 = mem[64]
                                        mem[mem[64]] = _11115 + _10283 + _10313 + -mem[64] + 40
                                        mem[64] = _11115 + _10283 + _10313 + 72
                                        mem[_11115 + _10283 + _10313 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[_11115 + _10283 + _10313 + 76] = 32
                                        _11872 = mem[_11744]
                                        mem[_11115 + _10283 + _10313 + 108] = mem[_11744]
                                        idx = 0
                                        while idx < _11872:
                                            mem[idx + _11115 + _10283 + _10313 + 140] = mem[idx + _11744 + 32]
                                            idx = idx + 32
                                            continue 
                                        if ceil32(_11872) > _11872:
                                            mem[_11872 + _11115 + _10283 + _10313 + 140] = 0
                                        revert with 0, 32, mem[_11115 + _10283 + _10313 + 108 len ceil32(_11872) + 32]
                                    _11116 = mem[_8381]
                                    idx = 0
                                    while idx < _11116:
                                        mem[idx + _10283 + _10313 + 72] = mem[idx + _8381 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_11116) <= _11116:
                                        _11745 = mem[64]
                                        mem[mem[64]] = _11116 + _10283 + _10313 + -mem[64] + 40
                                        mem[64] = _11116 + _10283 + _10313 + 72
                                        mem[_11116 + _10283 + _10313 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[_11116 + _10283 + _10313 + 76] = 32
                                        _11873 = mem[_11745]
                                        mem[_11116 + _10283 + _10313 + 108] = mem[_11745]
                                        idx = 0
                                        while idx < _11873:
                                            mem[idx + _11116 + _10283 + _10313 + 140] = mem[idx + _11745 + 32]
                                            idx = idx + 32
                                            continue 
                                        if ceil32(_11873) > _11873:
                                            mem[_11873 + _11116 + _10283 + _10313 + 140] = 0
                                        revert with 0, 32, mem[_11116 + _10283 + _10313 + 108 len ceil32(_11873) + 32]
                                    mem[_11116 + _10283 + _10313 + 72] = 0
                                    _11746 = mem[64]
                                    mem[mem[64]] = _11116 + _10283 + _10313 + -mem[64] + 40
                                    mem[64] = _11116 + _10283 + _10313 + 72
                                    mem[_11116 + _10283 + _10313 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_11116 + _10283 + _10313 + 76] = 32
                                    _11874 = mem[_11746]
                                    mem[_11116 + _10283 + _10313 + 108] = mem[_11746]
                                    idx = 0
                                    while idx < _11874:
                                        mem[idx + _11116 + _10283 + _10313 + 140] = mem[idx + _11746 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_11874) > _11874:
                                        mem[_11874 + _11116 + _10283 + _10313 + 140] = 0
                                    revert with 0, 32, mem[_11116 + _10283 + _10313 + 108 len ceil32(_11874) + 32]
                                require cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)] > 0
                                if sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] > -2:
                                    revert with 0, 17
                                if sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] + 1 > sub_fc86b662[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]]:
                                    revert with 0, 'Minting would exceed the max number of items for given type'
                                if stor13[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]]:
                                    revert with 0, 'Supplied id is already used'
                                if stor12[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]]:
                                    revert with 0, 'Given type is fungible'
                                stor13[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]] = 1
                                if sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] > -2:
                                    revert with 0, 17
                                sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]]++
                                sub_0f699e80[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                                mem[32] = 14
                                mintNumber[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]] = sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]]
                                _5731 = mem[64]
                                mem[mem[64]] = 0
                                if not address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]):
                                    revert with 0, 'ERC1155: mint to the zero address'
                                if msg.sender != this.address:
                                    mem[mem[64] + 32] = 1
                                    mem[64] = mem[64] + 96
                                    mem[_5731 + 64] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]
                                    mem[_5731 + 96] = 1
                                    mem[64] = _5731 + 160
                                    mem[_5731 + 128] = 1
                                    mem[0] = address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])
                                    mem[32] = sha3(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)], 0)
                                    if balanceOf[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])] > -2:
                                        revert with 0, 17
                                    balanceOf[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])]++
                                    mem[_5731 + 160] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]
                                    mem[_5731 + 192] = 1
                                    emit TransferSingle(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)], 1, msg.sender, 0, address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]));
                                    if ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])):
                                        mem[_5731 + 160] = 0xf23a6e6100000000000000000000000000000000000000000000000000000000
                                        mem[_5731 + 164] = msg.sender
                                        mem[_5731 + 196] = 0
                                        mem[_5731 + 228] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]
                                        mem[_5731 + 260] = 1
                                        mem[_5731 + 292] = 160
                                        mem[_5731 + 324] = mem[_5731]
                                        t = 0
                                        while t < mem[_5731]:
                                            mem[t + _5731 + 356] = mem[t + _5731 + 32]
                                            t = t + 32
                                            continue 
                                        if ceil32(mem[_5731]) > mem[_5731]:
                                            mem[mem[_5731] + _5731 + 356] = 0
                                        require ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]))
                                        call address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)], 1, 160, mem[_5731], mem[_5731 + 356 len ceil32(mem[_5731])]
                                        mem[_5731 + 160] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                                        mem[64] = _5731 + ceil32(return_data.size) + 160
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                                        if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                                else:
                                    mem[64] = mem[64] + ceil32(calldata.size) + 64
                                    mem[_5731 + 32] = calldata.size
                                    mem[_5731 + 64 len calldata.size] = call.data[0 len calldata.size]
                                    mem[_5731 + calldata.size + 64] = 0
                                    _5798 = mem[calldata.size + _5731 + 32]
                                    mem[_5731 + ceil32(calldata.size) + 64] = 1
                                    mem[_5731 + ceil32(calldata.size) + 96] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]
                                    mem[_5731 + ceil32(calldata.size) + 128] = 1
                                    mem[64] = _5731 + ceil32(calldata.size) + 192
                                    mem[_5731 + ceil32(calldata.size) + 160] = 1
                                    mem[0] = address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])
                                    mem[32] = sha3(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)], 0)
                                    if balanceOf[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])] > -2:
                                        revert with 0, 17
                                    balanceOf[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])]++
                                    mem[_5731 + ceil32(calldata.size) + 192] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]
                                    mem[_5731 + ceil32(calldata.size) + 224] = 1
                                    emit TransferSingle(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)], 1, address(_5798), 0, address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]));
                                    if ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])):
                                        mem[_5731 + ceil32(calldata.size) + 192] = 0xf23a6e6100000000000000000000000000000000000000000000000000000000
                                        mem[_5731 + ceil32(calldata.size) + 196] = address(_5798)
                                        mem[_5731 + ceil32(calldata.size) + 228] = 0
                                        mem[_5731 + ceil32(calldata.size) + 260] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]
                                        mem[_5731 + ceil32(calldata.size) + 292] = 1
                                        mem[_5731 + ceil32(calldata.size) + 324] = 160
                                        mem[_5731 + ceil32(calldata.size) + 356] = mem[_5731]
                                        t = 0
                                        while t < mem[_5731]:
                                            mem[t + _5731 + ceil32(calldata.size) + 388] = mem[t + _5731 + 32]
                                            t = t + 32
                                            continue 
                                        if ceil32(mem[_5731]) > mem[_5731]:
                                            mem[mem[_5731] + _5731 + ceil32(calldata.size) + 388] = 0
                                        require ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]))
                                        call address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                                             gas gas_remaining wei
                                            args address(_5798), 0, cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)], 1, 160, mem[_5731], mem[_5731 + ceil32(calldata.size) + 388 len ceil32(mem[_5731])]
                                        mem[_5731 + ceil32(calldata.size) + 192] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                                        mem[64] = _5731 + ceil32(calldata.size) + ceil32(return_data.size) + 192
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                                        if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                            else:
                                _5364 = mem[64]
                                mem[64] = mem[64] + ceil32(calldata.size) + 32
                                mem[_5364] = calldata.size
                                mem[_5364 + 32 len calldata.size] = call.data[0 len calldata.size]
                                mem[_5364 + calldata.size + 32] = 0
                                _5365 = mem[calldata.size + _5364]
                                mem[0] = mem[calldata.size + _5364 + 12 len 20]
                                mem[32] = sha3(0, 2)
                                if not uint8(roleAdmin[0][address(_5365)].field_0):
                                    _5532 = mem[64]
                                    mem[mem[64]] = 42
                                    mem[64] = mem[64] + 96
                                    mem[_5532 + 32 len 42] = call.data[calldata.size len 42]
                                    if 0 >= mem[_5532]:
                                        revert with 0, 50
                                    mem[_5532 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                                    if 1 >= mem[_5532]:
                                        revert with 0, 50
                                    mem[_5532 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                                    idx = 41
                                    s = address(_5365)
                                    while idx > 1:
                                        if s % 16 >= 16:
                                            revert with 0, 50
                                        if idx >= mem[_5532]:
                                            revert with 0, 50
                                        mem[idx + _5532 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                                        if not idx:
                                            revert with 0, 17
                                        idx = idx - 1
                                        s = Mask(252, 0, s) * 0.0625
                                        continue 
                                    if address(_5365) + 10240:
                                        revert with 0, 'Strings: hex length insufficient'
                                    _8382 = mem[64]
                                    mem[mem[64]] = 66
                                    mem[64] = mem[64] + 128
                                    mem[_8382 + 32 len 66] = call.data[calldata.size len 66]
                                    if 0 >= mem[_8382]:
                                        revert with 0, 50
                                    mem[_8382 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                                    if 1 >= mem[_8382]:
                                        revert with 0, 50
                                    mem[_8382 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                                    idx = 65
                                    while idx > 1:
                                        if idx >= mem[_8382]:
                                            revert with 0, 50
                                        mem[idx + _8382 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                                        if not idx:
                                            revert with 0, 17
                                        idx = idx - 1
                                        continue 
                                    _10284 = mem[64]
                                    mem[mem[64] + 32] = 'AccessControl: account '
                                    _10314 = mem[_5532]
                                    idx = 0
                                    while idx < _10314:
                                        mem[idx + _10284 + 55] = mem[idx + _5532 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_10284 + _10314 + 55] = 0x206973206d697373696e6720726f6c6520000000000000000000000000000000
                                    if ceil32(_10314) <= _10314:
                                        _11117 = mem[_8382]
                                        idx = 0
                                        while idx < _11117:
                                            mem[idx + _10284 + _10314 + 72] = mem[idx + _8382 + 32]
                                            idx = idx + 32
                                            continue 
                                        if ceil32(_11117) <= _11117:
                                            _11747 = mem[64]
                                            mem[mem[64]] = _11117 + _10284 + _10314 + -mem[64] + 40
                                            mem[64] = _11117 + _10284 + _10314 + 72
                                            mem[_11117 + _10284 + _10314 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_11117 + _10284 + _10314 + 76] = 32
                                            _11875 = mem[_11747]
                                            mem[_11117 + _10284 + _10314 + 108] = mem[_11747]
                                            idx = 0
                                            while idx < _11875:
                                                mem[idx + _11117 + _10284 + _10314 + 140] = mem[idx + _11747 + 32]
                                                idx = idx + 32
                                                continue 
                                            if ceil32(_11875) > _11875:
                                                mem[_11875 + _11117 + _10284 + _10314 + 140] = 0
                                            revert with 0, 32, mem[_11117 + _10284 + _10314 + 108 len ceil32(_11875) + 32]
                                        mem[_11117 + _10284 + _10314 + 72] = 0
                                        _11748 = mem[64]
                                        mem[mem[64]] = _11117 + _10284 + _10314 + -mem[64] + 40
                                        mem[64] = _11117 + _10284 + _10314 + 72
                                        mem[_11117 + _10284 + _10314 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[_11117 + _10284 + _10314 + 76] = 32
                                        _11876 = mem[_11748]
                                        mem[_11117 + _10284 + _10314 + 108] = mem[_11748]
                                        idx = 0
                                        while idx < _11876:
                                            mem[idx + _11117 + _10284 + _10314 + 140] = mem[idx + _11748 + 32]
                                            idx = idx + 32
                                            continue 
                                        if ceil32(_11876) > _11876:
                                            mem[_11876 + _11117 + _10284 + _10314 + 140] = 0
                                        revert with 0, 32, mem[_11117 + _10284 + _10314 + 108 len ceil32(_11876) + 32]
                                    _11118 = mem[_8382]
                                    idx = 0
                                    while idx < _11118:
                                        mem[idx + _10284 + _10314 + 72] = mem[idx + _8382 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_11118) <= _11118:
                                        _11749 = mem[64]
                                        mem[mem[64]] = _11118 + _10284 + _10314 + -mem[64] + 40
                                        mem[64] = _11118 + _10284 + _10314 + 72
                                        mem[_11118 + _10284 + _10314 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[_11118 + _10284 + _10314 + 76] = 32
                                        _11877 = mem[_11749]
                                        mem[_11118 + _10284 + _10314 + 108] = mem[_11749]
                                        idx = 0
                                        while idx < _11877:
                                            mem[idx + _11118 + _10284 + _10314 + 140] = mem[idx + _11749 + 32]
                                            idx = idx + 32
                                            continue 
                                        if ceil32(_11877) > _11877:
                                            mem[_11877 + _11118 + _10284 + _10314 + 140] = 0
                                        revert with 0, 32, mem[_11118 + _10284 + _10314 + 108 len ceil32(_11877) + 32]
                                    mem[_11118 + _10284 + _10314 + 72] = 0
                                    _11750 = mem[64]
                                    mem[mem[64]] = _11118 + _10284 + _10314 + -mem[64] + 40
                                    mem[64] = _11118 + _10284 + _10314 + 72
                                    mem[_11118 + _10284 + _10314 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_11118 + _10284 + _10314 + 76] = 32
                                    _11878 = mem[_11750]
                                    mem[_11118 + _10284 + _10314 + 108] = mem[_11750]
                                    idx = 0
                                    while idx < _11878:
                                        mem[idx + _11118 + _10284 + _10314 + 140] = mem[idx + _11750 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_11878) > _11878:
                                        mem[_11878 + _11118 + _10284 + _10314 + 140] = 0
                                    revert with 0, 32, mem[_11118 + _10284 + _10314 + 108 len ceil32(_11878) + 32]
                                require cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)] > 0
                                if sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] > -2:
                                    revert with 0, 17
                                if sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] + 1 > sub_fc86b662[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]]:
                                    revert with 0, 'Minting would exceed the max number of items for given type'
                                if stor13[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]]:
                                    revert with 0, 'Supplied id is already used'
                                if stor12[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]]:
                                    revert with 0, 'Given type is fungible'
                                stor13[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]] = 1
                                if sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] > -2:
                                    revert with 0, 17
                                sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]]++
                                sub_0f699e80[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                                mem[32] = 14
                                mintNumber[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]] = sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]]
                                _5732 = mem[64]
                                mem[mem[64]] = 0
                                if not address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]):
                                    revert with 0, 'ERC1155: mint to the zero address'
                                if msg.sender != this.address:
                                    mem[mem[64] + 32] = 1
                                    mem[64] = mem[64] + 96
                                    mem[_5732 + 64] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]
                                    mem[_5732 + 96] = 1
                                    mem[64] = _5732 + 160
                                    mem[_5732 + 128] = 1
                                    mem[0] = address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])
                                    mem[32] = sha3(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)], 0)
                                    if balanceOf[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])] > -2:
                                        revert with 0, 17
                                    balanceOf[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])]++
                                    mem[_5732 + 160] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]
                                    mem[_5732 + 192] = 1
                                    emit TransferSingle(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)], 1, msg.sender, 0, address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]));
                                    if ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])):
                                        mem[_5732 + 160] = 0xf23a6e6100000000000000000000000000000000000000000000000000000000
                                        mem[_5732 + 164] = msg.sender
                                        mem[_5732 + 196] = 0
                                        mem[_5732 + 228] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]
                                        mem[_5732 + 260] = 1
                                        mem[_5732 + 292] = 160
                                        mem[_5732 + 324] = mem[_5732]
                                        t = 0
                                        while t < mem[_5732]:
                                            mem[t + _5732 + 356] = mem[t + _5732 + 32]
                                            t = t + 32
                                            continue 
                                        if ceil32(mem[_5732]) > mem[_5732]:
                                            mem[mem[_5732] + _5732 + 356] = 0
                                        require ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]))
                                        call address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)], 1, 160, mem[_5732], mem[_5732 + 356 len ceil32(mem[_5732])]
                                        mem[_5732 + 160] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                                        mem[64] = _5732 + ceil32(return_data.size) + 160
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                                        if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                                else:
                                    mem[64] = mem[64] + ceil32(calldata.size) + 64
                                    mem[_5732 + 32] = calldata.size
                                    mem[_5732 + 64 len calldata.size] = call.data[0 len calldata.size]
                                    mem[_5732 + calldata.size + 64] = 0
                                    _5800 = mem[calldata.size + _5732 + 32]
                                    mem[_5732 + ceil32(calldata.size) + 64] = 1
                                    mem[_5732 + ceil32(calldata.size) + 96] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]
                                    mem[_5732 + ceil32(calldata.size) + 128] = 1
                                    mem[64] = _5732 + ceil32(calldata.size) + 192
                                    mem[_5732 + ceil32(calldata.size) + 160] = 1
                                    mem[0] = address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])
                                    mem[32] = sha3(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)], 0)
                                    if balanceOf[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])] > -2:
                                        revert with 0, 17
                                    balanceOf[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])]++
                                    mem[_5732 + ceil32(calldata.size) + 192] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]
                                    mem[_5732 + ceil32(calldata.size) + 224] = 1
                                    emit TransferSingle(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)], 1, address(_5800), 0, address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]));
                                    if ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])):
                                        mem[_5732 + ceil32(calldata.size) + 192] = 0xf23a6e6100000000000000000000000000000000000000000000000000000000
                                        mem[_5732 + ceil32(calldata.size) + 196] = address(_5800)
                                        mem[_5732 + ceil32(calldata.size) + 228] = 0
                                        mem[_5732 + ceil32(calldata.size) + 260] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]
                                        mem[_5732 + ceil32(calldata.size) + 292] = 1
                                        mem[_5732 + ceil32(calldata.size) + 324] = 160
                                        mem[_5732 + ceil32(calldata.size) + 356] = mem[_5732]
                                        t = 0
                                        while t < mem[_5732]:
                                            mem[t + _5732 + ceil32(calldata.size) + 388] = mem[t + _5732 + 32]
                                            t = t + 32
                                            continue 
                                        if ceil32(mem[_5732]) > mem[_5732]:
                                            mem[mem[_5732] + _5732 + ceil32(calldata.size) + 388] = 0
                                        require ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]))
                                        call address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                                             gas gas_remaining wei
                                            args address(_5800), 0, cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)], 1, 160, mem[_5732], mem[_5732 + ceil32(calldata.size) + 388 len ceil32(mem[_5732])]
                                        mem[_5732 + ceil32(calldata.size) + 192] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                                        mem[64] = _5732 + ceil32(calldata.size) + ceil32(return_data.size) + 192
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                                        if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            continue 
                        _5298 = mem[64]
                        mem[mem[64]] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                        mem[mem[64] + 32] = 96
                        mem[mem[64] + 96] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 36)]
                        require cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 36)] <= 0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
                        mem[mem[64] + 128 len 32 * cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 36)]] = call.data[cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68 len 32 * cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 36)]]
                        mem[mem[64] + 64] = (32 * cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 36)]) + 128
                        mem[_5298 + (32 * cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 36)]) + 128] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 36)]
                        s = 0
                        t = cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68
                        u = _5298 + (32 * cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 36)]) + 160
                        while s < cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 36)]:
                            require cd[t] == address(cd[t])
                            mem[u] = address(cd[t])
                            s = s + 1
                            t = t + 32
                            u = u + 32
                            continue 
                        emit 0x16a6af95: mem[mem[64] len u - mem[64]]
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    _2714 = mem[64]
                    mem[mem[64]] = 42
                    mem[64] = mem[64] + 96
                    mem[_2714 + 32 len 42] = call.data[calldata.size len 42]
                    if 0 >= mem[_2714]:
                        revert with 0, 50
                    mem[_2714 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                    if 1 >= mem[_2714]:
                        revert with 0, 50
                    mem[_2714 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                    idx = 41
                    s = address(_2664)
                    while idx > 1:
                        if s % 16 >= 16:
                            revert with 0, 50
                        if idx >= mem[_2714]:
                            revert with 0, 50
                        mem[idx + _2714 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                        if not idx:
                            revert with 0, 17
                        idx = idx - 1
                        s = Mask(252, 0, s) * 0.0625
                        continue 
                    if address(_2664) + 10240:
                        revert with 0, 'Strings: hex length insufficient'
                    _5350 = mem[64]
                    mem[mem[64]] = 66
                    mem[64] = mem[64] + 128
                    mem[_5350 + 32 len 66] = call.data[calldata.size len 66]
                    if 0 >= mem[_5350]:
                        revert with 0, 50
                    mem[_5350 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                    if 1 >= mem[_5350]:
                        revert with 0, 50
                    mem[_5350 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                    idx = 65
                    while idx > 1:
                        if idx >= mem[_5350]:
                            revert with 0, 50
                        mem[idx + _5350 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                        if not idx:
                            revert with 0, 17
                        idx = idx - 1
                        continue 
                    _8050 = mem[64]
                    mem[mem[64] + 32] = 'AccessControl: account '
                    _8076 = mem[_2714]
                    idx = 0
                    while idx < _8076:
                        mem[idx + _8050 + 55] = mem[idx + _2714 + 32]
                        idx = idx + 32
                        continue 
                    mem[_8050 + _8076 + 55] = 0x206973206d697373696e6720726f6c6520000000000000000000000000000000
                    if ceil32(_8076) <= _8076:
                        _10285 = mem[_5350]
                        idx = 0
                        while idx < _10285:
                            mem[idx + _8050 + _8076 + 72] = mem[idx + _5350 + 32]
                            idx = idx + 32
                            continue 
                        if ceil32(_10285) <= _10285:
                            _11147 = mem[64]
                            mem[mem[64]] = _10285 + _8050 + _8076 + -mem[64] + 40
                            mem[64] = _10285 + _8050 + _8076 + 72
                            mem[_10285 + _8050 + _8076 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_10285 + _8050 + _8076 + 76] = 32
                            _11203 = mem[_11147]
                            mem[_10285 + _8050 + _8076 + 108] = mem[_11147]
                            idx = 0
                            while idx < _11203:
                                mem[idx + _10285 + _8050 + _8076 + 140] = mem[idx + _11147 + 32]
                                idx = idx + 32
                                continue 
                            if ceil32(_11203) > _11203:
                                mem[_11203 + _10285 + _8050 + _8076 + 140] = 0
                            revert with 0, 32, mem[_10285 + _8050 + _8076 + 108 len ceil32(_11203) + 32]
                        mem[_10285 + _8050 + _8076 + 72] = 0
                        _11148 = mem[64]
                        mem[mem[64]] = _10285 + _8050 + _8076 + -mem[64] + 40
                        mem[64] = _10285 + _8050 + _8076 + 72
                        mem[_10285 + _8050 + _8076 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[_10285 + _8050 + _8076 + 76] = 32
                        _11204 = mem[_11148]
                        mem[_10285 + _8050 + _8076 + 108] = mem[_11148]
                        idx = 0
                        while idx < _11204:
                            mem[idx + _10285 + _8050 + _8076 + 140] = mem[idx + _11148 + 32]
                            idx = idx + 32
                            continue 
                        if ceil32(_11204) > _11204:
                            mem[_11204 + _10285 + _8050 + _8076 + 140] = 0
                        revert with 0, 32, mem[_10285 + _8050 + _8076 + 108 len ceil32(_11204) + 32]
                    _10286 = mem[_5350]
                    idx = 0
                    while idx < _10286:
                        mem[idx + _8050 + _8076 + 72] = mem[idx + _5350 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_10286) <= _10286:
                        _11149 = mem[64]
                        mem[mem[64]] = _10286 + _8050 + _8076 + -mem[64] + 40
                        mem[64] = _10286 + _8050 + _8076 + 72
                        mem[_10286 + _8050 + _8076 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[_10286 + _8050 + _8076 + 76] = 32
                        _11205 = mem[_11149]
                        mem[_10286 + _8050 + _8076 + 108] = mem[_11149]
                        idx = 0
                        while idx < _11205:
                            mem[idx + _10286 + _8050 + _8076 + 140] = mem[idx + _11149 + 32]
                            idx = idx + 32
                            continue 
                        if ceil32(_11205) > _11205:
                            mem[_11205 + _10286 + _8050 + _8076 + 140] = 0
                        revert with 0, 32, mem[_10286 + _8050 + _8076 + 108 len ceil32(_11205) + 32]
                    mem[_10286 + _8050 + _8076 + 72] = 0
                    _11150 = mem[64]
                    mem[mem[64]] = _10286 + _8050 + _8076 + -mem[64] + 40
                    mem[64] = _10286 + _8050 + _8076 + 72
                    mem[_10286 + _8050 + _8076 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[_10286 + _8050 + _8076 + 76] = 32
                    _11206 = mem[_11150]
                    mem[_10286 + _8050 + _8076 + 108] = mem[_11150]
                    idx = 0
                    while idx < _11206:
                        mem[idx + _10286 + _8050 + _8076 + 140] = mem[idx + _11150 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_11206) > _11206:
                        mem[_11206 + _10286 + _8050 + _8076 + 140] = 0
                    revert with 0, 32, mem[_10286 + _8050 + _8076 + 108 len ceil32(_11206) + 32]
                require cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] < calldata.size + -cd[(cd[4] + (32 * idx) + 36)] + -cd[4] - 67
                require cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 36)] <= test266151307()
                require cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68 <= calldata.size - (32 * cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 36)])
                require cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] < calldata.size + -cd[(cd[4] + (32 * idx) + 36)] + -cd[4] - 67
                require cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 36)] <= test266151307()
                require cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68 <= calldata.size - (32 * cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 36)])
                if msg.sender != this.address:
                    mem[0] = msg.sender
                    mem[32] = sha3(0, 2)
                    if uint8(roleAdmin[0][address(msg.sender)].field_0):
                        if cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 36)] != cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 36)]:
                            revert with 0, 'number of accounts must equal number of amounts'
                        s = 0
                        while s < cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 36)]:
                            require cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)] == address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])
                            if s >= cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 36)]:
                                revert with 0, 50
                            if msg.sender != this.address:
                                mem[0] = msg.sender
                                mem[32] = sha3(0, 2)
                                if not uint8(roleAdmin[0][address(msg.sender)].field_0):
                                    _5533 = mem[64]
                                    mem[mem[64]] = 42
                                    mem[64] = mem[64] + 96
                                    mem[_5533 + 32 len 42] = call.data[calldata.size len 42]
                                    if 0 >= mem[_5533]:
                                        revert with 0, 50
                                    mem[_5533 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                                    if 1 >= mem[_5533]:
                                        revert with 0, 50
                                    mem[_5533 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                                    idx = 41
                                    s = address(msg.sender)
                                    while idx > 1:
                                        if s % 16 >= 16:
                                            revert with 0, 50
                                        if idx >= mem[_5533]:
                                            revert with 0, 50
                                        mem[idx + _5533 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                                        if not idx:
                                            revert with 0, 17
                                        idx = idx - 1
                                        s = Mask(252, 0, s) * 0.0625
                                        continue 
                                    if msg.sender + 10240:
                                        revert with 0, 'Strings: hex length insufficient'
                                    _8383 = mem[64]
                                    mem[mem[64]] = 66
                                    mem[64] = mem[64] + 128
                                    mem[_8383 + 32 len 66] = call.data[calldata.size len 66]
                                    if 0 >= mem[_8383]:
                                        revert with 0, 50
                                    mem[_8383 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                                    if 1 >= mem[_8383]:
                                        revert with 0, 50
                                    mem[_8383 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                                    idx = 65
                                    while idx > 1:
                                        if idx >= mem[_8383]:
                                            revert with 0, 50
                                        mem[idx + _8383 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                                        if not idx:
                                            revert with 0, 17
                                        idx = idx - 1
                                        continue 
                                    _10287 = mem[64]
                                    mem[mem[64] + 32] = 'AccessControl: account '
                                    _10315 = mem[_5533]
                                    idx = 0
                                    while idx < _10315:
                                        mem[idx + _10287 + 55] = mem[idx + _5533 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_10287 + _10315 + 55] = 0x206973206d697373696e6720726f6c6520000000000000000000000000000000
                                    if ceil32(_10315) <= _10315:
                                        _11119 = mem[_8383]
                                        idx = 0
                                        while idx < _11119:
                                            mem[idx + _10287 + _10315 + 72] = mem[idx + _8383 + 32]
                                            idx = idx + 32
                                            continue 
                                        if ceil32(_11119) <= _11119:
                                            _11751 = mem[64]
                                            mem[mem[64]] = _11119 + _10287 + _10315 + -mem[64] + 40
                                            mem[64] = _11119 + _10287 + _10315 + 72
                                            mem[_11119 + _10287 + _10315 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_11119 + _10287 + _10315 + 76] = 32
                                            _11879 = mem[_11751]
                                            mem[_11119 + _10287 + _10315 + 108] = mem[_11751]
                                            idx = 0
                                            while idx < _11879:
                                                mem[idx + _11119 + _10287 + _10315 + 140] = mem[idx + _11751 + 32]
                                                idx = idx + 32
                                                continue 
                                            if ceil32(_11879) > _11879:
                                                mem[_11879 + _11119 + _10287 + _10315 + 140] = 0
                                            revert with 0, 32, mem[_11119 + _10287 + _10315 + 108 len ceil32(_11879) + 32]
                                        mem[_11119 + _10287 + _10315 + 72] = 0
                                        _11752 = mem[64]
                                        mem[mem[64]] = _11119 + _10287 + _10315 + -mem[64] + 40
                                        mem[64] = _11119 + _10287 + _10315 + 72
                                        mem[_11119 + _10287 + _10315 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[_11119 + _10287 + _10315 + 76] = 32
                                        _11880 = mem[_11752]
                                        mem[_11119 + _10287 + _10315 + 108] = mem[_11752]
                                        idx = 0
                                        while idx < _11880:
                                            mem[idx + _11119 + _10287 + _10315 + 140] = mem[idx + _11752 + 32]
                                            idx = idx + 32
                                            continue 
                                        if ceil32(_11880) > _11880:
                                            mem[_11880 + _11119 + _10287 + _10315 + 140] = 0
                                        revert with 0, 32, mem[_11119 + _10287 + _10315 + 108 len ceil32(_11880) + 32]
                                    _11120 = mem[_8383]
                                    idx = 0
                                    while idx < _11120:
                                        mem[idx + _10287 + _10315 + 72] = mem[idx + _8383 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_11120) <= _11120:
                                        _11753 = mem[64]
                                        mem[mem[64]] = _11120 + _10287 + _10315 + -mem[64] + 40
                                        mem[64] = _11120 + _10287 + _10315 + 72
                                        mem[_11120 + _10287 + _10315 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[_11120 + _10287 + _10315 + 76] = 32
                                        _11881 = mem[_11753]
                                        mem[_11120 + _10287 + _10315 + 108] = mem[_11753]
                                        idx = 0
                                        while idx < _11881:
                                            mem[idx + _11120 + _10287 + _10315 + 140] = mem[idx + _11753 + 32]
                                            idx = idx + 32
                                            continue 
                                        if ceil32(_11881) > _11881:
                                            mem[_11881 + _11120 + _10287 + _10315 + 140] = 0
                                        revert with 0, 32, mem[_11120 + _10287 + _10315 + 108 len ceil32(_11881) + 32]
                                    mem[_11120 + _10287 + _10315 + 72] = 0
                                    _11754 = mem[64]
                                    mem[mem[64]] = _11120 + _10287 + _10315 + -mem[64] + 40
                                    mem[64] = _11120 + _10287 + _10315 + 72
                                    mem[_11120 + _10287 + _10315 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_11120 + _10287 + _10315 + 76] = 32
                                    _11882 = mem[_11754]
                                    mem[_11120 + _10287 + _10315 + 108] = mem[_11754]
                                    idx = 0
                                    while idx < _11882:
                                        mem[idx + _11120 + _10287 + _10315 + 140] = mem[idx + _11754 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_11882) > _11882:
                                        mem[_11882 + _11120 + _10287 + _10315 + 140] = 0
                                    revert with 0, 32, mem[_11120 + _10287 + _10315 + 108 len ceil32(_11882) + 32]
                                require cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)] > 0
                                if cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)] <= 0:
                                    revert with 0, 'Amount should be > 0'
                                if sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] > !cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]:
                                    revert with 0, 17
                                if sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] + cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)] > sub_fc86b662[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]]:
                                    revert with 0, 'Minting would exceed the max number of items for given type'
                                if bool(stor12[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]]) != 1:
                                    revert with 0, 'typeId is not fungible.'
                                if sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] > !cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]:
                                    revert with 0, 17
                                mem[32] = 9
                                sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] += cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                _5733 = mem[64]
                                mem[mem[64]] = 0
                                if not address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]):
                                    revert with 0, 'ERC1155: mint to the zero address'
                                if msg.sender != this.address:
                                    mem[mem[64] + 32] = 1
                                    mem[64] = mem[64] + 96
                                    mem[_5733 + 64] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                                    mem[_5733 + 96] = 1
                                    mem[64] = _5733 + 160
                                    mem[_5733 + 128] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                    mem[0] = address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])
                                    mem[32] = sha3(cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)], 0)
                                    if balanceOf[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])] > !cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]:
                                        revert with 0, 17
                                    balanceOf[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])] += cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                    mem[_5733 + 160] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                                    mem[_5733 + 192] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                    emit TransferSingle(cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)], cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)], msg.sender, 0, address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]));
                                    if ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])):
                                        mem[_5733 + 160] = 0xf23a6e6100000000000000000000000000000000000000000000000000000000
                                        mem[_5733 + 164] = msg.sender
                                        mem[_5733 + 196] = 0
                                        mem[_5733 + 228] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                                        mem[_5733 + 260] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                        mem[_5733 + 292] = 160
                                        mem[_5733 + 324] = mem[_5733]
                                        t = 0
                                        while t < mem[_5733]:
                                            mem[t + _5733 + 356] = mem[t + _5733 + 32]
                                            t = t + 32
                                            continue 
                                        if ceil32(mem[_5733]) > mem[_5733]:
                                            mem[mem[_5733] + _5733 + 356] = 0
                                        require ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]))
                                        call address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)], cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)], 160, mem[_5733], mem[_5733 + 356 len ceil32(mem[_5733])]
                                        mem[_5733 + 160] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                                        mem[64] = _5733 + ceil32(return_data.size) + 160
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                                        if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                                else:
                                    mem[64] = mem[64] + ceil32(calldata.size) + 64
                                    mem[_5733 + 32] = calldata.size
                                    mem[_5733 + 64 len calldata.size] = call.data[0 len calldata.size]
                                    mem[_5733 + calldata.size + 64] = 0
                                    _5802 = mem[calldata.size + _5733 + 32]
                                    mem[_5733 + ceil32(calldata.size) + 64] = 1
                                    mem[_5733 + ceil32(calldata.size) + 96] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                                    mem[_5733 + ceil32(calldata.size) + 128] = 1
                                    mem[64] = _5733 + ceil32(calldata.size) + 192
                                    mem[_5733 + ceil32(calldata.size) + 160] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                    mem[0] = address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])
                                    mem[32] = sha3(cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)], 0)
                                    if balanceOf[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])] > !cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]:
                                        revert with 0, 17
                                    balanceOf[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])] += cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                    mem[_5733 + ceil32(calldata.size) + 192] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                                    mem[_5733 + ceil32(calldata.size) + 224] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                    emit TransferSingle(cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)], cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)], address(_5802), 0, address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]));
                                    if ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])):
                                        mem[_5733 + ceil32(calldata.size) + 192] = 0xf23a6e6100000000000000000000000000000000000000000000000000000000
                                        mem[_5733 + ceil32(calldata.size) + 196] = address(_5802)
                                        mem[_5733 + ceil32(calldata.size) + 228] = 0
                                        mem[_5733 + ceil32(calldata.size) + 260] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                                        mem[_5733 + ceil32(calldata.size) + 292] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                        mem[_5733 + ceil32(calldata.size) + 324] = 160
                                        mem[_5733 + ceil32(calldata.size) + 356] = mem[_5733]
                                        t = 0
                                        while t < mem[_5733]:
                                            mem[t + _5733 + ceil32(calldata.size) + 388] = mem[t + _5733 + 32]
                                            t = t + 32
                                            continue 
                                        if ceil32(mem[_5733]) > mem[_5733]:
                                            mem[mem[_5733] + _5733 + ceil32(calldata.size) + 388] = 0
                                        require ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]))
                                        call address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                                             gas gas_remaining wei
                                            args address(_5802), 0, cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)], cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)], 160, mem[_5733], mem[_5733 + ceil32(calldata.size) + 388 len ceil32(mem[_5733])]
                                        mem[_5733 + ceil32(calldata.size) + 192] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                                        mem[64] = _5733 + ceil32(calldata.size) + ceil32(return_data.size) + 192
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                                        if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                            else:
                                _5367 = mem[64]
                                mem[64] = mem[64] + ceil32(calldata.size) + 32
                                mem[_5367] = calldata.size
                                mem[_5367 + 32 len calldata.size] = call.data[0 len calldata.size]
                                mem[_5367 + calldata.size + 32] = 0
                                _5368 = mem[calldata.size + _5367]
                                mem[0] = mem[calldata.size + _5367 + 12 len 20]
                                mem[32] = sha3(0, 2)
                                if not uint8(roleAdmin[0][address(_5368)].field_0):
                                    _5534 = mem[64]
                                    mem[mem[64]] = 42
                                    mem[64] = mem[64] + 96
                                    mem[_5534 + 32 len 42] = call.data[calldata.size len 42]
                                    if 0 >= mem[_5534]:
                                        revert with 0, 50
                                    mem[_5534 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                                    if 1 >= mem[_5534]:
                                        revert with 0, 50
                                    mem[_5534 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                                    idx = 41
                                    s = address(_5368)
                                    while idx > 1:
                                        if s % 16 >= 16:
                                            revert with 0, 50
                                        if idx >= mem[_5534]:
                                            revert with 0, 50
                                        mem[idx + _5534 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                                        if not idx:
                                            revert with 0, 17
                                        idx = idx - 1
                                        s = Mask(252, 0, s) * 0.0625
                                        continue 
                                    if address(_5368) + 10240:
                                        revert with 0, 'Strings: hex length insufficient'
                                    _8384 = mem[64]
                                    mem[mem[64]] = 66
                                    mem[64] = mem[64] + 128
                                    mem[_8384 + 32 len 66] = call.data[calldata.size len 66]
                                    if 0 >= mem[_8384]:
                                        revert with 0, 50
                                    mem[_8384 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                                    if 1 >= mem[_8384]:
                                        revert with 0, 50
                                    mem[_8384 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                                    idx = 65
                                    while idx > 1:
                                        if idx >= mem[_8384]:
                                            revert with 0, 50
                                        mem[idx + _8384 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                                        if not idx:
                                            revert with 0, 17
                                        idx = idx - 1
                                        continue 
                                    _10288 = mem[64]
                                    mem[mem[64] + 32] = 'AccessControl: account '
                                    _10316 = mem[_5534]
                                    idx = 0
                                    while idx < _10316:
                                        mem[idx + _10288 + 55] = mem[idx + _5534 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_10288 + _10316 + 55] = 0x206973206d697373696e6720726f6c6520000000000000000000000000000000
                                    if ceil32(_10316) <= _10316:
                                        _11121 = mem[_8384]
                                        idx = 0
                                        while idx < _11121:
                                            mem[idx + _10288 + _10316 + 72] = mem[idx + _8384 + 32]
                                            idx = idx + 32
                                            continue 
                                        if ceil32(_11121) <= _11121:
                                            _11755 = mem[64]
                                            mem[mem[64]] = _11121 + _10288 + _10316 + -mem[64] + 40
                                            mem[64] = _11121 + _10288 + _10316 + 72
                                            mem[_11121 + _10288 + _10316 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_11121 + _10288 + _10316 + 76] = 32
                                            _11883 = mem[_11755]
                                            mem[_11121 + _10288 + _10316 + 108] = mem[_11755]
                                            idx = 0
                                            while idx < _11883:
                                                mem[idx + _11121 + _10288 + _10316 + 140] = mem[idx + _11755 + 32]
                                                idx = idx + 32
                                                continue 
                                            if ceil32(_11883) > _11883:
                                                mem[_11883 + _11121 + _10288 + _10316 + 140] = 0
                                            revert with 0, 32, mem[_11121 + _10288 + _10316 + 108 len ceil32(_11883) + 32]
                                        mem[_11121 + _10288 + _10316 + 72] = 0
                                        _11756 = mem[64]
                                        mem[mem[64]] = _11121 + _10288 + _10316 + -mem[64] + 40
                                        mem[64] = _11121 + _10288 + _10316 + 72
                                        mem[_11121 + _10288 + _10316 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[_11121 + _10288 + _10316 + 76] = 32
                                        _11884 = mem[_11756]
                                        mem[_11121 + _10288 + _10316 + 108] = mem[_11756]
                                        idx = 0
                                        while idx < _11884:
                                            mem[idx + _11121 + _10288 + _10316 + 140] = mem[idx + _11756 + 32]
                                            idx = idx + 32
                                            continue 
                                        if ceil32(_11884) > _11884:
                                            mem[_11884 + _11121 + _10288 + _10316 + 140] = 0
                                        revert with 0, 32, mem[_11121 + _10288 + _10316 + 108 len ceil32(_11884) + 32]
                                    _11122 = mem[_8384]
                                    idx = 0
                                    while idx < _11122:
                                        mem[idx + _10288 + _10316 + 72] = mem[idx + _8384 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_11122) <= _11122:
                                        _11757 = mem[64]
                                        mem[mem[64]] = _11122 + _10288 + _10316 + -mem[64] + 40
                                        mem[64] = _11122 + _10288 + _10316 + 72
                                        mem[_11122 + _10288 + _10316 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[_11122 + _10288 + _10316 + 76] = 32
                                        _11885 = mem[_11757]
                                        mem[_11122 + _10288 + _10316 + 108] = mem[_11757]
                                        idx = 0
                                        while idx < _11885:
                                            mem[idx + _11122 + _10288 + _10316 + 140] = mem[idx + _11757 + 32]
                                            idx = idx + 32
                                            continue 
                                        if ceil32(_11885) > _11885:
                                            mem[_11885 + _11122 + _10288 + _10316 + 140] = 0
                                        revert with 0, 32, mem[_11122 + _10288 + _10316 + 108 len ceil32(_11885) + 32]
                                    mem[_11122 + _10288 + _10316 + 72] = 0
                                    _11758 = mem[64]
                                    mem[mem[64]] = _11122 + _10288 + _10316 + -mem[64] + 40
                                    mem[64] = _11122 + _10288 + _10316 + 72
                                    mem[_11122 + _10288 + _10316 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_11122 + _10288 + _10316 + 76] = 32
                                    _11886 = mem[_11758]
                                    mem[_11122 + _10288 + _10316 + 108] = mem[_11758]
                                    idx = 0
                                    while idx < _11886:
                                        mem[idx + _11122 + _10288 + _10316 + 140] = mem[idx + _11758 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_11886) > _11886:
                                        mem[_11886 + _11122 + _10288 + _10316 + 140] = 0
                                    revert with 0, 32, mem[_11122 + _10288 + _10316 + 108 len ceil32(_11886) + 32]
                                require cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)] > 0
                                if cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)] <= 0:
                                    revert with 0, 'Amount should be > 0'
                                if sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] > !cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]:
                                    revert with 0, 17
                                if sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] + cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)] > sub_fc86b662[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]]:
                                    revert with 0, 'Minting would exceed the max number of items for given type'
                                if bool(stor12[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]]) != 1:
                                    revert with 0, 'typeId is not fungible.'
                                if sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] > !cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]:
                                    revert with 0, 17
                                mem[32] = 9
                                sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] += cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                _5734 = mem[64]
                                mem[mem[64]] = 0
                                if not address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]):
                                    revert with 0, 'ERC1155: mint to the zero address'
                                if msg.sender != this.address:
                                    mem[mem[64] + 32] = 1
                                    mem[64] = mem[64] + 96
                                    mem[_5734 + 64] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                                    mem[_5734 + 96] = 1
                                    mem[64] = _5734 + 160
                                    mem[_5734 + 128] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                    mem[0] = address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])
                                    mem[32] = sha3(cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)], 0)
                                    if balanceOf[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])] > !cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]:
                                        revert with 0, 17
                                    balanceOf[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])] += cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                    mem[_5734 + 160] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                                    mem[_5734 + 192] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                    emit TransferSingle(cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)], cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)], msg.sender, 0, address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]));
                                    if ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])):
                                        mem[_5734 + 160] = 0xf23a6e6100000000000000000000000000000000000000000000000000000000
                                        mem[_5734 + 164] = msg.sender
                                        mem[_5734 + 196] = 0
                                        mem[_5734 + 228] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                                        mem[_5734 + 260] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                        mem[_5734 + 292] = 160
                                        mem[_5734 + 324] = mem[_5734]
                                        t = 0
                                        while t < mem[_5734]:
                                            mem[t + _5734 + 356] = mem[t + _5734 + 32]
                                            t = t + 32
                                            continue 
                                        if ceil32(mem[_5734]) > mem[_5734]:
                                            mem[mem[_5734] + _5734 + 356] = 0
                                        require ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]))
                                        call address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)], cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)], 160, mem[_5734], mem[_5734 + 356 len ceil32(mem[_5734])]
                                        mem[_5734 + 160] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                                        mem[64] = _5734 + ceil32(return_data.size) + 160
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                                        if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                                else:
                                    mem[64] = mem[64] + ceil32(calldata.size) + 64
                                    mem[_5734 + 32] = calldata.size
                                    mem[_5734 + 64 len calldata.size] = call.data[0 len calldata.size]
                                    mem[_5734 + calldata.size + 64] = 0
                                    _5804 = mem[calldata.size + _5734 + 32]
                                    mem[_5734 + ceil32(calldata.size) + 64] = 1
                                    mem[_5734 + ceil32(calldata.size) + 96] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                                    mem[_5734 + ceil32(calldata.size) + 128] = 1
                                    mem[64] = _5734 + ceil32(calldata.size) + 192
                                    mem[_5734 + ceil32(calldata.size) + 160] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                    mem[0] = address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])
                                    mem[32] = sha3(cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)], 0)
                                    if balanceOf[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])] > !cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]:
                                        revert with 0, 17
                                    balanceOf[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])] += cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                    mem[_5734 + ceil32(calldata.size) + 192] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                                    mem[_5734 + ceil32(calldata.size) + 224] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                    emit TransferSingle(cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)], cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)], address(_5804), 0, address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]));
                                    if ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])):
                                        mem[_5734 + ceil32(calldata.size) + 192] = 0xf23a6e6100000000000000000000000000000000000000000000000000000000
                                        mem[_5734 + ceil32(calldata.size) + 196] = address(_5804)
                                        mem[_5734 + ceil32(calldata.size) + 228] = 0
                                        mem[_5734 + ceil32(calldata.size) + 260] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                                        mem[_5734 + ceil32(calldata.size) + 292] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                        mem[_5734 + ceil32(calldata.size) + 324] = 160
                                        mem[_5734 + ceil32(calldata.size) + 356] = mem[_5734]
                                        t = 0
                                        while t < mem[_5734]:
                                            mem[t + _5734 + ceil32(calldata.size) + 388] = mem[t + _5734 + 32]
                                            t = t + 32
                                            continue 
                                        if ceil32(mem[_5734]) > mem[_5734]:
                                            mem[mem[_5734] + _5734 + ceil32(calldata.size) + 388] = 0
                                        require ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]))
                                        call address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                                             gas gas_remaining wei
                                            args address(_5804), 0, cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)], cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)], 160, mem[_5734], mem[_5734 + ceil32(calldata.size) + 388 len ceil32(mem[_5734])]
                                        mem[_5734 + ceil32(calldata.size) + 192] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                                        mem[64] = _5734 + ceil32(calldata.size) + ceil32(return_data.size) + 192
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                                        if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            continue 
                        _5299 = mem[64]
                        mem[mem[64]] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                        mem[mem[64] + 32] = 96
                        mem[mem[64] + 96] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 36)]
                        s = 0
                        t = cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68
                        u = mem[64] + 128
                        while s < cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 36)]:
                            require cd[t] == address(cd[t])
                            mem[u] = address(cd[t])
                            s = s + 1
                            t = t + 32
                            u = u + 32
                            continue 
                        mem[_5299 + 64] = u - _5299
                        mem[u] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 36)]
                        require cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 36)] <= 0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
                        mem[u + 32 len 32 * cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 36)]] = call.data[cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68 len 32 * cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 36)]]
                        mem[u + (32 * cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 36)]) + 32] = 0
                        emit 0xbc11d48c: mem[mem[64] len u + (32 * cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 36)]) + -mem[64] + 32]
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    _2715 = mem[64]
                    mem[mem[64]] = 42
                    mem[64] = mem[64] + 96
                    mem[_2715 + 32 len 42] = call.data[calldata.size len 42]
                    if 0 >= mem[_2715]:
                        revert with 0, 50
                    mem[_2715 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                    if 1 >= mem[_2715]:
                        revert with 0, 50
                    mem[_2715 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                    idx = 41
                    s = address(msg.sender)
                    while idx > 1:
                        if s % 16 >= 16:
                            revert with 0, 50
                        if idx >= mem[_2715]:
                            revert with 0, 50
                        mem[idx + _2715 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                        if not idx:
                            revert with 0, 17
                        idx = idx - 1
                        s = Mask(252, 0, s) * 0.0625
                        continue 
                    if msg.sender + 10240:
                        revert with 0, 'Strings: hex length insufficient'
                    _5351 = mem[64]
                    mem[mem[64]] = 66
                    mem[64] = mem[64] + 128
                    mem[_5351 + 32 len 66] = call.data[calldata.size len 66]
                    if 0 >= mem[_5351]:
                        revert with 0, 50
                    mem[_5351 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                    if 1 >= mem[_5351]:
                        revert with 0, 50
                    mem[_5351 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                    idx = 65
                    while idx > 1:
                        if idx >= mem[_5351]:
                            revert with 0, 50
                        mem[idx + _5351 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                        if not idx:
                            revert with 0, 17
                        idx = idx - 1
                        continue 
                    _8053 = mem[64]
                    mem[mem[64] + 32] = 'AccessControl: account '
                    _8077 = mem[_2715]
                    idx = 0
                    while idx < _8077:
                        mem[idx + _8053 + 55] = mem[idx + _2715 + 32]
                        idx = idx + 32
                        continue 
                    mem[_8053 + _8077 + 55] = 0x206973206d697373696e6720726f6c6520000000000000000000000000000000
                    if ceil32(_8077) <= _8077:
                        _10289 = mem[_5351]
                        idx = 0
                        while idx < _10289:
                            mem[idx + _8053 + _8077 + 72] = mem[idx + _5351 + 32]
                            idx = idx + 32
                            continue 
                        if ceil32(_10289) <= _10289:
                            _11151 = mem[64]
                            mem[mem[64]] = _10289 + _8053 + _8077 + -mem[64] + 40
                            mem[64] = _10289 + _8053 + _8077 + 72
                            mem[_10289 + _8053 + _8077 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_10289 + _8053 + _8077 + 76] = 32
                            _11211 = mem[_11151]
                            mem[_10289 + _8053 + _8077 + 108] = mem[_11151]
                            idx = 0
                            while idx < _11211:
                                mem[idx + _10289 + _8053 + _8077 + 140] = mem[idx + _11151 + 32]
                                idx = idx + 32
                                continue 
                            if ceil32(_11211) > _11211:
                                mem[_11211 + _10289 + _8053 + _8077 + 140] = 0
                            revert with 0, 32, mem[_10289 + _8053 + _8077 + 108 len ceil32(_11211) + 32]
                        mem[_10289 + _8053 + _8077 + 72] = 0
                        _11152 = mem[64]
                        mem[mem[64]] = _10289 + _8053 + _8077 + -mem[64] + 40
                        mem[64] = _10289 + _8053 + _8077 + 72
                        mem[_10289 + _8053 + _8077 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[_10289 + _8053 + _8077 + 76] = 32
                        _11212 = mem[_11152]
                        mem[_10289 + _8053 + _8077 + 108] = mem[_11152]
                        idx = 0
                        while idx < _11212:
                            mem[idx + _10289 + _8053 + _8077 + 140] = mem[idx + _11152 + 32]
                            idx = idx + 32
                            continue 
                        if ceil32(_11212) > _11212:
                            mem[_11212 + _10289 + _8053 + _8077 + 140] = 0
                        revert with 0, 32, mem[_10289 + _8053 + _8077 + 108 len ceil32(_11212) + 32]
                    _10290 = mem[_5351]
                    idx = 0
                    while idx < _10290:
                        mem[idx + _8053 + _8077 + 72] = mem[idx + _5351 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_10290) <= _10290:
                        _11153 = mem[64]
                        mem[mem[64]] = _10290 + _8053 + _8077 + -mem[64] + 40
                        mem[64] = _10290 + _8053 + _8077 + 72
                        mem[_10290 + _8053 + _8077 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[_10290 + _8053 + _8077 + 76] = 32
                        _11213 = mem[_11153]
                        mem[_10290 + _8053 + _8077 + 108] = mem[_11153]
                        idx = 0
                        while idx < _11213:
                            mem[idx + _10290 + _8053 + _8077 + 140] = mem[idx + _11153 + 32]
                            idx = idx + 32
                            continue 
                        if ceil32(_11213) > _11213:
                            mem[_11213 + _10290 + _8053 + _8077 + 140] = 0
                        revert with 0, 32, mem[_10290 + _8053 + _8077 + 108 len ceil32(_11213) + 32]
                    mem[_10290 + _8053 + _8077 + 72] = 0
                    _11154 = mem[64]
                    mem[mem[64]] = _10290 + _8053 + _8077 + -mem[64] + 40
                    mem[64] = _10290 + _8053 + _8077 + 72
                    mem[_10290 + _8053 + _8077 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[_10290 + _8053 + _8077 + 76] = 32
                    _11214 = mem[_11154]
                    mem[_10290 + _8053 + _8077 + 108] = mem[_11154]
                    idx = 0
                    while idx < _11214:
                        mem[idx + _10290 + _8053 + _8077 + 140] = mem[idx + _11154 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_11214) > _11214:
                        mem[_11214 + _10290 + _8053 + _8077 + 140] = 0
                    revert with 0, 32, mem[_10290 + _8053 + _8077 + 108 len ceil32(_11214) + 32]
                _2665 = mem[64]
                mem[64] = mem[64] + ceil32(calldata.size) + 32
                mem[_2665] = calldata.size
                mem[_2665 + 32 len calldata.size] = call.data[0 len calldata.size]
                mem[_2665 + calldata.size + 32] = 0
                _2666 = mem[calldata.size + _2665]
                mem[0] = mem[calldata.size + _2665 + 12 len 20]
                mem[32] = sha3(0, 2)
                if uint8(roleAdmin[0][address(_2666)].field_0):
                    if cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 36)] != cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 36)]:
                        revert with 0, 'number of accounts must equal number of amounts'
                    s = 0
                    while s < cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 36)]:
                        require cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)] == address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])
                        if s >= cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 36)]:
                            revert with 0, 50
                        if msg.sender != this.address:
                            mem[0] = msg.sender
                            mem[32] = sha3(0, 2)
                            if not uint8(roleAdmin[0][address(msg.sender)].field_0):
                                _5535 = mem[64]
                                mem[mem[64]] = 42
                                mem[64] = mem[64] + 96
                                mem[_5535 + 32 len 42] = call.data[calldata.size len 42]
                                if 0 >= mem[_5535]:
                                    revert with 0, 50
                                mem[_5535 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                                if 1 >= mem[_5535]:
                                    revert with 0, 50
                                mem[_5535 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                                idx = 41
                                s = address(msg.sender)
                                while idx > 1:
                                    if s % 16 >= 16:
                                        revert with 0, 50
                                    if idx >= mem[_5535]:
                                        revert with 0, 50
                                    mem[idx + _5535 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                                    if not idx:
                                        revert with 0, 17
                                    idx = idx - 1
                                    s = Mask(252, 0, s) * 0.0625
                                    continue 
                                if msg.sender + 10240:
                                    revert with 0, 'Strings: hex length insufficient'
                                _8385 = mem[64]
                                mem[mem[64]] = 66
                                mem[64] = mem[64] + 128
                                mem[_8385 + 32 len 66] = call.data[calldata.size len 66]
                                if 0 >= mem[_8385]:
                                    revert with 0, 50
                                mem[_8385 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                                if 1 >= mem[_8385]:
                                    revert with 0, 50
                                mem[_8385 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                                idx = 65
                                while idx > 1:
                                    if idx >= mem[_8385]:
                                        revert with 0, 50
                                    mem[idx + _8385 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                                    if not idx:
                                        revert with 0, 17
                                    idx = idx - 1
                                    continue 
                                _10291 = mem[64]
                                mem[mem[64] + 32] = 'AccessControl: account '
                                _10317 = mem[_5535]
                                idx = 0
                                while idx < _10317:
                                    mem[idx + _10291 + 55] = mem[idx + _5535 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10291 + _10317 + 55] = 0x206973206d697373696e6720726f6c6520000000000000000000000000000000
                                if ceil32(_10317) <= _10317:
                                    _11123 = mem[_8385]
                                    idx = 0
                                    while idx < _11123:
                                        mem[idx + _10291 + _10317 + 72] = mem[idx + _8385 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_11123) <= _11123:
                                        _11759 = mem[64]
                                        mem[mem[64]] = _11123 + _10291 + _10317 + -mem[64] + 40
                                        mem[64] = _11123 + _10291 + _10317 + 72
                                        mem[_11123 + _10291 + _10317 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[_11123 + _10291 + _10317 + 76] = 32
                                        _11887 = mem[_11759]
                                        mem[_11123 + _10291 + _10317 + 108] = mem[_11759]
                                        idx = 0
                                        while idx < _11887:
                                            mem[idx + _11123 + _10291 + _10317 + 140] = mem[idx + _11759 + 32]
                                            idx = idx + 32
                                            continue 
                                        if ceil32(_11887) > _11887:
                                            mem[_11887 + _11123 + _10291 + _10317 + 140] = 0
                                        revert with 0, 32, mem[_11123 + _10291 + _10317 + 108 len ceil32(_11887) + 32]
                                    mem[_11123 + _10291 + _10317 + 72] = 0
                                    _11760 = mem[64]
                                    mem[mem[64]] = _11123 + _10291 + _10317 + -mem[64] + 40
                                    mem[64] = _11123 + _10291 + _10317 + 72
                                    mem[_11123 + _10291 + _10317 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_11123 + _10291 + _10317 + 76] = 32
                                    _11888 = mem[_11760]
                                    mem[_11123 + _10291 + _10317 + 108] = mem[_11760]
                                    idx = 0
                                    while idx < _11888:
                                        mem[idx + _11123 + _10291 + _10317 + 140] = mem[idx + _11760 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_11888) > _11888:
                                        mem[_11888 + _11123 + _10291 + _10317 + 140] = 0
                                    revert with 0, 32, mem[_11123 + _10291 + _10317 + 108 len ceil32(_11888) + 32]
                                _11124 = mem[_8385]
                                idx = 0
                                while idx < _11124:
                                    mem[idx + _10291 + _10317 + 72] = mem[idx + _8385 + 32]
                                    idx = idx + 32
                                    continue 
                                if ceil32(_11124) <= _11124:
                                    _11761 = mem[64]
                                    mem[mem[64]] = _11124 + _10291 + _10317 + -mem[64] + 40
                                    mem[64] = _11124 + _10291 + _10317 + 72
                                    mem[_11124 + _10291 + _10317 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_11124 + _10291 + _10317 + 76] = 32
                                    _11889 = mem[_11761]
                                    mem[_11124 + _10291 + _10317 + 108] = mem[_11761]
                                    idx = 0
                                    while idx < _11889:
                                        mem[idx + _11124 + _10291 + _10317 + 140] = mem[idx + _11761 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_11889) > _11889:
                                        mem[_11889 + _11124 + _10291 + _10317 + 140] = 0
                                    revert with 0, 32, mem[_11124 + _10291 + _10317 + 108 len ceil32(_11889) + 32]
                                mem[_11124 + _10291 + _10317 + 72] = 0
                                _11762 = mem[64]
                                mem[mem[64]] = _11124 + _10291 + _10317 + -mem[64] + 40
                                mem[64] = _11124 + _10291 + _10317 + 72
                                mem[_11124 + _10291 + _10317 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_11124 + _10291 + _10317 + 76] = 32
                                _11890 = mem[_11762]
                                mem[_11124 + _10291 + _10317 + 108] = mem[_11762]
                                idx = 0
                                while idx < _11890:
                                    mem[idx + _11124 + _10291 + _10317 + 140] = mem[idx + _11762 + 32]
                                    idx = idx + 32
                                    continue 
                                if ceil32(_11890) > _11890:
                                    mem[_11890 + _11124 + _10291 + _10317 + 140] = 0
                                revert with 0, 32, mem[_11124 + _10291 + _10317 + 108 len ceil32(_11890) + 32]
                            require cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)] > 0
                            if cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)] <= 0:
                                revert with 0, 'Amount should be > 0'
                            if sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] > !cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]:
                                revert with 0, 17
                            if sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] + cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)] > sub_fc86b662[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]]:
                                revert with 0, 'Minting would exceed the max number of items for given type'
                            if bool(stor12[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]]) != 1:
                                revert with 0, 'typeId is not fungible.'
                            if sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] > !cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]:
                                revert with 0, 17
                            mem[32] = 9
                            sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] += cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                            _5735 = mem[64]
                            mem[mem[64]] = 0
                            if not address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]):
                                revert with 0, 'ERC1155: mint to the zero address'
                            if msg.sender != this.address:
                                mem[mem[64] + 32] = 1
                                mem[64] = mem[64] + 96
                                mem[_5735 + 64] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                                mem[_5735 + 96] = 1
                                mem[64] = _5735 + 160
                                mem[_5735 + 128] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                mem[0] = address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])
                                mem[32] = sha3(cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)], 0)
                                if balanceOf[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])] > !cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]:
                                    revert with 0, 17
                                balanceOf[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])] += cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                mem[_5735 + 160] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                                mem[_5735 + 192] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                emit TransferSingle(cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)], cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)], msg.sender, 0, address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]));
                                if ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])):
                                    mem[_5735 + 160] = 0xf23a6e6100000000000000000000000000000000000000000000000000000000
                                    mem[_5735 + 164] = msg.sender
                                    mem[_5735 + 196] = 0
                                    mem[_5735 + 228] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                                    mem[_5735 + 260] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                    mem[_5735 + 292] = 160
                                    mem[_5735 + 324] = mem[_5735]
                                    t = 0
                                    while t < mem[_5735]:
                                        mem[t + _5735 + 356] = mem[t + _5735 + 32]
                                        t = t + 32
                                        continue 
                                    if ceil32(mem[_5735]) > mem[_5735]:
                                        mem[mem[_5735] + _5735 + 356] = 0
                                    require ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]))
                                    call address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)], cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)], 160, mem[_5735], mem[_5735 + 356 len ceil32(mem[_5735])]
                                    mem[_5735 + 160] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                                    mem[64] = _5735 + ceil32(return_data.size) + 160
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                                    if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                            else:
                                mem[64] = mem[64] + ceil32(calldata.size) + 64
                                mem[_5735 + 32] = calldata.size
                                mem[_5735 + 64 len calldata.size] = call.data[0 len calldata.size]
                                mem[_5735 + calldata.size + 64] = 0
                                _5806 = mem[calldata.size + _5735 + 32]
                                mem[_5735 + ceil32(calldata.size) + 64] = 1
                                mem[_5735 + ceil32(calldata.size) + 96] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                                mem[_5735 + ceil32(calldata.size) + 128] = 1
                                mem[64] = _5735 + ceil32(calldata.size) + 192
                                mem[_5735 + ceil32(calldata.size) + 160] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                mem[0] = address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])
                                mem[32] = sha3(cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)], 0)
                                if balanceOf[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])] > !cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]:
                                    revert with 0, 17
                                balanceOf[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])] += cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                mem[_5735 + ceil32(calldata.size) + 192] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                                mem[_5735 + ceil32(calldata.size) + 224] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                emit TransferSingle(cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)], cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)], address(_5806), 0, address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]));
                                if ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])):
                                    mem[_5735 + ceil32(calldata.size) + 192] = 0xf23a6e6100000000000000000000000000000000000000000000000000000000
                                    mem[_5735 + ceil32(calldata.size) + 196] = address(_5806)
                                    mem[_5735 + ceil32(calldata.size) + 228] = 0
                                    mem[_5735 + ceil32(calldata.size) + 260] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                                    mem[_5735 + ceil32(calldata.size) + 292] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                    mem[_5735 + ceil32(calldata.size) + 324] = 160
                                    mem[_5735 + ceil32(calldata.size) + 356] = mem[_5735]
                                    t = 0
                                    while t < mem[_5735]:
                                        mem[t + _5735 + ceil32(calldata.size) + 388] = mem[t + _5735 + 32]
                                        t = t + 32
                                        continue 
                                    if ceil32(mem[_5735]) > mem[_5735]:
                                        mem[mem[_5735] + _5735 + ceil32(calldata.size) + 388] = 0
                                    require ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]))
                                    call address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                                         gas gas_remaining wei
                                        args address(_5806), 0, cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)], cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)], 160, mem[_5735], mem[_5735 + ceil32(calldata.size) + 388 len ceil32(mem[_5735])]
                                    mem[_5735 + ceil32(calldata.size) + 192] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                                    mem[64] = _5735 + ceil32(calldata.size) + ceil32(return_data.size) + 192
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                                    if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                        else:
                            _5370 = mem[64]
                            mem[64] = mem[64] + ceil32(calldata.size) + 32
                            mem[_5370] = calldata.size
                            mem[_5370 + 32 len calldata.size] = call.data[0 len calldata.size]
                            mem[_5370 + calldata.size + 32] = 0
                            _5371 = mem[calldata.size + _5370]
                            mem[0] = mem[calldata.size + _5370 + 12 len 20]
                            mem[32] = sha3(0, 2)
                            if not uint8(roleAdmin[0][address(_5371)].field_0):
                                _5536 = mem[64]
                                mem[mem[64]] = 42
                                mem[64] = mem[64] + 96
                                mem[_5536 + 32 len 42] = call.data[calldata.size len 42]
                                if 0 >= mem[_5536]:
                                    revert with 0, 50
                                mem[_5536 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                                if 1 >= mem[_5536]:
                                    revert with 0, 50
                                mem[_5536 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                                idx = 41
                                s = address(_5371)
                                while idx > 1:
                                    if s % 16 >= 16:
                                        revert with 0, 50
                                    if idx >= mem[_5536]:
                                        revert with 0, 50
                                    mem[idx + _5536 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                                    if not idx:
                                        revert with 0, 17
                                    idx = idx - 1
                                    s = Mask(252, 0, s) * 0.0625
                                    continue 
                                if address(_5371) + 10240:
                                    revert with 0, 'Strings: hex length insufficient'
                                _8386 = mem[64]
                                mem[mem[64]] = 66
                                mem[64] = mem[64] + 128
                                mem[_8386 + 32 len 66] = call.data[calldata.size len 66]
                                if 0 >= mem[_8386]:
                                    revert with 0, 50
                                mem[_8386 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                                if 1 >= mem[_8386]:
                                    revert with 0, 50
                                mem[_8386 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                                idx = 65
                                while idx > 1:
                                    if idx >= mem[_8386]:
                                        revert with 0, 50
                                    mem[idx + _8386 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                                    if not idx:
                                        revert with 0, 17
                                    idx = idx - 1
                                    continue 
                                _10292 = mem[64]
                                mem[mem[64] + 32] = 'AccessControl: account '
                                _10318 = mem[_5536]
                                idx = 0
                                while idx < _10318:
                                    mem[idx + _10292 + 55] = mem[idx + _5536 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10292 + _10318 + 55] = 0x206973206d697373696e6720726f6c6520000000000000000000000000000000
                                if ceil32(_10318) <= _10318:
                                    _11125 = mem[_8386]
                                    idx = 0
                                    while idx < _11125:
                                        mem[idx + _10292 + _10318 + 72] = mem[idx + _8386 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_11125) <= _11125:
                                        _11763 = mem[64]
                                        mem[mem[64]] = _11125 + _10292 + _10318 + -mem[64] + 40
                                        mem[64] = _11125 + _10292 + _10318 + 72
                                        mem[_11125 + _10292 + _10318 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[_11125 + _10292 + _10318 + 76] = 32
                                        _11891 = mem[_11763]
                                        mem[_11125 + _10292 + _10318 + 108] = mem[_11763]
                                        idx = 0
                                        while idx < _11891:
                                            mem[idx + _11125 + _10292 + _10318 + 140] = mem[idx + _11763 + 32]
                                            idx = idx + 32
                                            continue 
                                        if ceil32(_11891) > _11891:
                                            mem[_11891 + _11125 + _10292 + _10318 + 140] = 0
                                        revert with 0, 32, mem[_11125 + _10292 + _10318 + 108 len ceil32(_11891) + 32]
                                    mem[_11125 + _10292 + _10318 + 72] = 0
                                    _11764 = mem[64]
                                    mem[mem[64]] = _11125 + _10292 + _10318 + -mem[64] + 40
                                    mem[64] = _11125 + _10292 + _10318 + 72
                                    mem[_11125 + _10292 + _10318 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_11125 + _10292 + _10318 + 76] = 32
                                    _11892 = mem[_11764]
                                    mem[_11125 + _10292 + _10318 + 108] = mem[_11764]
                                    idx = 0
                                    while idx < _11892:
                                        mem[idx + _11125 + _10292 + _10318 + 140] = mem[idx + _11764 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_11892) > _11892:
                                        mem[_11892 + _11125 + _10292 + _10318 + 140] = 0
                                    revert with 0, 32, mem[_11125 + _10292 + _10318 + 108 len ceil32(_11892) + 32]
                                _11126 = mem[_8386]
                                idx = 0
                                while idx < _11126:
                                    mem[idx + _10292 + _10318 + 72] = mem[idx + _8386 + 32]
                                    idx = idx + 32
                                    continue 
                                if ceil32(_11126) <= _11126:
                                    _11765 = mem[64]
                                    mem[mem[64]] = _11126 + _10292 + _10318 + -mem[64] + 40
                                    mem[64] = _11126 + _10292 + _10318 + 72
                                    mem[_11126 + _10292 + _10318 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_11126 + _10292 + _10318 + 76] = 32
                                    _11893 = mem[_11765]
                                    mem[_11126 + _10292 + _10318 + 108] = mem[_11765]
                                    idx = 0
                                    while idx < _11893:
                                        mem[idx + _11126 + _10292 + _10318 + 140] = mem[idx + _11765 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_11893) > _11893:
                                        mem[_11893 + _11126 + _10292 + _10318 + 140] = 0
                                    revert with 0, 32, mem[_11126 + _10292 + _10318 + 108 len ceil32(_11893) + 32]
                                mem[_11126 + _10292 + _10318 + 72] = 0
                                _11766 = mem[64]
                                mem[mem[64]] = _11126 + _10292 + _10318 + -mem[64] + 40
                                mem[64] = _11126 + _10292 + _10318 + 72
                                mem[_11126 + _10292 + _10318 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_11126 + _10292 + _10318 + 76] = 32
                                _11894 = mem[_11766]
                                mem[_11126 + _10292 + _10318 + 108] = mem[_11766]
                                idx = 0
                                while idx < _11894:
                                    mem[idx + _11126 + _10292 + _10318 + 140] = mem[idx + _11766 + 32]
                                    idx = idx + 32
                                    continue 
                                if ceil32(_11894) > _11894:
                                    mem[_11894 + _11126 + _10292 + _10318 + 140] = 0
                                revert with 0, 32, mem[_11126 + _10292 + _10318 + 108 len ceil32(_11894) + 32]
                            require cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)] > 0
                            if cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)] <= 0:
                                revert with 0, 'Amount should be > 0'
                            if sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] > !cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]:
                                revert with 0, 17
                            if sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] + cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)] > sub_fc86b662[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]]:
                                revert with 0, 'Minting would exceed the max number of items for given type'
                            if bool(stor12[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]]) != 1:
                                revert with 0, 'typeId is not fungible.'
                            if sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] > !cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]:
                                revert with 0, 17
                            mem[32] = 9
                            sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] += cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                            _5736 = mem[64]
                            mem[mem[64]] = 0
                            if not address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]):
                                revert with 0, 'ERC1155: mint to the zero address'
                            if msg.sender != this.address:
                                mem[mem[64] + 32] = 1
                                mem[64] = mem[64] + 96
                                mem[_5736 + 64] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                                mem[_5736 + 96] = 1
                                mem[64] = _5736 + 160
                                mem[_5736 + 128] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                mem[0] = address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])
                                mem[32] = sha3(cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)], 0)
                                if balanceOf[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])] > !cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]:
                                    revert with 0, 17
                                balanceOf[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])] += cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                mem[_5736 + 160] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                                mem[_5736 + 192] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                emit TransferSingle(cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)], cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)], msg.sender, 0, address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]));
                                if ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])):
                                    mem[_5736 + 160] = 0xf23a6e6100000000000000000000000000000000000000000000000000000000
                                    mem[_5736 + 164] = msg.sender
                                    mem[_5736 + 196] = 0
                                    mem[_5736 + 228] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                                    mem[_5736 + 260] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                    mem[_5736 + 292] = 160
                                    mem[_5736 + 324] = mem[_5736]
                                    t = 0
                                    while t < mem[_5736]:
                                        mem[t + _5736 + 356] = mem[t + _5736 + 32]
                                        t = t + 32
                                        continue 
                                    if ceil32(mem[_5736]) > mem[_5736]:
                                        mem[mem[_5736] + _5736 + 356] = 0
                                    require ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]))
                                    call address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)], cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)], 160, mem[_5736], mem[_5736 + 356 len ceil32(mem[_5736])]
                                    mem[_5736 + 160] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                                    mem[64] = _5736 + ceil32(return_data.size) + 160
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                                    if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                            else:
                                mem[64] = mem[64] + ceil32(calldata.size) + 64
                                mem[_5736 + 32] = calldata.size
                                mem[_5736 + 64 len calldata.size] = call.data[0 len calldata.size]
                                mem[_5736 + calldata.size + 64] = 0
                                _5808 = mem[calldata.size + _5736 + 32]
                                mem[_5736 + ceil32(calldata.size) + 64] = 1
                                mem[_5736 + ceil32(calldata.size) + 96] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                                mem[_5736 + ceil32(calldata.size) + 128] = 1
                                mem[64] = _5736 + ceil32(calldata.size) + 192
                                mem[_5736 + ceil32(calldata.size) + 160] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                mem[0] = address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])
                                mem[32] = sha3(cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)], 0)
                                if balanceOf[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])] > !cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]:
                                    revert with 0, 17
                                balanceOf[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])] += cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                mem[_5736 + ceil32(calldata.size) + 192] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                                mem[_5736 + ceil32(calldata.size) + 224] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                emit TransferSingle(cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)], cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)], address(_5808), 0, address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]));
                                if ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])):
                                    mem[_5736 + ceil32(calldata.size) + 192] = 0xf23a6e6100000000000000000000000000000000000000000000000000000000
                                    mem[_5736 + ceil32(calldata.size) + 196] = address(_5808)
                                    mem[_5736 + ceil32(calldata.size) + 228] = 0
                                    mem[_5736 + ceil32(calldata.size) + 260] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                                    mem[_5736 + ceil32(calldata.size) + 292] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                    mem[_5736 + ceil32(calldata.size) + 324] = 160
                                    mem[_5736 + ceil32(calldata.size) + 356] = mem[_5736]
                                    t = 0
                                    while t < mem[_5736]:
                                        mem[t + _5736 + ceil32(calldata.size) + 388] = mem[t + _5736 + 32]
                                        t = t + 32
                                        continue 
                                    if ceil32(mem[_5736]) > mem[_5736]:
                                        mem[mem[_5736] + _5736 + ceil32(calldata.size) + 388] = 0
                                    require ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]))
                                    call address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                                         gas gas_remaining wei
                                        args address(_5808), 0, cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)], cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)], 160, mem[_5736], mem[_5736 + ceil32(calldata.size) + 388 len ceil32(mem[_5736])]
                                    mem[_5736 + ceil32(calldata.size) + 192] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                                    mem[64] = _5736 + ceil32(calldata.size) + ceil32(return_data.size) + 192
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                                    if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                        if s == -1:
                            revert with 0, 17
                        s = s + 1
                        continue 
                    _5300 = mem[64]
                    mem[mem[64]] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                    mem[mem[64] + 32] = 96
                    mem[mem[64] + 96] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 36)]
                    s = 0
                    t = cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68
                    u = mem[64] + 128
                    while s < cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 36)]:
                        require cd[t] == address(cd[t])
                        mem[u] = address(cd[t])
                        s = s + 1
                        t = t + 32
                        u = u + 32
                        continue 
                    mem[_5300 + 64] = u - _5300
                    mem[u] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 36)]
                    require cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 36)] <= 0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
                    mem[u + 32 len 32 * cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 36)]] = call.data[cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68 len 32 * cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 36)]]
                    mem[u + (32 * cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 36)]) + 32] = 0
                    emit 0xbc11d48c: mem[mem[64] len u + (32 * cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 36)]) + -mem[64] + 32]
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                _2716 = mem[64]
                mem[mem[64]] = 42
                mem[64] = mem[64] + 96
                mem[_2716 + 32 len 42] = call.data[calldata.size len 42]
                if 0 >= mem[_2716]:
                    revert with 0, 50
                mem[_2716 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                if 1 >= mem[_2716]:
                    revert with 0, 50
                mem[_2716 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                idx = 41
                s = address(_2666)
                while idx > 1:
                    if s % 16 >= 16:
                        revert with 0, 50
                    if idx >= mem[_2716]:
                        revert with 0, 50
                    mem[idx + _2716 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                    if not idx:
                        revert with 0, 17
                    idx = idx - 1
                    s = Mask(252, 0, s) * 0.0625
                    continue 
                if address(_2666) + 10240:
                    revert with 0, 'Strings: hex length insufficient'
                _5352 = mem[64]
                mem[mem[64]] = 66
                mem[64] = mem[64] + 128
                mem[_5352 + 32 len 66] = call.data[calldata.size len 66]
                if 0 >= mem[_5352]:
                    revert with 0, 50
                mem[_5352 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                if 1 >= mem[_5352]:
                    revert with 0, 50
                mem[_5352 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                idx = 65
                while idx > 1:
                    if idx >= mem[_5352]:
                        revert with 0, 50
                    mem[idx + _5352 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                    if not idx:
                        revert with 0, 17
                    idx = idx - 1
                    continue 
                _8056 = mem[64]
                mem[mem[64] + 32] = 'AccessControl: account '
                _8078 = mem[_2716]
                idx = 0
                while idx < _8078:
                    mem[idx + _8056 + 55] = mem[idx + _2716 + 32]
                    idx = idx + 32
                    continue 
                mem[_8056 + _8078 + 55] = 0x206973206d697373696e6720726f6c6520000000000000000000000000000000
                if ceil32(_8078) <= _8078:
                    _10293 = mem[_5352]
                    idx = 0
                    while idx < _10293:
                        mem[idx + _8056 + _8078 + 72] = mem[idx + _5352 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_10293) <= _10293:
                        _11155 = mem[64]
                        mem[mem[64]] = _10293 + _8056 + _8078 + -mem[64] + 40
                        mem[64] = _10293 + _8056 + _8078 + 72
                        mem[_10293 + _8056 + _8078 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[_10293 + _8056 + _8078 + 76] = 32
                        _11219 = mem[_11155]
                        mem[_10293 + _8056 + _8078 + 108] = mem[_11155]
                        idx = 0
                        while idx < _11219:
                            mem[idx + _10293 + _8056 + _8078 + 140] = mem[idx + _11155 + 32]
                            idx = idx + 32
                            continue 
                        if ceil32(_11219) > _11219:
                            mem[_11219 + _10293 + _8056 + _8078 + 140] = 0
                        revert with 0, 32, mem[_10293 + _8056 + _8078 + 108 len ceil32(_11219) + 32]
                    mem[_10293 + _8056 + _8078 + 72] = 0
                    _11156 = mem[64]
                    mem[mem[64]] = _10293 + _8056 + _8078 + -mem[64] + 40
                    mem[64] = _10293 + _8056 + _8078 + 72
                    mem[_10293 + _8056 + _8078 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[_10293 + _8056 + _8078 + 76] = 32
                    _11220 = mem[_11156]
                    mem[_10293 + _8056 + _8078 + 108] = mem[_11156]
                    idx = 0
                    while idx < _11220:
                        mem[idx + _10293 + _8056 + _8078 + 140] = mem[idx + _11156 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_11220) > _11220:
                        mem[_11220 + _10293 + _8056 + _8078 + 140] = 0
                    revert with 0, 32, mem[_10293 + _8056 + _8078 + 108 len ceil32(_11220) + 32]
                _10294 = mem[_5352]
                idx = 0
                while idx < _10294:
                    mem[idx + _8056 + _8078 + 72] = mem[idx + _5352 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_10294) <= _10294:
                    _11157 = mem[64]
                    mem[mem[64]] = _10294 + _8056 + _8078 + -mem[64] + 40
                    mem[64] = _10294 + _8056 + _8078 + 72
                    mem[_10294 + _8056 + _8078 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[_10294 + _8056 + _8078 + 76] = 32
                    _11221 = mem[_11157]
                    mem[_10294 + _8056 + _8078 + 108] = mem[_11157]
                    idx = 0
                    while idx < _11221:
                        mem[idx + _10294 + _8056 + _8078 + 140] = mem[idx + _11157 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_11221) > _11221:
                        mem[_11221 + _10294 + _8056 + _8078 + 140] = 0
                    revert with 0, 32, mem[_10294 + _8056 + _8078 + 108 len ceil32(_11221) + 32]
                mem[_10294 + _8056 + _8078 + 72] = 0
                _11158 = mem[64]
                mem[mem[64]] = _10294 + _8056 + _8078 + -mem[64] + 40
                mem[64] = _10294 + _8056 + _8078 + 72
                mem[_10294 + _8056 + _8078 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[_10294 + _8056 + _8078 + 76] = 32
                _11222 = mem[_11158]
                mem[_10294 + _8056 + _8078 + 108] = mem[_11158]
                idx = 0
                while idx < _11222:
                    mem[idx + _10294 + _8056 + _8078 + 140] = mem[idx + _11158 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_11222) > _11222:
                    mem[_11222 + _10294 + _8056 + _8078 + 140] = 0
                revert with 0, 32, mem[_10294 + _8056 + _8078 + 108 len ceil32(_11222) + 32]
        mem[128 len 42] = call.data[calldata.size len 42]
        idx = 41
        s = address(msg.sender)
        while idx > 1:
            if s % 16 >= 16:
                revert with 0, 50
            if idx >= 42:
                revert with 0, 50
            mem[idx + 128 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
            if not idx:
                revert with 0, 17
            idx = idx - 1
            s = Mask(252, 0, s) * 0.0625
            continue 
        if msg.sender + 10240:
            revert with 0, 'Strings: hex length insufficient'
        mem[224 len 66] = call.data[calldata.size len 66]
        idx = 65
        while idx > 1:
            if idx >= 66:
                revert with 0, 50
            mem[idx + 224 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
            if not idx:
                revert with 0, 17
            idx = idx - 1
            continue 
        revert with 0, 32, 148, 'AccessControl: account ', mem[160 len 42], 8297, mem[288 len 66], 0, 0 >> 928, 0
    mem[64] = ceil32(calldata.size) + 128
    mem[96] = calldata.size
    mem[128 len calldata.size] = call.data[0 len calldata.size]
    mem[calldata.size + 128] = 0
    mem[0] = mem[calldata.size + 108 len 20]
    mem[32] = sha3(0, 2)
    if uint8(roleAdmin[0][address(mem[calldata.size + 96])].field_0):
        idx = 0
        while idx < ('cd', 4).length:
            require cd[(cd[4] + (32 * idx) + 36)] < calldata.size + -cd[4] - 163
            mem[0] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
            mem[32] = 12
            if bool(stor12[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]]) != 1:
                require cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] < calldata.size + -cd[(cd[4] + (32 * idx) + 36)] + -cd[4] - 67
                require cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 36)] <= test266151307()
                require cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68 <= calldata.size - (32 * cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 36)])
                require cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] < calldata.size + -cd[(cd[4] + (32 * idx) + 36)] + -cd[4] - 67
                require cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 36)] <= test266151307()
                require cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68 <= calldata.size - (32 * cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 36)])
                if msg.sender != this.address:
                    mem[0] = msg.sender
                    mem[32] = sha3(0, 2)
                    if uint8(roleAdmin[0][address(msg.sender)].field_0):
                        if cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 36)] != cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 36)]:
                            revert with 0, 'number of ids must equal number of accounts'
                        s = 0
                        while s < cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 36)]:
                            if s >= cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 36)]:
                                revert with 0, 50
                            require cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)] == address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])
                            if msg.sender != this.address:
                                mem[0] = msg.sender
                                mem[32] = sha3(0, 2)
                                if not uint8(roleAdmin[0][address(msg.sender)].field_0):
                                    _5539 = mem[64]
                                    mem[mem[64]] = 42
                                    mem[64] = mem[64] + 96
                                    mem[_5539 + 32 len 42] = call.data[calldata.size len 42]
                                    if 0 >= mem[_5539]:
                                        revert with 0, 50
                                    mem[_5539 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                                    if 1 >= mem[_5539]:
                                        revert with 0, 50
                                    mem[_5539 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                                    idx = 41
                                    s = address(msg.sender)
                                    while idx > 1:
                                        if s % 16 >= 16:
                                            revert with 0, 50
                                        if idx >= mem[_5539]:
                                            revert with 0, 50
                                        mem[idx + _5539 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                                        if not idx:
                                            revert with 0, 17
                                        idx = idx - 1
                                        s = Mask(252, 0, s) * 0.0625
                                        continue 
                                    if msg.sender + 10240:
                                        revert with 0, 'Strings: hex length insufficient'
                                    _8391 = mem[64]
                                    mem[mem[64]] = 66
                                    mem[64] = mem[64] + 128
                                    mem[_8391 + 32 len 66] = call.data[calldata.size len 66]
                                    if 0 >= mem[_8391]:
                                        revert with 0, 50
                                    mem[_8391 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                                    if 1 >= mem[_8391]:
                                        revert with 0, 50
                                    mem[_8391 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                                    idx = 65
                                    while idx > 1:
                                        if idx >= mem[_8391]:
                                            revert with 0, 50
                                        mem[idx + _8391 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                                        if not idx:
                                            revert with 0, 17
                                        idx = idx - 1
                                        continue 
                                    _10295 = mem[64]
                                    mem[mem[64] + 32] = 'AccessControl: account '
                                    _10323 = mem[_5539]
                                    idx = 0
                                    while idx < _10323:
                                        mem[idx + _10295 + 55] = mem[idx + _5539 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_10295 + _10323 + 55] = 0x206973206d697373696e6720726f6c6520000000000000000000000000000000
                                    if ceil32(_10323) <= _10323:
                                        _11127 = mem[_8391]
                                        idx = 0
                                        while idx < _11127:
                                            mem[idx + _10295 + _10323 + 72] = mem[idx + _8391 + 32]
                                            idx = idx + 32
                                            continue 
                                        if ceil32(_11127) <= _11127:
                                            _11767 = mem[64]
                                            mem[mem[64]] = _11127 + _10295 + _10323 + -mem[64] + 40
                                            mem[64] = _11127 + _10295 + _10323 + 72
                                            mem[_11127 + _10295 + _10323 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_11127 + _10295 + _10323 + 76] = 32
                                            _11895 = mem[_11767]
                                            mem[_11127 + _10295 + _10323 + 108] = mem[_11767]
                                            idx = 0
                                            while idx < _11895:
                                                mem[idx + _11127 + _10295 + _10323 + 140] = mem[idx + _11767 + 32]
                                                idx = idx + 32
                                                continue 
                                            if ceil32(_11895) > _11895:
                                                mem[_11895 + _11127 + _10295 + _10323 + 140] = 0
                                            revert with 0, 32, mem[_11127 + _10295 + _10323 + 108 len ceil32(_11895) + 32]
                                        mem[_11127 + _10295 + _10323 + 72] = 0
                                        _11768 = mem[64]
                                        mem[mem[64]] = _11127 + _10295 + _10323 + -mem[64] + 40
                                        mem[64] = _11127 + _10295 + _10323 + 72
                                        mem[_11127 + _10295 + _10323 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[_11127 + _10295 + _10323 + 76] = 32
                                        _11896 = mem[_11768]
                                        mem[_11127 + _10295 + _10323 + 108] = mem[_11768]
                                        idx = 0
                                        while idx < _11896:
                                            mem[idx + _11127 + _10295 + _10323 + 140] = mem[idx + _11768 + 32]
                                            idx = idx + 32
                                            continue 
                                        if ceil32(_11896) > _11896:
                                            mem[_11896 + _11127 + _10295 + _10323 + 140] = 0
                                        revert with 0, 32, mem[_11127 + _10295 + _10323 + 108 len ceil32(_11896) + 32]
                                    _11128 = mem[_8391]
                                    idx = 0
                                    while idx < _11128:
                                        mem[idx + _10295 + _10323 + 72] = mem[idx + _8391 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_11128) <= _11128:
                                        _11769 = mem[64]
                                        mem[mem[64]] = _11128 + _10295 + _10323 + -mem[64] + 40
                                        mem[64] = _11128 + _10295 + _10323 + 72
                                        mem[_11128 + _10295 + _10323 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[_11128 + _10295 + _10323 + 76] = 32
                                        _11897 = mem[_11769]
                                        mem[_11128 + _10295 + _10323 + 108] = mem[_11769]
                                        idx = 0
                                        while idx < _11897:
                                            mem[idx + _11128 + _10295 + _10323 + 140] = mem[idx + _11769 + 32]
                                            idx = idx + 32
                                            continue 
                                        if ceil32(_11897) > _11897:
                                            mem[_11897 + _11128 + _10295 + _10323 + 140] = 0
                                        revert with 0, 32, mem[_11128 + _10295 + _10323 + 108 len ceil32(_11897) + 32]
                                    mem[_11128 + _10295 + _10323 + 72] = 0
                                    _11770 = mem[64]
                                    mem[mem[64]] = _11128 + _10295 + _10323 + -mem[64] + 40
                                    mem[64] = _11128 + _10295 + _10323 + 72
                                    mem[_11128 + _10295 + _10323 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_11128 + _10295 + _10323 + 76] = 32
                                    _11898 = mem[_11770]
                                    mem[_11128 + _10295 + _10323 + 108] = mem[_11770]
                                    idx = 0
                                    while idx < _11898:
                                        mem[idx + _11128 + _10295 + _10323 + 140] = mem[idx + _11770 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_11898) > _11898:
                                        mem[_11898 + _11128 + _10295 + _10323 + 140] = 0
                                    revert with 0, 32, mem[_11128 + _10295 + _10323 + 108 len ceil32(_11898) + 32]
                                require cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)] > 0
                                if sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] > -2:
                                    revert with 0, 17
                                if sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] + 1 > sub_fc86b662[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]]:
                                    revert with 0, 'Minting would exceed the max number of items for given type'
                                if stor13[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]]:
                                    revert with 0, 'Supplied id is already used'
                                if stor12[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]]:
                                    revert with 0, 'Given type is fungible'
                                stor13[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]] = 1
                                if sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] > -2:
                                    revert with 0, 17
                                sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]]++
                                sub_0f699e80[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                                mem[32] = 14
                                mintNumber[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]] = sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]]
                                _5737 = mem[64]
                                mem[mem[64]] = 0
                                if not address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]):
                                    revert with 0, 'ERC1155: mint to the zero address'
                                if msg.sender != this.address:
                                    mem[mem[64] + 32] = 1
                                    mem[64] = mem[64] + 96
                                    mem[_5737 + 64] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]
                                    mem[_5737 + 96] = 1
                                    mem[64] = _5737 + 160
                                    mem[_5737 + 128] = 1
                                    mem[0] = address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])
                                    mem[32] = sha3(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)], 0)
                                    if balanceOf[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])] > -2:
                                        revert with 0, 17
                                    balanceOf[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])]++
                                    mem[_5737 + 160] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]
                                    mem[_5737 + 192] = 1
                                    emit TransferSingle(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)], 1, msg.sender, 0, address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]));
                                    if ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])):
                                        mem[_5737 + 160] = 0xf23a6e6100000000000000000000000000000000000000000000000000000000
                                        mem[_5737 + 164] = msg.sender
                                        mem[_5737 + 196] = 0
                                        mem[_5737 + 228] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]
                                        mem[_5737 + 260] = 1
                                        mem[_5737 + 292] = 160
                                        mem[_5737 + 324] = mem[_5737]
                                        t = 0
                                        while t < mem[_5737]:
                                            mem[t + _5737 + 356] = mem[t + _5737 + 32]
                                            t = t + 32
                                            continue 
                                        if ceil32(mem[_5737]) > mem[_5737]:
                                            mem[mem[_5737] + _5737 + 356] = 0
                                        require ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]))
                                        call address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)], 1, 160, mem[_5737], mem[_5737 + 356 len ceil32(mem[_5737])]
                                        mem[_5737 + 160] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                                        mem[64] = _5737 + ceil32(return_data.size) + 160
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                                        if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                                else:
                                    mem[64] = mem[64] + ceil32(calldata.size) + 64
                                    mem[_5737 + 32] = calldata.size
                                    mem[_5737 + 64 len calldata.size] = call.data[0 len calldata.size]
                                    mem[_5737 + calldata.size + 64] = 0
                                    _5810 = mem[calldata.size + _5737 + 32]
                                    mem[_5737 + ceil32(calldata.size) + 64] = 1
                                    mem[_5737 + ceil32(calldata.size) + 96] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]
                                    mem[_5737 + ceil32(calldata.size) + 128] = 1
                                    mem[64] = _5737 + ceil32(calldata.size) + 192
                                    mem[_5737 + ceil32(calldata.size) + 160] = 1
                                    mem[0] = address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])
                                    mem[32] = sha3(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)], 0)
                                    if balanceOf[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])] > -2:
                                        revert with 0, 17
                                    balanceOf[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])]++
                                    mem[_5737 + ceil32(calldata.size) + 192] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]
                                    mem[_5737 + ceil32(calldata.size) + 224] = 1
                                    emit TransferSingle(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)], 1, address(_5810), 0, address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]));
                                    if ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])):
                                        mem[_5737 + ceil32(calldata.size) + 192] = 0xf23a6e6100000000000000000000000000000000000000000000000000000000
                                        mem[_5737 + ceil32(calldata.size) + 196] = address(_5810)
                                        mem[_5737 + ceil32(calldata.size) + 228] = 0
                                        mem[_5737 + ceil32(calldata.size) + 260] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]
                                        mem[_5737 + ceil32(calldata.size) + 292] = 1
                                        mem[_5737 + ceil32(calldata.size) + 324] = 160
                                        mem[_5737 + ceil32(calldata.size) + 356] = mem[_5737]
                                        t = 0
                                        while t < mem[_5737]:
                                            mem[t + _5737 + ceil32(calldata.size) + 388] = mem[t + _5737 + 32]
                                            t = t + 32
                                            continue 
                                        if ceil32(mem[_5737]) > mem[_5737]:
                                            mem[mem[_5737] + _5737 + ceil32(calldata.size) + 388] = 0
                                        require ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]))
                                        call address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                                             gas gas_remaining wei
                                            args address(_5810), 0, cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)], 1, 160, mem[_5737], mem[_5737 + ceil32(calldata.size) + 388 len ceil32(mem[_5737])]
                                        mem[_5737 + ceil32(calldata.size) + 192] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                                        mem[64] = _5737 + ceil32(calldata.size) + ceil32(return_data.size) + 192
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                                        if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                            else:
                                _5373 = mem[64]
                                mem[64] = mem[64] + ceil32(calldata.size) + 32
                                mem[_5373] = calldata.size
                                mem[_5373 + 32 len calldata.size] = call.data[0 len calldata.size]
                                mem[_5373 + calldata.size + 32] = 0
                                _5374 = mem[calldata.size + _5373]
                                mem[0] = mem[calldata.size + _5373 + 12 len 20]
                                mem[32] = sha3(0, 2)
                                if not uint8(roleAdmin[0][address(_5374)].field_0):
                                    _5542 = mem[64]
                                    mem[mem[64]] = 42
                                    mem[64] = mem[64] + 96
                                    mem[_5542 + 32 len 42] = call.data[calldata.size len 42]
                                    if 0 >= mem[_5542]:
                                        revert with 0, 50
                                    mem[_5542 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                                    if 1 >= mem[_5542]:
                                        revert with 0, 50
                                    mem[_5542 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                                    idx = 41
                                    s = address(_5374)
                                    while idx > 1:
                                        if s % 16 >= 16:
                                            revert with 0, 50
                                        if idx >= mem[_5542]:
                                            revert with 0, 50
                                        mem[idx + _5542 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                                        if not idx:
                                            revert with 0, 17
                                        idx = idx - 1
                                        s = Mask(252, 0, s) * 0.0625
                                        continue 
                                    if address(_5374) + 10240:
                                        revert with 0, 'Strings: hex length insufficient'
                                    _8392 = mem[64]
                                    mem[mem[64]] = 66
                                    mem[64] = mem[64] + 128
                                    mem[_8392 + 32 len 66] = call.data[calldata.size len 66]
                                    if 0 >= mem[_8392]:
                                        revert with 0, 50
                                    mem[_8392 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                                    if 1 >= mem[_8392]:
                                        revert with 0, 50
                                    mem[_8392 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                                    idx = 65
                                    while idx > 1:
                                        if idx >= mem[_8392]:
                                            revert with 0, 50
                                        mem[idx + _8392 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                                        if not idx:
                                            revert with 0, 17
                                        idx = idx - 1
                                        continue 
                                    _10296 = mem[64]
                                    mem[mem[64] + 32] = 'AccessControl: account '
                                    _10324 = mem[_5542]
                                    idx = 0
                                    while idx < _10324:
                                        mem[idx + _10296 + 55] = mem[idx + _5542 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_10296 + _10324 + 55] = 0x206973206d697373696e6720726f6c6520000000000000000000000000000000
                                    if ceil32(_10324) <= _10324:
                                        _11129 = mem[_8392]
                                        idx = 0
                                        while idx < _11129:
                                            mem[idx + _10296 + _10324 + 72] = mem[idx + _8392 + 32]
                                            idx = idx + 32
                                            continue 
                                        if ceil32(_11129) <= _11129:
                                            _11771 = mem[64]
                                            mem[mem[64]] = _11129 + _10296 + _10324 + -mem[64] + 40
                                            mem[64] = _11129 + _10296 + _10324 + 72
                                            mem[_11129 + _10296 + _10324 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_11129 + _10296 + _10324 + 76] = 32
                                            _11899 = mem[_11771]
                                            mem[_11129 + _10296 + _10324 + 108] = mem[_11771]
                                            idx = 0
                                            while idx < _11899:
                                                mem[idx + _11129 + _10296 + _10324 + 140] = mem[idx + _11771 + 32]
                                                idx = idx + 32
                                                continue 
                                            if ceil32(_11899) > _11899:
                                                mem[_11899 + _11129 + _10296 + _10324 + 140] = 0
                                            revert with 0, 32, mem[_11129 + _10296 + _10324 + 108 len ceil32(_11899) + 32]
                                        mem[_11129 + _10296 + _10324 + 72] = 0
                                        _11772 = mem[64]
                                        mem[mem[64]] = _11129 + _10296 + _10324 + -mem[64] + 40
                                        mem[64] = _11129 + _10296 + _10324 + 72
                                        mem[_11129 + _10296 + _10324 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[_11129 + _10296 + _10324 + 76] = 32
                                        _11900 = mem[_11772]
                                        mem[_11129 + _10296 + _10324 + 108] = mem[_11772]
                                        idx = 0
                                        while idx < _11900:
                                            mem[idx + _11129 + _10296 + _10324 + 140] = mem[idx + _11772 + 32]
                                            idx = idx + 32
                                            continue 
                                        if ceil32(_11900) > _11900:
                                            mem[_11900 + _11129 + _10296 + _10324 + 140] = 0
                                        revert with 0, 32, mem[_11129 + _10296 + _10324 + 108 len ceil32(_11900) + 32]
                                    _11130 = mem[_8392]
                                    idx = 0
                                    while idx < _11130:
                                        mem[idx + _10296 + _10324 + 72] = mem[idx + _8392 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_11130) <= _11130:
                                        _11773 = mem[64]
                                        mem[mem[64]] = _11130 + _10296 + _10324 + -mem[64] + 40
                                        mem[64] = _11130 + _10296 + _10324 + 72
                                        mem[_11130 + _10296 + _10324 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[_11130 + _10296 + _10324 + 76] = 32
                                        _11901 = mem[_11773]
                                        mem[_11130 + _10296 + _10324 + 108] = mem[_11773]
                                        idx = 0
                                        while idx < _11901:
                                            mem[idx + _11130 + _10296 + _10324 + 140] = mem[idx + _11773 + 32]
                                            idx = idx + 32
                                            continue 
                                        if ceil32(_11901) > _11901:
                                            mem[_11901 + _11130 + _10296 + _10324 + 140] = 0
                                        revert with 0, 32, mem[_11130 + _10296 + _10324 + 108 len ceil32(_11901) + 32]
                                    mem[_11130 + _10296 + _10324 + 72] = 0
                                    _11774 = mem[64]
                                    mem[mem[64]] = _11130 + _10296 + _10324 + -mem[64] + 40
                                    mem[64] = _11130 + _10296 + _10324 + 72
                                    mem[_11130 + _10296 + _10324 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_11130 + _10296 + _10324 + 76] = 32
                                    _11902 = mem[_11774]
                                    mem[_11130 + _10296 + _10324 + 108] = mem[_11774]
                                    idx = 0
                                    while idx < _11902:
                                        mem[idx + _11130 + _10296 + _10324 + 140] = mem[idx + _11774 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_11902) > _11902:
                                        mem[_11902 + _11130 + _10296 + _10324 + 140] = 0
                                    revert with 0, 32, mem[_11130 + _10296 + _10324 + 108 len ceil32(_11902) + 32]
                                require cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)] > 0
                                if sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] > -2:
                                    revert with 0, 17
                                if sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] + 1 > sub_fc86b662[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]]:
                                    revert with 0, 'Minting would exceed the max number of items for given type'
                                if stor13[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]]:
                                    revert with 0, 'Supplied id is already used'
                                if stor12[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]]:
                                    revert with 0, 'Given type is fungible'
                                stor13[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]] = 1
                                if sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] > -2:
                                    revert with 0, 17
                                sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]]++
                                sub_0f699e80[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                                mem[32] = 14
                                mintNumber[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]] = sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]]
                                _5738 = mem[64]
                                mem[mem[64]] = 0
                                if not address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]):
                                    revert with 0, 'ERC1155: mint to the zero address'
                                if msg.sender != this.address:
                                    mem[mem[64] + 32] = 1
                                    mem[64] = mem[64] + 96
                                    mem[_5738 + 64] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]
                                    mem[_5738 + 96] = 1
                                    mem[64] = _5738 + 160
                                    mem[_5738 + 128] = 1
                                    mem[0] = address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])
                                    mem[32] = sha3(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)], 0)
                                    if balanceOf[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])] > -2:
                                        revert with 0, 17
                                    balanceOf[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])]++
                                    mem[_5738 + 160] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]
                                    mem[_5738 + 192] = 1
                                    emit TransferSingle(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)], 1, msg.sender, 0, address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]));
                                    if ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])):
                                        mem[_5738 + 160] = 0xf23a6e6100000000000000000000000000000000000000000000000000000000
                                        mem[_5738 + 164] = msg.sender
                                        mem[_5738 + 196] = 0
                                        mem[_5738 + 228] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]
                                        mem[_5738 + 260] = 1
                                        mem[_5738 + 292] = 160
                                        mem[_5738 + 324] = mem[_5738]
                                        t = 0
                                        while t < mem[_5738]:
                                            mem[t + _5738 + 356] = mem[t + _5738 + 32]
                                            t = t + 32
                                            continue 
                                        if ceil32(mem[_5738]) > mem[_5738]:
                                            mem[mem[_5738] + _5738 + 356] = 0
                                        require ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]))
                                        call address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)], 1, 160, mem[_5738], mem[_5738 + 356 len ceil32(mem[_5738])]
                                        mem[_5738 + 160] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                                        mem[64] = _5738 + ceil32(return_data.size) + 160
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                                        if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                                else:
                                    mem[64] = mem[64] + ceil32(calldata.size) + 64
                                    mem[_5738 + 32] = calldata.size
                                    mem[_5738 + 64 len calldata.size] = call.data[0 len calldata.size]
                                    mem[_5738 + calldata.size + 64] = 0
                                    _5812 = mem[calldata.size + _5738 + 32]
                                    mem[_5738 + ceil32(calldata.size) + 64] = 1
                                    mem[_5738 + ceil32(calldata.size) + 96] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]
                                    mem[_5738 + ceil32(calldata.size) + 128] = 1
                                    mem[64] = _5738 + ceil32(calldata.size) + 192
                                    mem[_5738 + ceil32(calldata.size) + 160] = 1
                                    mem[0] = address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])
                                    mem[32] = sha3(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)], 0)
                                    if balanceOf[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])] > -2:
                                        revert with 0, 17
                                    balanceOf[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])]++
                                    mem[_5738 + ceil32(calldata.size) + 192] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]
                                    mem[_5738 + ceil32(calldata.size) + 224] = 1
                                    emit TransferSingle(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)], 1, address(_5812), 0, address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]));
                                    if ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])):
                                        mem[_5738 + ceil32(calldata.size) + 192] = 0xf23a6e6100000000000000000000000000000000000000000000000000000000
                                        mem[_5738 + ceil32(calldata.size) + 196] = address(_5812)
                                        mem[_5738 + ceil32(calldata.size) + 228] = 0
                                        mem[_5738 + ceil32(calldata.size) + 260] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]
                                        mem[_5738 + ceil32(calldata.size) + 292] = 1
                                        mem[_5738 + ceil32(calldata.size) + 324] = 160
                                        mem[_5738 + ceil32(calldata.size) + 356] = mem[_5738]
                                        t = 0
                                        while t < mem[_5738]:
                                            mem[t + _5738 + ceil32(calldata.size) + 388] = mem[t + _5738 + 32]
                                            t = t + 32
                                            continue 
                                        if ceil32(mem[_5738]) > mem[_5738]:
                                            mem[mem[_5738] + _5738 + ceil32(calldata.size) + 388] = 0
                                        require ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]))
                                        call address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                                             gas gas_remaining wei
                                            args address(_5812), 0, cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)], 1, 160, mem[_5738], mem[_5738 + ceil32(calldata.size) + 388 len ceil32(mem[_5738])]
                                        mem[_5738 + ceil32(calldata.size) + 192] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                                        mem[64] = _5738 + ceil32(calldata.size) + ceil32(return_data.size) + 192
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                                        if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            continue 
                        _5301 = mem[64]
                        mem[mem[64]] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                        mem[mem[64] + 32] = 96
                        mem[mem[64] + 96] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 36)]
                        require cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 36)] <= 0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
                        mem[mem[64] + 128 len 32 * cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 36)]] = call.data[cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68 len 32 * cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 36)]]
                        mem[mem[64] + 64] = (32 * cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 36)]) + 128
                        mem[_5301 + (32 * cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 36)]) + 128] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 36)]
                        s = 0
                        t = cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68
                        u = _5301 + (32 * cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 36)]) + 160
                        while s < cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 36)]:
                            require cd[t] == address(cd[t])
                            mem[u] = address(cd[t])
                            s = s + 1
                            t = t + 32
                            u = u + 32
                            continue 
                        emit 0x16a6af95: mem[mem[64] len u - mem[64]]
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    _2717 = mem[64]
                    mem[mem[64]] = 42
                    mem[64] = mem[64] + 96
                    mem[_2717 + 32 len 42] = call.data[calldata.size len 42]
                    if 0 >= mem[_2717]:
                        revert with 0, 50
                    mem[_2717 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                    if 1 >= mem[_2717]:
                        revert with 0, 50
                    mem[_2717 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                    idx = 41
                    s = address(msg.sender)
                    while idx > 1:
                        if s % 16 >= 16:
                            revert with 0, 50
                        if idx >= mem[_2717]:
                            revert with 0, 50
                        mem[idx + _2717 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                        if not idx:
                            revert with 0, 17
                        idx = idx - 1
                        s = Mask(252, 0, s) * 0.0625
                        continue 
                    if msg.sender + 10240:
                        revert with 0, 'Strings: hex length insufficient'
                    _5353 = mem[64]
                    mem[mem[64]] = 66
                    mem[64] = mem[64] + 128
                    mem[_5353 + 32 len 66] = call.data[calldata.size len 66]
                    if 0 >= mem[_5353]:
                        revert with 0, 50
                    mem[_5353 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                    if 1 >= mem[_5353]:
                        revert with 0, 50
                    mem[_5353 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                    idx = 65
                    while idx > 1:
                        if idx >= mem[_5353]:
                            revert with 0, 50
                        mem[idx + _5353 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                        if not idx:
                            revert with 0, 17
                        idx = idx - 1
                        continue 
                    _8062 = mem[64]
                    mem[mem[64] + 32] = 'AccessControl: account '
                    _8079 = mem[_2717]
                    idx = 0
                    while idx < _8079:
                        mem[idx + _8062 + 55] = mem[idx + _2717 + 32]
                        idx = idx + 32
                        continue 
                    mem[_8062 + _8079 + 55] = 0x206973206d697373696e6720726f6c6520000000000000000000000000000000
                    if ceil32(_8079) <= _8079:
                        _10297 = mem[_5353]
                        idx = 0
                        while idx < _10297:
                            mem[idx + _8062 + _8079 + 72] = mem[idx + _5353 + 32]
                            idx = idx + 32
                            continue 
                        if ceil32(_10297) <= _10297:
                            _11159 = mem[64]
                            mem[mem[64]] = _10297 + _8062 + _8079 + -mem[64] + 40
                            mem[64] = _10297 + _8062 + _8079 + 72
                            mem[_10297 + _8062 + _8079 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_10297 + _8062 + _8079 + 76] = 32
                            _11227 = mem[_11159]
                            mem[_10297 + _8062 + _8079 + 108] = mem[_11159]
                            idx = 0
                            while idx < _11227:
                                mem[idx + _10297 + _8062 + _8079 + 140] = mem[idx + _11159 + 32]
                                idx = idx + 32
                                continue 
                            if ceil32(_11227) > _11227:
                                mem[_11227 + _10297 + _8062 + _8079 + 140] = 0
                            revert with 0, 32, mem[_10297 + _8062 + _8079 + 108 len ceil32(_11227) + 32]
                        mem[_10297 + _8062 + _8079 + 72] = 0
                        _11160 = mem[64]
                        mem[mem[64]] = _10297 + _8062 + _8079 + -mem[64] + 40
                        mem[64] = _10297 + _8062 + _8079 + 72
                        mem[_10297 + _8062 + _8079 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[_10297 + _8062 + _8079 + 76] = 32
                        _11228 = mem[_11160]
                        mem[_10297 + _8062 + _8079 + 108] = mem[_11160]
                        idx = 0
                        while idx < _11228:
                            mem[idx + _10297 + _8062 + _8079 + 140] = mem[idx + _11160 + 32]
                            idx = idx + 32
                            continue 
                        if ceil32(_11228) > _11228:
                            mem[_11228 + _10297 + _8062 + _8079 + 140] = 0
                        revert with 0, 32, mem[_10297 + _8062 + _8079 + 108 len ceil32(_11228) + 32]
                    _10298 = mem[_5353]
                    idx = 0
                    while idx < _10298:
                        mem[idx + _8062 + _8079 + 72] = mem[idx + _5353 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_10298) <= _10298:
                        _11161 = mem[64]
                        mem[mem[64]] = _10298 + _8062 + _8079 + -mem[64] + 40
                        mem[64] = _10298 + _8062 + _8079 + 72
                        mem[_10298 + _8062 + _8079 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[_10298 + _8062 + _8079 + 76] = 32
                        _11229 = mem[_11161]
                        mem[_10298 + _8062 + _8079 + 108] = mem[_11161]
                        idx = 0
                        while idx < _11229:
                            mem[idx + _10298 + _8062 + _8079 + 140] = mem[idx + _11161 + 32]
                            idx = idx + 32
                            continue 
                        if ceil32(_11229) > _11229:
                            mem[_11229 + _10298 + _8062 + _8079 + 140] = 0
                        revert with 0, 32, mem[_10298 + _8062 + _8079 + 108 len ceil32(_11229) + 32]
                    mem[_10298 + _8062 + _8079 + 72] = 0
                    _11162 = mem[64]
                    mem[mem[64]] = _10298 + _8062 + _8079 + -mem[64] + 40
                    mem[64] = _10298 + _8062 + _8079 + 72
                    mem[_10298 + _8062 + _8079 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[_10298 + _8062 + _8079 + 76] = 32
                    _11230 = mem[_11162]
                    mem[_10298 + _8062 + _8079 + 108] = mem[_11162]
                    idx = 0
                    while idx < _11230:
                        mem[idx + _10298 + _8062 + _8079 + 140] = mem[idx + _11162 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_11230) > _11230:
                        mem[_11230 + _10298 + _8062 + _8079 + 140] = 0
                    revert with 0, 32, mem[_10298 + _8062 + _8079 + 108 len ceil32(_11230) + 32]
                _2667 = mem[64]
                mem[64] = mem[64] + ceil32(calldata.size) + 32
                mem[_2667] = calldata.size
                mem[_2667 + 32 len calldata.size] = call.data[0 len calldata.size]
                mem[_2667 + calldata.size + 32] = 0
                _2668 = mem[calldata.size + _2667]
                mem[0] = mem[calldata.size + _2667 + 12 len 20]
                mem[32] = sha3(0, 2)
                if uint8(roleAdmin[0][address(_2668)].field_0):
                    if cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 36)] != cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 36)]:
                        revert with 0, 'number of ids must equal number of accounts'
                    s = 0
                    while s < cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 36)]:
                        if s >= cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 36)]:
                            revert with 0, 50
                        require cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)] == address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])
                        if msg.sender != this.address:
                            mem[0] = msg.sender
                            mem[32] = sha3(0, 2)
                            if not uint8(roleAdmin[0][address(msg.sender)].field_0):
                                _5545 = mem[64]
                                mem[mem[64]] = 42
                                mem[64] = mem[64] + 96
                                mem[_5545 + 32 len 42] = call.data[calldata.size len 42]
                                if 0 >= mem[_5545]:
                                    revert with 0, 50
                                mem[_5545 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                                if 1 >= mem[_5545]:
                                    revert with 0, 50
                                mem[_5545 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                                idx = 41
                                s = address(msg.sender)
                                while idx > 1:
                                    if s % 16 >= 16:
                                        revert with 0, 50
                                    if idx >= mem[_5545]:
                                        revert with 0, 50
                                    mem[idx + _5545 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                                    if not idx:
                                        revert with 0, 17
                                    idx = idx - 1
                                    s = Mask(252, 0, s) * 0.0625
                                    continue 
                                if msg.sender + 10240:
                                    revert with 0, 'Strings: hex length insufficient'
                                _8393 = mem[64]
                                mem[mem[64]] = 66
                                mem[64] = mem[64] + 128
                                mem[_8393 + 32 len 66] = call.data[calldata.size len 66]
                                if 0 >= mem[_8393]:
                                    revert with 0, 50
                                mem[_8393 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                                if 1 >= mem[_8393]:
                                    revert with 0, 50
                                mem[_8393 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                                idx = 65
                                while idx > 1:
                                    if idx >= mem[_8393]:
                                        revert with 0, 50
                                    mem[idx + _8393 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                                    if not idx:
                                        revert with 0, 17
                                    idx = idx - 1
                                    continue 
                                _10299 = mem[64]
                                mem[mem[64] + 32] = 'AccessControl: account '
                                _10325 = mem[_5545]
                                idx = 0
                                while idx < _10325:
                                    mem[idx + _10299 + 55] = mem[idx + _5545 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10299 + _10325 + 55] = 0x206973206d697373696e6720726f6c6520000000000000000000000000000000
                                if ceil32(_10325) <= _10325:
                                    _11131 = mem[_8393]
                                    idx = 0
                                    while idx < _11131:
                                        mem[idx + _10299 + _10325 + 72] = mem[idx + _8393 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_11131) <= _11131:
                                        _11775 = mem[64]
                                        mem[mem[64]] = _11131 + _10299 + _10325 + -mem[64] + 40
                                        mem[64] = _11131 + _10299 + _10325 + 72
                                        mem[_11131 + _10299 + _10325 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[_11131 + _10299 + _10325 + 76] = 32
                                        _11903 = mem[_11775]
                                        mem[_11131 + _10299 + _10325 + 108] = mem[_11775]
                                        idx = 0
                                        while idx < _11903:
                                            mem[idx + _11131 + _10299 + _10325 + 140] = mem[idx + _11775 + 32]
                                            idx = idx + 32
                                            continue 
                                        if ceil32(_11903) > _11903:
                                            mem[_11903 + _11131 + _10299 + _10325 + 140] = 0
                                        revert with 0, 32, mem[_11131 + _10299 + _10325 + 108 len ceil32(_11903) + 32]
                                    mem[_11131 + _10299 + _10325 + 72] = 0
                                    _11776 = mem[64]
                                    mem[mem[64]] = _11131 + _10299 + _10325 + -mem[64] + 40
                                    mem[64] = _11131 + _10299 + _10325 + 72
                                    mem[_11131 + _10299 + _10325 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_11131 + _10299 + _10325 + 76] = 32
                                    _11904 = mem[_11776]
                                    mem[_11131 + _10299 + _10325 + 108] = mem[_11776]
                                    idx = 0
                                    while idx < _11904:
                                        mem[idx + _11131 + _10299 + _10325 + 140] = mem[idx + _11776 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_11904) > _11904:
                                        mem[_11904 + _11131 + _10299 + _10325 + 140] = 0
                                    revert with 0, 32, mem[_11131 + _10299 + _10325 + 108 len ceil32(_11904) + 32]
                                _11132 = mem[_8393]
                                idx = 0
                                while idx < _11132:
                                    mem[idx + _10299 + _10325 + 72] = mem[idx + _8393 + 32]
                                    idx = idx + 32
                                    continue 
                                if ceil32(_11132) <= _11132:
                                    _11777 = mem[64]
                                    mem[mem[64]] = _11132 + _10299 + _10325 + -mem[64] + 40
                                    mem[64] = _11132 + _10299 + _10325 + 72
                                    mem[_11132 + _10299 + _10325 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_11132 + _10299 + _10325 + 76] = 32
                                    _11905 = mem[_11777]
                                    mem[_11132 + _10299 + _10325 + 108] = mem[_11777]
                                    idx = 0
                                    while idx < _11905:
                                        mem[idx + _11132 + _10299 + _10325 + 140] = mem[idx + _11777 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_11905) > _11905:
                                        mem[_11905 + _11132 + _10299 + _10325 + 140] = 0
                                    revert with 0, 32, mem[_11132 + _10299 + _10325 + 108 len ceil32(_11905) + 32]
                                mem[_11132 + _10299 + _10325 + 72] = 0
                                _11778 = mem[64]
                                mem[mem[64]] = _11132 + _10299 + _10325 + -mem[64] + 40
                                mem[64] = _11132 + _10299 + _10325 + 72
                                mem[_11132 + _10299 + _10325 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_11132 + _10299 + _10325 + 76] = 32
                                _11906 = mem[_11778]
                                mem[_11132 + _10299 + _10325 + 108] = mem[_11778]
                                idx = 0
                                while idx < _11906:
                                    mem[idx + _11132 + _10299 + _10325 + 140] = mem[idx + _11778 + 32]
                                    idx = idx + 32
                                    continue 
                                if ceil32(_11906) > _11906:
                                    mem[_11906 + _11132 + _10299 + _10325 + 140] = 0
                                revert with 0, 32, mem[_11132 + _10299 + _10325 + 108 len ceil32(_11906) + 32]
                            require cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)] > 0
                            if sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] > -2:
                                revert with 0, 17
                            if sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] + 1 > sub_fc86b662[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]]:
                                revert with 0, 'Minting would exceed the max number of items for given type'
                            if stor13[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]]:
                                revert with 0, 'Supplied id is already used'
                            if stor12[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]]:
                                revert with 0, 'Given type is fungible'
                            stor13[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]] = 1
                            if sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] > -2:
                                revert with 0, 17
                            sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]]++
                            sub_0f699e80[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                            mem[32] = 14
                            mintNumber[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]] = sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]]
                            _5739 = mem[64]
                            mem[mem[64]] = 0
                            if not address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]):
                                revert with 0, 'ERC1155: mint to the zero address'
                            if msg.sender != this.address:
                                mem[mem[64] + 32] = 1
                                mem[64] = mem[64] + 96
                                mem[_5739 + 64] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]
                                mem[_5739 + 96] = 1
                                mem[64] = _5739 + 160
                                mem[_5739 + 128] = 1
                                mem[0] = address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])
                                mem[32] = sha3(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)], 0)
                                if balanceOf[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])] > -2:
                                    revert with 0, 17
                                balanceOf[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])]++
                                mem[_5739 + 160] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]
                                mem[_5739 + 192] = 1
                                emit TransferSingle(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)], 1, msg.sender, 0, address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]));
                                if ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])):
                                    mem[_5739 + 160] = 0xf23a6e6100000000000000000000000000000000000000000000000000000000
                                    mem[_5739 + 164] = msg.sender
                                    mem[_5739 + 196] = 0
                                    mem[_5739 + 228] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]
                                    mem[_5739 + 260] = 1
                                    mem[_5739 + 292] = 160
                                    mem[_5739 + 324] = mem[_5739]
                                    t = 0
                                    while t < mem[_5739]:
                                        mem[t + _5739 + 356] = mem[t + _5739 + 32]
                                        t = t + 32
                                        continue 
                                    if ceil32(mem[_5739]) > mem[_5739]:
                                        mem[mem[_5739] + _5739 + 356] = 0
                                    require ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]))
                                    call address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)], 1, 160, mem[_5739], mem[_5739 + 356 len ceil32(mem[_5739])]
                                    mem[_5739 + 160] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                                    mem[64] = _5739 + ceil32(return_data.size) + 160
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                                    if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                            else:
                                mem[64] = mem[64] + ceil32(calldata.size) + 64
                                mem[_5739 + 32] = calldata.size
                                mem[_5739 + 64 len calldata.size] = call.data[0 len calldata.size]
                                mem[_5739 + calldata.size + 64] = 0
                                _5814 = mem[calldata.size + _5739 + 32]
                                mem[_5739 + ceil32(calldata.size) + 64] = 1
                                mem[_5739 + ceil32(calldata.size) + 96] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]
                                mem[_5739 + ceil32(calldata.size) + 128] = 1
                                mem[64] = _5739 + ceil32(calldata.size) + 192
                                mem[_5739 + ceil32(calldata.size) + 160] = 1
                                mem[0] = address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])
                                mem[32] = sha3(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)], 0)
                                if balanceOf[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])] > -2:
                                    revert with 0, 17
                                balanceOf[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])]++
                                mem[_5739 + ceil32(calldata.size) + 192] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]
                                mem[_5739 + ceil32(calldata.size) + 224] = 1
                                emit TransferSingle(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)], 1, address(_5814), 0, address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]));
                                if ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])):
                                    mem[_5739 + ceil32(calldata.size) + 192] = 0xf23a6e6100000000000000000000000000000000000000000000000000000000
                                    mem[_5739 + ceil32(calldata.size) + 196] = address(_5814)
                                    mem[_5739 + ceil32(calldata.size) + 228] = 0
                                    mem[_5739 + ceil32(calldata.size) + 260] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]
                                    mem[_5739 + ceil32(calldata.size) + 292] = 1
                                    mem[_5739 + ceil32(calldata.size) + 324] = 160
                                    mem[_5739 + ceil32(calldata.size) + 356] = mem[_5739]
                                    t = 0
                                    while t < mem[_5739]:
                                        mem[t + _5739 + ceil32(calldata.size) + 388] = mem[t + _5739 + 32]
                                        t = t + 32
                                        continue 
                                    if ceil32(mem[_5739]) > mem[_5739]:
                                        mem[mem[_5739] + _5739 + ceil32(calldata.size) + 388] = 0
                                    require ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]))
                                    call address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                                         gas gas_remaining wei
                                        args address(_5814), 0, cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)], 1, 160, mem[_5739], mem[_5739 + ceil32(calldata.size) + 388 len ceil32(mem[_5739])]
                                    mem[_5739 + ceil32(calldata.size) + 192] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                                    mem[64] = _5739 + ceil32(calldata.size) + ceil32(return_data.size) + 192
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                                    if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                        else:
                            _5376 = mem[64]
                            mem[64] = mem[64] + ceil32(calldata.size) + 32
                            mem[_5376] = calldata.size
                            mem[_5376 + 32 len calldata.size] = call.data[0 len calldata.size]
                            mem[_5376 + calldata.size + 32] = 0
                            _5377 = mem[calldata.size + _5376]
                            mem[0] = mem[calldata.size + _5376 + 12 len 20]
                            mem[32] = sha3(0, 2)
                            if not uint8(roleAdmin[0][address(_5377)].field_0):
                                _5548 = mem[64]
                                mem[mem[64]] = 42
                                mem[64] = mem[64] + 96
                                mem[_5548 + 32 len 42] = call.data[calldata.size len 42]
                                if 0 >= mem[_5548]:
                                    revert with 0, 50
                                mem[_5548 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                                if 1 >= mem[_5548]:
                                    revert with 0, 50
                                mem[_5548 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                                idx = 41
                                s = address(_5377)
                                while idx > 1:
                                    if s % 16 >= 16:
                                        revert with 0, 50
                                    if idx >= mem[_5548]:
                                        revert with 0, 50
                                    mem[idx + _5548 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                                    if not idx:
                                        revert with 0, 17
                                    idx = idx - 1
                                    s = Mask(252, 0, s) * 0.0625
                                    continue 
                                if address(_5377) + 10240:
                                    revert with 0, 'Strings: hex length insufficient'
                                _8394 = mem[64]
                                mem[mem[64]] = 66
                                mem[64] = mem[64] + 128
                                mem[_8394 + 32 len 66] = call.data[calldata.size len 66]
                                if 0 >= mem[_8394]:
                                    revert with 0, 50
                                mem[_8394 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                                if 1 >= mem[_8394]:
                                    revert with 0, 50
                                mem[_8394 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                                idx = 65
                                while idx > 1:
                                    if idx >= mem[_8394]:
                                        revert with 0, 50
                                    mem[idx + _8394 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                                    if not idx:
                                        revert with 0, 17
                                    idx = idx - 1
                                    continue 
                                _10300 = mem[64]
                                mem[mem[64] + 32] = 'AccessControl: account '
                                _10326 = mem[_5548]
                                idx = 0
                                while idx < _10326:
                                    mem[idx + _10300 + 55] = mem[idx + _5548 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10300 + _10326 + 55] = 0x206973206d697373696e6720726f6c6520000000000000000000000000000000
                                if ceil32(_10326) <= _10326:
                                    _11133 = mem[_8394]
                                    idx = 0
                                    while idx < _11133:
                                        mem[idx + _10300 + _10326 + 72] = mem[idx + _8394 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_11133) <= _11133:
                                        _11779 = mem[64]
                                        mem[mem[64]] = _11133 + _10300 + _10326 + -mem[64] + 40
                                        mem[64] = _11133 + _10300 + _10326 + 72
                                        mem[_11133 + _10300 + _10326 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[_11133 + _10300 + _10326 + 76] = 32
                                        _11907 = mem[_11779]
                                        mem[_11133 + _10300 + _10326 + 108] = mem[_11779]
                                        idx = 0
                                        while idx < _11907:
                                            mem[idx + _11133 + _10300 + _10326 + 140] = mem[idx + _11779 + 32]
                                            idx = idx + 32
                                            continue 
                                        if ceil32(_11907) > _11907:
                                            mem[_11907 + _11133 + _10300 + _10326 + 140] = 0
                                        revert with 0, 32, mem[_11133 + _10300 + _10326 + 108 len ceil32(_11907) + 32]
                                    mem[_11133 + _10300 + _10326 + 72] = 0
                                    _11780 = mem[64]
                                    mem[mem[64]] = _11133 + _10300 + _10326 + -mem[64] + 40
                                    mem[64] = _11133 + _10300 + _10326 + 72
                                    mem[_11133 + _10300 + _10326 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_11133 + _10300 + _10326 + 76] = 32
                                    _11908 = mem[_11780]
                                    mem[_11133 + _10300 + _10326 + 108] = mem[_11780]
                                    idx = 0
                                    while idx < _11908:
                                        mem[idx + _11133 + _10300 + _10326 + 140] = mem[idx + _11780 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_11908) > _11908:
                                        mem[_11908 + _11133 + _10300 + _10326 + 140] = 0
                                    revert with 0, 32, mem[_11133 + _10300 + _10326 + 108 len ceil32(_11908) + 32]
                                _11134 = mem[_8394]
                                idx = 0
                                while idx < _11134:
                                    mem[idx + _10300 + _10326 + 72] = mem[idx + _8394 + 32]
                                    idx = idx + 32
                                    continue 
                                if ceil32(_11134) <= _11134:
                                    _11781 = mem[64]
                                    mem[mem[64]] = _11134 + _10300 + _10326 + -mem[64] + 40
                                    mem[64] = _11134 + _10300 + _10326 + 72
                                    mem[_11134 + _10300 + _10326 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_11134 + _10300 + _10326 + 76] = 32
                                    _11909 = mem[_11781]
                                    mem[_11134 + _10300 + _10326 + 108] = mem[_11781]
                                    idx = 0
                                    while idx < _11909:
                                        mem[idx + _11134 + _10300 + _10326 + 140] = mem[idx + _11781 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_11909) > _11909:
                                        mem[_11909 + _11134 + _10300 + _10326 + 140] = 0
                                    revert with 0, 32, mem[_11134 + _10300 + _10326 + 108 len ceil32(_11909) + 32]
                                mem[_11134 + _10300 + _10326 + 72] = 0
                                _11782 = mem[64]
                                mem[mem[64]] = _11134 + _10300 + _10326 + -mem[64] + 40
                                mem[64] = _11134 + _10300 + _10326 + 72
                                mem[_11134 + _10300 + _10326 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_11134 + _10300 + _10326 + 76] = 32
                                _11910 = mem[_11782]
                                mem[_11134 + _10300 + _10326 + 108] = mem[_11782]
                                idx = 0
                                while idx < _11910:
                                    mem[idx + _11134 + _10300 + _10326 + 140] = mem[idx + _11782 + 32]
                                    idx = idx + 32
                                    continue 
                                if ceil32(_11910) > _11910:
                                    mem[_11910 + _11134 + _10300 + _10326 + 140] = 0
                                revert with 0, 32, mem[_11134 + _10300 + _10326 + 108 len ceil32(_11910) + 32]
                            require cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)] > 0
                            if sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] > -2:
                                revert with 0, 17
                            if sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] + 1 > sub_fc86b662[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]]:
                                revert with 0, 'Minting would exceed the max number of items for given type'
                            if stor13[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]]:
                                revert with 0, 'Supplied id is already used'
                            if stor12[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]]:
                                revert with 0, 'Given type is fungible'
                            stor13[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]] = 1
                            if sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] > -2:
                                revert with 0, 17
                            sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]]++
                            sub_0f699e80[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                            mem[32] = 14
                            mintNumber[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]] = sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]]
                            _5740 = mem[64]
                            mem[mem[64]] = 0
                            if not address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]):
                                revert with 0, 'ERC1155: mint to the zero address'
                            if msg.sender != this.address:
                                mem[mem[64] + 32] = 1
                                mem[64] = mem[64] + 96
                                mem[_5740 + 64] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]
                                mem[_5740 + 96] = 1
                                mem[64] = _5740 + 160
                                mem[_5740 + 128] = 1
                                mem[0] = address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])
                                mem[32] = sha3(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)], 0)
                                if balanceOf[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])] > -2:
                                    revert with 0, 17
                                balanceOf[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])]++
                                mem[_5740 + 160] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]
                                mem[_5740 + 192] = 1
                                emit TransferSingle(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)], 1, msg.sender, 0, address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]));
                                if ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])):
                                    mem[_5740 + 160] = 0xf23a6e6100000000000000000000000000000000000000000000000000000000
                                    mem[_5740 + 164] = msg.sender
                                    mem[_5740 + 196] = 0
                                    mem[_5740 + 228] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]
                                    mem[_5740 + 260] = 1
                                    mem[_5740 + 292] = 160
                                    mem[_5740 + 324] = mem[_5740]
                                    t = 0
                                    while t < mem[_5740]:
                                        mem[t + _5740 + 356] = mem[t + _5740 + 32]
                                        t = t + 32
                                        continue 
                                    if ceil32(mem[_5740]) > mem[_5740]:
                                        mem[mem[_5740] + _5740 + 356] = 0
                                    require ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]))
                                    call address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)], 1, 160, mem[_5740], mem[_5740 + 356 len ceil32(mem[_5740])]
                                    mem[_5740 + 160] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                                    mem[64] = _5740 + ceil32(return_data.size) + 160
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                                    if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                            else:
                                mem[64] = mem[64] + ceil32(calldata.size) + 64
                                mem[_5740 + 32] = calldata.size
                                mem[_5740 + 64 len calldata.size] = call.data[0 len calldata.size]
                                mem[_5740 + calldata.size + 64] = 0
                                _5816 = mem[calldata.size + _5740 + 32]
                                mem[_5740 + ceil32(calldata.size) + 64] = 1
                                mem[_5740 + ceil32(calldata.size) + 96] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]
                                mem[_5740 + ceil32(calldata.size) + 128] = 1
                                mem[64] = _5740 + ceil32(calldata.size) + 192
                                mem[_5740 + ceil32(calldata.size) + 160] = 1
                                mem[0] = address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])
                                mem[32] = sha3(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)], 0)
                                if balanceOf[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])] > -2:
                                    revert with 0, 17
                                balanceOf[cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])]++
                                mem[_5740 + ceil32(calldata.size) + 192] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]
                                mem[_5740 + ceil32(calldata.size) + 224] = 1
                                emit TransferSingle(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)], 1, address(_5816), 0, address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]));
                                if ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])):
                                    mem[_5740 + ceil32(calldata.size) + 192] = 0xf23a6e6100000000000000000000000000000000000000000000000000000000
                                    mem[_5740 + ceil32(calldata.size) + 196] = address(_5816)
                                    mem[_5740 + ceil32(calldata.size) + 228] = 0
                                    mem[_5740 + ceil32(calldata.size) + 260] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)]
                                    mem[_5740 + ceil32(calldata.size) + 292] = 1
                                    mem[_5740 + ceil32(calldata.size) + 324] = 160
                                    mem[_5740 + ceil32(calldata.size) + 356] = mem[_5740]
                                    t = 0
                                    while t < mem[_5740]:
                                        mem[t + _5740 + ceil32(calldata.size) + 388] = mem[t + _5740 + 32]
                                        t = t + 32
                                        continue 
                                    if ceil32(mem[_5740]) > mem[_5740]:
                                        mem[mem[_5740] + _5740 + ceil32(calldata.size) + 388] = 0
                                    require ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]))
                                    call address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                                         gas gas_remaining wei
                                        args address(_5816), 0, cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68)], 1, 160, mem[_5740], mem[_5740 + ceil32(calldata.size) + 388 len ceil32(mem[_5740])]
                                    mem[_5740 + ceil32(calldata.size) + 192] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                                    mem[64] = _5740 + ceil32(calldata.size) + ceil32(return_data.size) + 192
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                                    if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                        if s == -1:
                            revert with 0, 17
                        s = s + 1
                        continue 
                    _5302 = mem[64]
                    mem[mem[64]] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                    mem[mem[64] + 32] = 96
                    mem[mem[64] + 96] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 36)]
                    require cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 36)] <= 0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
                    mem[mem[64] + 128 len 32 * cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 36)]] = call.data[cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 68 len 32 * cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 36)]]
                    mem[mem[64] + 64] = (32 * cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 36)]) + 128
                    mem[_5302 + (32 * cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 36)]) + 128] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 36)]
                    s = 0
                    t = cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68
                    u = _5302 + (32 * cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 68)] + 36)]) + 160
                    while s < cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 36)]:
                        require cd[t] == address(cd[t])
                        mem[u] = address(cd[t])
                        s = s + 1
                        t = t + 32
                        u = u + 32
                        continue 
                    emit 0x16a6af95: mem[mem[64] len u - mem[64]]
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                _2718 = mem[64]
                mem[mem[64]] = 42
                mem[64] = mem[64] + 96
                mem[_2718 + 32 len 42] = call.data[calldata.size len 42]
                if 0 >= mem[_2718]:
                    revert with 0, 50
                mem[_2718 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                if 1 >= mem[_2718]:
                    revert with 0, 50
                mem[_2718 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                idx = 41
                s = address(_2668)
                while idx > 1:
                    if s % 16 >= 16:
                        revert with 0, 50
                    if idx >= mem[_2718]:
                        revert with 0, 50
                    mem[idx + _2718 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                    if not idx:
                        revert with 0, 17
                    idx = idx - 1
                    s = Mask(252, 0, s) * 0.0625
                    continue 
                if address(_2668) + 10240:
                    revert with 0, 'Strings: hex length insufficient'
                _5354 = mem[64]
                mem[mem[64]] = 66
                mem[64] = mem[64] + 128
                mem[_5354 + 32 len 66] = call.data[calldata.size len 66]
                if 0 >= mem[_5354]:
                    revert with 0, 50
                mem[_5354 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                if 1 >= mem[_5354]:
                    revert with 0, 50
                mem[_5354 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                idx = 65
                while idx > 1:
                    if idx >= mem[_5354]:
                        revert with 0, 50
                    mem[idx + _5354 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                    if not idx:
                        revert with 0, 17
                    idx = idx - 1
                    continue 
                _8066 = mem[64]
                mem[mem[64] + 32] = 'AccessControl: account '
                _8080 = mem[_2718]
                idx = 0
                while idx < _8080:
                    mem[idx + _8066 + 55] = mem[idx + _2718 + 32]
                    idx = idx + 32
                    continue 
                mem[_8066 + _8080 + 55] = 0x206973206d697373696e6720726f6c6520000000000000000000000000000000
                if ceil32(_8080) <= _8080:
                    _10301 = mem[_5354]
                    idx = 0
                    while idx < _10301:
                        mem[idx + _8066 + _8080 + 72] = mem[idx + _5354 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_10301) <= _10301:
                        _11163 = mem[64]
                        mem[mem[64]] = _10301 + _8066 + _8080 + -mem[64] + 40
                        mem[64] = _10301 + _8066 + _8080 + 72
                        mem[_10301 + _8066 + _8080 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[_10301 + _8066 + _8080 + 76] = 32
                        _11235 = mem[_11163]
                        mem[_10301 + _8066 + _8080 + 108] = mem[_11163]
                        idx = 0
                        while idx < _11235:
                            mem[idx + _10301 + _8066 + _8080 + 140] = mem[idx + _11163 + 32]
                            idx = idx + 32
                            continue 
                        if ceil32(_11235) > _11235:
                            mem[_11235 + _10301 + _8066 + _8080 + 140] = 0
                        revert with 0, 32, mem[_10301 + _8066 + _8080 + 108 len ceil32(_11235) + 32]
                    mem[_10301 + _8066 + _8080 + 72] = 0
                    _11164 = mem[64]
                    mem[mem[64]] = _10301 + _8066 + _8080 + -mem[64] + 40
                    mem[64] = _10301 + _8066 + _8080 + 72
                    mem[_10301 + _8066 + _8080 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[_10301 + _8066 + _8080 + 76] = 32
                    _11236 = mem[_11164]
                    mem[_10301 + _8066 + _8080 + 108] = mem[_11164]
                    idx = 0
                    while idx < _11236:
                        mem[idx + _10301 + _8066 + _8080 + 140] = mem[idx + _11164 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_11236) > _11236:
                        mem[_11236 + _10301 + _8066 + _8080 + 140] = 0
                    revert with 0, 32, mem[_10301 + _8066 + _8080 + 108 len ceil32(_11236) + 32]
                _10302 = mem[_5354]
                idx = 0
                while idx < _10302:
                    mem[idx + _8066 + _8080 + 72] = mem[idx + _5354 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_10302) <= _10302:
                    _11165 = mem[64]
                    mem[mem[64]] = _10302 + _8066 + _8080 + -mem[64] + 40
                    mem[64] = _10302 + _8066 + _8080 + 72
                    mem[_10302 + _8066 + _8080 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[_10302 + _8066 + _8080 + 76] = 32
                    _11237 = mem[_11165]
                    mem[_10302 + _8066 + _8080 + 108] = mem[_11165]
                    idx = 0
                    while idx < _11237:
                        mem[idx + _10302 + _8066 + _8080 + 140] = mem[idx + _11165 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_11237) > _11237:
                        mem[_11237 + _10302 + _8066 + _8080 + 140] = 0
                    revert with 0, 32, mem[_10302 + _8066 + _8080 + 108 len ceil32(_11237) + 32]
                mem[_10302 + _8066 + _8080 + 72] = 0
                _11166 = mem[64]
                mem[mem[64]] = _10302 + _8066 + _8080 + -mem[64] + 40
                mem[64] = _10302 + _8066 + _8080 + 72
                mem[_10302 + _8066 + _8080 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[_10302 + _8066 + _8080 + 76] = 32
                _11238 = mem[_11166]
                mem[_10302 + _8066 + _8080 + 108] = mem[_11166]
                idx = 0
                while idx < _11238:
                    mem[idx + _10302 + _8066 + _8080 + 140] = mem[idx + _11166 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_11238) > _11238:
                    mem[_11238 + _10302 + _8066 + _8080 + 140] = 0
                revert with 0, 32, mem[_10302 + _8066 + _8080 + 108 len ceil32(_11238) + 32]
            require cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] < calldata.size + -cd[(cd[4] + (32 * idx) + 36)] + -cd[4] - 67
            require cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 36)] <= test266151307()
            require cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68 <= calldata.size - (32 * cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 36)])
            require cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] < calldata.size + -cd[(cd[4] + (32 * idx) + 36)] + -cd[4] - 67
            require cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 36)] <= test266151307()
            require cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68 <= calldata.size - (32 * cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 36)])
            if msg.sender != this.address:
                mem[0] = msg.sender
                mem[32] = sha3(0, 2)
                if uint8(roleAdmin[0][address(msg.sender)].field_0):
                    if cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 36)] != cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 36)]:
                        revert with 0, 'number of accounts must equal number of amounts'
                    s = 0
                    while s < cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 36)]:
                        require cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)] == address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])
                        if s >= cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 36)]:
                            revert with 0, 50
                        if msg.sender != this.address:
                            mem[0] = msg.sender
                            mem[32] = sha3(0, 2)
                            if not uint8(roleAdmin[0][address(msg.sender)].field_0):
                                _5549 = mem[64]
                                mem[mem[64]] = 42
                                mem[64] = mem[64] + 96
                                mem[_5549 + 32 len 42] = call.data[calldata.size len 42]
                                if 0 >= mem[_5549]:
                                    revert with 0, 50
                                mem[_5549 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                                if 1 >= mem[_5549]:
                                    revert with 0, 50
                                mem[_5549 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                                idx = 41
                                s = address(msg.sender)
                                while idx > 1:
                                    if s % 16 >= 16:
                                        revert with 0, 50
                                    if idx >= mem[_5549]:
                                        revert with 0, 50
                                    mem[idx + _5549 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                                    if not idx:
                                        revert with 0, 17
                                    idx = idx - 1
                                    s = Mask(252, 0, s) * 0.0625
                                    continue 
                                if msg.sender + 10240:
                                    revert with 0, 'Strings: hex length insufficient'
                                _8395 = mem[64]
                                mem[mem[64]] = 66
                                mem[64] = mem[64] + 128
                                mem[_8395 + 32 len 66] = call.data[calldata.size len 66]
                                if 0 >= mem[_8395]:
                                    revert with 0, 50
                                mem[_8395 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                                if 1 >= mem[_8395]:
                                    revert with 0, 50
                                mem[_8395 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                                idx = 65
                                while idx > 1:
                                    if idx >= mem[_8395]:
                                        revert with 0, 50
                                    mem[idx + _8395 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                                    if not idx:
                                        revert with 0, 17
                                    idx = idx - 1
                                    continue 
                                _10303 = mem[64]
                                mem[mem[64] + 32] = 'AccessControl: account '
                                _10327 = mem[_5549]
                                idx = 0
                                while idx < _10327:
                                    mem[idx + _10303 + 55] = mem[idx + _5549 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10303 + _10327 + 55] = 0x206973206d697373696e6720726f6c6520000000000000000000000000000000
                                if ceil32(_10327) <= _10327:
                                    _11135 = mem[_8395]
                                    idx = 0
                                    while idx < _11135:
                                        mem[idx + _10303 + _10327 + 72] = mem[idx + _8395 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_11135) <= _11135:
                                        _11783 = mem[64]
                                        mem[mem[64]] = _11135 + _10303 + _10327 + -mem[64] + 40
                                        mem[64] = _11135 + _10303 + _10327 + 72
                                        mem[_11135 + _10303 + _10327 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[_11135 + _10303 + _10327 + 76] = 32
                                        _11911 = mem[_11783]
                                        mem[_11135 + _10303 + _10327 + 108] = mem[_11783]
                                        idx = 0
                                        while idx < _11911:
                                            mem[idx + _11135 + _10303 + _10327 + 140] = mem[idx + _11783 + 32]
                                            idx = idx + 32
                                            continue 
                                        if ceil32(_11911) > _11911:
                                            mem[_11911 + _11135 + _10303 + _10327 + 140] = 0
                                        revert with 0, 32, mem[_11135 + _10303 + _10327 + 108 len ceil32(_11911) + 32]
                                    mem[_11135 + _10303 + _10327 + 72] = 0
                                    _11784 = mem[64]
                                    mem[mem[64]] = _11135 + _10303 + _10327 + -mem[64] + 40
                                    mem[64] = _11135 + _10303 + _10327 + 72
                                    mem[_11135 + _10303 + _10327 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_11135 + _10303 + _10327 + 76] = 32
                                    _11912 = mem[_11784]
                                    mem[_11135 + _10303 + _10327 + 108] = mem[_11784]
                                    idx = 0
                                    while idx < _11912:
                                        mem[idx + _11135 + _10303 + _10327 + 140] = mem[idx + _11784 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_11912) > _11912:
                                        mem[_11912 + _11135 + _10303 + _10327 + 140] = 0
                                    revert with 0, 32, mem[_11135 + _10303 + _10327 + 108 len ceil32(_11912) + 32]
                                _11136 = mem[_8395]
                                idx = 0
                                while idx < _11136:
                                    mem[idx + _10303 + _10327 + 72] = mem[idx + _8395 + 32]
                                    idx = idx + 32
                                    continue 
                                if ceil32(_11136) <= _11136:
                                    _11785 = mem[64]
                                    mem[mem[64]] = _11136 + _10303 + _10327 + -mem[64] + 40
                                    mem[64] = _11136 + _10303 + _10327 + 72
                                    mem[_11136 + _10303 + _10327 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_11136 + _10303 + _10327 + 76] = 32
                                    _11913 = mem[_11785]
                                    mem[_11136 + _10303 + _10327 + 108] = mem[_11785]
                                    idx = 0
                                    while idx < _11913:
                                        mem[idx + _11136 + _10303 + _10327 + 140] = mem[idx + _11785 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_11913) > _11913:
                                        mem[_11913 + _11136 + _10303 + _10327 + 140] = 0
                                    revert with 0, 32, mem[_11136 + _10303 + _10327 + 108 len ceil32(_11913) + 32]
                                mem[_11136 + _10303 + _10327 + 72] = 0
                                _11786 = mem[64]
                                mem[mem[64]] = _11136 + _10303 + _10327 + -mem[64] + 40
                                mem[64] = _11136 + _10303 + _10327 + 72
                                mem[_11136 + _10303 + _10327 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_11136 + _10303 + _10327 + 76] = 32
                                _11914 = mem[_11786]
                                mem[_11136 + _10303 + _10327 + 108] = mem[_11786]
                                idx = 0
                                while idx < _11914:
                                    mem[idx + _11136 + _10303 + _10327 + 140] = mem[idx + _11786 + 32]
                                    idx = idx + 32
                                    continue 
                                if ceil32(_11914) > _11914:
                                    mem[_11914 + _11136 + _10303 + _10327 + 140] = 0
                                revert with 0, 32, mem[_11136 + _10303 + _10327 + 108 len ceil32(_11914) + 32]
                            require cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)] > 0
                            if cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)] <= 0:
                                revert with 0, 'Amount should be > 0'
                            if sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] > !cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]:
                                revert with 0, 17
                            if sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] + cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)] > sub_fc86b662[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]]:
                                revert with 0, 'Minting would exceed the max number of items for given type'
                            if bool(stor12[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]]) != 1:
                                revert with 0, 'typeId is not fungible.'
                            if sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] > !cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]:
                                revert with 0, 17
                            mem[32] = 9
                            sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] += cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                            _5741 = mem[64]
                            mem[mem[64]] = 0
                            if not address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]):
                                revert with 0, 'ERC1155: mint to the zero address'
                            if msg.sender != this.address:
                                mem[mem[64] + 32] = 1
                                mem[64] = mem[64] + 96
                                mem[_5741 + 64] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                                mem[_5741 + 96] = 1
                                mem[64] = _5741 + 160
                                mem[_5741 + 128] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                mem[0] = address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])
                                mem[32] = sha3(cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)], 0)
                                if balanceOf[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])] > !cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]:
                                    revert with 0, 17
                                balanceOf[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])] += cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                mem[_5741 + 160] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                                mem[_5741 + 192] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                emit TransferSingle(cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)], cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)], msg.sender, 0, address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]));
                                if ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])):
                                    mem[_5741 + 160] = 0xf23a6e6100000000000000000000000000000000000000000000000000000000
                                    mem[_5741 + 164] = msg.sender
                                    mem[_5741 + 196] = 0
                                    mem[_5741 + 228] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                                    mem[_5741 + 260] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                    mem[_5741 + 292] = 160
                                    mem[_5741 + 324] = mem[_5741]
                                    t = 0
                                    while t < mem[_5741]:
                                        mem[t + _5741 + 356] = mem[t + _5741 + 32]
                                        t = t + 32
                                        continue 
                                    if ceil32(mem[_5741]) > mem[_5741]:
                                        mem[mem[_5741] + _5741 + 356] = 0
                                    require ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]))
                                    call address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)], cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)], 160, mem[_5741], mem[_5741 + 356 len ceil32(mem[_5741])]
                                    mem[_5741 + 160] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                                    mem[64] = _5741 + ceil32(return_data.size) + 160
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                                    if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                            else:
                                mem[64] = mem[64] + ceil32(calldata.size) + 64
                                mem[_5741 + 32] = calldata.size
                                mem[_5741 + 64 len calldata.size] = call.data[0 len calldata.size]
                                mem[_5741 + calldata.size + 64] = 0
                                _5818 = mem[calldata.size + _5741 + 32]
                                mem[_5741 + ceil32(calldata.size) + 64] = 1
                                mem[_5741 + ceil32(calldata.size) + 96] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                                mem[_5741 + ceil32(calldata.size) + 128] = 1
                                mem[64] = _5741 + ceil32(calldata.size) + 192
                                mem[_5741 + ceil32(calldata.size) + 160] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                mem[0] = address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])
                                mem[32] = sha3(cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)], 0)
                                if balanceOf[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])] > !cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]:
                                    revert with 0, 17
                                balanceOf[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])] += cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                mem[_5741 + ceil32(calldata.size) + 192] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                                mem[_5741 + ceil32(calldata.size) + 224] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                emit TransferSingle(cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)], cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)], address(_5818), 0, address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]));
                                if ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])):
                                    mem[_5741 + ceil32(calldata.size) + 192] = 0xf23a6e6100000000000000000000000000000000000000000000000000000000
                                    mem[_5741 + ceil32(calldata.size) + 196] = address(_5818)
                                    mem[_5741 + ceil32(calldata.size) + 228] = 0
                                    mem[_5741 + ceil32(calldata.size) + 260] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                                    mem[_5741 + ceil32(calldata.size) + 292] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                    mem[_5741 + ceil32(calldata.size) + 324] = 160
                                    mem[_5741 + ceil32(calldata.size) + 356] = mem[_5741]
                                    t = 0
                                    while t < mem[_5741]:
                                        mem[t + _5741 + ceil32(calldata.size) + 388] = mem[t + _5741 + 32]
                                        t = t + 32
                                        continue 
                                    if ceil32(mem[_5741]) > mem[_5741]:
                                        mem[mem[_5741] + _5741 + ceil32(calldata.size) + 388] = 0
                                    require ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]))
                                    call address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                                         gas gas_remaining wei
                                        args address(_5818), 0, cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)], cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)], 160, mem[_5741], mem[_5741 + ceil32(calldata.size) + 388 len ceil32(mem[_5741])]
                                    mem[_5741 + ceil32(calldata.size) + 192] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                                    mem[64] = _5741 + ceil32(calldata.size) + ceil32(return_data.size) + 192
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                                    if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                        else:
                            _5379 = mem[64]
                            mem[64] = mem[64] + ceil32(calldata.size) + 32
                            mem[_5379] = calldata.size
                            mem[_5379 + 32 len calldata.size] = call.data[0 len calldata.size]
                            mem[_5379 + calldata.size + 32] = 0
                            _5380 = mem[calldata.size + _5379]
                            mem[0] = mem[calldata.size + _5379 + 12 len 20]
                            mem[32] = sha3(0, 2)
                            if not uint8(roleAdmin[0][address(_5380)].field_0):
                                _5550 = mem[64]
                                mem[mem[64]] = 42
                                mem[64] = mem[64] + 96
                                mem[_5550 + 32 len 42] = call.data[calldata.size len 42]
                                if 0 >= mem[_5550]:
                                    revert with 0, 50
                                mem[_5550 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                                if 1 >= mem[_5550]:
                                    revert with 0, 50
                                mem[_5550 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                                idx = 41
                                s = address(_5380)
                                while idx > 1:
                                    if s % 16 >= 16:
                                        revert with 0, 50
                                    if idx >= mem[_5550]:
                                        revert with 0, 50
                                    mem[idx + _5550 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                                    if not idx:
                                        revert with 0, 17
                                    idx = idx - 1
                                    s = Mask(252, 0, s) * 0.0625
                                    continue 
                                if address(_5380) + 10240:
                                    revert with 0, 'Strings: hex length insufficient'
                                _8396 = mem[64]
                                mem[mem[64]] = 66
                                mem[64] = mem[64] + 128
                                mem[_8396 + 32 len 66] = call.data[calldata.size len 66]
                                if 0 >= mem[_8396]:
                                    revert with 0, 50
                                mem[_8396 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                                if 1 >= mem[_8396]:
                                    revert with 0, 50
                                mem[_8396 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                                idx = 65
                                while idx > 1:
                                    if idx >= mem[_8396]:
                                        revert with 0, 50
                                    mem[idx + _8396 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                                    if not idx:
                                        revert with 0, 17
                                    idx = idx - 1
                                    continue 
                                _10304 = mem[64]
                                mem[mem[64] + 32] = 'AccessControl: account '
                                _10328 = mem[_5550]
                                idx = 0
                                while idx < _10328:
                                    mem[idx + _10304 + 55] = mem[idx + _5550 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10304 + _10328 + 55] = 0x206973206d697373696e6720726f6c6520000000000000000000000000000000
                                if ceil32(_10328) <= _10328:
                                    _11137 = mem[_8396]
                                    idx = 0
                                    while idx < _11137:
                                        mem[idx + _10304 + _10328 + 72] = mem[idx + _8396 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_11137) <= _11137:
                                        _11787 = mem[64]
                                        mem[mem[64]] = _11137 + _10304 + _10328 + -mem[64] + 40
                                        mem[64] = _11137 + _10304 + _10328 + 72
                                        mem[_11137 + _10304 + _10328 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[_11137 + _10304 + _10328 + 76] = 32
                                        _11915 = mem[_11787]
                                        mem[_11137 + _10304 + _10328 + 108] = mem[_11787]
                                        idx = 0
                                        while idx < _11915:
                                            mem[idx + _11137 + _10304 + _10328 + 140] = mem[idx + _11787 + 32]
                                            idx = idx + 32
                                            continue 
                                        if ceil32(_11915) > _11915:
                                            mem[_11915 + _11137 + _10304 + _10328 + 140] = 0
                                        revert with 0, 32, mem[_11137 + _10304 + _10328 + 108 len ceil32(_11915) + 32]
                                    mem[_11137 + _10304 + _10328 + 72] = 0
                                    _11788 = mem[64]
                                    mem[mem[64]] = _11137 + _10304 + _10328 + -mem[64] + 40
                                    mem[64] = _11137 + _10304 + _10328 + 72
                                    mem[_11137 + _10304 + _10328 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_11137 + _10304 + _10328 + 76] = 32
                                    _11916 = mem[_11788]
                                    mem[_11137 + _10304 + _10328 + 108] = mem[_11788]
                                    idx = 0
                                    while idx < _11916:
                                        mem[idx + _11137 + _10304 + _10328 + 140] = mem[idx + _11788 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_11916) > _11916:
                                        mem[_11916 + _11137 + _10304 + _10328 + 140] = 0
                                    revert with 0, 32, mem[_11137 + _10304 + _10328 + 108 len ceil32(_11916) + 32]
                                _11138 = mem[_8396]
                                idx = 0
                                while idx < _11138:
                                    mem[idx + _10304 + _10328 + 72] = mem[idx + _8396 + 32]
                                    idx = idx + 32
                                    continue 
                                if ceil32(_11138) <= _11138:
                                    _11789 = mem[64]
                                    mem[mem[64]] = _11138 + _10304 + _10328 + -mem[64] + 40
                                    mem[64] = _11138 + _10304 + _10328 + 72
                                    mem[_11138 + _10304 + _10328 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_11138 + _10304 + _10328 + 76] = 32
                                    _11917 = mem[_11789]
                                    mem[_11138 + _10304 + _10328 + 108] = mem[_11789]
                                    idx = 0
                                    while idx < _11917:
                                        mem[idx + _11138 + _10304 + _10328 + 140] = mem[idx + _11789 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_11917) > _11917:
                                        mem[_11917 + _11138 + _10304 + _10328 + 140] = 0
                                    revert with 0, 32, mem[_11138 + _10304 + _10328 + 108 len ceil32(_11917) + 32]
                                mem[_11138 + _10304 + _10328 + 72] = 0
                                _11790 = mem[64]
                                mem[mem[64]] = _11138 + _10304 + _10328 + -mem[64] + 40
                                mem[64] = _11138 + _10304 + _10328 + 72
                                mem[_11138 + _10304 + _10328 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_11138 + _10304 + _10328 + 76] = 32
                                _11918 = mem[_11790]
                                mem[_11138 + _10304 + _10328 + 108] = mem[_11790]
                                idx = 0
                                while idx < _11918:
                                    mem[idx + _11138 + _10304 + _10328 + 140] = mem[idx + _11790 + 32]
                                    idx = idx + 32
                                    continue 
                                if ceil32(_11918) > _11918:
                                    mem[_11918 + _11138 + _10304 + _10328 + 140] = 0
                                revert with 0, 32, mem[_11138 + _10304 + _10328 + 108 len ceil32(_11918) + 32]
                            require cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)] > 0
                            if cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)] <= 0:
                                revert with 0, 'Amount should be > 0'
                            if sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] > !cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]:
                                revert with 0, 17
                            if sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] + cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)] > sub_fc86b662[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]]:
                                revert with 0, 'Minting would exceed the max number of items for given type'
                            if bool(stor12[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]]) != 1:
                                revert with 0, 'typeId is not fungible.'
                            if sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] > !cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]:
                                revert with 0, 17
                            mem[32] = 9
                            sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] += cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                            _5742 = mem[64]
                            mem[mem[64]] = 0
                            if not address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]):
                                revert with 0, 'ERC1155: mint to the zero address'
                            if msg.sender != this.address:
                                mem[mem[64] + 32] = 1
                                mem[64] = mem[64] + 96
                                mem[_5742 + 64] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                                mem[_5742 + 96] = 1
                                mem[64] = _5742 + 160
                                mem[_5742 + 128] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                mem[0] = address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])
                                mem[32] = sha3(cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)], 0)
                                if balanceOf[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])] > !cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]:
                                    revert with 0, 17
                                balanceOf[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])] += cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                mem[_5742 + 160] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                                mem[_5742 + 192] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                emit TransferSingle(cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)], cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)], msg.sender, 0, address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]));
                                if ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])):
                                    mem[_5742 + 160] = 0xf23a6e6100000000000000000000000000000000000000000000000000000000
                                    mem[_5742 + 164] = msg.sender
                                    mem[_5742 + 196] = 0
                                    mem[_5742 + 228] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                                    mem[_5742 + 260] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                    mem[_5742 + 292] = 160
                                    mem[_5742 + 324] = mem[_5742]
                                    t = 0
                                    while t < mem[_5742]:
                                        mem[t + _5742 + 356] = mem[t + _5742 + 32]
                                        t = t + 32
                                        continue 
                                    if ceil32(mem[_5742]) > mem[_5742]:
                                        mem[mem[_5742] + _5742 + 356] = 0
                                    require ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]))
                                    call address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                                         gas gas_remaining wei
                                        args msg.sender, 0, cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)], cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)], 160, mem[_5742], mem[_5742 + 356 len ceil32(mem[_5742])]
                                    mem[_5742 + 160] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                                    mem[64] = _5742 + ceil32(return_data.size) + 160
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                                    if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                            else:
                                mem[64] = mem[64] + ceil32(calldata.size) + 64
                                mem[_5742 + 32] = calldata.size
                                mem[_5742 + 64 len calldata.size] = call.data[0 len calldata.size]
                                mem[_5742 + calldata.size + 64] = 0
                                _5820 = mem[calldata.size + _5742 + 32]
                                mem[_5742 + ceil32(calldata.size) + 64] = 1
                                mem[_5742 + ceil32(calldata.size) + 96] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                                mem[_5742 + ceil32(calldata.size) + 128] = 1
                                mem[64] = _5742 + ceil32(calldata.size) + 192
                                mem[_5742 + ceil32(calldata.size) + 160] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                mem[0] = address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])
                                mem[32] = sha3(cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)], 0)
                                if balanceOf[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])] > !cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]:
                                    revert with 0, 17
                                balanceOf[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])] += cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                mem[_5742 + ceil32(calldata.size) + 192] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                                mem[_5742 + ceil32(calldata.size) + 224] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                emit TransferSingle(cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)], cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)], address(_5820), 0, address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]));
                                if ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])):
                                    mem[_5742 + ceil32(calldata.size) + 192] = 0xf23a6e6100000000000000000000000000000000000000000000000000000000
                                    mem[_5742 + ceil32(calldata.size) + 196] = address(_5820)
                                    mem[_5742 + ceil32(calldata.size) + 228] = 0
                                    mem[_5742 + ceil32(calldata.size) + 260] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                                    mem[_5742 + ceil32(calldata.size) + 292] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                    mem[_5742 + ceil32(calldata.size) + 324] = 160
                                    mem[_5742 + ceil32(calldata.size) + 356] = mem[_5742]
                                    t = 0
                                    while t < mem[_5742]:
                                        mem[t + _5742 + ceil32(calldata.size) + 388] = mem[t + _5742 + 32]
                                        t = t + 32
                                        continue 
                                    if ceil32(mem[_5742]) > mem[_5742]:
                                        mem[mem[_5742] + _5742 + ceil32(calldata.size) + 388] = 0
                                    require ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]))
                                    call address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                                         gas gas_remaining wei
                                        args address(_5820), 0, cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)], cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)], 160, mem[_5742], mem[_5742 + ceil32(calldata.size) + 388 len ceil32(mem[_5742])]
                                    mem[_5742 + ceil32(calldata.size) + 192] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                                    mem[64] = _5742 + ceil32(calldata.size) + ceil32(return_data.size) + 192
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                                    if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                        if s == -1:
                            revert with 0, 17
                        s = s + 1
                        continue 
                    _5303 = mem[64]
                    mem[mem[64]] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                    mem[mem[64] + 32] = 96
                    mem[mem[64] + 96] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 36)]
                    s = 0
                    t = cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68
                    u = mem[64] + 128
                    while s < cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 36)]:
                        require cd[t] == address(cd[t])
                        mem[u] = address(cd[t])
                        s = s + 1
                        t = t + 32
                        u = u + 32
                        continue 
                    mem[_5303 + 64] = u - _5303
                    mem[u] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 36)]
                    require cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 36)] <= 0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
                    mem[u + 32 len 32 * cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 36)]] = call.data[cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68 len 32 * cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 36)]]
                    mem[u + (32 * cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 36)]) + 32] = 0
                    emit 0xbc11d48c: mem[mem[64] len u + (32 * cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 36)]) + -mem[64] + 32]
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                _2719 = mem[64]
                mem[mem[64]] = 42
                mem[64] = mem[64] + 96
                mem[_2719 + 32 len 42] = call.data[calldata.size len 42]
                if 0 >= mem[_2719]:
                    revert with 0, 50
                mem[_2719 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                if 1 >= mem[_2719]:
                    revert with 0, 50
                mem[_2719 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                idx = 41
                s = address(msg.sender)
                while idx > 1:
                    if s % 16 >= 16:
                        revert with 0, 50
                    if idx >= mem[_2719]:
                        revert with 0, 50
                    mem[idx + _2719 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                    if not idx:
                        revert with 0, 17
                    idx = idx - 1
                    s = Mask(252, 0, s) * 0.0625
                    continue 
                if msg.sender + 10240:
                    revert with 0, 'Strings: hex length insufficient'
                _5355 = mem[64]
                mem[mem[64]] = 66
                mem[64] = mem[64] + 128
                mem[_5355 + 32 len 66] = call.data[calldata.size len 66]
                if 0 >= mem[_5355]:
                    revert with 0, 50
                mem[_5355 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                if 1 >= mem[_5355]:
                    revert with 0, 50
                mem[_5355 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                idx = 65
                while idx > 1:
                    if idx >= mem[_5355]:
                        revert with 0, 50
                    mem[idx + _5355 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                    if not idx:
                        revert with 0, 17
                    idx = idx - 1
                    continue 
                _8069 = mem[64]
                mem[mem[64] + 32] = 'AccessControl: account '
                _8081 = mem[_2719]
                idx = 0
                while idx < _8081:
                    mem[idx + _8069 + 55] = mem[idx + _2719 + 32]
                    idx = idx + 32
                    continue 
                mem[_8069 + _8081 + 55] = 0x206973206d697373696e6720726f6c6520000000000000000000000000000000
                if ceil32(_8081) <= _8081:
                    _10305 = mem[_5355]
                    idx = 0
                    while idx < _10305:
                        mem[idx + _8069 + _8081 + 72] = mem[idx + _5355 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_10305) <= _10305:
                        _11167 = mem[64]
                        mem[mem[64]] = _10305 + _8069 + _8081 + -mem[64] + 40
                        mem[64] = _10305 + _8069 + _8081 + 72
                        mem[_10305 + _8069 + _8081 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[_10305 + _8069 + _8081 + 76] = 32
                        _11243 = mem[_11167]
                        mem[_10305 + _8069 + _8081 + 108] = mem[_11167]
                        idx = 0
                        while idx < _11243:
                            mem[idx + _10305 + _8069 + _8081 + 140] = mem[idx + _11167 + 32]
                            idx = idx + 32
                            continue 
                        if ceil32(_11243) > _11243:
                            mem[_11243 + _10305 + _8069 + _8081 + 140] = 0
                        revert with 0, 32, mem[_10305 + _8069 + _8081 + 108 len ceil32(_11243) + 32]
                    mem[_10305 + _8069 + _8081 + 72] = 0
                    _11168 = mem[64]
                    mem[mem[64]] = _10305 + _8069 + _8081 + -mem[64] + 40
                    mem[64] = _10305 + _8069 + _8081 + 72
                    mem[_10305 + _8069 + _8081 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[_10305 + _8069 + _8081 + 76] = 32
                    _11244 = mem[_11168]
                    mem[_10305 + _8069 + _8081 + 108] = mem[_11168]
                    idx = 0
                    while idx < _11244:
                        mem[idx + _10305 + _8069 + _8081 + 140] = mem[idx + _11168 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_11244) > _11244:
                        mem[_11244 + _10305 + _8069 + _8081 + 140] = 0
                    revert with 0, 32, mem[_10305 + _8069 + _8081 + 108 len ceil32(_11244) + 32]
                _10306 = mem[_5355]
                idx = 0
                while idx < _10306:
                    mem[idx + _8069 + _8081 + 72] = mem[idx + _5355 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_10306) <= _10306:
                    _11169 = mem[64]
                    mem[mem[64]] = _10306 + _8069 + _8081 + -mem[64] + 40
                    mem[64] = _10306 + _8069 + _8081 + 72
                    mem[_10306 + _8069 + _8081 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[_10306 + _8069 + _8081 + 76] = 32
                    _11245 = mem[_11169]
                    mem[_10306 + _8069 + _8081 + 108] = mem[_11169]
                    idx = 0
                    while idx < _11245:
                        mem[idx + _10306 + _8069 + _8081 + 140] = mem[idx + _11169 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_11245) > _11245:
                        mem[_11245 + _10306 + _8069 + _8081 + 140] = 0
                    revert with 0, 32, mem[_10306 + _8069 + _8081 + 108 len ceil32(_11245) + 32]
                mem[_10306 + _8069 + _8081 + 72] = 0
                _11170 = mem[64]
                mem[mem[64]] = _10306 + _8069 + _8081 + -mem[64] + 40
                mem[64] = _10306 + _8069 + _8081 + 72
                mem[_10306 + _8069 + _8081 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[_10306 + _8069 + _8081 + 76] = 32
                _11246 = mem[_11170]
                mem[_10306 + _8069 + _8081 + 108] = mem[_11170]
                idx = 0
                while idx < _11246:
                    mem[idx + _10306 + _8069 + _8081 + 140] = mem[idx + _11170 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_11246) > _11246:
                    mem[_11246 + _10306 + _8069 + _8081 + 140] = 0
                revert with 0, 32, mem[_10306 + _8069 + _8081 + 108 len ceil32(_11246) + 32]
            _2669 = mem[64]
            mem[64] = mem[64] + ceil32(calldata.size) + 32
            mem[_2669] = calldata.size
            mem[_2669 + 32 len calldata.size] = call.data[0 len calldata.size]
            mem[_2669 + calldata.size + 32] = 0
            _2670 = mem[calldata.size + _2669]
            mem[0] = mem[calldata.size + _2669 + 12 len 20]
            mem[32] = sha3(0, 2)
            if uint8(roleAdmin[0][address(_2670)].field_0):
                if cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 36)] != cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 36)]:
                    revert with 0, 'number of accounts must equal number of amounts'
                s = 0
                while s < cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 36)]:
                    require cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)] == address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])
                    if s >= cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 36)]:
                        revert with 0, 50
                    if msg.sender != this.address:
                        mem[0] = msg.sender
                        mem[32] = sha3(0, 2)
                        if not uint8(roleAdmin[0][address(msg.sender)].field_0):
                            _5551 = mem[64]
                            mem[mem[64]] = 42
                            mem[64] = mem[64] + 96
                            mem[_5551 + 32 len 42] = call.data[calldata.size len 42]
                            if 0 >= mem[_5551]:
                                revert with 0, 50
                            mem[_5551 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                            if 1 >= mem[_5551]:
                                revert with 0, 50
                            mem[_5551 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                            idx = 41
                            s = address(msg.sender)
                            while idx > 1:
                                if s % 16 >= 16:
                                    revert with 0, 50
                                if idx >= mem[_5551]:
                                    revert with 0, 50
                                mem[idx + _5551 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                                if not idx:
                                    revert with 0, 17
                                idx = idx - 1
                                s = Mask(252, 0, s) * 0.0625
                                continue 
                            if msg.sender + 10240:
                                revert with 0, 'Strings: hex length insufficient'
                            _8397 = mem[64]
                            mem[mem[64]] = 66
                            mem[64] = mem[64] + 128
                            mem[_8397 + 32 len 66] = call.data[calldata.size len 66]
                            if 0 >= mem[_8397]:
                                revert with 0, 50
                            mem[_8397 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                            if 1 >= mem[_8397]:
                                revert with 0, 50
                            mem[_8397 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                            idx = 65
                            while idx > 1:
                                if idx >= mem[_8397]:
                                    revert with 0, 50
                                mem[idx + _8397 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                                if not idx:
                                    revert with 0, 17
                                idx = idx - 1
                                continue 
                            _10307 = mem[64]
                            mem[mem[64] + 32] = 'AccessControl: account '
                            _10329 = mem[_5551]
                            idx = 0
                            while idx < _10329:
                                mem[idx + _10307 + 55] = mem[idx + _5551 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10307 + _10329 + 55] = 0x206973206d697373696e6720726f6c6520000000000000000000000000000000
                            if ceil32(_10329) <= _10329:
                                _11139 = mem[_8397]
                                idx = 0
                                while idx < _11139:
                                    mem[idx + _10307 + _10329 + 72] = mem[idx + _8397 + 32]
                                    idx = idx + 32
                                    continue 
                                if ceil32(_11139) <= _11139:
                                    _11791 = mem[64]
                                    mem[mem[64]] = _11139 + _10307 + _10329 + -mem[64] + 40
                                    mem[64] = _11139 + _10307 + _10329 + 72
                                    mem[_11139 + _10307 + _10329 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_11139 + _10307 + _10329 + 76] = 32
                                    _11919 = mem[_11791]
                                    mem[_11139 + _10307 + _10329 + 108] = mem[_11791]
                                    idx = 0
                                    while idx < _11919:
                                        mem[idx + _11139 + _10307 + _10329 + 140] = mem[idx + _11791 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_11919) > _11919:
                                        mem[_11919 + _11139 + _10307 + _10329 + 140] = 0
                                    revert with 0, 32, mem[_11139 + _10307 + _10329 + 108 len ceil32(_11919) + 32]
                                mem[_11139 + _10307 + _10329 + 72] = 0
                                _11792 = mem[64]
                                mem[mem[64]] = _11139 + _10307 + _10329 + -mem[64] + 40
                                mem[64] = _11139 + _10307 + _10329 + 72
                                mem[_11139 + _10307 + _10329 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_11139 + _10307 + _10329 + 76] = 32
                                _11920 = mem[_11792]
                                mem[_11139 + _10307 + _10329 + 108] = mem[_11792]
                                idx = 0
                                while idx < _11920:
                                    mem[idx + _11139 + _10307 + _10329 + 140] = mem[idx + _11792 + 32]
                                    idx = idx + 32
                                    continue 
                                if ceil32(_11920) > _11920:
                                    mem[_11920 + _11139 + _10307 + _10329 + 140] = 0
                                revert with 0, 32, mem[_11139 + _10307 + _10329 + 108 len ceil32(_11920) + 32]
                            _11140 = mem[_8397]
                            idx = 0
                            while idx < _11140:
                                mem[idx + _10307 + _10329 + 72] = mem[idx + _8397 + 32]
                                idx = idx + 32
                                continue 
                            if ceil32(_11140) <= _11140:
                                _11793 = mem[64]
                                mem[mem[64]] = _11140 + _10307 + _10329 + -mem[64] + 40
                                mem[64] = _11140 + _10307 + _10329 + 72
                                mem[_11140 + _10307 + _10329 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_11140 + _10307 + _10329 + 76] = 32
                                _11921 = mem[_11793]
                                mem[_11140 + _10307 + _10329 + 108] = mem[_11793]
                                idx = 0
                                while idx < _11921:
                                    mem[idx + _11140 + _10307 + _10329 + 140] = mem[idx + _11793 + 32]
                                    idx = idx + 32
                                    continue 
                                if ceil32(_11921) > _11921:
                                    mem[_11921 + _11140 + _10307 + _10329 + 140] = 0
                                revert with 0, 32, mem[_11140 + _10307 + _10329 + 108 len ceil32(_11921) + 32]
                            mem[_11140 + _10307 + _10329 + 72] = 0
                            _11794 = mem[64]
                            mem[mem[64]] = _11140 + _10307 + _10329 + -mem[64] + 40
                            mem[64] = _11140 + _10307 + _10329 + 72
                            mem[_11140 + _10307 + _10329 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_11140 + _10307 + _10329 + 76] = 32
                            _11922 = mem[_11794]
                            mem[_11140 + _10307 + _10329 + 108] = mem[_11794]
                            idx = 0
                            while idx < _11922:
                                mem[idx + _11140 + _10307 + _10329 + 140] = mem[idx + _11794 + 32]
                                idx = idx + 32
                                continue 
                            if ceil32(_11922) > _11922:
                                mem[_11922 + _11140 + _10307 + _10329 + 140] = 0
                            revert with 0, 32, mem[_11140 + _10307 + _10329 + 108 len ceil32(_11922) + 32]
                        require cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)] > 0
                        if cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)] <= 0:
                            revert with 0, 'Amount should be > 0'
                        if sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] > !cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]:
                            revert with 0, 17
                        if sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] + cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)] > sub_fc86b662[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]]:
                            revert with 0, 'Minting would exceed the max number of items for given type'
                        if bool(stor12[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]]) != 1:
                            revert with 0, 'typeId is not fungible.'
                        if sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] > !cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]:
                            revert with 0, 17
                        mem[32] = 9
                        sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] += cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                        _5743 = mem[64]
                        mem[mem[64]] = 0
                        if not address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]):
                            revert with 0, 'ERC1155: mint to the zero address'
                        if msg.sender != this.address:
                            mem[mem[64] + 32] = 1
                            mem[64] = mem[64] + 96
                            mem[_5743 + 64] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                            mem[_5743 + 96] = 1
                            mem[64] = _5743 + 160
                            mem[_5743 + 128] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                            mem[0] = address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])
                            mem[32] = sha3(cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)], 0)
                            if balanceOf[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])] > !cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]:
                                revert with 0, 17
                            balanceOf[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])] += cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                            mem[_5743 + 160] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                            mem[_5743 + 192] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                            emit TransferSingle(cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)], cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)], msg.sender, 0, address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]));
                            if ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])):
                                mem[_5743 + 160] = 0xf23a6e6100000000000000000000000000000000000000000000000000000000
                                mem[_5743 + 164] = msg.sender
                                mem[_5743 + 196] = 0
                                mem[_5743 + 228] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                                mem[_5743 + 260] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                mem[_5743 + 292] = 160
                                mem[_5743 + 324] = mem[_5743]
                                t = 0
                                while t < mem[_5743]:
                                    mem[t + _5743 + 356] = mem[t + _5743 + 32]
                                    t = t + 32
                                    continue 
                                if ceil32(mem[_5743]) > mem[_5743]:
                                    mem[mem[_5743] + _5743 + 356] = 0
                                require ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]))
                                call address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                                     gas gas_remaining wei
                                    args msg.sender, 0, cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)], cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)], 160, mem[_5743], mem[_5743 + 356 len ceil32(mem[_5743])]
                                mem[_5743 + 160] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                                mem[64] = _5743 + ceil32(return_data.size) + 160
                                require return_data.size >= 32
                                require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                                if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                                    revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                        else:
                            mem[64] = mem[64] + ceil32(calldata.size) + 64
                            mem[_5743 + 32] = calldata.size
                            mem[_5743 + 64 len calldata.size] = call.data[0 len calldata.size]
                            mem[_5743 + calldata.size + 64] = 0
                            _5822 = mem[calldata.size + _5743 + 32]
                            mem[_5743 + ceil32(calldata.size) + 64] = 1
                            mem[_5743 + ceil32(calldata.size) + 96] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                            mem[_5743 + ceil32(calldata.size) + 128] = 1
                            mem[64] = _5743 + ceil32(calldata.size) + 192
                            mem[_5743 + ceil32(calldata.size) + 160] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                            mem[0] = address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])
                            mem[32] = sha3(cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)], 0)
                            if balanceOf[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])] > !cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]:
                                revert with 0, 17
                            balanceOf[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])] += cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                            mem[_5743 + ceil32(calldata.size) + 192] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                            mem[_5743 + ceil32(calldata.size) + 224] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                            emit TransferSingle(cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)], cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)], address(_5822), 0, address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]));
                            if ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])):
                                mem[_5743 + ceil32(calldata.size) + 192] = 0xf23a6e6100000000000000000000000000000000000000000000000000000000
                                mem[_5743 + ceil32(calldata.size) + 196] = address(_5822)
                                mem[_5743 + ceil32(calldata.size) + 228] = 0
                                mem[_5743 + ceil32(calldata.size) + 260] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                                mem[_5743 + ceil32(calldata.size) + 292] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                mem[_5743 + ceil32(calldata.size) + 324] = 160
                                mem[_5743 + ceil32(calldata.size) + 356] = mem[_5743]
                                t = 0
                                while t < mem[_5743]:
                                    mem[t + _5743 + ceil32(calldata.size) + 388] = mem[t + _5743 + 32]
                                    t = t + 32
                                    continue 
                                if ceil32(mem[_5743]) > mem[_5743]:
                                    mem[mem[_5743] + _5743 + ceil32(calldata.size) + 388] = 0
                                require ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]))
                                call address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                                     gas gas_remaining wei
                                    args address(_5822), 0, cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)], cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)], 160, mem[_5743], mem[_5743 + ceil32(calldata.size) + 388 len ceil32(mem[_5743])]
                                mem[_5743 + ceil32(calldata.size) + 192] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                                mem[64] = _5743 + ceil32(calldata.size) + ceil32(return_data.size) + 192
                                require return_data.size >= 32
                                require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                                if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                                    revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                    else:
                        _5382 = mem[64]
                        mem[64] = mem[64] + ceil32(calldata.size) + 32
                        mem[_5382] = calldata.size
                        mem[_5382 + 32 len calldata.size] = call.data[0 len calldata.size]
                        mem[_5382 + calldata.size + 32] = 0
                        _5383 = mem[calldata.size + _5382]
                        mem[0] = mem[calldata.size + _5382 + 12 len 20]
                        mem[32] = sha3(0, 2)
                        if not uint8(roleAdmin[0][address(_5383)].field_0):
                            _5552 = mem[64]
                            mem[mem[64]] = 42
                            mem[64] = mem[64] + 96
                            mem[_5552 + 32 len 42] = call.data[calldata.size len 42]
                            if 0 >= mem[_5552]:
                                revert with 0, 50
                            mem[_5552 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                            if 1 >= mem[_5552]:
                                revert with 0, 50
                            mem[_5552 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                            idx = 41
                            s = address(_5383)
                            while idx > 1:
                                if s % 16 >= 16:
                                    revert with 0, 50
                                if idx >= mem[_5552]:
                                    revert with 0, 50
                                mem[idx + _5552 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                                if not idx:
                                    revert with 0, 17
                                idx = idx - 1
                                s = Mask(252, 0, s) * 0.0625
                                continue 
                            if address(_5383) + 10240:
                                revert with 0, 'Strings: hex length insufficient'
                            _8398 = mem[64]
                            mem[mem[64]] = 66
                            mem[64] = mem[64] + 128
                            mem[_8398 + 32 len 66] = call.data[calldata.size len 66]
                            if 0 >= mem[_8398]:
                                revert with 0, 50
                            mem[_8398 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
                            if 1 >= mem[_8398]:
                                revert with 0, 50
                            mem[_8398 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
                            idx = 65
                            while idx > 1:
                                if idx >= mem[_8398]:
                                    revert with 0, 50
                                mem[idx + _8398 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                                if not idx:
                                    revert with 0, 17
                                idx = idx - 1
                                continue 
                            _10308 = mem[64]
                            mem[mem[64] + 32] = 'AccessControl: account '
                            _10330 = mem[_5552]
                            idx = 0
                            while idx < _10330:
                                mem[idx + _10308 + 55] = mem[idx + _5552 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10308 + _10330 + 55] = 0x206973206d697373696e6720726f6c6520000000000000000000000000000000
                            if ceil32(_10330) <= _10330:
                                _11141 = mem[_8398]
                                idx = 0
                                while idx < _11141:
                                    mem[idx + _10308 + _10330 + 72] = mem[idx + _8398 + 32]
                                    idx = idx + 32
                                    continue 
                                if ceil32(_11141) <= _11141:
                                    _11795 = mem[64]
                                    mem[mem[64]] = _11141 + _10308 + _10330 + -mem[64] + 40
                                    mem[64] = _11141 + _10308 + _10330 + 72
                                    mem[_11141 + _10308 + _10330 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_11141 + _10308 + _10330 + 76] = 32
                                    _11923 = mem[_11795]
                                    mem[_11141 + _10308 + _10330 + 108] = mem[_11795]
                                    idx = 0
                                    while idx < _11923:
                                        mem[idx + _11141 + _10308 + _10330 + 140] = mem[idx + _11795 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_11923) > _11923:
                                        mem[_11923 + _11141 + _10308 + _10330 + 140] = 0
                                    revert with 0, 32, mem[_11141 + _10308 + _10330 + 108 len ceil32(_11923) + 32]
                                mem[_11141 + _10308 + _10330 + 72] = 0
                                _11796 = mem[64]
                                mem[mem[64]] = _11141 + _10308 + _10330 + -mem[64] + 40
                                mem[64] = _11141 + _10308 + _10330 + 72
                                mem[_11141 + _10308 + _10330 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_11141 + _10308 + _10330 + 76] = 32
                                _11924 = mem[_11796]
                                mem[_11141 + _10308 + _10330 + 108] = mem[_11796]
                                idx = 0
                                while idx < _11924:
                                    mem[idx + _11141 + _10308 + _10330 + 140] = mem[idx + _11796 + 32]
                                    idx = idx + 32
                                    continue 
                                if ceil32(_11924) > _11924:
                                    mem[_11924 + _11141 + _10308 + _10330 + 140] = 0
                                revert with 0, 32, mem[_11141 + _10308 + _10330 + 108 len ceil32(_11924) + 32]
                            _11142 = mem[_8398]
                            idx = 0
                            while idx < _11142:
                                mem[idx + _10308 + _10330 + 72] = mem[idx + _8398 + 32]
                                idx = idx + 32
                                continue 
                            if ceil32(_11142) <= _11142:
                                _11797 = mem[64]
                                mem[mem[64]] = _11142 + _10308 + _10330 + -mem[64] + 40
                                mem[64] = _11142 + _10308 + _10330 + 72
                                mem[_11142 + _10308 + _10330 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_11142 + _10308 + _10330 + 76] = 32
                                _11925 = mem[_11797]
                                mem[_11142 + _10308 + _10330 + 108] = mem[_11797]
                                idx = 0
                                while idx < _11925:
                                    mem[idx + _11142 + _10308 + _10330 + 140] = mem[idx + _11797 + 32]
                                    idx = idx + 32
                                    continue 
                                if ceil32(_11925) > _11925:
                                    mem[_11925 + _11142 + _10308 + _10330 + 140] = 0
                                revert with 0, 32, mem[_11142 + _10308 + _10330 + 108 len ceil32(_11925) + 32]
                            mem[_11142 + _10308 + _10330 + 72] = 0
                            _11798 = mem[64]
                            mem[mem[64]] = _11142 + _10308 + _10330 + -mem[64] + 40
                            mem[64] = _11142 + _10308 + _10330 + 72
                            mem[_11142 + _10308 + _10330 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_11142 + _10308 + _10330 + 76] = 32
                            _11926 = mem[_11798]
                            mem[_11142 + _10308 + _10330 + 108] = mem[_11798]
                            idx = 0
                            while idx < _11926:
                                mem[idx + _11142 + _10308 + _10330 + 140] = mem[idx + _11798 + 32]
                                idx = idx + 32
                                continue 
                            if ceil32(_11926) > _11926:
                                mem[_11926 + _11142 + _10308 + _10330 + 140] = 0
                            revert with 0, 32, mem[_11142 + _10308 + _10330 + 108 len ceil32(_11926) + 32]
                        require cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)] > 0
                        if cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)] <= 0:
                            revert with 0, 'Amount should be > 0'
                        if sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] > !cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]:
                            revert with 0, 17
                        if sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] + cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)] > sub_fc86b662[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]]:
                            revert with 0, 'Minting would exceed the max number of items for given type'
                        if bool(stor12[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]]) != 1:
                            revert with 0, 'typeId is not fungible.'
                        if sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] > !cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]:
                            revert with 0, 17
                        mem[32] = 9
                        sub_79920951[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]] += cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                        _5744 = mem[64]
                        mem[mem[64]] = 0
                        if not address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]):
                            revert with 0, 'ERC1155: mint to the zero address'
                        if msg.sender != this.address:
                            mem[mem[64] + 32] = 1
                            mem[64] = mem[64] + 96
                            mem[_5744 + 64] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                            mem[_5744 + 96] = 1
                            mem[64] = _5744 + 160
                            mem[_5744 + 128] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                            mem[0] = address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])
                            mem[32] = sha3(cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)], 0)
                            if balanceOf[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])] > !cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]:
                                revert with 0, 17
                            balanceOf[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])] += cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                            mem[_5744 + 160] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                            mem[_5744 + 192] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                            emit TransferSingle(cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)], cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)], msg.sender, 0, address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]));
                            if ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])):
                                mem[_5744 + 160] = 0xf23a6e6100000000000000000000000000000000000000000000000000000000
                                mem[_5744 + 164] = msg.sender
                                mem[_5744 + 196] = 0
                                mem[_5744 + 228] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                                mem[_5744 + 260] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                mem[_5744 + 292] = 160
                                mem[_5744 + 324] = mem[_5744]
                                t = 0
                                while t < mem[_5744]:
                                    mem[t + _5744 + 356] = mem[t + _5744 + 32]
                                    t = t + 32
                                    continue 
                                if ceil32(mem[_5744]) > mem[_5744]:
                                    mem[mem[_5744] + _5744 + 356] = 0
                                require ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]))
                                call address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                                     gas gas_remaining wei
                                    args msg.sender, 0, cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)], cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)], 160, mem[_5744], mem[_5744 + 356 len ceil32(mem[_5744])]
                                mem[_5744 + 160] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                                mem[64] = _5744 + ceil32(return_data.size) + 160
                                require return_data.size >= 32
                                require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                                if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                                    revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                        else:
                            mem[64] = mem[64] + ceil32(calldata.size) + 64
                            mem[_5744 + 32] = calldata.size
                            mem[_5744 + 64 len calldata.size] = call.data[0 len calldata.size]
                            mem[_5744 + calldata.size + 64] = 0
                            _5824 = mem[calldata.size + _5744 + 32]
                            mem[_5744 + ceil32(calldata.size) + 64] = 1
                            mem[_5744 + ceil32(calldata.size) + 96] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                            mem[_5744 + ceil32(calldata.size) + 128] = 1
                            mem[64] = _5744 + ceil32(calldata.size) + 192
                            mem[_5744 + ceil32(calldata.size) + 160] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                            mem[0] = address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])
                            mem[32] = sha3(cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)], 0)
                            if balanceOf[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])] > !cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]:
                                revert with 0, 17
                            balanceOf[cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]][address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])] += cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                            mem[_5744 + ceil32(calldata.size) + 192] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                            mem[_5744 + ceil32(calldata.size) + 224] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                            emit TransferSingle(cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)], cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)], address(_5824), 0, address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]));
                            if ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)])):
                                mem[_5744 + ceil32(calldata.size) + 192] = 0xf23a6e6100000000000000000000000000000000000000000000000000000000
                                mem[_5744 + ceil32(calldata.size) + 196] = address(_5824)
                                mem[_5744 + ceil32(calldata.size) + 228] = 0
                                mem[_5744 + ceil32(calldata.size) + 260] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                                mem[_5744 + ceil32(calldata.size) + 292] = cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)]
                                mem[_5744 + ceil32(calldata.size) + 324] = 160
                                mem[_5744 + ceil32(calldata.size) + 356] = mem[_5744]
                                t = 0
                                while t < mem[_5744]:
                                    mem[t + _5744 + ceil32(calldata.size) + 388] = mem[t + _5744 + 32]
                                    t = t + 32
                                    continue 
                                if ceil32(mem[_5744]) > mem[_5744]:
                                    mem[mem[_5744] + _5744 + ceil32(calldata.size) + 388] = 0
                                require ext_code.size(address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]))
                                call address(cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68)]).onERC1155Received(address rg1, address rg2, uint256 rg3, uint256 rg4, bytes rg5) with:
                                     gas gas_remaining wei
                                    args address(_5824), 0, cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)], cd[((32 * s) + cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68)], 160, mem[_5744], mem[_5744 + ceil32(calldata.size) + 388 len ceil32(mem[_5744])]
                                mem[_5744 + ceil32(calldata.size) + 192] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with 0, 'ERC1155: transfer to non ERC1155Receiver implementer'
                                mem[64] = _5744 + ceil32(calldata.size) + ceil32(return_data.size) + 192
                                require return_data.size >= 32
                                require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                                if Mask(32, 224, ext_call.return_data[0]) != 0xf23a6e6100000000000000000000000000000000000000000000000000000000:
                                    revert with 0, 'ERC1155: ERC1155Receiver rejected tokens'
                    if s == -1:
                        revert with 0, 17
                    s = s + 1
                    continue 
                _5304 = mem[64]
                mem[mem[64]] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 36)]
                mem[mem[64] + 32] = 96
                mem[mem[64] + 96] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 36)]
                s = 0
                t = cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 68
                u = mem[64] + 128
                while s < cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 100)] + 36)]:
                    require cd[t] == address(cd[t])
                    mem[u] = address(cd[t])
                    s = s + 1
                    t = t + 32
                    u = u + 32
                    continue 
                mem[_5304 + 64] = u - _5304
                mem[u] = cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 36)]
                require cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 36)] <= 0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
                mem[u + 32 len 32 * cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 36)]] = call.data[cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 68 len 32 * cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 36)]]
                mem[u + (32 * cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 36)]) + 32] = 0
                emit 0xbc11d48c: mem[mem[64] len u + (32 * cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + cd[(cd[(cd[4] + (32 * idx) + 36)] + cd[4] + 132)] + 36)]) + -mem[64] + 32]
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _2720 = mem[64]
            mem[mem[64]] = 42
            mem[64] = mem[64] + 96
            mem[_2720 + 32 len 42] = call.data[calldata.size len 42]
            if 0 >= mem[_2720]:
                revert with 0, 50
            mem[_2720 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
            if 1 >= mem[_2720]:
                revert with 0, 50
            mem[_2720 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
            idx = 41
            s = address(_2670)
            while idx > 1:
                if s % 16 >= 16:
                    revert with 0, 50
                if idx >= mem[_2720]:
                    revert with 0, 50
                mem[idx + _2720 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                if not idx:
                    revert with 0, 17
                idx = idx - 1
                s = Mask(252, 0, s) * 0.0625
                continue 
            if address(_2670) + 10240:
                revert with 0, 'Strings: hex length insufficient'
            _5356 = mem[64]
            mem[mem[64]] = 66
            mem[64] = mem[64] + 128
            mem[_5356 + 32 len 66] = call.data[calldata.size len 66]
            if 0 >= mem[_5356]:
                revert with 0, 50
            mem[_5356 + 32 len 8] = Mask(8, -(2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) + 256, 0) << (2713877091499598330239944961141122840311015265600950719674787125185463975936, 0) - 256
            if 1 >= mem[_5356]:
                revert with 0, 50
            mem[_5356 + 33 len 8] = Mask(8, -(6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) + 256, 0) << (6784692728748995825599862402852807100777538164002376799186967812963659939840, 0) - 256
            idx = 65
            while idx > 1:
                if idx >= mem[_5356]:
                    revert with 0, 50
                mem[idx + _5356 + 32 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
                if not idx:
                    revert with 0, 17
                idx = idx - 1
                continue 
            _8072 = mem[64]
            mem[mem[64] + 32] = 'AccessControl: account '
            _8082 = mem[_2720]
            idx = 0
            while idx < _8082:
                mem[idx + _8072 + 55] = mem[idx + _2720 + 32]
                idx = idx + 32
                continue 
            mem[_8072 + _8082 + 55] = 0x206973206d697373696e6720726f6c6520000000000000000000000000000000
            if ceil32(_8082) <= _8082:
                _10309 = mem[_5356]
                idx = 0
                while idx < _10309:
                    mem[idx + _8072 + _8082 + 72] = mem[idx + _5356 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_10309) <= _10309:
                    _11171 = mem[64]
                    mem[mem[64]] = _10309 + _8072 + _8082 + -mem[64] + 40
                    mem[64] = _10309 + _8072 + _8082 + 72
                    mem[_10309 + _8072 + _8082 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[_10309 + _8072 + _8082 + 76] = 32
                    _11251 = mem[_11171]
                    mem[_10309 + _8072 + _8082 + 108] = mem[_11171]
                    idx = 0
                    while idx < _11251:
                        mem[idx + _10309 + _8072 + _8082 + 140] = mem[idx + _11171 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_11251) > _11251:
                        mem[_11251 + _10309 + _8072 + _8082 + 140] = 0
                    revert with 0, 32, mem[_10309 + _8072 + _8082 + 108 len ceil32(_11251) + 32]
                mem[_10309 + _8072 + _8082 + 72] = 0
                _11172 = mem[64]
                mem[mem[64]] = _10309 + _8072 + _8082 + -mem[64] + 40
                mem[64] = _10309 + _8072 + _8082 + 72
                mem[_10309 + _8072 + _8082 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[_10309 + _8072 + _8082 + 76] = 32
                _11252 = mem[_11172]
                mem[_10309 + _8072 + _8082 + 108] = mem[_11172]
                idx = 0
                while idx < _11252:
                    mem[idx + _10309 + _8072 + _8082 + 140] = mem[idx + _11172 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_11252) > _11252:
                    mem[_11252 + _10309 + _8072 + _8082 + 140] = 0
                revert with 0, 32, mem[_10309 + _8072 + _8082 + 108 len ceil32(_11252) + 32]
            _10310 = mem[_5356]
            idx = 0
            while idx < _10310:
                mem[idx + _8072 + _8082 + 72] = mem[idx + _5356 + 32]
                idx = idx + 32
                continue 
            if ceil32(_10310) <= _10310:
                _11173 = mem[64]
                mem[mem[64]] = _10310 + _8072 + _8082 + -mem[64] + 40
                mem[64] = _10310 + _8072 + _8082 + 72
                mem[_10310 + _8072 + _8082 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[_10310 + _8072 + _8082 + 76] = 32
                _11253 = mem[_11173]
                mem[_10310 + _8072 + _8082 + 108] = mem[_11173]
                idx = 0
                while idx < _11253:
                    mem[idx + _10310 + _8072 + _8082 + 140] = mem[idx + _11173 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_11253) > _11253:
                    mem[_11253 + _10310 + _8072 + _8082 + 140] = 0
                revert with 0, 32, mem[_10310 + _8072 + _8082 + 108 len ceil32(_11253) + 32]
            mem[_10310 + _8072 + _8082 + 72] = 0
            _11174 = mem[64]
            mem[mem[64]] = _10310 + _8072 + _8082 + -mem[64] + 40
            mem[64] = _10310 + _8072 + _8082 + 72
            mem[_10310 + _8072 + _8082 + 72] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[_10310 + _8072 + _8082 + 76] = 32
            _11254 = mem[_11174]
            mem[_10310 + _8072 + _8082 + 108] = mem[_11174]
            idx = 0
            while idx < _11254:
                mem[idx + _10310 + _8072 + _8082 + 140] = mem[idx + _11174 + 32]
                idx = idx + 32
                continue 
            if ceil32(_11254) > _11254:
                mem[_11254 + _10310 + _8072 + _8082 + 140] = 0
            revert with 0, 32, mem[_10310 + _8072 + _8082 + 108 len ceil32(_11254) + 32]
    mem[ceil32(calldata.size) + 160 len 42] = call.data[calldata.size len 42]
    idx = 41
    s = mem[calldata.size + 108 len 20]
    while idx > 1:
        if s % 16 >= 16:
            revert with 0, 50
        if idx >= 42:
            revert with 0, 50
        mem[idx + ceil32(calldata.size) + 160 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
        if not idx:
            revert with 0, 17
        idx = idx - 1
        s = Mask(252, 0, s) * 0.0625
        continue 
    if mem[calldata.size + 108 len 20] + 10240:
        revert with 0, 'Strings: hex length insufficient'
    mem[ceil32(calldata.size) + 256 len 66] = call.data[calldata.size len 66]
    idx = 65
    while idx > 1:
        if idx >= 66:
            revert with 0, 50
        mem[idx + ceil32(calldata.size) + 256 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
        if not idx:
            revert with 0, 17
        idx = idx - 1
        continue 
    revert with 0, 
                32,
                148,
                'AccessControl: account ', mem[ceil32(calldata.size) + 192 len 42], 8297, mem[ceil32(calldata.size) + 320 len 66], 0, 0 >> 928,
                0
}



}
